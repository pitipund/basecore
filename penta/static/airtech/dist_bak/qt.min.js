dictionary = {
    // ============================================================== COMMON
    'history': 'ประวัติ',
    'accept': 'ตกลง',
    'completed': 'สำเร็จ',
    'close': 'ปิด',
    'paid': 'ชำระเงินแล้ว',
    'unpaid': 'ยังไม่ชำระเงิน',
    'title': 'หัวข้อ',
    'status': 'สถานะ',
    'payment': 'การชำระเงิน',
    'confirm': 'ยืนยัน',
    'cause': 'สาเหตุ',
    'save': 'บันทึก',
    'time': 'เวลา',
    'division': 'แผนก',
    'total': 'รวม',
    'claimable': 'เบิกได้',
    'non_claimable': 'เบิกไม่ได้',
    'please_choose': 'กรุณาเลือก',

    // ============================================================== SPECIFIC
    'drug_order_queue': 'คิวใบสั่งยา',
    'transfer_request': 'ขอยา',
    'transfer_request_queue': 'คิวใบขอยา',
    'transfer_request_history': 'ประวัติการขอยา',
    'dispenser_workload': 'อัตรากำลัง',
    'paper_drugorder_all': 'ใบสรุปรายการสั่งยาของเภสัชกรและของผู้ป่วย',
    'paper_drugorder_for_pharmacist': 'ใบสรุปรายการสั่งยาของเภสัชกร',
    'paper_drugorder_for_patient': 'ใบสรุปรายการสั่งยาของผู้ป่วย',
    'drugorder_requester': 'ผู้สั่ง',
    'drugorder_verifier': 'ผู้ตรวจ',
    'drugorder_checker': 'ผู้จัด',
    'drugorder_deliverer': 'ผู้จ่าย',
    'drugorder_transporter': 'ผู้ขนส่ง',
    'drugorder_receiver': 'ผู้รับ',
    'drugorder_verifier': 'ผู้ตรวจ',
    'drugorder_rejecter': 'ผู้ปฏิเสธ',
    'drugorder_canceler': 'ผู้ยกเลิก',
    'drugorder_approver': 'ผู้อนุมัติ',
    'title_drugtransferrequest': 'ขอยาจากห้องยาอื่นๆ',
    'title_drugorder_home_opd_requested': 'ตรวจสอบการสั่งยาผู้ป่วยนอก (VERIFY)',
    'title_drugorder_home_opd_printed': 'จัดยาผู้ป่วยนอก (CHECK)',
    'title_drugorder_home_opd_checked': 'จ่ายยาผู้ป่วยนอก (DELIVER)',
    'title_drugorder_home_opd_delivered': 'รายละเอียดการสั่งยาผู้ป่วยนอก (DETAIL)',
    'title_drugorder_stat_requested': 'ตรวจสอบการสั่งยาเร่งด่วน (VERIFY)',
    'title_drugorder_stat_printed': 'จัดยาเร่งด่วน (CHECK)',
    'title_drugorder_stat_checked': 'จ่ายยาเร่งด่วน (DELIVER)',
    'title_drugorder_stat_transported': 'รายละเอียดการสั่งยาเร่งด่วน (DETAIL)',
    'title_drugorder_selling_requested': 'ตรวจสอบการสั่งยาเพื่อจำหน่าย (VERIFY)',
    'title_drugorder_selling_printed': 'จัดยาสำหรับจำหน่าย (CHECK)',
    'title_drugorder_selling_checked': 'จ่ายยาสำหรับจำหน่าย (DELIVER)',
    'title_drugorder_selling_delivered': 'รายละเอียดการจำหน่ายยา (DETAIL)',
    'diagnosis': 'การวินิจฉัย',
    'order_supply': 'สั่งเวชภัณฑ์',
    'refill_supply': 'เติมเวชภัณฑ์',
    'set_receipt_code': 'ตั้งเลขที่ใบเสร็จ',
    'patient_queue': 'คิวผู้ป่วย',
    'specify_patient': 'ระบุผู้ป่วย',
    'drug_order_is_not_paid': 'ใบยายังไม่ได้รับชำระเงิน',
    'drug_order_contains_risky_drug': 'มียาที่อาจเป็นอันตรายต่อผู้ป่วย',
    'deliverer': 'ผู้จัดส่ง',
    'order_history': 'ประวัติการสั่ง',
    'dispense_history': 'ประวัติการจ่าย',
    'order_selling': 'สั่งยาจำหน่าย',
    'no_active_encounter': 'ไม่พบ encounter ของผู้ป่วย',
    'med_error_list': 'ความคลาดเคลื่อน',
    'new_adverse_reaction': 'มีบันทึก ADR ใหม่',
    'drug_external_usage': 'บันทึกใช้ยานอกโรงพยาบาล',
}

// Stub for Internationalization
function _(message) {
    if (dictionary[message]){
        return dictionary[message]
    } else {
        return message;
    }
}
//! moment.js
//! version : 2.9.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
(function(a){function b(a,b,c){switch(arguments.length){case 2:return null!=a?a:b;case 3:return null!=a?a:null!=b?b:c;default:throw new Error("Implement me")}}function c(a,b){return Bb.call(a,b)}function d(){return{empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1}}function e(a){vb.suppressDeprecationWarnings===!1&&"undefined"!=typeof console&&console.warn&&console.warn("Deprecation warning: "+a)}function f(a,b){var c=!0;return o(function(){return c&&(e(a),c=!1),b.apply(this,arguments)},b)}function g(a,b){sc[a]||(e(b),sc[a]=!0)}function h(a,b){return function(c){return r(a.call(this,c),b)}}function i(a,b){return function(c){return this.localeData().ordinal(a.call(this,c),b)}}function j(a,b){var c,d,e=12*(b.year()-a.year())+(b.month()-a.month()),f=a.clone().add(e,"months");return 0>b-f?(c=a.clone().add(e-1,"months"),d=(b-f)/(f-c)):(c=a.clone().add(e+1,"months"),d=(b-f)/(c-f)),-(e+d)}function k(a,b,c){var d;return null==c?b:null!=a.meridiemHour?a.meridiemHour(b,c):null!=a.isPM?(d=a.isPM(c),d&&12>b&&(b+=12),d||12!==b||(b=0),b):b}function l(){}function m(a,b){b!==!1&&H(a),p(this,a),this._d=new Date(+a._d),uc===!1&&(uc=!0,vb.updateOffset(this),uc=!1)}function n(a){var b=A(a),c=b.year||0,d=b.quarter||0,e=b.month||0,f=b.week||0,g=b.day||0,h=b.hour||0,i=b.minute||0,j=b.second||0,k=b.millisecond||0;this._milliseconds=+k+1e3*j+6e4*i+36e5*h,this._days=+g+7*f,this._months=+e+3*d+12*c,this._data={},this._locale=vb.localeData(),this._bubble()}function o(a,b){for(var d in b)c(b,d)&&(a[d]=b[d]);return c(b,"toString")&&(a.toString=b.toString),c(b,"valueOf")&&(a.valueOf=b.valueOf),a}function p(a,b){var c,d,e;if("undefined"!=typeof b._isAMomentObject&&(a._isAMomentObject=b._isAMomentObject),"undefined"!=typeof b._i&&(a._i=b._i),"undefined"!=typeof b._f&&(a._f=b._f),"undefined"!=typeof b._l&&(a._l=b._l),"undefined"!=typeof b._strict&&(a._strict=b._strict),"undefined"!=typeof b._tzm&&(a._tzm=b._tzm),"undefined"!=typeof b._isUTC&&(a._isUTC=b._isUTC),"undefined"!=typeof b._offset&&(a._offset=b._offset),"undefined"!=typeof b._pf&&(a._pf=b._pf),"undefined"!=typeof b._locale&&(a._locale=b._locale),Kb.length>0)for(c in Kb)d=Kb[c],e=b[d],"undefined"!=typeof e&&(a[d]=e);return a}function q(a){return 0>a?Math.ceil(a):Math.floor(a)}function r(a,b,c){for(var d=""+Math.abs(a),e=a>=0;d.length<b;)d="0"+d;return(e?c?"+":"":"-")+d}function s(a,b){var c={milliseconds:0,months:0};return c.months=b.month()-a.month()+12*(b.year()-a.year()),a.clone().add(c.months,"M").isAfter(b)&&--c.months,c.milliseconds=+b-+a.clone().add(c.months,"M"),c}function t(a,b){var c;return b=M(b,a),a.isBefore(b)?c=s(a,b):(c=s(b,a),c.milliseconds=-c.milliseconds,c.months=-c.months),c}function u(a,b){return function(c,d){var e,f;return null===d||isNaN(+d)||(g(b,"moment()."+b+"(period, number) is deprecated. Please use moment()."+b+"(number, period)."),f=c,c=d,d=f),c="string"==typeof c?+c:c,e=vb.duration(c,d),v(this,e,a),this}}function v(a,b,c,d){var e=b._milliseconds,f=b._days,g=b._months;d=null==d?!0:d,e&&a._d.setTime(+a._d+e*c),f&&pb(a,"Date",ob(a,"Date")+f*c),g&&nb(a,ob(a,"Month")+g*c),d&&vb.updateOffset(a,f||g)}function w(a){return"[object Array]"===Object.prototype.toString.call(a)}function x(a){return"[object Date]"===Object.prototype.toString.call(a)||a instanceof Date}function y(a,b,c){var d,e=Math.min(a.length,b.length),f=Math.abs(a.length-b.length),g=0;for(d=0;e>d;d++)(c&&a[d]!==b[d]||!c&&C(a[d])!==C(b[d]))&&g++;return g+f}function z(a){if(a){var b=a.toLowerCase().replace(/(.)s$/,"$1");a=lc[a]||mc[b]||b}return a}function A(a){var b,d,e={};for(d in a)c(a,d)&&(b=z(d),b&&(e[b]=a[d]));return e}function B(b){var c,d;if(0===b.indexOf("week"))c=7,d="day";else{if(0!==b.indexOf("month"))return;c=12,d="month"}vb[b]=function(e,f){var g,h,i=vb._locale[b],j=[];if("number"==typeof e&&(f=e,e=a),h=function(a){var b=vb().utc().set(d,a);return i.call(vb._locale,b,e||"")},null!=f)return h(f);for(g=0;c>g;g++)j.push(h(g));return j}}function C(a){var b=+a,c=0;return 0!==b&&isFinite(b)&&(c=b>=0?Math.floor(b):Math.ceil(b)),c}function D(a,b){return new Date(Date.UTC(a,b+1,0)).getUTCDate()}function E(a,b,c){return jb(vb([a,11,31+b-c]),b,c).week}function F(a){return G(a)?366:365}function G(a){return a%4===0&&a%100!==0||a%400===0}function H(a){var b;a._a&&-2===a._pf.overflow&&(b=a._a[Db]<0||a._a[Db]>11?Db:a._a[Eb]<1||a._a[Eb]>D(a._a[Cb],a._a[Db])?Eb:a._a[Fb]<0||a._a[Fb]>24||24===a._a[Fb]&&(0!==a._a[Gb]||0!==a._a[Hb]||0!==a._a[Ib])?Fb:a._a[Gb]<0||a._a[Gb]>59?Gb:a._a[Hb]<0||a._a[Hb]>59?Hb:a._a[Ib]<0||a._a[Ib]>999?Ib:-1,a._pf._overflowDayOfYear&&(Cb>b||b>Eb)&&(b=Eb),a._pf.overflow=b)}function I(b){return null==b._isValid&&(b._isValid=!isNaN(b._d.getTime())&&b._pf.overflow<0&&!b._pf.empty&&!b._pf.invalidMonth&&!b._pf.nullInput&&!b._pf.invalidFormat&&!b._pf.userInvalidated,b._strict&&(b._isValid=b._isValid&&0===b._pf.charsLeftOver&&0===b._pf.unusedTokens.length&&b._pf.bigHour===a)),b._isValid}function J(a){return a?a.toLowerCase().replace("_","-"):a}function K(a){for(var b,c,d,e,f=0;f<a.length;){for(e=J(a[f]).split("-"),b=e.length,c=J(a[f+1]),c=c?c.split("-"):null;b>0;){if(d=L(e.slice(0,b).join("-")))return d;if(c&&c.length>=b&&y(e,c,!0)>=b-1)break;b--}f++}return null}function L(a){var b=null;if(!Jb[a]&&Lb)try{b=vb.locale(),require("./locale/"+a),vb.locale(b)}catch(c){}return Jb[a]}function M(a,b){var c,d;return b._isUTC?(c=b.clone(),d=(vb.isMoment(a)||x(a)?+a:+vb(a))-+c,c._d.setTime(+c._d+d),vb.updateOffset(c,!1),c):vb(a).local()}function N(a){return a.match(/\[[\s\S]/)?a.replace(/^\[|\]$/g,""):a.replace(/\\/g,"")}function O(a){var b,c,d=a.match(Pb);for(b=0,c=d.length;c>b;b++)d[b]=rc[d[b]]?rc[d[b]]:N(d[b]);return function(e){var f="";for(b=0;c>b;b++)f+=d[b]instanceof Function?d[b].call(e,a):d[b];return f}}function P(a,b){return a.isValid()?(b=Q(b,a.localeData()),nc[b]||(nc[b]=O(b)),nc[b](a)):a.localeData().invalidDate()}function Q(a,b){function c(a){return b.longDateFormat(a)||a}var d=5;for(Qb.lastIndex=0;d>=0&&Qb.test(a);)a=a.replace(Qb,c),Qb.lastIndex=0,d-=1;return a}function R(a,b){var c,d=b._strict;switch(a){case"Q":return _b;case"DDDD":return bc;case"YYYY":case"GGGG":case"gggg":return d?cc:Tb;case"Y":case"G":case"g":return ec;case"YYYYYY":case"YYYYY":case"GGGGG":case"ggggg":return d?dc:Ub;case"S":if(d)return _b;case"SS":if(d)return ac;case"SSS":if(d)return bc;case"DDD":return Sb;case"MMM":case"MMMM":case"dd":case"ddd":case"dddd":return Wb;case"a":case"A":return b._locale._meridiemParse;case"x":return Zb;case"X":return $b;case"Z":case"ZZ":return Xb;case"T":return Yb;case"SSSS":return Vb;case"MM":case"DD":case"YY":case"GG":case"gg":case"HH":case"hh":case"mm":case"ss":case"ww":case"WW":return d?ac:Rb;case"M":case"D":case"d":case"H":case"h":case"m":case"s":case"w":case"W":case"e":case"E":return Rb;case"Do":return d?b._locale._ordinalParse:b._locale._ordinalParseLenient;default:return c=new RegExp($(Z(a.replace("\\","")),"i"))}}function S(a){a=a||"";var b=a.match(Xb)||[],c=b[b.length-1]||[],d=(c+"").match(jc)||["-",0,0],e=+(60*d[1])+C(d[2]);return"+"===d[0]?e:-e}function T(a,b,c){var d,e=c._a;switch(a){case"Q":null!=b&&(e[Db]=3*(C(b)-1));break;case"M":case"MM":null!=b&&(e[Db]=C(b)-1);break;case"MMM":case"MMMM":d=c._locale.monthsParse(b,a,c._strict),null!=d?e[Db]=d:c._pf.invalidMonth=b;break;case"D":case"DD":null!=b&&(e[Eb]=C(b));break;case"Do":null!=b&&(e[Eb]=C(parseInt(b.match(/\d{1,2}/)[0],10)));break;case"DDD":case"DDDD":null!=b&&(c._dayOfYear=C(b));break;case"YY":e[Cb]=vb.parseTwoDigitYear(b);break;case"YYYY":case"YYYYY":case"YYYYYY":e[Cb]=C(b);break;case"a":case"A":c._meridiem=b;break;case"h":case"hh":c._pf.bigHour=!0;case"H":case"HH":e[Fb]=C(b);break;case"m":case"mm":e[Gb]=C(b);break;case"s":case"ss":e[Hb]=C(b);break;case"S":case"SS":case"SSS":case"SSSS":e[Ib]=C(1e3*("0."+b));break;case"x":c._d=new Date(C(b));break;case"X":c._d=new Date(1e3*parseFloat(b));break;case"Z":case"ZZ":c._useUTC=!0,c._tzm=S(b);break;case"dd":case"ddd":case"dddd":d=c._locale.weekdaysParse(b),null!=d?(c._w=c._w||{},c._w.d=d):c._pf.invalidWeekday=b;break;case"w":case"ww":case"W":case"WW":case"d":case"e":case"E":a=a.substr(0,1);case"gggg":case"GGGG":case"GGGGG":a=a.substr(0,2),b&&(c._w=c._w||{},c._w[a]=C(b));break;case"gg":case"GG":c._w=c._w||{},c._w[a]=vb.parseTwoDigitYear(b)}}function U(a){var c,d,e,f,g,h,i;c=a._w,null!=c.GG||null!=c.W||null!=c.E?(g=1,h=4,d=b(c.GG,a._a[Cb],jb(vb(),1,4).year),e=b(c.W,1),f=b(c.E,1)):(g=a._locale._week.dow,h=a._locale._week.doy,d=b(c.gg,a._a[Cb],jb(vb(),g,h).year),e=b(c.w,1),null!=c.d?(f=c.d,g>f&&++e):f=null!=c.e?c.e+g:g),i=kb(d,e,f,h,g),a._a[Cb]=i.year,a._dayOfYear=i.dayOfYear}function V(a){var c,d,e,f,g=[];if(!a._d){for(e=X(a),a._w&&null==a._a[Eb]&&null==a._a[Db]&&U(a),a._dayOfYear&&(f=b(a._a[Cb],e[Cb]),a._dayOfYear>F(f)&&(a._pf._overflowDayOfYear=!0),d=fb(f,0,a._dayOfYear),a._a[Db]=d.getUTCMonth(),a._a[Eb]=d.getUTCDate()),c=0;3>c&&null==a._a[c];++c)a._a[c]=g[c]=e[c];for(;7>c;c++)a._a[c]=g[c]=null==a._a[c]?2===c?1:0:a._a[c];24===a._a[Fb]&&0===a._a[Gb]&&0===a._a[Hb]&&0===a._a[Ib]&&(a._nextDay=!0,a._a[Fb]=0),a._d=(a._useUTC?fb:eb).apply(null,g),null!=a._tzm&&a._d.setUTCMinutes(a._d.getUTCMinutes()-a._tzm),a._nextDay&&(a._a[Fb]=24)}}function W(a){var b;a._d||(b=A(a._i),a._a=[b.year,b.month,b.day||b.date,b.hour,b.minute,b.second,b.millisecond],V(a))}function X(a){var b=new Date;return a._useUTC?[b.getUTCFullYear(),b.getUTCMonth(),b.getUTCDate()]:[b.getFullYear(),b.getMonth(),b.getDate()]}function Y(b){if(b._f===vb.ISO_8601)return void ab(b);b._a=[],b._pf.empty=!0;var c,d,e,f,g,h=""+b._i,i=h.length,j=0;for(e=Q(b._f,b._locale).match(Pb)||[],c=0;c<e.length;c++)f=e[c],d=(h.match(R(f,b))||[])[0],d&&(g=h.substr(0,h.indexOf(d)),g.length>0&&b._pf.unusedInput.push(g),h=h.slice(h.indexOf(d)+d.length),j+=d.length),rc[f]?(d?b._pf.empty=!1:b._pf.unusedTokens.push(f),T(f,d,b)):b._strict&&!d&&b._pf.unusedTokens.push(f);b._pf.charsLeftOver=i-j,h.length>0&&b._pf.unusedInput.push(h),b._pf.bigHour===!0&&b._a[Fb]<=12&&(b._pf.bigHour=a),b._a[Fb]=k(b._locale,b._a[Fb],b._meridiem),V(b),H(b)}function Z(a){return a.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(a,b,c,d,e){return b||c||d||e})}function $(a){return a.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}function _(a){var b,c,e,f,g;if(0===a._f.length)return a._pf.invalidFormat=!0,void(a._d=new Date(0/0));for(f=0;f<a._f.length;f++)g=0,b=p({},a),null!=a._useUTC&&(b._useUTC=a._useUTC),b._pf=d(),b._f=a._f[f],Y(b),I(b)&&(g+=b._pf.charsLeftOver,g+=10*b._pf.unusedTokens.length,b._pf.score=g,(null==e||e>g)&&(e=g,c=b));o(a,c||b)}function ab(a){var b,c,d=a._i,e=fc.exec(d);if(e){for(a._pf.iso=!0,b=0,c=hc.length;c>b;b++)if(hc[b][1].exec(d)){a._f=hc[b][0]+(e[6]||" ");break}for(b=0,c=ic.length;c>b;b++)if(ic[b][1].exec(d)){a._f+=ic[b][0];break}d.match(Xb)&&(a._f+="Z"),Y(a)}else a._isValid=!1}function bb(a){ab(a),a._isValid===!1&&(delete a._isValid,vb.createFromInputFallback(a))}function cb(a,b){var c,d=[];for(c=0;c<a.length;++c)d.push(b(a[c],c));return d}function db(b){var c,d=b._i;d===a?b._d=new Date:x(d)?b._d=new Date(+d):null!==(c=Mb.exec(d))?b._d=new Date(+c[1]):"string"==typeof d?bb(b):w(d)?(b._a=cb(d.slice(0),function(a){return parseInt(a,10)}),V(b)):"object"==typeof d?W(b):"number"==typeof d?b._d=new Date(d):vb.createFromInputFallback(b)}function eb(a,b,c,d,e,f,g){var h=new Date(a,b,c,d,e,f,g);return 1970>a&&h.setFullYear(a),h}function fb(a){var b=new Date(Date.UTC.apply(null,arguments));return 1970>a&&b.setUTCFullYear(a),b}function gb(a,b){if("string"==typeof a)if(isNaN(a)){if(a=b.weekdaysParse(a),"number"!=typeof a)return null}else a=parseInt(a,10);return a}function hb(a,b,c,d,e){return e.relativeTime(b||1,!!c,a,d)}function ib(a,b,c){var d=vb.duration(a).abs(),e=Ab(d.as("s")),f=Ab(d.as("m")),g=Ab(d.as("h")),h=Ab(d.as("d")),i=Ab(d.as("M")),j=Ab(d.as("y")),k=e<oc.s&&["s",e]||1===f&&["m"]||f<oc.m&&["mm",f]||1===g&&["h"]||g<oc.h&&["hh",g]||1===h&&["d"]||h<oc.d&&["dd",h]||1===i&&["M"]||i<oc.M&&["MM",i]||1===j&&["y"]||["yy",j];return k[2]=b,k[3]=+a>0,k[4]=c,hb.apply({},k)}function jb(a,b,c){var d,e=c-b,f=c-a.day();return f>e&&(f-=7),e-7>f&&(f+=7),d=vb(a).add(f,"d"),{week:Math.ceil(d.dayOfYear()/7),year:d.year()}}function kb(a,b,c,d,e){var f,g,h=fb(a,0,1).getUTCDay();return h=0===h?7:h,c=null!=c?c:e,f=e-h+(h>d?7:0)-(e>h?7:0),g=7*(b-1)+(c-e)+f+1,{year:g>0?a:a-1,dayOfYear:g>0?g:F(a-1)+g}}function lb(b){var c,d=b._i,e=b._f;return b._locale=b._locale||vb.localeData(b._l),null===d||e===a&&""===d?vb.invalid({nullInput:!0}):("string"==typeof d&&(b._i=d=b._locale.preparse(d)),vb.isMoment(d)?new m(d,!0):(e?w(e)?_(b):Y(b):db(b),c=new m(b),c._nextDay&&(c.add(1,"d"),c._nextDay=a),c))}function mb(a,b){var c,d;if(1===b.length&&w(b[0])&&(b=b[0]),!b.length)return vb();for(c=b[0],d=1;d<b.length;++d)b[d][a](c)&&(c=b[d]);return c}function nb(a,b){var c;return"string"==typeof b&&(b=a.localeData().monthsParse(b),"number"!=typeof b)?a:(c=Math.min(a.date(),D(a.year(),b)),a._d["set"+(a._isUTC?"UTC":"")+"Month"](b,c),a)}function ob(a,b){return a._d["get"+(a._isUTC?"UTC":"")+b]()}function pb(a,b,c){return"Month"===b?nb(a,c):a._d["set"+(a._isUTC?"UTC":"")+b](c)}function qb(a,b){return function(c){return null!=c?(pb(this,a,c),vb.updateOffset(this,b),this):ob(this,a)}}function rb(a){return 400*a/146097}function sb(a){return 146097*a/400}function tb(a){vb.duration.fn[a]=function(){return this._data[a]}}function ub(a){"undefined"==typeof ender&&(wb=zb.moment,zb.moment=a?f("Accessing Moment through the global scope is deprecated, and will be removed in an upcoming release.",vb):vb)}for(var vb,wb,xb,yb="2.9.0",zb="undefined"==typeof global||"undefined"!=typeof window&&window!==global.window?this:global,Ab=Math.round,Bb=Object.prototype.hasOwnProperty,Cb=0,Db=1,Eb=2,Fb=3,Gb=4,Hb=5,Ib=6,Jb={},Kb=[],Lb="undefined"!=typeof module&&module&&module.exports,Mb=/^\/?Date\((\-?\d+)/i,Nb=/(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,Ob=/^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,Pb=/(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g,Qb=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,Rb=/\d\d?/,Sb=/\d{1,3}/,Tb=/\d{1,4}/,Ub=/[+\-]?\d{1,6}/,Vb=/\d+/,Wb=/[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i,Xb=/Z|[\+\-]\d\d:?\d\d/gi,Yb=/T/i,Zb=/[\+\-]?\d+/,$b=/[\+\-]?\d+(\.\d{1,3})?/,_b=/\d/,ac=/\d\d/,bc=/\d{3}/,cc=/\d{4}/,dc=/[+-]?\d{6}/,ec=/[+-]?\d+/,fc=/^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,gc="YYYY-MM-DDTHH:mm:ssZ",hc=[["YYYYYY-MM-DD",/[+-]\d{6}-\d{2}-\d{2}/],["YYYY-MM-DD",/\d{4}-\d{2}-\d{2}/],["GGGG-[W]WW-E",/\d{4}-W\d{2}-\d/],["GGGG-[W]WW",/\d{4}-W\d{2}/],["YYYY-DDD",/\d{4}-\d{3}/]],ic=[["HH:mm:ss.SSSS",/(T| )\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss",/(T| )\d\d:\d\d:\d\d/],["HH:mm",/(T| )\d\d:\d\d/],["HH",/(T| )\d\d/]],jc=/([\+\-]|\d\d)/gi,kc=("Date|Hours|Minutes|Seconds|Milliseconds".split("|"),{Milliseconds:1,Seconds:1e3,Minutes:6e4,Hours:36e5,Days:864e5,Months:2592e6,Years:31536e6}),lc={ms:"millisecond",s:"second",m:"minute",h:"hour",d:"day",D:"date",w:"week",W:"isoWeek",M:"month",Q:"quarter",y:"year",DDD:"dayOfYear",e:"weekday",E:"isoWeekday",gg:"weekYear",GG:"isoWeekYear"},mc={dayofyear:"dayOfYear",isoweekday:"isoWeekday",isoweek:"isoWeek",weekyear:"weekYear",isoweekyear:"isoWeekYear"},nc={},oc={s:45,m:45,h:22,d:26,M:11},pc="DDD w W M D d".split(" "),qc="M D H h m s w W".split(" "),rc={M:function(){return this.month()+1},MMM:function(a){return this.localeData().monthsShort(this,a)},MMMM:function(a){return this.localeData().months(this,a)},D:function(){return this.date()},DDD:function(){return this.dayOfYear()},d:function(){return this.day()},dd:function(a){return this.localeData().weekdaysMin(this,a)},ddd:function(a){return this.localeData().weekdaysShort(this,a)},dddd:function(a){return this.localeData().weekdays(this,a)},w:function(){return this.week()},W:function(){return this.isoWeek()},YY:function(){return r(this.year()%100,2)},YYYY:function(){return r(this.year(),4)},YYYYY:function(){return r(this.year(),5)},YYYYYY:function(){var a=this.year(),b=a>=0?"+":"-";return b+r(Math.abs(a),6)},gg:function(){return r(this.weekYear()%100,2)},gggg:function(){return r(this.weekYear(),4)},ggggg:function(){return r(this.weekYear(),5)},GG:function(){return r(this.isoWeekYear()%100,2)},GGGG:function(){return r(this.isoWeekYear(),4)},GGGGG:function(){return r(this.isoWeekYear(),5)},e:function(){return this.weekday()},E:function(){return this.isoWeekday()},a:function(){return this.localeData().meridiem(this.hours(),this.minutes(),!0)},A:function(){return this.localeData().meridiem(this.hours(),this.minutes(),!1)},H:function(){return this.hours()},h:function(){return this.hours()%12||12},m:function(){return this.minutes()},s:function(){return this.seconds()},S:function(){return C(this.milliseconds()/100)},SS:function(){return r(C(this.milliseconds()/10),2)},SSS:function(){return r(this.milliseconds(),3)},SSSS:function(){return r(this.milliseconds(),3)},Z:function(){var a=this.utcOffset(),b="+";return 0>a&&(a=-a,b="-"),b+r(C(a/60),2)+":"+r(C(a)%60,2)},ZZ:function(){var a=this.utcOffset(),b="+";return 0>a&&(a=-a,b="-"),b+r(C(a/60),2)+r(C(a)%60,2)},z:function(){return this.zoneAbbr()},zz:function(){return this.zoneName()},x:function(){return this.valueOf()},X:function(){return this.unix()},Q:function(){return this.quarter()}},sc={},tc=["months","monthsShort","weekdays","weekdaysShort","weekdaysMin"],uc=!1;pc.length;)xb=pc.pop(),rc[xb+"o"]=i(rc[xb],xb);for(;qc.length;)xb=qc.pop(),rc[xb+xb]=h(rc[xb],2);rc.DDDD=h(rc.DDD,3),o(l.prototype,{set:function(a){var b,c;for(c in a)b=a[c],"function"==typeof b?this[c]=b:this["_"+c]=b;this._ordinalParseLenient=new RegExp(this._ordinalParse.source+"|"+/\d{1,2}/.source)},_months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),months:function(a){return this._months[a.month()]},_monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),monthsShort:function(a){return this._monthsShort[a.month()]},monthsParse:function(a,b,c){var d,e,f;for(this._monthsParse||(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[]),d=0;12>d;d++){if(e=vb.utc([2e3,d]),c&&!this._longMonthsParse[d]&&(this._longMonthsParse[d]=new RegExp("^"+this.months(e,"").replace(".","")+"$","i"),this._shortMonthsParse[d]=new RegExp("^"+this.monthsShort(e,"").replace(".","")+"$","i")),c||this._monthsParse[d]||(f="^"+this.months(e,"")+"|^"+this.monthsShort(e,""),this._monthsParse[d]=new RegExp(f.replace(".",""),"i")),c&&"MMMM"===b&&this._longMonthsParse[d].test(a))return d;if(c&&"MMM"===b&&this._shortMonthsParse[d].test(a))return d;if(!c&&this._monthsParse[d].test(a))return d}},_weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdays:function(a){return this._weekdays[a.day()]},_weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysShort:function(a){return this._weekdaysShort[a.day()]},_weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),weekdaysMin:function(a){return this._weekdaysMin[a.day()]},weekdaysParse:function(a){var b,c,d;for(this._weekdaysParse||(this._weekdaysParse=[]),b=0;7>b;b++)if(this._weekdaysParse[b]||(c=vb([2e3,1]).day(b),d="^"+this.weekdays(c,"")+"|^"+this.weekdaysShort(c,"")+"|^"+this.weekdaysMin(c,""),this._weekdaysParse[b]=new RegExp(d.replace(".",""),"i")),this._weekdaysParse[b].test(a))return b},_longDateFormat:{LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY LT",LLLL:"dddd, MMMM D, YYYY LT"},longDateFormat:function(a){var b=this._longDateFormat[a];return!b&&this._longDateFormat[a.toUpperCase()]&&(b=this._longDateFormat[a.toUpperCase()].replace(/MMMM|MM|DD|dddd/g,function(a){return a.slice(1)}),this._longDateFormat[a]=b),b},isPM:function(a){return"p"===(a+"").toLowerCase().charAt(0)},_meridiemParse:/[ap]\.?m?\.?/i,meridiem:function(a,b,c){return a>11?c?"pm":"PM":c?"am":"AM"},_calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},calendar:function(a,b,c){var d=this._calendar[a];return"function"==typeof d?d.apply(b,[c]):d},_relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},relativeTime:function(a,b,c,d){var e=this._relativeTime[c];return"function"==typeof e?e(a,b,c,d):e.replace(/%d/i,a)},pastFuture:function(a,b){var c=this._relativeTime[a>0?"future":"past"];return"function"==typeof c?c(b):c.replace(/%s/i,b)},ordinal:function(a){return this._ordinal.replace("%d",a)},_ordinal:"%d",_ordinalParse:/\d{1,2}/,preparse:function(a){return a},postformat:function(a){return a},week:function(a){return jb(a,this._week.dow,this._week.doy).week},_week:{dow:0,doy:6},firstDayOfWeek:function(){return this._week.dow},firstDayOfYear:function(){return this._week.doy},_invalidDate:"Invalid date",invalidDate:function(){return this._invalidDate}}),vb=function(b,c,e,f){var g;return"boolean"==typeof e&&(f=e,e=a),g={},g._isAMomentObject=!0,g._i=b,g._f=c,g._l=e,g._strict=f,g._isUTC=!1,g._pf=d(),lb(g)},vb.suppressDeprecationWarnings=!1,vb.createFromInputFallback=f("moment construction falls back to js Date. This is discouraged and will be removed in upcoming major release. Please refer to https://github.com/moment/moment/issues/1407 for more info.",function(a){a._d=new Date(a._i+(a._useUTC?" UTC":""))}),vb.min=function(){var a=[].slice.call(arguments,0);return mb("isBefore",a)},vb.max=function(){var a=[].slice.call(arguments,0);return mb("isAfter",a)},vb.utc=function(b,c,e,f){var g;return"boolean"==typeof e&&(f=e,e=a),g={},g._isAMomentObject=!0,g._useUTC=!0,g._isUTC=!0,g._l=e,g._i=b,g._f=c,g._strict=f,g._pf=d(),lb(g).utc()},vb.unix=function(a){return vb(1e3*a)},vb.duration=function(a,b){var d,e,f,g,h=a,i=null;return vb.isDuration(a)?h={ms:a._milliseconds,d:a._days,M:a._months}:"number"==typeof a?(h={},b?h[b]=a:h.milliseconds=a):(i=Nb.exec(a))?(d="-"===i[1]?-1:1,h={y:0,d:C(i[Eb])*d,h:C(i[Fb])*d,m:C(i[Gb])*d,s:C(i[Hb])*d,ms:C(i[Ib])*d}):(i=Ob.exec(a))?(d="-"===i[1]?-1:1,f=function(a){var b=a&&parseFloat(a.replace(",","."));return(isNaN(b)?0:b)*d},h={y:f(i[2]),M:f(i[3]),d:f(i[4]),h:f(i[5]),m:f(i[6]),s:f(i[7]),w:f(i[8])}):null==h?h={}:"object"==typeof h&&("from"in h||"to"in h)&&(g=t(vb(h.from),vb(h.to)),h={},h.ms=g.milliseconds,h.M=g.months),e=new n(h),vb.isDuration(a)&&c(a,"_locale")&&(e._locale=a._locale),e},vb.version=yb,vb.defaultFormat=gc,vb.ISO_8601=function(){},vb.momentProperties=Kb,vb.updateOffset=function(){},vb.relativeTimeThreshold=function(b,c){return oc[b]===a?!1:c===a?oc[b]:(oc[b]=c,!0)},vb.lang=f("moment.lang is deprecated. Use moment.locale instead.",function(a,b){return vb.locale(a,b)}),vb.locale=function(a,b){var c;return a&&(c="undefined"!=typeof b?vb.defineLocale(a,b):vb.localeData(a),c&&(vb.duration._locale=vb._locale=c)),vb._locale._abbr},vb.defineLocale=function(a,b){return null!==b?(b.abbr=a,Jb[a]||(Jb[a]=new l),Jb[a].set(b),vb.locale(a),Jb[a]):(delete Jb[a],null)},vb.langData=f("moment.langData is deprecated. Use moment.localeData instead.",function(a){return vb.localeData(a)}),vb.localeData=function(a){var b;if(a&&a._locale&&a._locale._abbr&&(a=a._locale._abbr),!a)return vb._locale;if(!w(a)){if(b=L(a))return b;a=[a]}return K(a)},vb.isMoment=function(a){return a instanceof m||null!=a&&c(a,"_isAMomentObject")},vb.isDuration=function(a){return a instanceof n};for(xb=tc.length-1;xb>=0;--xb)B(tc[xb]);vb.normalizeUnits=function(a){return z(a)},vb.invalid=function(a){var b=vb.utc(0/0);return null!=a?o(b._pf,a):b._pf.userInvalidated=!0,b},vb.parseZone=function(){return vb.apply(null,arguments).parseZone()},vb.parseTwoDigitYear=function(a){return C(a)+(C(a)>68?1900:2e3)},vb.isDate=x,o(vb.fn=m.prototype,{clone:function(){return vb(this)},valueOf:function(){return+this._d-6e4*(this._offset||0)},unix:function(){return Math.floor(+this/1e3)},toString:function(){return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")},toDate:function(){return this._offset?new Date(+this):this._d},toISOString:function(){var a=vb(this).utc();return 0<a.year()&&a.year()<=9999?"function"==typeof Date.prototype.toISOString?this.toDate().toISOString():P(a,"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]"):P(a,"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]")},toArray:function(){var a=this;return[a.year(),a.month(),a.date(),a.hours(),a.minutes(),a.seconds(),a.milliseconds()]},isValid:function(){return I(this)},isDSTShifted:function(){return this._a?this.isValid()&&y(this._a,(this._isUTC?vb.utc(this._a):vb(this._a)).toArray())>0:!1},parsingFlags:function(){return o({},this._pf)},invalidAt:function(){return this._pf.overflow},utc:function(a){return this.utcOffset(0,a)},local:function(a){return this._isUTC&&(this.utcOffset(0,a),this._isUTC=!1,a&&this.subtract(this._dateUtcOffset(),"m")),this},format:function(a){var b=P(this,a||vb.defaultFormat);return this.localeData().postformat(b)},add:u(1,"add"),subtract:u(-1,"subtract"),diff:function(a,b,c){var d,e,f=M(a,this),g=6e4*(f.utcOffset()-this.utcOffset());return b=z(b),"year"===b||"month"===b||"quarter"===b?(e=j(this,f),"quarter"===b?e/=3:"year"===b&&(e/=12)):(d=this-f,e="second"===b?d/1e3:"minute"===b?d/6e4:"hour"===b?d/36e5:"day"===b?(d-g)/864e5:"week"===b?(d-g)/6048e5:d),c?e:q(e)},from:function(a,b){return vb.duration({to:this,from:a}).locale(this.locale()).humanize(!b)},fromNow:function(a){return this.from(vb(),a)},calendar:function(a){var b=a||vb(),c=M(b,this).startOf("day"),d=this.diff(c,"days",!0),e=-6>d?"sameElse":-1>d?"lastWeek":0>d?"lastDay":1>d?"sameDay":2>d?"nextDay":7>d?"nextWeek":"sameElse";return this.format(this.localeData().calendar(e,this,vb(b)))},isLeapYear:function(){return G(this.year())},isDST:function(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()},day:function(a){var b=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=a?(a=gb(a,this.localeData()),this.add(a-b,"d")):b},month:qb("Month",!0),startOf:function(a){switch(a=z(a)){case"year":this.month(0);case"quarter":case"month":this.date(1);case"week":case"isoWeek":case"day":this.hours(0);case"hour":this.minutes(0);case"minute":this.seconds(0);case"second":this.milliseconds(0)}return"week"===a?this.weekday(0):"isoWeek"===a&&this.isoWeekday(1),"quarter"===a&&this.month(3*Math.floor(this.month()/3)),this},endOf:function(b){return b=z(b),b===a||"millisecond"===b?this:this.startOf(b).add(1,"isoWeek"===b?"week":b).subtract(1,"ms")},isAfter:function(a,b){var c;return b=z("undefined"!=typeof b?b:"millisecond"),"millisecond"===b?(a=vb.isMoment(a)?a:vb(a),+this>+a):(c=vb.isMoment(a)?+a:+vb(a),c<+this.clone().startOf(b))},isBefore:function(a,b){var c;return b=z("undefined"!=typeof b?b:"millisecond"),"millisecond"===b?(a=vb.isMoment(a)?a:vb(a),+a>+this):(c=vb.isMoment(a)?+a:+vb(a),+this.clone().endOf(b)<c)},isBetween:function(a,b,c){return this.isAfter(a,c)&&this.isBefore(b,c)},isSame:function(a,b){var c;return b=z(b||"millisecond"),"millisecond"===b?(a=vb.isMoment(a)?a:vb(a),+this===+a):(c=+vb(a),+this.clone().startOf(b)<=c&&c<=+this.clone().endOf(b))},min:f("moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548",function(a){return a=vb.apply(null,arguments),this>a?this:a}),max:f("moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548",function(a){return a=vb.apply(null,arguments),a>this?this:a}),zone:f("moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779",function(a,b){return null!=a?("string"!=typeof a&&(a=-a),this.utcOffset(a,b),this):-this.utcOffset()}),utcOffset:function(a,b){var c,d=this._offset||0;return null!=a?("string"==typeof a&&(a=S(a)),Math.abs(a)<16&&(a=60*a),!this._isUTC&&b&&(c=this._dateUtcOffset()),this._offset=a,this._isUTC=!0,null!=c&&this.add(c,"m"),d!==a&&(!b||this._changeInProgress?v(this,vb.duration(a-d,"m"),1,!1):this._changeInProgress||(this._changeInProgress=!0,vb.updateOffset(this,!0),this._changeInProgress=null)),this):this._isUTC?d:this._dateUtcOffset()},isLocal:function(){return!this._isUTC},isUtcOffset:function(){return this._isUTC},isUtc:function(){return this._isUTC&&0===this._offset},zoneAbbr:function(){return this._isUTC?"UTC":""},zoneName:function(){return this._isUTC?"Coordinated Universal Time":""},parseZone:function(){return this._tzm?this.utcOffset(this._tzm):"string"==typeof this._i&&this.utcOffset(S(this._i)),this},hasAlignedHourOffset:function(a){return a=a?vb(a).utcOffset():0,(this.utcOffset()-a)%60===0},daysInMonth:function(){return D(this.year(),this.month())},dayOfYear:function(a){var b=Ab((vb(this).startOf("day")-vb(this).startOf("year"))/864e5)+1;return null==a?b:this.add(a-b,"d")},quarter:function(a){return null==a?Math.ceil((this.month()+1)/3):this.month(3*(a-1)+this.month()%3)},weekYear:function(a){var b=jb(this,this.localeData()._week.dow,this.localeData()._week.doy).year;return null==a?b:this.add(a-b,"y")},isoWeekYear:function(a){var b=jb(this,1,4).year;return null==a?b:this.add(a-b,"y")},week:function(a){var b=this.localeData().week(this);return null==a?b:this.add(7*(a-b),"d")},isoWeek:function(a){var b=jb(this,1,4).week;return null==a?b:this.add(7*(a-b),"d")},weekday:function(a){var b=(this.day()+7-this.localeData()._week.dow)%7;return null==a?b:this.add(a-b,"d")},isoWeekday:function(a){return null==a?this.day()||7:this.day(this.day()%7?a:a-7)},isoWeeksInYear:function(){return E(this.year(),1,4)},weeksInYear:function(){var a=this.localeData()._week;return E(this.year(),a.dow,a.doy)},get:function(a){return a=z(a),this[a]()},set:function(a,b){var c;if("object"==typeof a)for(c in a)this.set(c,a[c]);else a=z(a),"function"==typeof this[a]&&this[a](b);return this},locale:function(b){var c;return b===a?this._locale._abbr:(c=vb.localeData(b),null!=c&&(this._locale=c),this)},lang:f("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",function(b){return b===a?this.localeData():this.locale(b)}),localeData:function(){return this._locale},_dateUtcOffset:function(){return 15*-Math.round(this._d.getTimezoneOffset()/15)}}),vb.fn.millisecond=vb.fn.milliseconds=qb("Milliseconds",!1),vb.fn.second=vb.fn.seconds=qb("Seconds",!1),vb.fn.minute=vb.fn.minutes=qb("Minutes",!1),vb.fn.hour=vb.fn.hours=qb("Hours",!0),vb.fn.date=qb("Date",!0),vb.fn.dates=f("dates accessor is deprecated. Use date instead.",qb("Date",!0)),vb.fn.year=qb("FullYear",!0),vb.fn.years=f("years accessor is deprecated. Use year instead.",qb("FullYear",!0)),vb.fn.days=vb.fn.day,vb.fn.months=vb.fn.month,vb.fn.weeks=vb.fn.week,vb.fn.isoWeeks=vb.fn.isoWeek,vb.fn.quarters=vb.fn.quarter,vb.fn.toJSON=vb.fn.toISOString,vb.fn.isUTC=vb.fn.isUtc,o(vb.duration.fn=n.prototype,{_bubble:function(){var a,b,c,d=this._milliseconds,e=this._days,f=this._months,g=this._data,h=0;g.milliseconds=d%1e3,a=q(d/1e3),g.seconds=a%60,b=q(a/60),g.minutes=b%60,c=q(b/60),g.hours=c%24,e+=q(c/24),h=q(rb(e)),e-=q(sb(h)),f+=q(e/30),e%=30,h+=q(f/12),f%=12,g.days=e,g.months=f,g.years=h},abs:function(){return this._milliseconds=Math.abs(this._milliseconds),this._days=Math.abs(this._days),this._months=Math.abs(this._months),this._data.milliseconds=Math.abs(this._data.milliseconds),this._data.seconds=Math.abs(this._data.seconds),this._data.minutes=Math.abs(this._data.minutes),this._data.hours=Math.abs(this._data.hours),this._data.months=Math.abs(this._data.months),this._data.years=Math.abs(this._data.years),this},weeks:function(){return q(this.days()/7)},valueOf:function(){return this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*C(this._months/12)
},humanize:function(a){var b=ib(this,!a,this.localeData());return a&&(b=this.localeData().pastFuture(+this,b)),this.localeData().postformat(b)},add:function(a,b){var c=vb.duration(a,b);return this._milliseconds+=c._milliseconds,this._days+=c._days,this._months+=c._months,this._bubble(),this},subtract:function(a,b){var c=vb.duration(a,b);return this._milliseconds-=c._milliseconds,this._days-=c._days,this._months-=c._months,this._bubble(),this},get:function(a){return a=z(a),this[a.toLowerCase()+"s"]()},as:function(a){var b,c;if(a=z(a),"month"===a||"year"===a)return b=this._days+this._milliseconds/864e5,c=this._months+12*rb(b),"month"===a?c:c/12;switch(b=this._days+Math.round(sb(this._months/12)),a){case"week":return b/7+this._milliseconds/6048e5;case"day":return b+this._milliseconds/864e5;case"hour":return 24*b+this._milliseconds/36e5;case"minute":return 24*b*60+this._milliseconds/6e4;case"second":return 24*b*60*60+this._milliseconds/1e3;case"millisecond":return Math.floor(24*b*60*60*1e3)+this._milliseconds;default:throw new Error("Unknown unit "+a)}},lang:vb.fn.lang,locale:vb.fn.locale,toIsoString:f("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",function(){return this.toISOString()}),toISOString:function(){var a=Math.abs(this.years()),b=Math.abs(this.months()),c=Math.abs(this.days()),d=Math.abs(this.hours()),e=Math.abs(this.minutes()),f=Math.abs(this.seconds()+this.milliseconds()/1e3);return this.asSeconds()?(this.asSeconds()<0?"-":"")+"P"+(a?a+"Y":"")+(b?b+"M":"")+(c?c+"D":"")+(d||e||f?"T":"")+(d?d+"H":"")+(e?e+"M":"")+(f?f+"S":""):"P0D"},localeData:function(){return this._locale},toJSON:function(){return this.toISOString()}}),vb.duration.fn.toString=vb.duration.fn.toISOString;for(xb in kc)c(kc,xb)&&tb(xb.toLowerCase());vb.duration.fn.asMilliseconds=function(){return this.as("ms")},vb.duration.fn.asSeconds=function(){return this.as("s")},vb.duration.fn.asMinutes=function(){return this.as("m")},vb.duration.fn.asHours=function(){return this.as("h")},vb.duration.fn.asDays=function(){return this.as("d")},vb.duration.fn.asWeeks=function(){return this.as("weeks")},vb.duration.fn.asMonths=function(){return this.as("M")},vb.duration.fn.asYears=function(){return this.as("y")},vb.locale("en",{ordinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(a){var b=a%10,c=1===C(a%100/10)?"th":1===b?"st":2===b?"nd":3===b?"rd":"th";return a+c}}),Lb?module.exports=vb:"function"==typeof define&&define.amd?(define(function(a,b,c){return c.config&&c.config()&&c.config().noGlobal===!0&&(zb.moment=wb),vb}),ub(!0)):ub()}).call(this);
/*! jQuery v3.1.1 | (c) jQuery Foundation | jquery.org/license */
!function(a,b){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){"use strict";var c=[],d=a.document,e=Object.getPrototypeOf,f=c.slice,g=c.concat,h=c.push,i=c.indexOf,j={},k=j.toString,l=j.hasOwnProperty,m=l.toString,n=m.call(Object),o={};function p(a,b){b=b||d;var c=b.createElement("script");c.text=a,b.head.appendChild(c).parentNode.removeChild(c)}var q="3.1.1",r=function(a,b){return new r.fn.init(a,b)},s=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,t=/^-ms-/,u=/-([a-z])/g,v=function(a,b){return b.toUpperCase()};r.fn=r.prototype={jquery:q,constructor:r,length:0,toArray:function(){return f.call(this)},get:function(a){return null==a?f.call(this):a<0?this[a+this.length]:this[a]},pushStack:function(a){var b=r.merge(this.constructor(),a);return b.prevObject=this,b},each:function(a){return r.each(this,a)},map:function(a){return this.pushStack(r.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(f.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(a<0?b:0);return this.pushStack(c>=0&&c<b?[this[c]]:[])},end:function(){return this.prevObject||this.constructor()},push:h,sort:c.sort,splice:c.splice},r.extend=r.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||r.isFunction(g)||(g={}),h===i&&(g=this,h--);h<i;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(r.isPlainObject(d)||(e=r.isArray(d)))?(e?(e=!1,f=c&&r.isArray(c)?c:[]):f=c&&r.isPlainObject(c)?c:{},g[b]=r.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},r.extend({expando:"jQuery"+(q+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===r.type(a)},isArray:Array.isArray,isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){var b=r.type(a);return("number"===b||"string"===b)&&!isNaN(a-parseFloat(a))},isPlainObject:function(a){var b,c;return!(!a||"[object Object]"!==k.call(a))&&(!(b=e(a))||(c=l.call(b,"constructor")&&b.constructor,"function"==typeof c&&m.call(c)===n))},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?j[k.call(a)]||"object":typeof a},globalEval:function(a){p(a)},camelCase:function(a){return a.replace(t,"ms-").replace(u,v)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b){var c,d=0;if(w(a)){for(c=a.length;d<c;d++)if(b.call(a[d],d,a[d])===!1)break}else for(d in a)if(b.call(a[d],d,a[d])===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(s,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(w(Object(a))?r.merge(c,"string"==typeof a?[a]:a):h.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:i.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;d<c;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;f<g;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,e,f=0,h=[];if(w(a))for(d=a.length;f<d;f++)e=b(a[f],f,c),null!=e&&h.push(e);else for(f in a)e=b(a[f],f,c),null!=e&&h.push(e);return g.apply([],h)},guid:1,proxy:function(a,b){var c,d,e;if("string"==typeof b&&(c=a[b],b=a,a=c),r.isFunction(a))return d=f.call(arguments,2),e=function(){return a.apply(b||this,d.concat(f.call(arguments)))},e.guid=a.guid=a.guid||r.guid++,e},now:Date.now,support:o}),"function"==typeof Symbol&&(r.fn[Symbol.iterator]=c[Symbol.iterator]),r.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(a,b){j["[object "+b+"]"]=b.toLowerCase()});function w(a){var b=!!a&&"length"in a&&a.length,c=r.type(a);return"function"!==c&&!r.isWindow(a)&&("array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a)}var x=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C={}.hasOwnProperty,D=[],E=D.pop,F=D.push,G=D.push,H=D.slice,I=function(a,b){for(var c=0,d=a.length;c<d;c++)if(a[c]===b)return c;return-1},J="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",K="[\\x20\\t\\r\\n\\f]",L="(?:\\\\.|[\\w-]|[^\0-\\xa0])+",M="\\["+K+"*("+L+")(?:"+K+"*([*^$|!~]?=)"+K+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+L+"))|)"+K+"*\\]",N=":("+L+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+M+")*)|.*)\\)|)",O=new RegExp(K+"+","g"),P=new RegExp("^"+K+"+|((?:^|[^\\\\])(?:\\\\.)*)"+K+"+$","g"),Q=new RegExp("^"+K+"*,"+K+"*"),R=new RegExp("^"+K+"*([>+~]|"+K+")"+K+"*"),S=new RegExp("="+K+"*([^\\]'\"]*?)"+K+"*\\]","g"),T=new RegExp(N),U=new RegExp("^"+L+"$"),V={ID:new RegExp("^#("+L+")"),CLASS:new RegExp("^\\.("+L+")"),TAG:new RegExp("^("+L+"|[*])"),ATTR:new RegExp("^"+M),PSEUDO:new RegExp("^"+N),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+K+"*(even|odd|(([+-]|)(\\d*)n|)"+K+"*(?:([+-]|)"+K+"*(\\d+)|))"+K+"*\\)|)","i"),bool:new RegExp("^(?:"+J+")$","i"),needsContext:new RegExp("^"+K+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+K+"*((?:-\\d)?\\d*)"+K+"*\\)|)(?=[^-]|$)","i")},W=/^(?:input|select|textarea|button)$/i,X=/^h\d$/i,Y=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,$=/[+~]/,_=new RegExp("\\\\([\\da-f]{1,6}"+K+"?|("+K+")|.)","ig"),aa=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:d<0?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ba=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ca=function(a,b){return b?"\0"===a?"\ufffd":a.slice(0,-1)+"\\"+a.charCodeAt(a.length-1).toString(16)+" ":"\\"+a},da=function(){m()},ea=ta(function(a){return a.disabled===!0&&("form"in a||"label"in a)},{dir:"parentNode",next:"legend"});try{G.apply(D=H.call(v.childNodes),v.childNodes),D[v.childNodes.length].nodeType}catch(fa){G={apply:D.length?function(a,b){F.apply(a,H.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s=b&&b.ownerDocument,w=b?b.nodeType:9;if(d=d||[],"string"!=typeof a||!a||1!==w&&9!==w&&11!==w)return d;if(!e&&((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,p)){if(11!==w&&(l=Z.exec(a)))if(f=l[1]){if(9===w){if(!(j=b.getElementById(f)))return d;if(j.id===f)return d.push(j),d}else if(s&&(j=s.getElementById(f))&&t(b,j)&&j.id===f)return d.push(j),d}else{if(l[2])return G.apply(d,b.getElementsByTagName(a)),d;if((f=l[3])&&c.getElementsByClassName&&b.getElementsByClassName)return G.apply(d,b.getElementsByClassName(f)),d}if(c.qsa&&!A[a+" "]&&(!q||!q.test(a))){if(1!==w)s=b,r=a;else if("object"!==b.nodeName.toLowerCase()){(k=b.getAttribute("id"))?k=k.replace(ba,ca):b.setAttribute("id",k=u),o=g(a),h=o.length;while(h--)o[h]="#"+k+" "+sa(o[h]);r=o.join(","),s=$.test(a)&&qa(b.parentNode)||b}if(r)try{return G.apply(d,s.querySelectorAll(r)),d}catch(x){}finally{k===u&&b.removeAttribute("id")}}}return i(a.replace(P,"$1"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement("fieldset");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split("|"),e=c.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&a.sourceIndex-b.sourceIndex;if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function oa(a){return function(b){return"form"in b?b.parentNode&&b.disabled===!1?"label"in b?"label"in b.parentNode?b.parentNode.disabled===a:b.disabled===a:b.isDisabled===a||b.isDisabled!==!a&&ea(b)===a:b.disabled===a:"label"in b&&b.disabled===a}}function pa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function qa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return!!b&&"HTML"!==b.nodeName},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=n.documentElement,p=!f(n),v!==n&&(e=n.defaultView)&&e.top!==e&&(e.addEventListener?e.addEventListener("unload",da,!1):e.attachEvent&&e.attachEvent("onunload",da)),c.attributes=ja(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ja(function(a){return a.appendChild(n.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=Y.test(n.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!n.getElementsByName||!n.getElementsByName(u).length}),c.getById?(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){return a.getAttribute("id")===b}},d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c?[c]:[]}}):(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}},d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c,d,e,f=b.getElementById(a);if(f){if(c=f.getAttributeNode("id"),c&&c.value===a)return[f];e=b.getElementsByName(a),d=0;while(f=e[d++])if(c=f.getAttributeNode("id"),c&&c.value===a)return[f]}return[]}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){if("undefined"!=typeof b.getElementsByClassName&&p)return b.getElementsByClassName(a)},r=[],q=[],(c.qsa=Y.test(n.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\r\\' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+K+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+K+"*(?:value|"+J+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ja(function(a){a.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var b=n.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+K+"*[*^$|!~]?="),2!==a.querySelectorAll(":enabled").length&&q.push(":enabled",":disabled"),o.appendChild(a).disabled=!0,2!==a.querySelectorAll(":disabled").length&&q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=Y.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,"*"),s.call(a,"[s!='']:x"),r.push("!=",N)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=Y.test(o.compareDocumentPosition),t=b||Y.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===n||a.ownerDocument===v&&t(v,a)?-1:b===n||b.ownerDocument===v&&t(v,b)?1:k?I(k,a)-I(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,g=[a],h=[b];if(!e||!f)return a===n?-1:b===n?1:e?-1:f?1:k?I(k,a)-I(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)g.unshift(c);c=b;while(c=c.parentNode)h.unshift(c);while(g[d]===h[d])d++;return d?la(g[d],h[d]):g[d]===v?-1:h[d]===v?1:0},n):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(S,"='$1']"),c.matchesSelector&&p&&!A[b+" "]&&(!r||!r.test(b))&&(!q||!q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&C.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.escape=function(a){return(a+"").replace(ba,ca)},ga.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:V,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(_,aa),a[3]=(a[3]||a[4]||a[5]||"").replace(_,aa),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return V.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&T.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(_,aa).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+K+")"+a+"("+K+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?"!="===b:!b||(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(O," ")+" ").indexOf(c)>-1:"|="===b&&(e===c||e.slice(0,c.length+1)===c+"-"))}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h,t=!1;if(q){if(f){while(p){m=b;while(m=m[p])if(h?m.nodeName.toLowerCase()===r:1===m.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){m=q,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n&&j[2],m=n&&q.childNodes[n];while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if(1===m.nodeType&&++t&&m===b){k[a]=[w,n,t];break}}else if(s&&(m=b,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n),t===!1)while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if((h?m.nodeName.toLowerCase()===r:1===m.nodeType)&&++t&&(s&&(l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),k[a]=[w,t]),m===b))break;return t-=e,t===d||t%d===0&&t/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=I(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(P,"$1"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(_,aa),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return U.test(a||"")||ga.error("unsupported lang: "+a),a=a.replace(_,aa).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:oa(!1),disabled:oa(!0),checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return X.test(a.nodeName)},input:function(a){return W.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:pa(function(){return[0]}),last:pa(function(a,b){return[b-1]}),eq:pa(function(a,b,c){return[c<0?c+b:c]}),even:pa(function(a,b){for(var c=0;c<b;c+=2)a.push(c);return a}),odd:pa(function(a,b){for(var c=1;c<b;c+=2)a.push(c);return a}),lt:pa(function(a,b,c){for(var d=c<0?c+b:c;--d>=0;)a.push(d);return a}),gt:pa(function(a,b,c){for(var d=c<0?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function ra(){}ra.prototype=d.filters=d.pseudos,d.setFilters=new ra,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){c&&!(e=Q.exec(h))||(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=R.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(P," ")}),h=h.slice(c.length));for(g in d.filter)!(e=V[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function sa(a){for(var b=0,c=a.length,d="";b<c;b++)d+=a[b].value;return d}function ta(a,b,c){var d=b.dir,e=b.next,f=e||d,g=c&&"parentNode"===f,h=x++;return b.first?function(b,c,e){while(b=b[d])if(1===b.nodeType||g)return a(b,c,e);return!1}:function(b,c,i){var j,k,l,m=[w,h];if(i){while(b=b[d])if((1===b.nodeType||g)&&a(b,c,i))return!0}else while(b=b[d])if(1===b.nodeType||g)if(l=b[u]||(b[u]={}),k=l[b.uniqueID]||(l[b.uniqueID]={}),e&&e===b.nodeName.toLowerCase())b=b[d]||b;else{if((j=k[f])&&j[0]===w&&j[1]===h)return m[2]=j[2];if(k[f]=m,m[2]=a(b,c,i))return!0}return!1}}function ua(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function va(a,b,c){for(var d=0,e=b.length;d<e;d++)ga(a,b[d],c);return c}function wa(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;h<i;h++)(f=a[h])&&(c&&!c(f,d,e)||(g.push(f),j&&b.push(h)));return g}function xa(a,b,c,d,e,f){return d&&!d[u]&&(d=xa(d)),e&&!e[u]&&(e=xa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||va(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:wa(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=wa(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?I(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=wa(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):G.apply(g,r)})}function ya(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=ta(function(a){return a===b},h,!0),l=ta(function(a){return I(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];i<f;i++)if(c=d.relative[a[i].type])m=[ta(ua(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;e<f;e++)if(d.relative[a[e].type])break;return xa(i>1&&ua(m),i>1&&sa(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(P,"$1"),c,i<e&&ya(a.slice(i,e)),e<f&&ya(a=a.slice(e)),e<f&&sa(a))}m.push(c)}return ua(m)}function za(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,o,q,r=0,s="0",t=f&&[],u=[],v=j,x=f||e&&d.find.TAG("*",k),y=w+=null==v?1:Math.random()||.1,z=x.length;for(k&&(j=g===n||g||k);s!==z&&null!=(l=x[s]);s++){if(e&&l){o=0,g||l.ownerDocument===n||(m(l),h=!p);while(q=a[o++])if(q(l,g||n,h)){i.push(l);break}k&&(w=y)}c&&((l=!q&&l)&&r--,f&&t.push(l))}if(r+=s,c&&s!==r){o=0;while(q=b[o++])q(t,u,g,h);if(f){if(r>0)while(s--)t[s]||u[s]||(u[s]=E.call(i));u=wa(u)}G.apply(i,u),k&&!f&&u.length>0&&r+b.length>1&&ga.uniqueSort(i)}return k&&(w=y,j=v),t};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=ya(b[c]),f[u]?d.push(f):e.push(f);f=A(a,za(e,d)),f.selector=a}return f},i=ga.select=function(a,b,c,e){var f,i,j,k,l,m="function"==typeof a&&a,n=!e&&g(a=m.selector||a);if(c=c||[],1===n.length){if(i=n[0]=n[0].slice(0),i.length>2&&"ID"===(j=i[0]).type&&9===b.nodeType&&p&&d.relative[i[1].type]){if(b=(d.find.ID(j.matches[0].replace(_,aa),b)||[])[0],!b)return c;m&&(b=b.parentNode),a=a.slice(i.shift().value.length)}f=V.needsContext.test(a)?0:i.length;while(f--){if(j=i[f],d.relative[k=j.type])break;if((l=d.find[k])&&(e=l(j.matches[0].replace(_,aa),$.test(i[0].type)&&qa(b.parentNode)||b))){if(i.splice(f,1),a=e.length&&sa(i),!a)return G.apply(c,e),c;break}}}return(m||h(a,n))(e,b,!p,c,!b||$.test(a)&&qa(b.parentNode)||b),c},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement("fieldset"))}),ja(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ka("type|href|height|width",function(a,b,c){if(!c)return a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ka("value",function(a,b,c){if(!c&&"input"===a.nodeName.toLowerCase())return a.defaultValue}),ja(function(a){return null==a.getAttribute("disabled")})||ka(J,function(a,b,c){var d;if(!c)return a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);r.find=x,r.expr=x.selectors,r.expr[":"]=r.expr.pseudos,r.uniqueSort=r.unique=x.uniqueSort,r.text=x.getText,r.isXMLDoc=x.isXML,r.contains=x.contains,r.escapeSelector=x.escape;var y=function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&r(a).is(c))break;d.push(a)}return d},z=function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c},A=r.expr.match.needsContext,B=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i,C=/^.[^:#\[\.,]*$/;function D(a,b,c){return r.isFunction(b)?r.grep(a,function(a,d){return!!b.call(a,d,a)!==c}):b.nodeType?r.grep(a,function(a){return a===b!==c}):"string"!=typeof b?r.grep(a,function(a){return i.call(b,a)>-1!==c}):C.test(b)?r.filter(b,a,c):(b=r.filter(b,a),r.grep(a,function(a){return i.call(b,a)>-1!==c&&1===a.nodeType}))}r.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?r.find.matchesSelector(d,a)?[d]:[]:r.find.matches(a,r.grep(b,function(a){return 1===a.nodeType}))},r.fn.extend({find:function(a){var b,c,d=this.length,e=this;if("string"!=typeof a)return this.pushStack(r(a).filter(function(){for(b=0;b<d;b++)if(r.contains(e[b],this))return!0}));for(c=this.pushStack([]),b=0;b<d;b++)r.find(a,e[b],c);return d>1?r.uniqueSort(c):c},filter:function(a){return this.pushStack(D(this,a||[],!1))},not:function(a){return this.pushStack(D(this,a||[],!0))},is:function(a){return!!D(this,"string"==typeof a&&A.test(a)?r(a):a||[],!1).length}});var E,F=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,G=r.fn.init=function(a,b,c){var e,f;if(!a)return this;if(c=c||E,"string"==typeof a){if(e="<"===a[0]&&">"===a[a.length-1]&&a.length>=3?[null,a,null]:F.exec(a),!e||!e[1]&&b)return!b||b.jquery?(b||c).find(a):this.constructor(b).find(a);if(e[1]){if(b=b instanceof r?b[0]:b,r.merge(this,r.parseHTML(e[1],b&&b.nodeType?b.ownerDocument||b:d,!0)),B.test(e[1])&&r.isPlainObject(b))for(e in b)r.isFunction(this[e])?this[e](b[e]):this.attr(e,b[e]);return this}return f=d.getElementById(e[2]),f&&(this[0]=f,this.length=1),this}return a.nodeType?(this[0]=a,this.length=1,this):r.isFunction(a)?void 0!==c.ready?c.ready(a):a(r):r.makeArray(a,this)};G.prototype=r.fn,E=r(d);var H=/^(?:parents|prev(?:Until|All))/,I={children:!0,contents:!0,next:!0,prev:!0};r.fn.extend({has:function(a){var b=r(a,this),c=b.length;return this.filter(function(){for(var a=0;a<c;a++)if(r.contains(this,b[a]))return!0})},closest:function(a,b){var c,d=0,e=this.length,f=[],g="string"!=typeof a&&r(a);if(!A.test(a))for(;d<e;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&r.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?r.uniqueSort(f):f)},index:function(a){return a?"string"==typeof a?i.call(r(a),this[0]):i.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(r.uniqueSort(r.merge(this.get(),r(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function J(a,b){while((a=a[b])&&1!==a.nodeType);return a}r.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return y(a,"parentNode")},parentsUntil:function(a,b,c){return y(a,"parentNode",c)},next:function(a){return J(a,"nextSibling")},prev:function(a){return J(a,"previousSibling")},nextAll:function(a){return y(a,"nextSibling")},prevAll:function(a){return y(a,"previousSibling")},nextUntil:function(a,b,c){return y(a,"nextSibling",c)},prevUntil:function(a,b,c){return y(a,"previousSibling",c)},siblings:function(a){return z((a.parentNode||{}).firstChild,a)},children:function(a){return z(a.firstChild)},contents:function(a){return a.contentDocument||r.merge([],a.childNodes)}},function(a,b){r.fn[a]=function(c,d){var e=r.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=r.filter(d,e)),this.length>1&&(I[a]||r.uniqueSort(e),H.test(a)&&e.reverse()),this.pushStack(e)}});var K=/[^\x20\t\r\n\f]+/g;function L(a){var b={};return r.each(a.match(K)||[],function(a,c){b[c]=!0}),b}r.Callbacks=function(a){a="string"==typeof a?L(a):r.extend({},a);var b,c,d,e,f=[],g=[],h=-1,i=function(){for(e=a.once,d=b=!0;g.length;h=-1){c=g.shift();while(++h<f.length)f[h].apply(c[0],c[1])===!1&&a.stopOnFalse&&(h=f.length,c=!1)}a.memory||(c=!1),b=!1,e&&(f=c?[]:"")},j={add:function(){return f&&(c&&!b&&(h=f.length-1,g.push(c)),function d(b){r.each(b,function(b,c){r.isFunction(c)?a.unique&&j.has(c)||f.push(c):c&&c.length&&"string"!==r.type(c)&&d(c)})}(arguments),c&&!b&&i()),this},remove:function(){return r.each(arguments,function(a,b){var c;while((c=r.inArray(b,f,c))>-1)f.splice(c,1),c<=h&&h--}),this},has:function(a){return a?r.inArray(a,f)>-1:f.length>0},empty:function(){return f&&(f=[]),this},disable:function(){return e=g=[],f=c="",this},disabled:function(){return!f},lock:function(){return e=g=[],c||b||(f=c=""),this},locked:function(){return!!e},fireWith:function(a,c){return e||(c=c||[],c=[a,c.slice?c.slice():c],g.push(c),b||i()),this},fire:function(){return j.fireWith(this,arguments),this},fired:function(){return!!d}};return j};function M(a){return a}function N(a){throw a}function O(a,b,c){var d;try{a&&r.isFunction(d=a.promise)?d.call(a).done(b).fail(c):a&&r.isFunction(d=a.then)?d.call(a,b,c):b.call(void 0,a)}catch(a){c.call(void 0,a)}}r.extend({Deferred:function(b){var c=[["notify","progress",r.Callbacks("memory"),r.Callbacks("memory"),2],["resolve","done",r.Callbacks("once memory"),r.Callbacks("once memory"),0,"resolved"],["reject","fail",r.Callbacks("once memory"),r.Callbacks("once memory"),1,"rejected"]],d="pending",e={state:function(){return d},always:function(){return f.done(arguments).fail(arguments),this},"catch":function(a){return e.then(null,a)},pipe:function(){var a=arguments;return r.Deferred(function(b){r.each(c,function(c,d){var e=r.isFunction(a[d[4]])&&a[d[4]];f[d[1]](function(){var a=e&&e.apply(this,arguments);a&&r.isFunction(a.promise)?a.promise().progress(b.notify).done(b.resolve).fail(b.reject):b[d[0]+"With"](this,e?[a]:arguments)})}),a=null}).promise()},then:function(b,d,e){var f=0;function g(b,c,d,e){return function(){var h=this,i=arguments,j=function(){var a,j;if(!(b<f)){if(a=d.apply(h,i),a===c.promise())throw new TypeError("Thenable self-resolution");j=a&&("object"==typeof a||"function"==typeof a)&&a.then,r.isFunction(j)?e?j.call(a,g(f,c,M,e),g(f,c,N,e)):(f++,j.call(a,g(f,c,M,e),g(f,c,N,e),g(f,c,M,c.notifyWith))):(d!==M&&(h=void 0,i=[a]),(e||c.resolveWith)(h,i))}},k=e?j:function(){try{j()}catch(a){r.Deferred.exceptionHook&&r.Deferred.exceptionHook(a,k.stackTrace),b+1>=f&&(d!==N&&(h=void 0,i=[a]),c.rejectWith(h,i))}};b?k():(r.Deferred.getStackHook&&(k.stackTrace=r.Deferred.getStackHook()),a.setTimeout(k))}}return r.Deferred(function(a){c[0][3].add(g(0,a,r.isFunction(e)?e:M,a.notifyWith)),c[1][3].add(g(0,a,r.isFunction(b)?b:M)),c[2][3].add(g(0,a,r.isFunction(d)?d:N))}).promise()},promise:function(a){return null!=a?r.extend(a,e):e}},f={};return r.each(c,function(a,b){var g=b[2],h=b[5];e[b[1]]=g.add,h&&g.add(function(){d=h},c[3-a][2].disable,c[0][2].lock),g.add(b[3].fire),f[b[0]]=function(){return f[b[0]+"With"](this===f?void 0:this,arguments),this},f[b[0]+"With"]=g.fireWith}),e.promise(f),b&&b.call(f,f),f},when:function(a){var b=arguments.length,c=b,d=Array(c),e=f.call(arguments),g=r.Deferred(),h=function(a){return function(c){d[a]=this,e[a]=arguments.length>1?f.call(arguments):c,--b||g.resolveWith(d,e)}};if(b<=1&&(O(a,g.done(h(c)).resolve,g.reject),"pending"===g.state()||r.isFunction(e[c]&&e[c].then)))return g.then();while(c--)O(e[c],h(c),g.reject);return g.promise()}});var P=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;r.Deferred.exceptionHook=function(b,c){a.console&&a.console.warn&&b&&P.test(b.name)&&a.console.warn("jQuery.Deferred exception: "+b.message,b.stack,c)},r.readyException=function(b){a.setTimeout(function(){throw b})};var Q=r.Deferred();r.fn.ready=function(a){return Q.then(a)["catch"](function(a){r.readyException(a)}),this},r.extend({isReady:!1,readyWait:1,holdReady:function(a){a?r.readyWait++:r.ready(!0)},ready:function(a){(a===!0?--r.readyWait:r.isReady)||(r.isReady=!0,a!==!0&&--r.readyWait>0||Q.resolveWith(d,[r]))}}),r.ready.then=Q.then;function R(){d.removeEventListener("DOMContentLoaded",R),
a.removeEventListener("load",R),r.ready()}"complete"===d.readyState||"loading"!==d.readyState&&!d.documentElement.doScroll?a.setTimeout(r.ready):(d.addEventListener("DOMContentLoaded",R),a.addEventListener("load",R));var S=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===r.type(c)){e=!0;for(h in c)S(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,r.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(r(a),c)})),b))for(;h<i;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},T=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function U(){this.expando=r.expando+U.uid++}U.uid=1,U.prototype={cache:function(a){var b=a[this.expando];return b||(b={},T(a)&&(a.nodeType?a[this.expando]=b:Object.defineProperty(a,this.expando,{value:b,configurable:!0}))),b},set:function(a,b,c){var d,e=this.cache(a);if("string"==typeof b)e[r.camelCase(b)]=c;else for(d in b)e[r.camelCase(d)]=b[d];return e},get:function(a,b){return void 0===b?this.cache(a):a[this.expando]&&a[this.expando][r.camelCase(b)]},access:function(a,b,c){return void 0===b||b&&"string"==typeof b&&void 0===c?this.get(a,b):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d=a[this.expando];if(void 0!==d){if(void 0!==b){r.isArray(b)?b=b.map(r.camelCase):(b=r.camelCase(b),b=b in d?[b]:b.match(K)||[]),c=b.length;while(c--)delete d[b[c]]}(void 0===b||r.isEmptyObject(d))&&(a.nodeType?a[this.expando]=void 0:delete a[this.expando])}},hasData:function(a){var b=a[this.expando];return void 0!==b&&!r.isEmptyObject(b)}};var V=new U,W=new U,X=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,Y=/[A-Z]/g;function Z(a){return"true"===a||"false"!==a&&("null"===a?null:a===+a+""?+a:X.test(a)?JSON.parse(a):a)}function $(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d="data-"+b.replace(Y,"-$&").toLowerCase(),c=a.getAttribute(d),"string"==typeof c){try{c=Z(c)}catch(e){}W.set(a,b,c)}else c=void 0;return c}r.extend({hasData:function(a){return W.hasData(a)||V.hasData(a)},data:function(a,b,c){return W.access(a,b,c)},removeData:function(a,b){W.remove(a,b)},_data:function(a,b,c){return V.access(a,b,c)},_removeData:function(a,b){V.remove(a,b)}}),r.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=W.get(f),1===f.nodeType&&!V.get(f,"hasDataAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=r.camelCase(d.slice(5)),$(f,d,e[d])));V.set(f,"hasDataAttrs",!0)}return e}return"object"==typeof a?this.each(function(){W.set(this,a)}):S(this,function(b){var c;if(f&&void 0===b){if(c=W.get(f,a),void 0!==c)return c;if(c=$(f,a),void 0!==c)return c}else this.each(function(){W.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){W.remove(this,a)})}}),r.extend({queue:function(a,b,c){var d;if(a)return b=(b||"fx")+"queue",d=V.get(a,b),c&&(!d||r.isArray(c)?d=V.access(a,b,r.makeArray(c)):d.push(c)),d||[]},dequeue:function(a,b){b=b||"fx";var c=r.queue(a,b),d=c.length,e=c.shift(),f=r._queueHooks(a,b),g=function(){r.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return V.get(a,c)||V.access(a,c,{empty:r.Callbacks("once memory").add(function(){V.remove(a,[b+"queue",c])})})}}),r.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?r.queue(this[0],a):void 0===b?this:this.each(function(){var c=r.queue(this,a,b);r._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&r.dequeue(this,a)})},dequeue:function(a){return this.each(function(){r.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=r.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=V.get(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var _=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,aa=new RegExp("^(?:([+-])=|)("+_+")([a-z%]*)$","i"),ba=["Top","Right","Bottom","Left"],ca=function(a,b){return a=b||a,"none"===a.style.display||""===a.style.display&&r.contains(a.ownerDocument,a)&&"none"===r.css(a,"display")},da=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};function ea(a,b,c,d){var e,f=1,g=20,h=d?function(){return d.cur()}:function(){return r.css(a,b,"")},i=h(),j=c&&c[3]||(r.cssNumber[b]?"":"px"),k=(r.cssNumber[b]||"px"!==j&&+i)&&aa.exec(r.css(a,b));if(k&&k[3]!==j){j=j||k[3],c=c||[],k=+i||1;do f=f||".5",k/=f,r.style(a,b,k+j);while(f!==(f=h()/i)&&1!==f&&--g)}return c&&(k=+k||+i||0,e=c[1]?k+(c[1]+1)*c[2]:+c[2],d&&(d.unit=j,d.start=k,d.end=e)),e}var fa={};function ga(a){var b,c=a.ownerDocument,d=a.nodeName,e=fa[d];return e?e:(b=c.body.appendChild(c.createElement(d)),e=r.css(b,"display"),b.parentNode.removeChild(b),"none"===e&&(e="block"),fa[d]=e,e)}function ha(a,b){for(var c,d,e=[],f=0,g=a.length;f<g;f++)d=a[f],d.style&&(c=d.style.display,b?("none"===c&&(e[f]=V.get(d,"display")||null,e[f]||(d.style.display="")),""===d.style.display&&ca(d)&&(e[f]=ga(d))):"none"!==c&&(e[f]="none",V.set(d,"display",c)));for(f=0;f<g;f++)null!=e[f]&&(a[f].style.display=e[f]);return a}r.fn.extend({show:function(){return ha(this,!0)},hide:function(){return ha(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){ca(this)?r(this).show():r(this).hide()})}});var ia=/^(?:checkbox|radio)$/i,ja=/<([a-z][^\/\0>\x20\t\r\n\f]+)/i,ka=/^$|\/(?:java|ecma)script/i,la={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};la.optgroup=la.option,la.tbody=la.tfoot=la.colgroup=la.caption=la.thead,la.th=la.td;function ma(a,b){var c;return c="undefined"!=typeof a.getElementsByTagName?a.getElementsByTagName(b||"*"):"undefined"!=typeof a.querySelectorAll?a.querySelectorAll(b||"*"):[],void 0===b||b&&r.nodeName(a,b)?r.merge([a],c):c}function na(a,b){for(var c=0,d=a.length;c<d;c++)V.set(a[c],"globalEval",!b||V.get(b[c],"globalEval"))}var oa=/<|&#?\w+;/;function pa(a,b,c,d,e){for(var f,g,h,i,j,k,l=b.createDocumentFragment(),m=[],n=0,o=a.length;n<o;n++)if(f=a[n],f||0===f)if("object"===r.type(f))r.merge(m,f.nodeType?[f]:f);else if(oa.test(f)){g=g||l.appendChild(b.createElement("div")),h=(ja.exec(f)||["",""])[1].toLowerCase(),i=la[h]||la._default,g.innerHTML=i[1]+r.htmlPrefilter(f)+i[2],k=i[0];while(k--)g=g.lastChild;r.merge(m,g.childNodes),g=l.firstChild,g.textContent=""}else m.push(b.createTextNode(f));l.textContent="",n=0;while(f=m[n++])if(d&&r.inArray(f,d)>-1)e&&e.push(f);else if(j=r.contains(f.ownerDocument,f),g=ma(l.appendChild(f),"script"),j&&na(g),c){k=0;while(f=g[k++])ka.test(f.type||"")&&c.push(f)}return l}!function(){var a=d.createDocumentFragment(),b=a.appendChild(d.createElement("div")),c=d.createElement("input");c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),b.appendChild(c),o.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML="<textarea>x</textarea>",o.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var qa=d.documentElement,ra=/^key/,sa=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,ta=/^([^.]*)(?:\.(.+)|)/;function ua(){return!0}function va(){return!1}function wa(){try{return d.activeElement}catch(a){}}function xa(a,b,c,d,e,f){var g,h;if("object"==typeof b){"string"!=typeof c&&(d=d||c,c=void 0);for(h in b)xa(a,h,c,d,b[h],f);return a}if(null==d&&null==e?(e=c,d=c=void 0):null==e&&("string"==typeof c?(e=d,d=void 0):(e=d,d=c,c=void 0)),e===!1)e=va;else if(!e)return a;return 1===f&&(g=e,e=function(a){return r().off(a),g.apply(this,arguments)},e.guid=g.guid||(g.guid=r.guid++)),a.each(function(){r.event.add(this,b,e,d,c)})}r.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=V.get(a);if(q){c.handler&&(f=c,c=f.handler,e=f.selector),e&&r.find.matchesSelector(qa,e),c.guid||(c.guid=r.guid++),(i=q.events)||(i=q.events={}),(g=q.handle)||(g=q.handle=function(b){return"undefined"!=typeof r&&r.event.triggered!==b.type?r.event.dispatch.apply(a,arguments):void 0}),b=(b||"").match(K)||[""],j=b.length;while(j--)h=ta.exec(b[j])||[],n=p=h[1],o=(h[2]||"").split(".").sort(),n&&(l=r.event.special[n]||{},n=(e?l.delegateType:l.bindType)||n,l=r.event.special[n]||{},k=r.extend({type:n,origType:p,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&r.expr.match.needsContext.test(e),namespace:o.join(".")},f),(m=i[n])||(m=i[n]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,o,g)!==!1||a.addEventListener&&a.addEventListener(n,g)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),r.event.global[n]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=V.hasData(a)&&V.get(a);if(q&&(i=q.events)){b=(b||"").match(K)||[""],j=b.length;while(j--)if(h=ta.exec(b[j])||[],n=p=h[1],o=(h[2]||"").split(".").sort(),n){l=r.event.special[n]||{},n=(d?l.delegateType:l.bindType)||n,m=i[n]||[],h=h[2]&&new RegExp("(^|\\.)"+o.join("\\.(?:.*\\.|)")+"(\\.|$)"),g=f=m.length;while(f--)k=m[f],!e&&p!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&("**"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,o,q.handle)!==!1||r.removeEvent(a,n,q.handle),delete i[n])}else for(n in i)r.event.remove(a,n+b[j],c,d,!0);r.isEmptyObject(i)&&V.remove(a,"handle events")}},dispatch:function(a){var b=r.event.fix(a),c,d,e,f,g,h,i=new Array(arguments.length),j=(V.get(this,"events")||{})[b.type]||[],k=r.event.special[b.type]||{};for(i[0]=b,c=1;c<arguments.length;c++)i[c]=arguments[c];if(b.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,b)!==!1){h=r.event.handlers.call(this,b,j),c=0;while((f=h[c++])&&!b.isPropagationStopped()){b.currentTarget=f.elem,d=0;while((g=f.handlers[d++])&&!b.isImmediatePropagationStopped())b.rnamespace&&!b.rnamespace.test(g.namespace)||(b.handleObj=g,b.data=g.data,e=((r.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(b.result=e)===!1&&(b.preventDefault(),b.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,b),b.result}},handlers:function(a,b){var c,d,e,f,g,h=[],i=b.delegateCount,j=a.target;if(i&&j.nodeType&&!("click"===a.type&&a.button>=1))for(;j!==this;j=j.parentNode||this)if(1===j.nodeType&&("click"!==a.type||j.disabled!==!0)){for(f=[],g={},c=0;c<i;c++)d=b[c],e=d.selector+" ",void 0===g[e]&&(g[e]=d.needsContext?r(e,this).index(j)>-1:r.find(e,this,null,[j]).length),g[e]&&f.push(d);f.length&&h.push({elem:j,handlers:f})}return j=this,i<b.length&&h.push({elem:j,handlers:b.slice(i)}),h},addProp:function(a,b){Object.defineProperty(r.Event.prototype,a,{enumerable:!0,configurable:!0,get:r.isFunction(b)?function(){if(this.originalEvent)return b(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[a]},set:function(b){Object.defineProperty(this,a,{enumerable:!0,configurable:!0,writable:!0,value:b})}})},fix:function(a){return a[r.expando]?a:new r.Event(a)},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==wa()&&this.focus)return this.focus(),!1},delegateType:"focusin"},blur:{trigger:function(){if(this===wa()&&this.blur)return this.blur(),!1},delegateType:"focusout"},click:{trigger:function(){if("checkbox"===this.type&&this.click&&r.nodeName(this,"input"))return this.click(),!1},_default:function(a){return r.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}}},r.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c)},r.Event=function(a,b){return this instanceof r.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?ua:va,this.target=a.target&&3===a.target.nodeType?a.target.parentNode:a.target,this.currentTarget=a.currentTarget,this.relatedTarget=a.relatedTarget):this.type=a,b&&r.extend(this,b),this.timeStamp=a&&a.timeStamp||r.now(),void(this[r.expando]=!0)):new r.Event(a,b)},r.Event.prototype={constructor:r.Event,isDefaultPrevented:va,isPropagationStopped:va,isImmediatePropagationStopped:va,isSimulated:!1,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=ua,a&&!this.isSimulated&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=ua,a&&!this.isSimulated&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=ua,a&&!this.isSimulated&&a.stopImmediatePropagation(),this.stopPropagation()}},r.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(a){var b=a.button;return null==a.which&&ra.test(a.type)?null!=a.charCode?a.charCode:a.keyCode:!a.which&&void 0!==b&&sa.test(a.type)?1&b?1:2&b?3:4&b?2:0:a.which}},r.event.addProp),r.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){r.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return e&&(e===d||r.contains(d,e))||(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),r.fn.extend({on:function(a,b,c,d){return xa(this,a,b,c,d)},one:function(a,b,c,d){return xa(this,a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,r(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return b!==!1&&"function"!=typeof b||(c=b,b=void 0),c===!1&&(c=va),this.each(function(){r.event.remove(this,a,c,b)})}});var ya=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,za=/<script|<style|<link/i,Aa=/checked\s*(?:[^=]|=\s*.checked.)/i,Ba=/^true\/(.*)/,Ca=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function Da(a,b){return r.nodeName(a,"table")&&r.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a:a}function Ea(a){return a.type=(null!==a.getAttribute("type"))+"/"+a.type,a}function Fa(a){var b=Ba.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function Ga(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(V.hasData(a)&&(f=V.access(a),g=V.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;c<d;c++)r.event.add(b,e,j[e][c])}W.hasData(a)&&(h=W.access(a),i=r.extend({},h),W.set(b,i))}}function Ha(a,b){var c=b.nodeName.toLowerCase();"input"===c&&ia.test(a.type)?b.checked=a.checked:"input"!==c&&"textarea"!==c||(b.defaultValue=a.defaultValue)}function Ia(a,b,c,d){b=g.apply([],b);var e,f,h,i,j,k,l=0,m=a.length,n=m-1,q=b[0],s=r.isFunction(q);if(s||m>1&&"string"==typeof q&&!o.checkClone&&Aa.test(q))return a.each(function(e){var f=a.eq(e);s&&(b[0]=q.call(this,e,f.html())),Ia(f,b,c,d)});if(m&&(e=pa(b,a[0].ownerDocument,!1,a,d),f=e.firstChild,1===e.childNodes.length&&(e=f),f||d)){for(h=r.map(ma(e,"script"),Ea),i=h.length;l<m;l++)j=e,l!==n&&(j=r.clone(j,!0,!0),i&&r.merge(h,ma(j,"script"))),c.call(a[l],j,l);if(i)for(k=h[h.length-1].ownerDocument,r.map(h,Fa),l=0;l<i;l++)j=h[l],ka.test(j.type||"")&&!V.access(j,"globalEval")&&r.contains(k,j)&&(j.src?r._evalUrl&&r._evalUrl(j.src):p(j.textContent.replace(Ca,""),k))}return a}function Ja(a,b,c){for(var d,e=b?r.filter(b,a):a,f=0;null!=(d=e[f]);f++)c||1!==d.nodeType||r.cleanData(ma(d)),d.parentNode&&(c&&r.contains(d.ownerDocument,d)&&na(ma(d,"script")),d.parentNode.removeChild(d));return a}r.extend({htmlPrefilter:function(a){return a.replace(ya,"<$1></$2>")},clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=r.contains(a.ownerDocument,a);if(!(o.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||r.isXMLDoc(a)))for(g=ma(h),f=ma(a),d=0,e=f.length;d<e;d++)Ha(f[d],g[d]);if(b)if(c)for(f=f||ma(a),g=g||ma(h),d=0,e=f.length;d<e;d++)Ga(f[d],g[d]);else Ga(a,h);return g=ma(h,"script"),g.length>0&&na(g,!i&&ma(a,"script")),h},cleanData:function(a){for(var b,c,d,e=r.event.special,f=0;void 0!==(c=a[f]);f++)if(T(c)){if(b=c[V.expando]){if(b.events)for(d in b.events)e[d]?r.event.remove(c,d):r.removeEvent(c,d,b.handle);c[V.expando]=void 0}c[W.expando]&&(c[W.expando]=void 0)}}}),r.fn.extend({detach:function(a){return Ja(this,a,!0)},remove:function(a){return Ja(this,a)},text:function(a){return S(this,function(a){return void 0===a?r.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=a)})},null,a,arguments.length)},append:function(){return Ia(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Da(this,a);b.appendChild(a)}})},prepend:function(){return Ia(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Da(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return Ia(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return Ia(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(r.cleanData(ma(a,!1)),a.textContent="");return this},clone:function(a,b){return a=null!=a&&a,b=null==b?a:b,this.map(function(){return r.clone(this,a,b)})},html:function(a){return S(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if("string"==typeof a&&!za.test(a)&&!la[(ja.exec(a)||["",""])[1].toLowerCase()]){a=r.htmlPrefilter(a);try{for(;c<d;c++)b=this[c]||{},1===b.nodeType&&(r.cleanData(ma(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=[];return Ia(this,arguments,function(b){var c=this.parentNode;r.inArray(this,a)<0&&(r.cleanData(ma(this)),c&&c.replaceChild(b,this))},a)}}),r.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){r.fn[a]=function(a){for(var c,d=[],e=r(a),f=e.length-1,g=0;g<=f;g++)c=g===f?this:this.clone(!0),r(e[g])[b](c),h.apply(d,c.get());return this.pushStack(d)}});var Ka=/^margin/,La=new RegExp("^("+_+")(?!px)[a-z%]+$","i"),Ma=function(b){var c=b.ownerDocument.defaultView;return c&&c.opener||(c=a),c.getComputedStyle(b)};!function(){function b(){if(i){i.style.cssText="box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%",i.innerHTML="",qa.appendChild(h);var b=a.getComputedStyle(i);c="1%"!==b.top,g="2px"===b.marginLeft,e="4px"===b.width,i.style.marginRight="50%",f="4px"===b.marginRight,qa.removeChild(h),i=null}}var c,e,f,g,h=d.createElement("div"),i=d.createElement("div");i.style&&(i.style.backgroundClip="content-box",i.cloneNode(!0).style.backgroundClip="",o.clearCloneStyle="content-box"===i.style.backgroundClip,h.style.cssText="border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute",h.appendChild(i),r.extend(o,{pixelPosition:function(){return b(),c},boxSizingReliable:function(){return b(),e},pixelMarginRight:function(){return b(),f},reliableMarginLeft:function(){return b(),g}}))}();function Na(a,b,c){var d,e,f,g,h=a.style;return c=c||Ma(a),c&&(g=c.getPropertyValue(b)||c[b],""!==g||r.contains(a.ownerDocument,a)||(g=r.style(a,b)),!o.pixelMarginRight()&&La.test(g)&&Ka.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+"":g}function Oa(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}var Pa=/^(none|table(?!-c[ea]).+)/,Qa={position:"absolute",visibility:"hidden",display:"block"},Ra={letterSpacing:"0",fontWeight:"400"},Sa=["Webkit","Moz","ms"],Ta=d.createElement("div").style;function Ua(a){if(a in Ta)return a;var b=a[0].toUpperCase()+a.slice(1),c=Sa.length;while(c--)if(a=Sa[c]+b,a in Ta)return a}function Va(a,b,c){var d=aa.exec(b);return d?Math.max(0,d[2]-(c||0))+(d[3]||"px"):b}function Wa(a,b,c,d,e){var f,g=0;for(f=c===(d?"border":"content")?4:"width"===b?1:0;f<4;f+=2)"margin"===c&&(g+=r.css(a,c+ba[f],!0,e)),d?("content"===c&&(g-=r.css(a,"padding"+ba[f],!0,e)),"margin"!==c&&(g-=r.css(a,"border"+ba[f]+"Width",!0,e))):(g+=r.css(a,"padding"+ba[f],!0,e),"padding"!==c&&(g+=r.css(a,"border"+ba[f]+"Width",!0,e)));return g}function Xa(a,b,c){var d,e=!0,f=Ma(a),g="border-box"===r.css(a,"boxSizing",!1,f);if(a.getClientRects().length&&(d=a.getBoundingClientRect()[b]),d<=0||null==d){if(d=Na(a,b,f),(d<0||null==d)&&(d=a.style[b]),La.test(d))return d;e=g&&(o.boxSizingReliable()||d===a.style[b]),d=parseFloat(d)||0}return d+Wa(a,b,c||(g?"border":"content"),e,f)+"px"}r.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Na(a,"opacity");return""===c?"1":c}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=r.camelCase(b),i=a.style;return b=r.cssProps[h]||(r.cssProps[h]=Ua(h)||h),g=r.cssHooks[b]||r.cssHooks[h],void 0===c?g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b]:(f=typeof c,"string"===f&&(e=aa.exec(c))&&e[1]&&(c=ea(a,b,e),f="number"),null!=c&&c===c&&("number"===f&&(c+=e&&e[3]||(r.cssNumber[h]?"":"px")),o.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),g&&"set"in g&&void 0===(c=g.set(a,c,d))||(i[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=r.camelCase(b);return b=r.cssProps[h]||(r.cssProps[h]=Ua(h)||h),g=r.cssHooks[b]||r.cssHooks[h],g&&"get"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=Na(a,b,d)),"normal"===e&&b in Ra&&(e=Ra[b]),""===c||c?(f=parseFloat(e),c===!0||isFinite(f)?f||0:e):e}}),r.each(["height","width"],function(a,b){r.cssHooks[b]={get:function(a,c,d){if(c)return!Pa.test(r.css(a,"display"))||a.getClientRects().length&&a.getBoundingClientRect().width?Xa(a,b,d):da(a,Qa,function(){return Xa(a,b,d)})},set:function(a,c,d){var e,f=d&&Ma(a),g=d&&Wa(a,b,d,"border-box"===r.css(a,"boxSizing",!1,f),f);return g&&(e=aa.exec(c))&&"px"!==(e[3]||"px")&&(a.style[b]=c,c=r.css(a,b)),Va(a,c,g)}}}),r.cssHooks.marginLeft=Oa(o.reliableMarginLeft,function(a,b){if(b)return(parseFloat(Na(a,"marginLeft"))||a.getBoundingClientRect().left-da(a,{marginLeft:0},function(){return a.getBoundingClientRect().left}))+"px"}),r.each({margin:"",padding:"",border:"Width"},function(a,b){r.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];d<4;d++)e[a+ba[d]+b]=f[d]||f[d-2]||f[0];return e}},Ka.test(a)||(r.cssHooks[a+b].set=Va)}),r.fn.extend({css:function(a,b){return S(this,function(a,b,c){var d,e,f={},g=0;if(r.isArray(b)){for(d=Ma(a),e=b.length;g<e;g++)f[b[g]]=r.css(a,b[g],!1,d);return f}return void 0!==c?r.style(a,b,c):r.css(a,b)},a,b,arguments.length>1)}});function Ya(a,b,c,d,e){return new Ya.prototype.init(a,b,c,d,e)}r.Tween=Ya,Ya.prototype={constructor:Ya,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||r.easing._default,this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(r.cssNumber[c]?"":"px")},cur:function(){var a=Ya.propHooks[this.prop];return a&&a.get?a.get(this):Ya.propHooks._default.get(this)},run:function(a){var b,c=Ya.propHooks[this.prop];return this.options.duration?this.pos=b=r.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Ya.propHooks._default.set(this),this}},Ya.prototype.init.prototype=Ya.prototype,Ya.propHooks={_default:{get:function(a){var b;return 1!==a.elem.nodeType||null!=a.elem[a.prop]&&null==a.elem.style[a.prop]?a.elem[a.prop]:(b=r.css(a.elem,a.prop,""),b&&"auto"!==b?b:0)},set:function(a){r.fx.step[a.prop]?r.fx.step[a.prop](a):1!==a.elem.nodeType||null==a.elem.style[r.cssProps[a.prop]]&&!r.cssHooks[a.prop]?a.elem[a.prop]=a.now:r.style(a.elem,a.prop,a.now+a.unit)}}},Ya.propHooks.scrollTop=Ya.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},r.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2},_default:"swing"},r.fx=Ya.prototype.init,r.fx.step={};var Za,$a,_a=/^(?:toggle|show|hide)$/,ab=/queueHooks$/;function bb(){$a&&(a.requestAnimationFrame(bb),r.fx.tick())}function cb(){return a.setTimeout(function(){Za=void 0}),Za=r.now()}function db(a,b){var c,d=0,e={height:a};for(b=b?1:0;d<4;d+=2-b)c=ba[d],e["margin"+c]=e["padding"+c]=a;return b&&(e.opacity=e.width=a),e}function eb(a,b,c){for(var d,e=(hb.tweeners[b]||[]).concat(hb.tweeners["*"]),f=0,g=e.length;f<g;f++)if(d=e[f].call(c,b,a))return d}function fb(a,b,c){var d,e,f,g,h,i,j,k,l="width"in b||"height"in b,m=this,n={},o=a.style,p=a.nodeType&&ca(a),q=V.get(a,"fxshow");c.queue||(g=r._queueHooks(a,"fx"),null==g.unqueued&&(g.unqueued=0,h=g.empty.fire,g.empty.fire=function(){g.unqueued||h()}),g.unqueued++,m.always(function(){m.always(function(){g.unqueued--,r.queue(a,"fx").length||g.empty.fire()})}));for(d in b)if(e=b[d],_a.test(e)){if(delete b[d],f=f||"toggle"===e,e===(p?"hide":"show")){if("show"!==e||!q||void 0===q[d])continue;p=!0}n[d]=q&&q[d]||r.style(a,d)}if(i=!r.isEmptyObject(b),i||!r.isEmptyObject(n)){l&&1===a.nodeType&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=q&&q.display,null==j&&(j=V.get(a,"display")),k=r.css(a,"display"),"none"===k&&(j?k=j:(ha([a],!0),j=a.style.display||j,k=r.css(a,"display"),ha([a]))),("inline"===k||"inline-block"===k&&null!=j)&&"none"===r.css(a,"float")&&(i||(m.done(function(){o.display=j}),null==j&&(k=o.display,j="none"===k?"":k)),o.display="inline-block")),c.overflow&&(o.overflow="hidden",m.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]})),i=!1;for(d in n)i||(q?"hidden"in q&&(p=q.hidden):q=V.access(a,"fxshow",{display:j}),f&&(q.hidden=!p),p&&ha([a],!0),m.done(function(){p||ha([a]),V.remove(a,"fxshow");for(d in n)r.style(a,d,n[d])})),i=eb(p?q[d]:0,d,m),d in q||(q[d]=i.start,p&&(i.end=i.start,i.start=0))}}function gb(a,b){var c,d,e,f,g;for(c in a)if(d=r.camelCase(c),e=b[d],f=a[c],r.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=r.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function hb(a,b,c){var d,e,f=0,g=hb.prefilters.length,h=r.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=Za||cb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;g<i;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),f<1&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:r.extend({},b),opts:r.extend(!0,{specialEasing:{},easing:r.easing._default},c),originalProperties:b,originalOptions:c,startTime:Za||cb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=r.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;c<d;c++)j.tweens[c].run(1);return b?(h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j,b])):h.rejectWith(a,[j,b]),this}}),k=j.props;for(gb(k,j.opts.specialEasing);f<g;f++)if(d=hb.prefilters[f].call(j,a,k,j.opts))return r.isFunction(d.stop)&&(r._queueHooks(j.elem,j.opts.queue).stop=r.proxy(d.stop,d)),d;return r.map(k,eb,j),r.isFunction(j.opts.start)&&j.opts.start.call(a,j),r.fx.timer(r.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}r.Animation=r.extend(hb,{tweeners:{"*":[function(a,b){var c=this.createTween(a,b);return ea(c.elem,a,aa.exec(b),c),c}]},tweener:function(a,b){r.isFunction(a)?(b=a,a=["*"]):a=a.match(K);for(var c,d=0,e=a.length;d<e;d++)c=a[d],hb.tweeners[c]=hb.tweeners[c]||[],hb.tweeners[c].unshift(b)},prefilters:[fb],prefilter:function(a,b){b?hb.prefilters.unshift(a):hb.prefilters.push(a)}}),r.speed=function(a,b,c){var e=a&&"object"==typeof a?r.extend({},a):{complete:c||!c&&b||r.isFunction(a)&&a,duration:a,easing:c&&b||b&&!r.isFunction(b)&&b};return r.fx.off||d.hidden?e.duration=0:"number"!=typeof e.duration&&(e.duration in r.fx.speeds?e.duration=r.fx.speeds[e.duration]:e.duration=r.fx.speeds._default),null!=e.queue&&e.queue!==!0||(e.queue="fx"),e.old=e.complete,e.complete=function(){r.isFunction(e.old)&&e.old.call(this),e.queue&&r.dequeue(this,e.queue)},e},r.fn.extend({fadeTo:function(a,b,c,d){return this.filter(ca).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=r.isEmptyObject(a),f=r.speed(b,c,d),g=function(){var b=hb(this,r.extend({},a),f);(e||V.get(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=r.timers,g=V.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&ab.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));!b&&c||r.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=V.get(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=r.timers,g=d?d.length:0;for(c.finish=!0,r.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;b<g;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),r.each(["toggle","show","hide"],function(a,b){var c=r.fn[b];r.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(db(b,!0),a,d,e)}}),r.each({slideDown:db("show"),slideUp:db("hide"),slideToggle:db("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){r.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),r.timers=[],r.fx.tick=function(){var a,b=0,c=r.timers;for(Za=r.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||r.fx.stop(),Za=void 0},r.fx.timer=function(a){r.timers.push(a),a()?r.fx.start():r.timers.pop()},r.fx.interval=13,r.fx.start=function(){$a||($a=a.requestAnimationFrame?a.requestAnimationFrame(bb):a.setInterval(r.fx.tick,r.fx.interval))},r.fx.stop=function(){a.cancelAnimationFrame?a.cancelAnimationFrame($a):a.clearInterval($a),$a=null},r.fx.speeds={slow:600,fast:200,_default:400},r.fn.delay=function(b,c){return b=r.fx?r.fx.speeds[b]||b:b,c=c||"fx",this.queue(c,function(c,d){var e=a.setTimeout(c,b);d.stop=function(){a.clearTimeout(e)}})},function(){var a=d.createElement("input"),b=d.createElement("select"),c=b.appendChild(d.createElement("option"));a.type="checkbox",o.checkOn=""!==a.value,o.optSelected=c.selected,a=d.createElement("input"),a.value="t",a.type="radio",o.radioValue="t"===a.value}();var ib,jb=r.expr.attrHandle;r.fn.extend({attr:function(a,b){return S(this,r.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){r.removeAttr(this,a)})}}),r.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return"undefined"==typeof a.getAttribute?r.prop(a,b,c):(1===f&&r.isXMLDoc(a)||(e=r.attrHooks[b.toLowerCase()]||(r.expr.match.bool.test(b)?ib:void 0)),
void 0!==c?null===c?void r.removeAttr(a,b):e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:(a.setAttribute(b,c+""),c):e&&"get"in e&&null!==(d=e.get(a,b))?d:(d=r.find.attr(a,b),null==d?void 0:d))},attrHooks:{type:{set:function(a,b){if(!o.radioValue&&"radio"===b&&r.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}},removeAttr:function(a,b){var c,d=0,e=b&&b.match(K);if(e&&1===a.nodeType)while(c=e[d++])a.removeAttribute(c)}}),ib={set:function(a,b,c){return b===!1?r.removeAttr(a,c):a.setAttribute(c,c),c}},r.each(r.expr.match.bool.source.match(/\w+/g),function(a,b){var c=jb[b]||r.find.attr;jb[b]=function(a,b,d){var e,f,g=b.toLowerCase();return d||(f=jb[g],jb[g]=e,e=null!=c(a,b,d)?g:null,jb[g]=f),e}});var kb=/^(?:input|select|textarea|button)$/i,lb=/^(?:a|area)$/i;r.fn.extend({prop:function(a,b){return S(this,r.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[r.propFix[a]||a]})}}),r.extend({prop:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return 1===f&&r.isXMLDoc(a)||(b=r.propFix[b]||b,e=r.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=r.find.attr(a,"tabindex");return b?parseInt(b,10):kb.test(a.nodeName)||lb.test(a.nodeName)&&a.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),o.optSelected||(r.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null},set:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex)}}),r.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){r.propFix[this.toLowerCase()]=this});function mb(a){var b=a.match(K)||[];return b.join(" ")}function nb(a){return a.getAttribute&&a.getAttribute("class")||""}r.fn.extend({addClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).addClass(a.call(this,b,nb(this)))});if("string"==typeof a&&a){b=a.match(K)||[];while(c=this[i++])if(e=nb(c),d=1===c.nodeType&&" "+mb(e)+" "){g=0;while(f=b[g++])d.indexOf(" "+f+" ")<0&&(d+=f+" ");h=mb(d),e!==h&&c.setAttribute("class",h)}}return this},removeClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).removeClass(a.call(this,b,nb(this)))});if(!arguments.length)return this.attr("class","");if("string"==typeof a&&a){b=a.match(K)||[];while(c=this[i++])if(e=nb(c),d=1===c.nodeType&&" "+mb(e)+" "){g=0;while(f=b[g++])while(d.indexOf(" "+f+" ")>-1)d=d.replace(" "+f+" "," ");h=mb(d),e!==h&&c.setAttribute("class",h)}}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):r.isFunction(a)?this.each(function(c){r(this).toggleClass(a.call(this,c,nb(this),b),b)}):this.each(function(){var b,d,e,f;if("string"===c){d=0,e=r(this),f=a.match(K)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else void 0!==a&&"boolean"!==c||(b=nb(this),b&&V.set(this,"__className__",b),this.setAttribute&&this.setAttribute("class",b||a===!1?"":V.get(this,"__className__")||""))})},hasClass:function(a){var b,c,d=0;b=" "+a+" ";while(c=this[d++])if(1===c.nodeType&&(" "+mb(nb(c))+" ").indexOf(b)>-1)return!0;return!1}});var ob=/\r/g;r.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=r.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,r(this).val()):a,null==e?e="":"number"==typeof e?e+="":r.isArray(e)&&(e=r.map(e,function(a){return null==a?"":a+""})),b=r.valHooks[this.type]||r.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=r.valHooks[e.type]||r.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(ob,""):null==c?"":c)}}}),r.extend({valHooks:{option:{get:function(a){var b=r.find.attr(a,"value");return null!=b?b:mb(r.text(a))}},select:{get:function(a){var b,c,d,e=a.options,f=a.selectedIndex,g="select-one"===a.type,h=g?null:[],i=g?f+1:e.length;for(d=f<0?i:g?f:0;d<i;d++)if(c=e[d],(c.selected||d===f)&&!c.disabled&&(!c.parentNode.disabled||!r.nodeName(c.parentNode,"optgroup"))){if(b=r(c).val(),g)return b;h.push(b)}return h},set:function(a,b){var c,d,e=a.options,f=r.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=r.inArray(r.valHooks.option.get(d),f)>-1)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),r.each(["radio","checkbox"],function(){r.valHooks[this]={set:function(a,b){if(r.isArray(b))return a.checked=r.inArray(r(a).val(),b)>-1}},o.checkOn||(r.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})});var pb=/^(?:focusinfocus|focusoutblur)$/;r.extend(r.event,{trigger:function(b,c,e,f){var g,h,i,j,k,m,n,o=[e||d],p=l.call(b,"type")?b.type:b,q=l.call(b,"namespace")?b.namespace.split("."):[];if(h=i=e=e||d,3!==e.nodeType&&8!==e.nodeType&&!pb.test(p+r.event.triggered)&&(p.indexOf(".")>-1&&(q=p.split("."),p=q.shift(),q.sort()),k=p.indexOf(":")<0&&"on"+p,b=b[r.expando]?b:new r.Event(p,"object"==typeof b&&b),b.isTrigger=f?2:3,b.namespace=q.join("."),b.rnamespace=b.namespace?new RegExp("(^|\\.)"+q.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=e),c=null==c?[b]:r.makeArray(c,[b]),n=r.event.special[p]||{},f||!n.trigger||n.trigger.apply(e,c)!==!1)){if(!f&&!n.noBubble&&!r.isWindow(e)){for(j=n.delegateType||p,pb.test(j+p)||(h=h.parentNode);h;h=h.parentNode)o.push(h),i=h;i===(e.ownerDocument||d)&&o.push(i.defaultView||i.parentWindow||a)}g=0;while((h=o[g++])&&!b.isPropagationStopped())b.type=g>1?j:n.bindType||p,m=(V.get(h,"events")||{})[b.type]&&V.get(h,"handle"),m&&m.apply(h,c),m=k&&h[k],m&&m.apply&&T(h)&&(b.result=m.apply(h,c),b.result===!1&&b.preventDefault());return b.type=p,f||b.isDefaultPrevented()||n._default&&n._default.apply(o.pop(),c)!==!1||!T(e)||k&&r.isFunction(e[p])&&!r.isWindow(e)&&(i=e[k],i&&(e[k]=null),r.event.triggered=p,e[p](),r.event.triggered=void 0,i&&(e[k]=i)),b.result}},simulate:function(a,b,c){var d=r.extend(new r.Event,c,{type:a,isSimulated:!0});r.event.trigger(d,null,b)}}),r.fn.extend({trigger:function(a,b){return this.each(function(){r.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];if(c)return r.event.trigger(a,b,c,!0)}}),r.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(a,b){r.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),r.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),o.focusin="onfocusin"in a,o.focusin||r.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){r.event.simulate(b,a.target,r.event.fix(a))};r.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=V.access(d,b);e||d.addEventListener(a,c,!0),V.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=V.access(d,b)-1;e?V.access(d,b,e):(d.removeEventListener(a,c,!0),V.remove(d,b))}}});var qb=a.location,rb=r.now(),sb=/\?/;r.parseXML=function(b){var c;if(!b||"string"!=typeof b)return null;try{c=(new a.DOMParser).parseFromString(b,"text/xml")}catch(d){c=void 0}return c&&!c.getElementsByTagName("parsererror").length||r.error("Invalid XML: "+b),c};var tb=/\[\]$/,ub=/\r?\n/g,vb=/^(?:submit|button|image|reset|file)$/i,wb=/^(?:input|select|textarea|keygen)/i;function xb(a,b,c,d){var e;if(r.isArray(b))r.each(b,function(b,e){c||tb.test(a)?d(a,e):xb(a+"["+("object"==typeof e&&null!=e?b:"")+"]",e,c,d)});else if(c||"object"!==r.type(b))d(a,b);else for(e in b)xb(a+"["+e+"]",b[e],c,d)}r.param=function(a,b){var c,d=[],e=function(a,b){var c=r.isFunction(b)?b():b;d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(null==c?"":c)};if(r.isArray(a)||a.jquery&&!r.isPlainObject(a))r.each(a,function(){e(this.name,this.value)});else for(c in a)xb(c,a[c],b,e);return d.join("&")},r.fn.extend({serialize:function(){return r.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=r.prop(this,"elements");return a?r.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!r(this).is(":disabled")&&wb.test(this.nodeName)&&!vb.test(a)&&(this.checked||!ia.test(a))}).map(function(a,b){var c=r(this).val();return null==c?null:r.isArray(c)?r.map(c,function(a){return{name:b.name,value:a.replace(ub,"\r\n")}}):{name:b.name,value:c.replace(ub,"\r\n")}}).get()}});var yb=/%20/g,zb=/#.*$/,Ab=/([?&])_=[^&]*/,Bb=/^(.*?):[ \t]*([^\r\n]*)$/gm,Cb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Db=/^(?:GET|HEAD)$/,Eb=/^\/\//,Fb={},Gb={},Hb="*/".concat("*"),Ib=d.createElement("a");Ib.href=qb.href;function Jb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(K)||[];if(r.isFunction(c))while(d=f[e++])"+"===d[0]?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Kb(a,b,c,d){var e={},f=a===Gb;function g(h){var i;return e[h]=!0,r.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function Lb(a,b){var c,d,e=r.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&r.extend(!0,a,d),a}function Mb(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader("Content-Type"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+" "+i[0]]){f=e;break}g||(g=e)}f=f||g}if(f)return f!==i[0]&&i.unshift(f),c[f]}function Nb(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}r.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:qb.href,type:"GET",isLocal:Cb.test(qb.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Hb,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":r.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Lb(Lb(a,r.ajaxSettings),b):Lb(r.ajaxSettings,a)},ajaxPrefilter:Jb(Fb),ajaxTransport:Jb(Gb),ajax:function(b,c){"object"==typeof b&&(c=b,b=void 0),c=c||{};var e,f,g,h,i,j,k,l,m,n,o=r.ajaxSetup({},c),p=o.context||o,q=o.context&&(p.nodeType||p.jquery)?r(p):r.event,s=r.Deferred(),t=r.Callbacks("once memory"),u=o.statusCode||{},v={},w={},x="canceled",y={readyState:0,getResponseHeader:function(a){var b;if(k){if(!h){h={};while(b=Bb.exec(g))h[b[1].toLowerCase()]=b[2]}b=h[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return k?g:null},setRequestHeader:function(a,b){return null==k&&(a=w[a.toLowerCase()]=w[a.toLowerCase()]||a,v[a]=b),this},overrideMimeType:function(a){return null==k&&(o.mimeType=a),this},statusCode:function(a){var b;if(a)if(k)y.always(a[y.status]);else for(b in a)u[b]=[u[b],a[b]];return this},abort:function(a){var b=a||x;return e&&e.abort(b),A(0,b),this}};if(s.promise(y),o.url=((b||o.url||qb.href)+"").replace(Eb,qb.protocol+"//"),o.type=c.method||c.type||o.method||o.type,o.dataTypes=(o.dataType||"*").toLowerCase().match(K)||[""],null==o.crossDomain){j=d.createElement("a");try{j.href=o.url,j.href=j.href,o.crossDomain=Ib.protocol+"//"+Ib.host!=j.protocol+"//"+j.host}catch(z){o.crossDomain=!0}}if(o.data&&o.processData&&"string"!=typeof o.data&&(o.data=r.param(o.data,o.traditional)),Kb(Fb,o,c,y),k)return y;l=r.event&&o.global,l&&0===r.active++&&r.event.trigger("ajaxStart"),o.type=o.type.toUpperCase(),o.hasContent=!Db.test(o.type),f=o.url.replace(zb,""),o.hasContent?o.data&&o.processData&&0===(o.contentType||"").indexOf("application/x-www-form-urlencoded")&&(o.data=o.data.replace(yb,"+")):(n=o.url.slice(f.length),o.data&&(f+=(sb.test(f)?"&":"?")+o.data,delete o.data),o.cache===!1&&(f=f.replace(Ab,"$1"),n=(sb.test(f)?"&":"?")+"_="+rb++ +n),o.url=f+n),o.ifModified&&(r.lastModified[f]&&y.setRequestHeader("If-Modified-Since",r.lastModified[f]),r.etag[f]&&y.setRequestHeader("If-None-Match",r.etag[f])),(o.data&&o.hasContent&&o.contentType!==!1||c.contentType)&&y.setRequestHeader("Content-Type",o.contentType),y.setRequestHeader("Accept",o.dataTypes[0]&&o.accepts[o.dataTypes[0]]?o.accepts[o.dataTypes[0]]+("*"!==o.dataTypes[0]?", "+Hb+"; q=0.01":""):o.accepts["*"]);for(m in o.headers)y.setRequestHeader(m,o.headers[m]);if(o.beforeSend&&(o.beforeSend.call(p,y,o)===!1||k))return y.abort();if(x="abort",t.add(o.complete),y.done(o.success),y.fail(o.error),e=Kb(Gb,o,c,y)){if(y.readyState=1,l&&q.trigger("ajaxSend",[y,o]),k)return y;o.async&&o.timeout>0&&(i=a.setTimeout(function(){y.abort("timeout")},o.timeout));try{k=!1,e.send(v,A)}catch(z){if(k)throw z;A(-1,z)}}else A(-1,"No Transport");function A(b,c,d,h){var j,m,n,v,w,x=c;k||(k=!0,i&&a.clearTimeout(i),e=void 0,g=h||"",y.readyState=b>0?4:0,j=b>=200&&b<300||304===b,d&&(v=Mb(o,y,d)),v=Nb(o,v,y,j),j?(o.ifModified&&(w=y.getResponseHeader("Last-Modified"),w&&(r.lastModified[f]=w),w=y.getResponseHeader("etag"),w&&(r.etag[f]=w)),204===b||"HEAD"===o.type?x="nocontent":304===b?x="notmodified":(x=v.state,m=v.data,n=v.error,j=!n)):(n=x,!b&&x||(x="error",b<0&&(b=0))),y.status=b,y.statusText=(c||x)+"",j?s.resolveWith(p,[m,x,y]):s.rejectWith(p,[y,x,n]),y.statusCode(u),u=void 0,l&&q.trigger(j?"ajaxSuccess":"ajaxError",[y,o,j?m:n]),t.fireWith(p,[y,x]),l&&(q.trigger("ajaxComplete",[y,o]),--r.active||r.event.trigger("ajaxStop")))}return y},getJSON:function(a,b,c){return r.get(a,b,c,"json")},getScript:function(a,b){return r.get(a,void 0,b,"script")}}),r.each(["get","post"],function(a,b){r[b]=function(a,c,d,e){return r.isFunction(c)&&(e=e||d,d=c,c=void 0),r.ajax(r.extend({url:a,type:b,dataType:e,data:c,success:d},r.isPlainObject(a)&&a))}}),r._evalUrl=function(a){return r.ajax({url:a,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,"throws":!0})},r.fn.extend({wrapAll:function(a){var b;return this[0]&&(r.isFunction(a)&&(a=a.call(this[0])),b=r(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this},wrapInner:function(a){return r.isFunction(a)?this.each(function(b){r(this).wrapInner(a.call(this,b))}):this.each(function(){var b=r(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=r.isFunction(a);return this.each(function(c){r(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(a){return this.parent(a).not("body").each(function(){r(this).replaceWith(this.childNodes)}),this}}),r.expr.pseudos.hidden=function(a){return!r.expr.pseudos.visible(a)},r.expr.pseudos.visible=function(a){return!!(a.offsetWidth||a.offsetHeight||a.getClientRects().length)},r.ajaxSettings.xhr=function(){try{return new a.XMLHttpRequest}catch(b){}};var Ob={0:200,1223:204},Pb=r.ajaxSettings.xhr();o.cors=!!Pb&&"withCredentials"in Pb,o.ajax=Pb=!!Pb,r.ajaxTransport(function(b){var c,d;if(o.cors||Pb&&!b.crossDomain)return{send:function(e,f){var g,h=b.xhr();if(h.open(b.type,b.url,b.async,b.username,b.password),b.xhrFields)for(g in b.xhrFields)h[g]=b.xhrFields[g];b.mimeType&&h.overrideMimeType&&h.overrideMimeType(b.mimeType),b.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest");for(g in e)h.setRequestHeader(g,e[g]);c=function(a){return function(){c&&(c=d=h.onload=h.onerror=h.onabort=h.onreadystatechange=null,"abort"===a?h.abort():"error"===a?"number"!=typeof h.status?f(0,"error"):f(h.status,h.statusText):f(Ob[h.status]||h.status,h.statusText,"text"!==(h.responseType||"text")||"string"!=typeof h.responseText?{binary:h.response}:{text:h.responseText},h.getAllResponseHeaders()))}},h.onload=c(),d=h.onerror=c("error"),void 0!==h.onabort?h.onabort=d:h.onreadystatechange=function(){4===h.readyState&&a.setTimeout(function(){c&&d()})},c=c("abort");try{h.send(b.hasContent&&b.data||null)}catch(i){if(c)throw i}},abort:function(){c&&c()}}}),r.ajaxPrefilter(function(a){a.crossDomain&&(a.contents.script=!1)}),r.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(a){return r.globalEval(a),a}}}),r.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET")}),r.ajaxTransport("script",function(a){if(a.crossDomain){var b,c;return{send:function(e,f){b=r("<script>").prop({charset:a.scriptCharset,src:a.url}).on("load error",c=function(a){b.remove(),c=null,a&&f("error"===a.type?404:200,a.type)}),d.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Qb=[],Rb=/(=)\?(?=&|$)|\?\?/;r.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=Qb.pop()||r.expando+"_"+rb++;return this[a]=!0,a}}),r.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Rb.test(b.url)?"url":"string"==typeof b.data&&0===(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&Rb.test(b.data)&&"data");if(h||"jsonp"===b.dataTypes[0])return e=b.jsonpCallback=r.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Rb,"$1"+e):b.jsonp!==!1&&(b.url+=(sb.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||r.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){void 0===f?r(a).removeProp(e):a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Qb.push(e)),g&&r.isFunction(f)&&f(g[0]),g=f=void 0}),"script"}),o.createHTMLDocument=function(){var a=d.implementation.createHTMLDocument("").body;return a.innerHTML="<form></form><form></form>",2===a.childNodes.length}(),r.parseHTML=function(a,b,c){if("string"!=typeof a)return[];"boolean"==typeof b&&(c=b,b=!1);var e,f,g;return b||(o.createHTMLDocument?(b=d.implementation.createHTMLDocument(""),e=b.createElement("base"),e.href=d.location.href,b.head.appendChild(e)):b=d),f=B.exec(a),g=!c&&[],f?[b.createElement(f[1])]:(f=pa([a],b,g),g&&g.length&&r(g).remove(),r.merge([],f.childNodes))},r.fn.load=function(a,b,c){var d,e,f,g=this,h=a.indexOf(" ");return h>-1&&(d=mb(a.slice(h)),a=a.slice(0,h)),r.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&r.ajax({url:a,type:e||"GET",dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?r("<div>").append(r.parseHTML(a)).find(d):a)}).always(c&&function(a,b){g.each(function(){c.apply(this,f||[a.responseText,b,a])})}),this},r.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){r.fn[b]=function(a){return this.on(b,a)}}),r.expr.pseudos.animated=function(a){return r.grep(r.timers,function(b){return a===b.elem}).length};function Sb(a){return r.isWindow(a)?a:9===a.nodeType&&a.defaultView}r.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=r.css(a,"position"),l=r(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=r.css(a,"top"),i=r.css(a,"left"),j=("absolute"===k||"fixed"===k)&&(f+i).indexOf("auto")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),r.isFunction(b)&&(b=b.call(a,c,r.extend({},h))),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},r.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){r.offset.setOffset(this,a,b)});var b,c,d,e,f=this[0];if(f)return f.getClientRects().length?(d=f.getBoundingClientRect(),d.width||d.height?(e=f.ownerDocument,c=Sb(e),b=e.documentElement,{top:d.top+c.pageYOffset-b.clientTop,left:d.left+c.pageXOffset-b.clientLeft}):d):{top:0,left:0}},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return"fixed"===r.css(c,"position")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),r.nodeName(a[0],"html")||(d=a.offset()),d={top:d.top+r.css(a[0],"borderTopWidth",!0),left:d.left+r.css(a[0],"borderLeftWidth",!0)}),{top:b.top-d.top-r.css(c,"marginTop",!0),left:b.left-d.left-r.css(c,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent;while(a&&"static"===r.css(a,"position"))a=a.offsetParent;return a||qa})}}),r.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,b){var c="pageYOffset"===b;r.fn[a]=function(d){return S(this,function(a,d,e){var f=Sb(a);return void 0===e?f?f[b]:a[d]:void(f?f.scrollTo(c?f.pageXOffset:e,c?e:f.pageYOffset):a[d]=e)},a,d,arguments.length)}}),r.each(["top","left"],function(a,b){r.cssHooks[b]=Oa(o.pixelPosition,function(a,c){if(c)return c=Na(a,b),La.test(c)?r(a).position()[b]+"px":c})}),r.each({Height:"height",Width:"width"},function(a,b){r.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){r.fn[d]=function(e,f){var g=arguments.length&&(c||"boolean"!=typeof e),h=c||(e===!0||f===!0?"margin":"border");return S(this,function(b,c,e){var f;return r.isWindow(b)?0===d.indexOf("outer")?b["inner"+a]:b.document.documentElement["client"+a]:9===b.nodeType?(f=b.documentElement,Math.max(b.body["scroll"+a],f["scroll"+a],b.body["offset"+a],f["offset"+a],f["client"+a])):void 0===e?r.css(b,c,h):r.style(b,c,e,h)},b,g?e:void 0,g)}})}),r.fn.extend({bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}}),r.parseJSON=JSON.parse,"function"==typeof define&&define.amd&&define("jquery",[],function(){return r});var Tb=a.jQuery,Ub=a.$;return r.noConflict=function(b){return a.$===r&&(a.$=Ub),b&&a.jQuery===r&&(a.jQuery=Tb),r},b||(a.jQuery=a.$=r),r});

 /*
 * # Semantic UI - 2.2.10
 * https://github.com/Semantic-Org/Semantic-UI
 * http://www.semantic-ui.com/
 *
 * Copyright 2014 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */
!function(e,t,n,i){e.site=e.fn.site=function(i){var o,a,r=(new Date).getTime(),s=[],l=arguments[0],c="string"==typeof l,u=[].slice.call(arguments,1),d=e.isPlainObject(i)?e.extend(!0,{},e.site.settings,i):e.extend({},e.site.settings),f=d.namespace,m=d.error,g="module-"+f,v=e(n),p=v,h=this,b=p.data(g);return o={initialize:function(){o.instantiate()},instantiate:function(){o.verbose("Storing instance of site",o),b=o,p.data(g,o)},normalize:function(){o.fix.console(),o.fix.requestAnimationFrame()},fix:{console:function(){o.debug("Normalizing window.console"),void 0!==console&&void 0!==console.log||(o.verbose("Console not available, normalizing events"),o.disable.console()),void 0!==console.group&&void 0!==console.groupEnd&&void 0!==console.groupCollapsed||(o.verbose("Console group not available, normalizing events"),t.console.group=function(){},t.console.groupEnd=function(){},t.console.groupCollapsed=function(){}),void 0===console.markTimeline&&(o.verbose("Mark timeline not available, normalizing events"),t.console.markTimeline=function(){})},consoleClear:function(){o.debug("Disabling programmatic console clearing"),t.console.clear=function(){}},requestAnimationFrame:function(){o.debug("Normalizing requestAnimationFrame"),void 0===t.requestAnimationFrame&&(o.debug("RequestAnimationFrame not available, normalizing event"),t.requestAnimationFrame=t.requestAnimationFrame||t.mozRequestAnimationFrame||t.webkitRequestAnimationFrame||t.msRequestAnimationFrame||function(e){setTimeout(e,0)})}},moduleExists:function(t){return void 0!==e.fn[t]&&void 0!==e.fn[t].settings},enabled:{modules:function(t){var n=[];return t=t||d.modules,e.each(t,function(e,t){o.moduleExists(t)&&n.push(t)}),n}},disabled:{modules:function(t){var n=[];return t=t||d.modules,e.each(t,function(e,t){o.moduleExists(t)||n.push(t)}),n}},change:{setting:function(t,n,i,a){i="string"==typeof i?"all"===i?d.modules:[i]:i||d.modules,a=void 0===a||a,e.each(i,function(i,r){var s,l=!o.moduleExists(r)||(e.fn[r].settings.namespace||!1);o.moduleExists(r)&&(o.verbose("Changing default setting",t,n,r),e.fn[r].settings[t]=n,a&&l&&(s=e(":data(module-"+l+")"),s.length>0&&(o.verbose("Modifying existing settings",s),s[r]("setting",t,n))))})},settings:function(t,n,i){n="string"==typeof n?[n]:n||d.modules,i=void 0===i||i,e.each(n,function(n,a){var r;o.moduleExists(a)&&(o.verbose("Changing default setting",t,a),e.extend(!0,e.fn[a].settings,t),i&&f&&(r=e(":data(module-"+f+")"),r.length>0&&(o.verbose("Modifying existing settings",r),r[a]("setting",t))))})}},enable:{console:function(){o.console(!0)},debug:function(e,t){e=e||d.modules,o.debug("Enabling debug for modules",e),o.change.setting("debug",!0,e,t)},verbose:function(e,t){e=e||d.modules,o.debug("Enabling verbose debug for modules",e),o.change.setting("verbose",!0,e,t)}},disable:{console:function(){o.console(!1)},debug:function(e,t){e=e||d.modules,o.debug("Disabling debug for modules",e),o.change.setting("debug",!1,e,t)},verbose:function(e,t){e=e||d.modules,o.debug("Disabling verbose debug for modules",e),o.change.setting("verbose",!1,e,t)}},console:function(e){if(e){if(void 0===b.cache.console)return void o.error(m.console);o.debug("Restoring console function"),t.console=b.cache.console}else o.debug("Disabling console function"),b.cache.console=t.console,t.console={clear:function(){},error:function(){},group:function(){},groupCollapsed:function(){},groupEnd:function(){},info:function(){},log:function(){},markTimeline:function(){},warn:function(){}}},destroy:function(){o.verbose("Destroying previous site for",p),p.removeData(g)},cache:{},setting:function(t,n){if(e.isPlainObject(t))e.extend(!0,d,t);else{if(void 0===n)return d[t];d[t]=n}},internal:function(t,n){if(e.isPlainObject(t))e.extend(!0,o,t);else{if(void 0===n)return o[t];o[t]=n}},debug:function(){d.debug&&(d.performance?o.performance.log(arguments):(o.debug=Function.prototype.bind.call(console.info,console,d.name+":"),o.debug.apply(console,arguments)))},verbose:function(){d.verbose&&d.debug&&(d.performance?o.performance.log(arguments):(o.verbose=Function.prototype.bind.call(console.info,console,d.name+":"),o.verbose.apply(console,arguments)))},error:function(){o.error=Function.prototype.bind.call(console.error,console,d.name+":"),o.error.apply(console,arguments)},performance:{log:function(e){var t,n,i;d.performance&&(t=(new Date).getTime(),i=r||t,n=t-i,r=t,s.push({Element:h,Name:e[0],Arguments:[].slice.call(e,1)||"","Execution Time":n})),clearTimeout(o.performance.timer),o.performance.timer=setTimeout(o.performance.display,500)},display:function(){var t=d.name+":",n=0;r=!1,clearTimeout(o.performance.timer),e.each(s,function(e,t){n+=t["Execution Time"]}),t+=" "+n+"ms",(void 0!==console.group||void 0!==console.table)&&s.length>0&&(console.groupCollapsed(t),console.table?console.table(s):e.each(s,function(e,t){console.log(t.Name+": "+t["Execution Time"]+"ms")}),console.groupEnd()),s=[]}},invoke:function(t,n,i){var r,s,l,c=b;return n=n||u,i=h||i,"string"==typeof t&&void 0!==c&&(t=t.split(/[\. ]/),r=t.length-1,e.each(t,function(n,i){var a=n!=r?i+t[n+1].charAt(0).toUpperCase()+t[n+1].slice(1):t;if(e.isPlainObject(c[a])&&n!=r)c=c[a];else{if(void 0!==c[a])return s=c[a],!1;if(!e.isPlainObject(c[i])||n==r)return void 0!==c[i]?(s=c[i],!1):(o.error(m.method,t),!1);c=c[i]}})),e.isFunction(s)?l=s.apply(i,n):void 0!==s&&(l=s),e.isArray(a)?a.push(l):void 0!==a?a=[a,l]:void 0!==l&&(a=l),s}},c?(void 0===b&&o.initialize(),o.invoke(l)):(void 0!==b&&o.destroy(),o.initialize()),void 0!==a?a:this},e.site.settings={name:"Site",namespace:"site",error:{console:"Console cannot be restored, most likely it was overwritten outside of module",method:"The method you called is not defined."},debug:!1,verbose:!1,performance:!0,modules:["accordion","api","checkbox","dimmer","dropdown","embed","form","modal","nag","popup","rating","shape","sidebar","state","sticky","tab","transition","visit","visibility"],siteNamespace:"site",namespaceStub:{cache:{},config:{},sections:{},section:{},utilities:{}}},e.extend(e.expr[":"],{data:e.expr.createPseudo?e.expr.createPseudo(function(t){return function(n){return!!e.data(n,t)}}):function(t,n,i){return!!e.data(t,i[3])}})}(jQuery,window,document),function(e,t,n,i){"use strict";t=void 0!==t&&t.Math==Math?t:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")(),e.fn.form=function(t){var i,o=e(this),a=o.selector||"",r=(new Date).getTime(),s=[],l=arguments[0],c=arguments[1],u="string"==typeof l,d=[].slice.call(arguments,1);return o.each(function(){var f,m,g,v,p,h,b,y,x,C,w,k,S,T,A,R,P,E,F,O=e(this),D=this,q=[],j=!1;F={initialize:function(){F.get.settings(),u?(void 0===E&&F.instantiate(),F.invoke(l)):(void 0!==E&&E.invoke("destroy"),F.verbose("Initializing form validation",O,y),F.bindEvents(),F.set.defaults(),F.instantiate())},instantiate:function(){F.verbose("Storing instance of module",F),E=F,O.data(R,F)},destroy:function(){F.verbose("Destroying previous module",E),F.removeEvents(),O.removeData(R)},refresh:function(){F.verbose("Refreshing selector cache"),f=O.find(w.field),m=O.find(w.group),g=O.find(w.message),v=O.find(w.prompt),p=O.find(w.submit),h=O.find(w.clear),b=O.find(w.reset)},submit:function(){F.verbose("Submitting form",O),O.submit()},attachEvents:function(t,n){n=n||"submit",e(t).on("click"+P,function(e){F[n](),e.preventDefault()})},bindEvents:function(){F.verbose("Attaching form events"),O.on("submit"+P,F.validate.form).on("blur"+P,w.field,F.event.field.blur).on("click"+P,w.submit,F.submit).on("click"+P,w.reset,F.reset).on("click"+P,w.clear,F.clear),y.keyboardShortcuts&&O.on("keydown"+P,w.field,F.event.field.keydown),f.each(function(){var t=e(this),n=t.prop("type"),i=F.get.changeEvent(n,t);e(this).on(i+P,F.event.field.change)})},clear:function(){f.each(function(){var t=e(this),n=t.parent(),i=t.closest(m),o=i.find(w.prompt),a=t.data(C.defaultValue)||"",r=n.is(w.uiCheckbox),s=n.is(w.uiDropdown);i.hasClass(k.error)&&(F.verbose("Resetting error on field",i),i.removeClass(k.error),o.remove()),s?(F.verbose("Resetting dropdown value",n,a),n.dropdown("clear")):r?t.prop("checked",!1):(F.verbose("Resetting field value",t,a),t.val(""))})},reset:function(){f.each(function(){var t=e(this),n=t.parent(),i=t.closest(m),o=i.find(w.prompt),a=t.data(C.defaultValue),r=n.is(w.uiCheckbox),s=n.is(w.uiDropdown),l=i.hasClass(k.error);void 0!==a&&(l&&(F.verbose("Resetting error on field",i),i.removeClass(k.error),o.remove()),s?(F.verbose("Resetting dropdown value",n,a),n.dropdown("restore defaults")):r?(F.verbose("Resetting checkbox value",n,a),t.prop("checked",a)):(F.verbose("Resetting field value",t,a),t.val(a)))})},determine:{isValid:function(){var t=!0;return e.each(x,function(e,n){F.validate.field(n,e,!0)||(t=!1)}),t}},is:{bracketedRule:function(e){return e.type&&e.type.match(y.regExp.bracket)},empty:function(e){return!e||0===e.length||(e.is('input[type="checkbox"]')?!e.is(":checked"):F.is.blank(e))},blank:function(t){return""===e.trim(t.val())},valid:function(t){var n=!0;return t?(F.verbose("Checking if field is valid",t),F.validate.field(x[t],t,!1)):(F.verbose("Checking if form is valid"),e.each(x,function(e,t){F.is.valid(e)||(n=!1)}),n)}},removeEvents:function(){O.off(P),f.off(P),p.off(P),f.off(P)},event:{field:{keydown:function(t){var n=e(this),i=t.which,o=n.is(w.input),a=n.is(w.checkbox),r=n.closest(w.uiDropdown).length>0,s={enter:13,escape:27};i==s.escape&&(F.verbose("Escape key pressed blurring field"),n.blur()),t.ctrlKey||i!=s.enter||!o||r||a||(j||(n.one("keyup"+P,F.event.field.keyup),F.submit(),F.debug("Enter pressed on input submitting form")),j=!0)},keyup:function(){j=!1},blur:function(t){var n=e(this),i=n.closest(m),o=F.get.validation(n);i.hasClass(k.error)?(F.debug("Revalidating field",n,o),o&&F.validate.field(o)):"blur"!=y.on&&"change"!=y.on||o&&F.validate.field(o)},change:function(t){var n=e(this),i=n.closest(m),o=F.get.validation(n);o&&("change"==y.on||i.hasClass(k.error)&&y.revalidate)&&(clearTimeout(F.timer),F.timer=setTimeout(function(){F.debug("Revalidating field",n,F.get.validation(n)),F.validate.field(o)},y.delay))}}},get:{ancillaryValue:function(e){return!(!e.type||!e.value&&!F.is.bracketedRule(e))&&(void 0!==e.value?e.value:e.type.match(y.regExp.bracket)[1]+"")},ruleName:function(e){return F.is.bracketedRule(e)?e.type.replace(e.type.match(y.regExp.bracket)[0],""):e.type},changeEvent:function(e,t){return"checkbox"==e||"radio"==e||"hidden"==e||t.is("select")?"change":F.get.inputEvent()},inputEvent:function(){return void 0!==n.createElement("input").oninput?"input":void 0!==n.createElement("input").onpropertychange?"propertychange":"keyup"},prompt:function(e,t){var n,i,o,a=F.get.ruleName(e),r=F.get.ancillaryValue(e),s=e.prompt||y.prompt[a]||y.text.unspecifiedRule,l=-1!==s.search("{value}"),c=-1!==s.search("{name}");return(c||l)&&(i=F.get.field(t.identifier)),l&&(s=s.replace("{value}",i.val())),c&&(n=i.closest(w.group).find("label").eq(0),o=1==n.length?n.text():i.prop("placeholder")||y.text.unspecifiedField,s=s.replace("{name}",o)),s=s.replace("{identifier}",t.identifier),s=s.replace("{ruleValue}",r),e.prompt||F.verbose("Using default validation prompt for type",s,a),s},settings:function(){if(e.isPlainObject(t)){var n,i=Object.keys(t),o=i.length>0&&(void 0!==t[i[0]].identifier&&void 0!==t[i[0]].rules);o?(y=e.extend(!0,{},e.fn.form.settings,c),x=e.extend({},e.fn.form.settings.defaults,t),F.error(y.error.oldSyntax,D),F.verbose("Extending settings from legacy parameters",x,y)):(t.fields&&(n=Object.keys(t.fields),("string"==typeof t.fields[n[0]]||e.isArray(t.fields[n[0]]))&&e.each(t.fields,function(n,i){"string"==typeof i&&(i=[i]),t.fields[n]={rules:[]},e.each(i,function(e,i){t.fields[n].rules.push({type:i})})})),y=e.extend(!0,{},e.fn.form.settings,t),x=e.extend({},e.fn.form.settings.defaults,y.fields),F.verbose("Extending settings",x,y))}else y=e.fn.form.settings,x=e.fn.form.settings.defaults,F.verbose("Using default form validation",x,y);A=y.namespace,C=y.metadata,w=y.selector,k=y.className,S=y.regExp,T=y.error,R="module-"+A,P="."+A,E=O.data(R),F.refresh()},field:function(t){return F.verbose("Finding field with identifier",t),t=F.escape.string(t),f.filter("#"+t).length>0?f.filter("#"+t):f.filter('[name="'+t+'"]').length>0?f.filter('[name="'+t+'"]'):f.filter('[name="'+t+'[]"]').length>0?f.filter('[name="'+t+'[]"]'):f.filter("[data-"+C.validate+'="'+t+'"]').length>0?f.filter("[data-"+C.validate+'="'+t+'"]'):e("<input/>")},fields:function(t){var n=e();return e.each(t,function(e,t){n=n.add(F.get.field(t))}),n},validation:function(t){var n,i;return!!x&&(e.each(x,function(e,o){i=o.identifier||e,F.get.field(i)[0]==t[0]&&(o.identifier=i,n=o)}),n||!1)},value:function(e){var t,n=[];return n.push(e),t=F.get.values.call(D,n),t[e]},values:function(t){var n=e.isArray(t)?F.get.fields(t):f,i={};return n.each(function(t,n){var o=e(n),a=(o.prop("type"),o.prop("name")),r=o.val(),s=o.is(w.checkbox),l=o.is(w.radio),c=-1!==a.indexOf("[]"),u=!!s&&o.is(":checked");a&&(c?(a=a.replace("[]",""),i[a]||(i[a]=[]),s?u?i[a].push(r||!0):i[a].push(!1):i[a].push(r)):l?u&&(i[a]=r):i[a]=s?!!u&&(r||!0):r)}),i}},has:{field:function(e){return F.verbose("Checking for existence of a field with identifier",e),e=F.escape.string(e),"string"!=typeof e&&F.error(T.identifier,e),f.filter("#"+e).length>0||(f.filter('[name="'+e+'"]').length>0||f.filter("[data-"+C.validate+'="'+e+'"]').length>0)}},escape:{string:function(e){return e=String(e),e.replace(S.escape,"\\$&")}},add:{prompt:function(t,n){var i=F.get.field(t),o=i.closest(m),a=o.children(w.prompt),r=0!==a.length;n="string"==typeof n?[n]:n,F.verbose("Adding field error state",t),o.addClass(k.error),y.inline&&(r||(a=y.templates.prompt(n),a.appendTo(o)),a.html(n[0]),r?F.verbose("Inline errors are disabled, no inline error added",t):y.transition&&void 0!==e.fn.transition&&O.transition("is supported")?(F.verbose("Displaying error with css transition",y.transition),a.transition(y.transition+" in",y.duration)):(F.verbose("Displaying error with fallback javascript animation"),a.fadeIn(y.duration)))},errors:function(e){F.debug("Adding form error messages",e),F.set.error(),g.html(y.templates.error(e))}},remove:{prompt:function(t){var n=F.get.field(t),i=n.closest(m),o=i.children(w.prompt);i.removeClass(k.error),y.inline&&o.is(":visible")&&(F.verbose("Removing prompt for field",t),y.transition&&void 0!==e.fn.transition&&O.transition("is supported")?o.transition(y.transition+" out",y.duration,function(){o.remove()}):o.fadeOut(y.duration,function(){o.remove()}))}},set:{success:function(){O.removeClass(k.error).addClass(k.success)},defaults:function(){f.each(function(){var t=e(this),n=t.filter(w.checkbox).length>0,i=n?t.is(":checked"):t.val();t.data(C.defaultValue,i)})},error:function(){O.removeClass(k.success).addClass(k.error)},value:function(e,t){var n={};return n[e]=t,F.set.values.call(D,n)},values:function(t){e.isEmptyObject(t)||e.each(t,function(t,n){var i,o=F.get.field(t),a=o.parent(),r=e.isArray(n),s=a.is(w.uiCheckbox),l=a.is(w.uiDropdown),c=o.is(w.radio)&&s,u=o.length>0;u&&(r&&s?(F.verbose("Selecting multiple",n,o),a.checkbox("uncheck"),e.each(n,function(e,t){i=o.filter('[value="'+t+'"]'),a=i.parent(),i.length>0&&a.checkbox("check")})):c?(F.verbose("Selecting radio value",n,o),o.filter('[value="'+n+'"]').parent(w.uiCheckbox).checkbox("check")):s?(F.verbose("Setting checkbox value",n,a),!0===n?a.checkbox("check"):a.checkbox("uncheck")):l?(F.verbose("Setting dropdown value",n,a),a.dropdown("set selected",n)):(F.verbose("Setting field value",n,o),o.val(n)))})}},validate:{form:function(e,t){var n=F.get.values();if(j)return!1;if(q=[],F.determine.isValid()){if(F.debug("Form has no validation errors, submitting"),F.set.success(),!0!==t)return y.onSuccess.call(D,e,n)}else if(F.debug("Form has errors"),F.set.error(),y.inline||F.add.errors(q),void 0!==O.data("moduleApi")&&e.stopImmediatePropagation(),!0!==t)return y.onFailure.call(D,q,n)},field:function(t,n,i){i=void 0===i||i,"string"==typeof t&&(F.verbose("Validating field",t),n=t,t=x[t]);var o=t.identifier||n,a=F.get.field(o),r=!!t.depends&&F.get.field(t.depends),s=!0,l=[];return t.identifier||(F.debug("Using field name as identifier",o),t.identifier=o),a.prop("disabled")?(F.debug("Field is disabled. Skipping",o),s=!0):t.optional&&F.is.blank(a)?(F.debug("Field is optional and blank. Skipping",o),s=!0):t.depends&&F.is.empty(r)?(F.debug("Field depends on another value that is not present or empty. Skipping",r),s=!0):void 0!==t.rules&&e.each(t.rules,function(e,n){F.has.field(o)&&!F.validate.rule(t,n)&&(F.debug("Field is invalid",o,n.type),l.push(F.get.prompt(n,t)),s=!1)}),s?(i&&(F.remove.prompt(o,l),y.onValid.call(a)),!0):(i&&(q=q.concat(l),F.add.prompt(o,l),y.onInvalid.call(a,l)),!1)},rule:function(t,n){var i=F.get.field(t.identifier),o=(n.type,i.val()),a=F.get.ancillaryValue(n),r=F.get.ruleName(n),s=y.rules[r];return e.isFunction(s)?(o=void 0===o||""===o||null===o?"":e.trim(o+""),s.call(i,o,a)):void F.error(T.noRule,r)}},setting:function(t,n){if(e.isPlainObject(t))e.extend(!0,y,t);else{if(void 0===n)return y[t];y[t]=n}},internal:function(t,n){if(e.isPlainObject(t))e.extend(!0,F,t);else{if(void 0===n)return F[t];F[t]=n}},debug:function(){!y.silent&&y.debug&&(y.performance?F.performance.log(arguments):(F.debug=Function.prototype.bind.call(console.info,console,y.name+":"),F.debug.apply(console,arguments)))},verbose:function(){!y.silent&&y.verbose&&y.debug&&(y.performance?F.performance.log(arguments):(F.verbose=Function.prototype.bind.call(console.info,console,y.name+":"),F.verbose.apply(console,arguments)))},error:function(){y.silent||(F.error=Function.prototype.bind.call(console.error,console,y.name+":"),F.error.apply(console,arguments))},performance:{log:function(e){var t,n,i;y.performance&&(t=(new Date).getTime(),i=r||t,n=t-i,r=t,s.push({Name:e[0],Arguments:[].slice.call(e,1)||"",Element:D,"Execution Time":n})),clearTimeout(F.performance.timer),F.performance.timer=setTimeout(F.performance.display,500)},display:function(){var t=y.name+":",n=0;r=!1,clearTimeout(F.performance.timer),e.each(s,function(e,t){n+=t["Execution Time"]}),t+=" "+n+"ms",a&&(t+=" '"+a+"'"),o.length>1&&(t+=" ("+o.length+")"),(void 0!==console.group||void 0!==console.table)&&s.length>0&&(console.groupCollapsed(t),console.table?console.table(s):e.each(s,function(e,t){console.log(t.Name+": "+t["Execution Time"]+"ms")}),console.groupEnd()),s=[]}},invoke:function(t,n,o){var a,r,s,l=E;return n=n||d,o=D||o,"string"==typeof t&&void 0!==l&&(t=t.split(/[\. ]/),a=t.length-1,e.each(t,function(n,i){var o=n!=a?i+t[n+1].charAt(0).toUpperCase()+t[n+1].slice(1):t;if(e.isPlainObject(l[o])&&n!=a)l=l[o];else{if(void 0!==l[o])return r=l[o],!1;if(!e.isPlainObject(l[i])||n==a)return void 0!==l[i]&&(r=l[i],!1);l=l[i]}})),e.isFunction(r)?s=r.apply(o,n):void 0!==r&&(s=r),e.isArray(i)?i.push(s):void 0!==i?i=[i,s]:void 0!==s&&(i=s),r}},F.initialize()}),void 0!==i?i:this},e.fn.form.settings={name:"Form",namespace:"form",debug:!1,verbose:!1,performance:!0,fields:!1,keyboardShortcuts:!0,on:"submit",inline:!1,delay:200,revalidate:!0,transition:"scale",duration:200,onValid:function(){},onInvalid:function(){},onSuccess:function(){return!0},onFailure:function(){return!1},metadata:{defaultValue:"default",validate:"validate"},regExp:{htmlID:/^[a-zA-Z][\w:.-]*$/g,bracket:/\[(.*)\]/i,decimal:/^\d+\.?\d*$/,email:/^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i,escape:/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,flags:/^\/(.*)\/(.*)?/,integer:/^\-?\d+$/,number:/^\-?\d*(\.\d+)?$/,url:/(https?:\/\/(?:www\.|(?!www))[^\s\.]+\.[^\s]{2,}|www\.[^\s]+\.[^\s]{2,})/i},text:{unspecifiedRule:"Please enter a valid value",unspecifiedField:"This field"},prompt:{empty:"{name} must have a value",checked:"{name} must be checked",email:"{name} must be a valid e-mail",url:"{name} must be a valid url",regExp:"{name} is not formatted correctly",integer:"{name} must be an integer",decimal:"{name} must be a decimal number",number:"{name} must be set to a number",is:'{name} must be "{ruleValue}"',isExactly:'{name} must be exactly "{ruleValue}"',not:'{name} cannot be set to "{ruleValue}"',notExactly:'{name} cannot be set to exactly "{ruleValue}"',contain:'{name} cannot contain "{ruleValue}"',containExactly:'{name} cannot contain exactly "{ruleValue}"',doesntContain:'{name} must contain  "{ruleValue}"',doesntContainExactly:'{name} must contain exactly "{ruleValue}"',minLength:"{name} must be at least {ruleValue} characters",length:"{name} must be at least {ruleValue} characters",exactLength:"{name} must be exactly {ruleValue} characters",maxLength:"{name} cannot be longer than {ruleValue} characters",match:"{name} must match {ruleValue} field",different:"{name} must have a different value than {ruleValue} field",creditCard:"{name} must be a valid credit card number",minCount:"{name} must have at least {ruleValue} choices",exactCount:"{name} must have exactly {ruleValue} choices",maxCount:"{name} must have {ruleValue} or less choices"},selector:{checkbox:'input[type="checkbox"], input[type="radio"]',clear:".clear",field:"input, textarea, select",group:".field",input:"input",message:".error.message",prompt:".prompt.label",radio:'input[type="radio"]',reset:'.reset:not([type="reset"])',submit:'.submit:not([type="submit"])',uiCheckbox:".ui.checkbox",uiDropdown:".ui.dropdown"},className:{error:"error",label:"ui prompt label",pressed:"down",success:"success"},error:{identifier:"You must specify a string identifier for each field",method:"The method you called is not defined.",noRule:"There is no rule matching the one you specified",oldSyntax:"Starting in 2.0 forms now only take a single settings object. Validation settings converted to new syntax automatically."},templates:{error:function(t){var n='<ul class="list">';return e.each(t,function(e,t){n+="<li>"+t+"</li>"}),n+="</ul>",e(n)},prompt:function(t){return e("<div/>").addClass("ui basic red pointing prompt label").html(t[0])}},rules:{empty:function(t){return!(void 0===t||""===t||e.isArray(t)&&0===t.length)},checked:function(){return e(this).filter(":checked").length>0},email:function(t){return e.fn.form.settings.regExp.email.test(t)},url:function(t){return e.fn.form.settings.regExp.url.test(t)},regExp:function(t,n){if(n instanceof RegExp)return t.match(n);var i,o=n.match(e.fn.form.settings.regExp.flags);return o&&(n=o.length>=2?o[1]:n,i=o.length>=3?o[2]:""),t.match(new RegExp(n,i))},integer:function(t,n){var i,o,a,r=e.fn.form.settings.regExp.integer;return n&&-1===["",".."].indexOf(n)&&(-1==n.indexOf("..")?r.test(n)&&(i=o=n-0):(a=n.split("..",2),r.test(a[0])&&(i=a[0]-0),r.test(a[1])&&(o=a[1]-0))),r.test(t)&&(void 0===i||t>=i)&&(void 0===o||t<=o)},decimal:function(t){return e.fn.form.settings.regExp.decimal.test(t)},number:function(t){return e.fn.form.settings.regExp.number.test(t)},is:function(e,t){return t="string"==typeof t?t.toLowerCase():t,(e="string"==typeof e?e.toLowerCase():e)==t},isExactly:function(e,t){return e==t},not:function(e,t){return e="string"==typeof e?e.toLowerCase():e,t="string"==typeof t?t.toLowerCase():t,e!=t},notExactly:function(e,t){return e!=t},contains:function(t,n){return n=n.replace(e.fn.form.settings.regExp.escape,"\\$&"),-1!==t.search(new RegExp(n,"i"))},containsExactly:function(t,n){return n=n.replace(e.fn.form.settings.regExp.escape,"\\$&"),-1!==t.search(new RegExp(n))},doesntContain:function(t,n){return n=n.replace(e.fn.form.settings.regExp.escape,"\\$&"),-1===t.search(new RegExp(n,"i"))},doesntContainExactly:function(t,n){return n=n.replace(e.fn.form.settings.regExp.escape,"\\$&"),-1===t.search(new RegExp(n))},minLength:function(e,t){return void 0!==e&&e.length>=t},length:function(e,t){return void 0!==e&&e.length>=t},exactLength:function(e,t){return void 0!==e&&e.length==t},maxLength:function(e,t){return void 0!==e&&e.length<=t},match:function(t,n){var i;e(this);return e('[data-validate="'+n+'"]').length>0?i=e('[data-validate="'+n+'"]').val():e("#"+n).length>0?i=e("#"+n).val():e('[name="'+n+'"]').length>0?i=e('[name="'+n+'"]').val():e('[name="'+n+'[]"]').length>0&&(i=e('[name="'+n+'[]"]')),void 0!==i&&t.toString()==i.toString()},different:function(t,n){var i;e(this);return e('[data-validate="'+n+'"]').length>0?i=e('[data-validate="'+n+'"]').val():e("#"+n).length>0?i=e("#"+n).val():e('[name="'+n+'"]').length>0?i=e('[name="'+n+'"]').val():e('[name="'+n+'[]"]').length>0&&(i=e('[name="'+n+'[]"]')),void 0!==i&&t.toString()!==i.toString()},creditCard:function(t,n){var i,o,a={visa:{pattern:/^4/,length:[16]},amex:{pattern:/^3[47]/,length:[15]},mastercard:{pattern:/^5[1-5]/,length:[16]},discover:{pattern:/^(6011|622(12[6-9]|1[3-9][0-9]|[2-8][0-9]{2}|9[0-1][0-9]|92[0-5]|64[4-9])|65)/,length:[16]},unionPay:{pattern:/^(62|88)/,length:[16,17,18,19]},jcb:{pattern:/^35(2[89]|[3-8][0-9])/,length:[16]},maestro:{pattern:/^(5018|5020|5038|6304|6759|676[1-3])/,length:[12,13,14,15,16,17,18,19]},dinersClub:{pattern:/^(30[0-5]|^36)/,length:[14]},laser:{pattern:/^(6304|670[69]|6771)/,length:[16,17,18,19]},visaElectron:{pattern:/^(4026|417500|4508|4844|491(3|7))/,length:[16]}},r={},s=!1,l="string"==typeof n&&n.split(",");if("string"==typeof t&&0!==t.length){if(t=t.replace(/[\-]/g,""),l&&(e.each(l,function(n,i){(o=a[i])&&(r={length:-1!==e.inArray(t.length,o.length),pattern:-1!==t.search(o.pattern)},r.length&&r.pattern&&(s=!0))}),!s))return!1;if(i={number:-1!==e.inArray(t.length,a.unionPay.length),pattern:-1!==t.search(a.unionPay.pattern)},i.number&&i.pattern)return!0;for(var c=t.length,u=0,d=[[0,1,2,3,4,5,6,7,8,9],[0,2,4,6,8,1,3,5,7,9]],f=0;c--;)f+=d[u][parseInt(t.charAt(c),10)],u^=1;return f%10==0&&f>0}},minCount:function(e,t){return 0==t||(1==t?""!==e:e.split(",").length>=t)},exactCount:function(e,t){return 0==t?""===e:1==t?""!==e&&-1===e.search(","):e.split(",").length==t},maxCount:function(e,t){return 0!=t&&(1==t?-1===e.search(","):e.split(",").length<=t)}}}}(jQuery,window,document),function(e,t,n,i){"use strict";t=void 0!==t&&t.Math==Math?t:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")(),e.fn.accordion=function(n){var i,o=e(this),a=(new Date).getTime(),r=[],s=arguments[0],l="string"==typeof s,c=[].slice.call(arguments,1);t.requestAnimationFrame||t.mozRequestAnimationFrame||t.webkitRequestAnimationFrame||t.msRequestAnimationFrame;return o.each(function(){var u,d,f=e.isPlainObject(n)?e.extend(!0,{},e.fn.accordion.settings,n):e.extend({},e.fn.accordion.settings),m=f.className,g=f.namespace,v=f.selector,p=f.error,h="."+g,b="module-"+g,y=o.selector||"",x=e(this),C=x.find(v.title),w=x.find(v.content),k=this,S=x.data(b);d={initialize:function(){d.debug("Initializing",x),d.bind.events(),f.observeChanges&&d.observeChanges(),d.instantiate()},instantiate:function(){S=d,x.data(b,d)},destroy:function(){d.debug("Destroying previous instance",x),x.off(h).removeData(b)},refresh:function(){C=x.find(v.title),w=x.find(v.content)},observeChanges:function(){"MutationObserver"in t&&(u=new MutationObserver(function(e){d.debug("DOM tree modified, updating selector cache"),d.refresh()}),u.observe(k,{childList:!0,subtree:!0}),d.debug("Setting up mutation observer",u))},bind:{events:function(){d.debug("Binding delegated events"),x.on(f.on+h,v.trigger,d.event.click)}},event:{click:function(){d.toggle.call(this)}},toggle:function(t){var n=void 0!==t?"number"==typeof t?C.eq(t):e(t).closest(v.title):e(this).closest(v.title),i=n.next(w),o=i.hasClass(m.animating),a=i.hasClass(m.active),r=a&&!o,s=!a&&o;d.debug("Toggling visibility of content",n),r||s?f.collapsible?d.close.call(n):d.debug("Cannot close accordion content collapsing is disabled"):d.open.call(n)},open:function(t){var n=void 0!==t?"number"==typeof t?C.eq(t):e(t).closest(v.title):e(this).closest(v.title),i=n.next(w),o=i.hasClass(m.animating);if(i.hasClass(m.active)||o)return void d.debug("Accordion already open, skipping",i);d.debug("Opening accordion content",n),f.onOpening.call(i),f.exclusive&&d.closeOthers.call(n),n.addClass(m.active),i.stop(!0,!0).addClass(m.animating),f.animateChildren&&(void 0!==e.fn.transition&&x.transition("is supported")?i.children().transition({animation:"fade in",queue:!1,useFailSafe:!0,debug:f.debug,verbose:f.verbose,duration:f.duration}):i.children().stop(!0,!0).animate({opacity:1},f.duration,d.resetOpacity)),i.slideDown(f.duration,f.easing,function(){i.removeClass(m.animating).addClass(m.active),d.reset.display.call(this),f.onOpen.call(this),f.onChange.call(this)})},close:function(t){var n=void 0!==t?"number"==typeof t?C.eq(t):e(t).closest(v.title):e(this).closest(v.title),i=n.next(w),o=i.hasClass(m.animating),a=i.hasClass(m.active),r=!a&&o,s=a&&o;!a&&!r||s||(d.debug("Closing accordion content",i),f.onClosing.call(i),n.removeClass(m.active),i.stop(!0,!0).addClass(m.animating),f.animateChildren&&(void 0!==e.fn.transition&&x.transition("is supported")?i.children().transition({animation:"fade out",queue:!1,useFailSafe:!0,debug:f.debug,verbose:f.verbose,duration:f.duration}):i.children().stop(!0,!0).animate({opacity:0},f.duration,d.resetOpacity)),i.slideUp(f.duration,f.easing,function(){i.removeClass(m.animating).removeClass(m.active),d.reset.display.call(this),f.onClose.call(this),f.onChange.call(this)}))},closeOthers:function(t){var n,i,o,a=void 0!==t?C.eq(t):e(this).closest(v.title),r=a.parents(v.content).prev(v.title),s=a.closest(v.accordion),l=v.title+"."+m.active+":visible",c=v.content+"."+m.active+":visible";f.closeNested?(n=s.find(l).not(r),o=n.next(w)):(n=s.find(l).not(r),i=s.find(c).find(l).not(r),n=n.not(i),o=n.next(w)),n.length>0&&(d.debug("Exclusive enabled, closing other content",n),n.removeClass(m.active),o.removeClass(m.animating).stop(!0,!0),f.animateChildren&&(void 0!==e.fn.transition&&x.transition("is supported")?o.children().transition({animation:"fade out",useFailSafe:!0,debug:f.debug,verbose:f.verbose,duration:f.duration}):o.children().stop(!0,!0).animate({opacity:0},f.duration,d.resetOpacity)),o.slideUp(f.duration,f.easing,function(){e(this).removeClass(m.active),d.reset.display.call(this)}))},reset:{display:function(){d.verbose("Removing inline display from element",this),e(this).css("display",""),""===e(this).attr("style")&&e(this).attr("style","").removeAttr("style")},opacity:function(){d.verbose("Removing inline opacity from element",this),e(this).css("opacity",""),""===e(this).attr("style")&&e(this).attr("style","").removeAttr("style")}},setting:function(t,n){if(d.debug("Changing setting",t,n),e.isPlainObject(t))e.extend(!0,f,t);else{if(void 0===n)return f[t];e.isPlainObject(f[t])?e.extend(!0,f[t],n):f[t]=n}},internal:function(t,n){if(d.debug("Changing internal",t,n),void 0===n)return d[t];e.isPlainObject(t)?e.extend(!0,d,t):d[t]=n},debug:function(){!f.silent&&f.debug&&(f.performance?d.performance.log(arguments):(d.debug=Function.prototype.bind.call(console.info,console,f.name+":"),d.debug.apply(console,arguments)))},verbose:function(){!f.silent&&f.verbose&&f.debug&&(f.performance?d.performance.log(arguments):(d.verbose=Function.prototype.bind.call(console.info,console,f.name+":"),d.verbose.apply(console,arguments)))},error:function(){f.silent||(d.error=Function.prototype.bind.call(console.error,console,f.name+":"),d.error.apply(console,arguments))},performance:{log:function(e){var t,n,i;f.performance&&(t=(new Date).getTime(),i=a||t,n=t-i,a=t,r.push({Name:e[0],Arguments:[].slice.call(e,1)||"",Element:k,"Execution Time":n})),clearTimeout(d.performance.timer),d.performance.timer=setTimeout(d.performance.display,500)},display:function(){var t=f.name+":",n=0;a=!1,clearTimeout(d.performance.timer),e.each(r,function(e,t){n+=t["Execution Time"]}),t+=" "+n+"ms",y&&(t+=" '"+y+"'"),(void 0!==console.group||void 0!==console.table)&&r.length>0&&(console.groupCollapsed(t),console.table?console.table(r):e.each(r,function(e,t){console.log(t.Name+": "+t["Execution Time"]+"ms")}),console.groupEnd()),r=[]}},invoke:function(t,n,o){var a,r,s,l=S;return n=n||c,o=k||o,"string"==typeof t&&void 0!==l&&(t=t.split(/[\. ]/),a=t.length-1,e.each(t,function(n,i){
var o=n!=a?i+t[n+1].charAt(0).toUpperCase()+t[n+1].slice(1):t;if(e.isPlainObject(l[o])&&n!=a)l=l[o];else{if(void 0!==l[o])return r=l[o],!1;if(!e.isPlainObject(l[i])||n==a)return void 0!==l[i]?(r=l[i],!1):(d.error(p.method,t),!1);l=l[i]}})),e.isFunction(r)?s=r.apply(o,n):void 0!==r&&(s=r),e.isArray(i)?i.push(s):void 0!==i?i=[i,s]:void 0!==s&&(i=s),r}},l?(void 0===S&&d.initialize(),d.invoke(s)):(void 0!==S&&S.invoke("destroy"),d.initialize())}),void 0!==i?i:this},e.fn.accordion.settings={name:"Accordion",namespace:"accordion",silent:!1,debug:!1,verbose:!1,performance:!0,on:"click",observeChanges:!0,exclusive:!0,collapsible:!0,closeNested:!1,animateChildren:!0,duration:350,easing:"easeOutQuad",onOpening:function(){},onOpen:function(){},onClosing:function(){},onClose:function(){},onChange:function(){},error:{method:"The method you called is not defined"},className:{active:"active",animating:"animating"},selector:{accordion:".accordion",title:".title",trigger:".title",content:".content"}},e.extend(e.easing,{easeOutQuad:function(e,t,n,i,o){return-i*(t/=o)*(t-2)+n}})}(jQuery,window,document),function(e,t,n,i){"use strict";t=void 0!==t&&t.Math==Math?t:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")(),e.fn.checkbox=function(i){var o,a=e(this),r=a.selector||"",s=(new Date).getTime(),l=[],c=arguments[0],u="string"==typeof c,d=[].slice.call(arguments,1);return a.each(function(){var a,f,m=e.extend(!0,{},e.fn.checkbox.settings,i),g=m.className,v=m.namespace,p=m.selector,h=m.error,b="."+v,y="module-"+v,x=e(this),C=e(this).children(p.label),w=e(this).children(p.input),k=w[0],S=!1,T=!1,A=x.data(y),R=this;f={initialize:function(){f.verbose("Initializing checkbox",m),f.create.label(),f.bind.events(),f.set.tabbable(),f.hide.input(),f.observeChanges(),f.instantiate(),f.setup()},instantiate:function(){f.verbose("Storing instance of module",f),A=f,x.data(y,f)},destroy:function(){f.verbose("Destroying module"),f.unbind.events(),f.show.input(),x.removeData(y)},fix:{reference:function(){x.is(p.input)&&(f.debug("Behavior called on <input> adjusting invoked element"),x=x.closest(p.checkbox),f.refresh())}},setup:function(){f.set.initialLoad(),f.is.indeterminate()?(f.debug("Initial value is indeterminate"),f.indeterminate()):f.is.checked()?(f.debug("Initial value is checked"),f.check()):(f.debug("Initial value is unchecked"),f.uncheck()),f.remove.initialLoad()},refresh:function(){C=x.children(p.label),w=x.children(p.input),k=w[0]},hide:{input:function(){f.verbose("Modifying <input> z-index to be unselectable"),w.addClass(g.hidden)}},show:{input:function(){f.verbose("Modifying <input> z-index to be selectable"),w.removeClass(g.hidden)}},observeChanges:function(){"MutationObserver"in t&&(a=new MutationObserver(function(e){f.debug("DOM tree modified, updating selector cache"),f.refresh()}),a.observe(R,{childList:!0,subtree:!0}),f.debug("Setting up mutation observer",a))},attachEvents:function(t,n){var i=e(t);n=e.isFunction(f[n])?f[n]:f.toggle,i.length>0?(f.debug("Attaching checkbox events to element",t,n),i.on("click"+b,n)):f.error(h.notFound)},event:{click:function(t){var n=e(t.target);return n.is(p.input)?void f.verbose("Using default check action on initialized checkbox"):n.is(p.link)?void f.debug("Clicking link inside checkbox, skipping toggle"):(f.toggle(),w.focus(),void t.preventDefault())},keydown:function(e){var t=e.which,n={enter:13,space:32,escape:27};t==n.escape?(f.verbose("Escape key pressed blurring field"),w.blur(),T=!0):e.ctrlKey||t!=n.space&&t!=n.enter?T=!1:(f.verbose("Enter/space key pressed, toggling checkbox"),f.toggle(),T=!0)},keyup:function(e){T&&e.preventDefault()}},check:function(){f.should.allowCheck()&&(f.debug("Checking checkbox",w),f.set.checked(),f.should.ignoreCallbacks()||(m.onChecked.call(k),m.onChange.call(k)))},uncheck:function(){f.should.allowUncheck()&&(f.debug("Unchecking checkbox"),f.set.unchecked(),f.should.ignoreCallbacks()||(m.onUnchecked.call(k),m.onChange.call(k)))},indeterminate:function(){if(f.should.allowIndeterminate())return void f.debug("Checkbox is already indeterminate");f.debug("Making checkbox indeterminate"),f.set.indeterminate(),f.should.ignoreCallbacks()||(m.onIndeterminate.call(k),m.onChange.call(k))},determinate:function(){if(f.should.allowDeterminate())return void f.debug("Checkbox is already determinate");f.debug("Making checkbox determinate"),f.set.determinate(),f.should.ignoreCallbacks()||(m.onDeterminate.call(k),m.onChange.call(k))},enable:function(){if(f.is.enabled())return void f.debug("Checkbox is already enabled");f.debug("Enabling checkbox"),f.set.enabled(),m.onEnable.call(k),m.onEnabled.call(k)},disable:function(){if(f.is.disabled())return void f.debug("Checkbox is already disabled");f.debug("Disabling checkbox"),f.set.disabled(),m.onDisable.call(k),m.onDisabled.call(k)},get:{radios:function(){var t=f.get.name();return e('input[name="'+t+'"]').closest(p.checkbox)},otherRadios:function(){return f.get.radios().not(x)},name:function(){return w.attr("name")}},is:{initialLoad:function(){return S},radio:function(){return w.hasClass(g.radio)||"radio"==w.attr("type")},indeterminate:function(){return void 0!==w.prop("indeterminate")&&w.prop("indeterminate")},checked:function(){return void 0!==w.prop("checked")&&w.prop("checked")},disabled:function(){return void 0!==w.prop("disabled")&&w.prop("disabled")},enabled:function(){return!f.is.disabled()},determinate:function(){return!f.is.indeterminate()},unchecked:function(){return!f.is.checked()}},should:{allowCheck:function(){return f.is.determinate()&&f.is.checked()&&!f.should.forceCallbacks()?(f.debug("Should not allow check, checkbox is already checked"),!1):!1!==m.beforeChecked.apply(k)||(f.debug("Should not allow check, beforeChecked cancelled"),!1)},allowUncheck:function(){return f.is.determinate()&&f.is.unchecked()&&!f.should.forceCallbacks()?(f.debug("Should not allow uncheck, checkbox is already unchecked"),!1):!1!==m.beforeUnchecked.apply(k)||(f.debug("Should not allow uncheck, beforeUnchecked cancelled"),!1)},allowIndeterminate:function(){return f.is.indeterminate()&&!f.should.forceCallbacks()?(f.debug("Should not allow indeterminate, checkbox is already indeterminate"),!1):!1!==m.beforeIndeterminate.apply(k)||(f.debug("Should not allow indeterminate, beforeIndeterminate cancelled"),!1)},allowDeterminate:function(){return f.is.determinate()&&!f.should.forceCallbacks()?(f.debug("Should not allow determinate, checkbox is already determinate"),!1):!1!==m.beforeDeterminate.apply(k)||(f.debug("Should not allow determinate, beforeDeterminate cancelled"),!1)},forceCallbacks:function(){return f.is.initialLoad()&&m.fireOnInit},ignoreCallbacks:function(){return S&&!m.fireOnInit}},can:{change:function(){return!(x.hasClass(g.disabled)||x.hasClass(g.readOnly)||w.prop("disabled")||w.prop("readonly"))},uncheck:function(){return"boolean"==typeof m.uncheckable?m.uncheckable:!f.is.radio()}},set:{initialLoad:function(){S=!0},checked:function(){if(f.verbose("Setting class to checked"),x.removeClass(g.indeterminate).addClass(g.checked),f.is.radio()&&f.uncheckOthers(),!f.is.indeterminate()&&f.is.checked())return void f.debug("Input is already checked, skipping input property change");f.verbose("Setting state to checked",k),w.prop("indeterminate",!1).prop("checked",!0),f.trigger.change()},unchecked:function(){if(f.verbose("Removing checked class"),x.removeClass(g.indeterminate).removeClass(g.checked),!f.is.indeterminate()&&f.is.unchecked())return void f.debug("Input is already unchecked");f.debug("Setting state to unchecked"),w.prop("indeterminate",!1).prop("checked",!1),f.trigger.change()},indeterminate:function(){if(f.verbose("Setting class to indeterminate"),x.addClass(g.indeterminate),f.is.indeterminate())return void f.debug("Input is already indeterminate, skipping input property change");f.debug("Setting state to indeterminate"),w.prop("indeterminate",!0),f.trigger.change()},determinate:function(){if(f.verbose("Removing indeterminate class"),x.removeClass(g.indeterminate),f.is.determinate())return void f.debug("Input is already determinate, skipping input property change");f.debug("Setting state to determinate"),w.prop("indeterminate",!1)},disabled:function(){if(f.verbose("Setting class to disabled"),x.addClass(g.disabled),f.is.disabled())return void f.debug("Input is already disabled, skipping input property change");f.debug("Setting state to disabled"),w.prop("disabled","disabled"),f.trigger.change()},enabled:function(){if(f.verbose("Removing disabled class"),x.removeClass(g.disabled),f.is.enabled())return void f.debug("Input is already enabled, skipping input property change");f.debug("Setting state to enabled"),w.prop("disabled",!1),f.trigger.change()},tabbable:function(){f.verbose("Adding tabindex to checkbox"),void 0===w.attr("tabindex")&&w.attr("tabindex",0)}},remove:{initialLoad:function(){S=!1}},trigger:{change:function(){var e=n.createEvent("HTMLEvents"),t=w[0];t&&(f.verbose("Triggering native change event"),e.initEvent("change",!0,!1),t.dispatchEvent(e))}},create:{label:function(){w.prevAll(p.label).length>0?(w.prev(p.label).detach().insertAfter(w),f.debug("Moving existing label",C)):f.has.label()||(C=e("<label>").insertAfter(w),f.debug("Creating label",C))}},has:{label:function(){return C.length>0}},bind:{events:function(){f.verbose("Attaching checkbox events"),x.on("click"+b,f.event.click).on("keydown"+b,p.input,f.event.keydown).on("keyup"+b,p.input,f.event.keyup)}},unbind:{events:function(){f.debug("Removing events"),x.off(b)}},uncheckOthers:function(){var e=f.get.otherRadios();f.debug("Unchecking other radios",e),e.removeClass(g.checked)},toggle:function(){if(!f.can.change())return void(f.is.radio()||f.debug("Checkbox is read-only or disabled, ignoring toggle"));f.is.indeterminate()||f.is.unchecked()?(f.debug("Currently unchecked"),f.check()):f.is.checked()&&f.can.uncheck()&&(f.debug("Currently checked"),f.uncheck())},setting:function(t,n){if(f.debug("Changing setting",t,n),e.isPlainObject(t))e.extend(!0,m,t);else{if(void 0===n)return m[t];e.isPlainObject(m[t])?e.extend(!0,m[t],n):m[t]=n}},internal:function(t,n){if(e.isPlainObject(t))e.extend(!0,f,t);else{if(void 0===n)return f[t];f[t]=n}},debug:function(){!m.silent&&m.debug&&(m.performance?f.performance.log(arguments):(f.debug=Function.prototype.bind.call(console.info,console,m.name+":"),f.debug.apply(console,arguments)))},verbose:function(){!m.silent&&m.verbose&&m.debug&&(m.performance?f.performance.log(arguments):(f.verbose=Function.prototype.bind.call(console.info,console,m.name+":"),f.verbose.apply(console,arguments)))},error:function(){m.silent||(f.error=Function.prototype.bind.call(console.error,console,m.name+":"),f.error.apply(console,arguments))},performance:{log:function(e){var t,n,i;m.performance&&(t=(new Date).getTime(),i=s||t,n=t-i,s=t,l.push({Name:e[0],Arguments:[].slice.call(e,1)||"",Element:R,"Execution Time":n})),clearTimeout(f.performance.timer),f.performance.timer=setTimeout(f.performance.display,500)},display:function(){var t=m.name+":",n=0;s=!1,clearTimeout(f.performance.timer),e.each(l,function(e,t){n+=t["Execution Time"]}),t+=" "+n+"ms",r&&(t+=" '"+r+"'"),(void 0!==console.group||void 0!==console.table)&&l.length>0&&(console.groupCollapsed(t),console.table?console.table(l):e.each(l,function(e,t){console.log(t.Name+": "+t["Execution Time"]+"ms")}),console.groupEnd()),l=[]}},invoke:function(t,n,i){var a,r,s,l=A;return n=n||d,i=R||i,"string"==typeof t&&void 0!==l&&(t=t.split(/[\. ]/),a=t.length-1,e.each(t,function(n,i){var o=n!=a?i+t[n+1].charAt(0).toUpperCase()+t[n+1].slice(1):t;if(e.isPlainObject(l[o])&&n!=a)l=l[o];else{if(void 0!==l[o])return r=l[o],!1;if(!e.isPlainObject(l[i])||n==a)return void 0!==l[i]?(r=l[i],!1):(f.error(h.method,t),!1);l=l[i]}})),e.isFunction(r)?s=r.apply(i,n):void 0!==r&&(s=r),e.isArray(o)?o.push(s):void 0!==o?o=[o,s]:void 0!==s&&(o=s),r}},u?(void 0===A&&f.initialize(),f.invoke(c)):(void 0!==A&&A.invoke("destroy"),f.initialize())}),void 0!==o?o:this},e.fn.checkbox.settings={name:"Checkbox",namespace:"checkbox",silent:!1,debug:!1,verbose:!0,performance:!0,uncheckable:"auto",fireOnInit:!1,onChange:function(){},beforeChecked:function(){},beforeUnchecked:function(){},beforeDeterminate:function(){},beforeIndeterminate:function(){},onChecked:function(){},onUnchecked:function(){},onDeterminate:function(){},onIndeterminate:function(){},onEnable:function(){},onDisable:function(){},onEnabled:function(){},onDisabled:function(){},className:{checked:"checked",indeterminate:"indeterminate",disabled:"disabled",hidden:"hidden",radio:"radio",readOnly:"read-only"},error:{method:"The method you called is not defined"},selector:{checkbox:".ui.checkbox",label:"label, .box",input:'input[type="checkbox"], input[type="radio"]',link:"a[href]"}}}(jQuery,window,document),function(e,t,n,i){"use strict";t=void 0!==t&&t.Math==Math?t:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")(),e.fn.dimmer=function(t){var i,o=e(this),a=(new Date).getTime(),r=[],s=arguments[0],l="string"==typeof s,c=[].slice.call(arguments,1);return o.each(function(){var u,d,f,m=e.isPlainObject(t)?e.extend(!0,{},e.fn.dimmer.settings,t):e.extend({},e.fn.dimmer.settings),g=m.selector,v=m.namespace,p=m.className,h=m.error,b="."+v,y="module-"+v,x=o.selector||"",C="ontouchstart"in n.documentElement?"touchstart":"click",w=e(this),k=this,S=w.data(y);f={preinitialize:function(){f.is.dimmer()?(d=w.parent(),u=w):(d=w,u=f.has.dimmer()?m.dimmerName?d.find(g.dimmer).filter("."+m.dimmerName):d.find(g.dimmer):f.create(),f.set.variation())},initialize:function(){f.debug("Initializing dimmer",m),f.bind.events(),f.set.dimmable(),f.instantiate()},instantiate:function(){f.verbose("Storing instance of module",f),S=f,w.data(y,S)},destroy:function(){f.verbose("Destroying previous module",u),f.unbind.events(),f.remove.variation(),d.off(b)},bind:{events:function(){"hover"==m.on?d.on("mouseenter"+b,f.show).on("mouseleave"+b,f.hide):"click"==m.on&&d.on(C+b,f.toggle),f.is.page()&&(f.debug("Setting as a page dimmer",d),f.set.pageDimmer()),f.is.closable()&&(f.verbose("Adding dimmer close event",u),d.on(C+b,g.dimmer,f.event.click))}},unbind:{events:function(){w.removeData(y),d.off(b)}},event:{click:function(t){f.verbose("Determining if event occured on dimmer",t),(0===u.find(t.target).length||e(t.target).is(g.content))&&(f.hide(),t.stopImmediatePropagation())}},addContent:function(t){var n=e(t);f.debug("Add content to dimmer",n),n.parent()[0]!==u[0]&&n.detach().appendTo(u)},create:function(){var t=e(m.template.dimmer());return m.dimmerName&&(f.debug("Creating named dimmer",m.dimmerName),t.addClass(m.dimmerName)),t.appendTo(d),t},show:function(t){t=e.isFunction(t)?t:function(){},f.debug("Showing dimmer",u,m),f.is.dimmed()&&!f.is.animating()||!f.is.enabled()?f.debug("Dimmer is already shown or disabled"):(f.animate.show(t),m.onShow.call(k),m.onChange.call(k))},hide:function(t){t=e.isFunction(t)?t:function(){},f.is.dimmed()||f.is.animating()?(f.debug("Hiding dimmer",u),f.animate.hide(t),m.onHide.call(k),m.onChange.call(k)):f.debug("Dimmer is not visible")},toggle:function(){f.verbose("Toggling dimmer visibility",u),f.is.dimmed()?f.hide():f.show()},animate:{show:function(t){t=e.isFunction(t)?t:function(){},m.useCSS&&void 0!==e.fn.transition&&u.transition("is supported")?("auto"!==m.opacity&&f.set.opacity(),u.transition({animation:m.transition+" in",queue:!1,duration:f.get.duration(),useFailSafe:!0,onStart:function(){f.set.dimmed()},onComplete:function(){f.set.active(),t()}})):(f.verbose("Showing dimmer animation with javascript"),f.set.dimmed(),"auto"==m.opacity&&(m.opacity=.8),u.stop().css({opacity:0,width:"100%",height:"100%"}).fadeTo(f.get.duration(),m.opacity,function(){u.removeAttr("style"),f.set.active(),t()}))},hide:function(t){t=e.isFunction(t)?t:function(){},m.useCSS&&void 0!==e.fn.transition&&u.transition("is supported")?(f.verbose("Hiding dimmer with css"),u.transition({animation:m.transition+" out",queue:!1,duration:f.get.duration(),useFailSafe:!0,onStart:function(){f.remove.dimmed()},onComplete:function(){f.remove.active(),t()}})):(f.verbose("Hiding dimmer with javascript"),f.remove.dimmed(),u.stop().fadeOut(f.get.duration(),function(){f.remove.active(),u.removeAttr("style"),t()}))}},get:{dimmer:function(){return u},duration:function(){return"object"==typeof m.duration?f.is.active()?m.duration.hide:m.duration.show:m.duration}},has:{dimmer:function(){return m.dimmerName?w.find(g.dimmer).filter("."+m.dimmerName).length>0:w.find(g.dimmer).length>0}},is:{active:function(){return u.hasClass(p.active)},animating:function(){return u.is(":animated")||u.hasClass(p.animating)},closable:function(){return"auto"==m.closable?"hover"!=m.on:m.closable},dimmer:function(){return w.hasClass(p.dimmer)},dimmable:function(){return w.hasClass(p.dimmable)},dimmed:function(){return d.hasClass(p.dimmed)},disabled:function(){return d.hasClass(p.disabled)},enabled:function(){return!f.is.disabled()},page:function(){return d.is("body")},pageDimmer:function(){return u.hasClass(p.pageDimmer)}},can:{show:function(){return!u.hasClass(p.disabled)}},set:{opacity:function(e){var t=u.css("background-color"),n=t.split(","),i=n&&3==n.length,o=n&&4==n.length;e=0===m.opacity?0:m.opacity||e,i||o?(n[3]=e+")",t=n.join(",")):t="rgba(0, 0, 0, "+e+")",f.debug("Setting opacity to",e),u.css("background-color",t)},active:function(){u.addClass(p.active)},dimmable:function(){d.addClass(p.dimmable)},dimmed:function(){d.addClass(p.dimmed)},pageDimmer:function(){u.addClass(p.pageDimmer)},disabled:function(){u.addClass(p.disabled)},variation:function(e){(e=e||m.variation)&&u.addClass(e)}},remove:{active:function(){u.removeClass(p.active)},dimmed:function(){d.removeClass(p.dimmed)},disabled:function(){u.removeClass(p.disabled)},variation:function(e){(e=e||m.variation)&&u.removeClass(e)}},setting:function(t,n){if(f.debug("Changing setting",t,n),e.isPlainObject(t))e.extend(!0,m,t);else{if(void 0===n)return m[t];e.isPlainObject(m[t])?e.extend(!0,m[t],n):m[t]=n}},internal:function(t,n){if(e.isPlainObject(t))e.extend(!0,f,t);else{if(void 0===n)return f[t];f[t]=n}},debug:function(){!m.silent&&m.debug&&(m.performance?f.performance.log(arguments):(f.debug=Function.prototype.bind.call(console.info,console,m.name+":"),f.debug.apply(console,arguments)))},verbose:function(){!m.silent&&m.verbose&&m.debug&&(m.performance?f.performance.log(arguments):(f.verbose=Function.prototype.bind.call(console.info,console,m.name+":"),f.verbose.apply(console,arguments)))},error:function(){m.silent||(f.error=Function.prototype.bind.call(console.error,console,m.name+":"),f.error.apply(console,arguments))},performance:{log:function(e){var t,n,i;m.performance&&(t=(new Date).getTime(),i=a||t,n=t-i,a=t,r.push({Name:e[0],Arguments:[].slice.call(e,1)||"",Element:k,"Execution Time":n})),clearTimeout(f.performance.timer),f.performance.timer=setTimeout(f.performance.display,500)},display:function(){var t=m.name+":",n=0;a=!1,clearTimeout(f.performance.timer),e.each(r,function(e,t){n+=t["Execution Time"]}),t+=" "+n+"ms",x&&(t+=" '"+x+"'"),o.length>1&&(t+=" ("+o.length+")"),(void 0!==console.group||void 0!==console.table)&&r.length>0&&(console.groupCollapsed(t),console.table?console.table(r):e.each(r,function(e,t){console.log(t.Name+": "+t["Execution Time"]+"ms")}),console.groupEnd()),r=[]}},invoke:function(t,n,o){var a,r,s,l=S;return n=n||c,o=k||o,"string"==typeof t&&void 0!==l&&(t=t.split(/[\. ]/),a=t.length-1,e.each(t,function(n,i){var o=n!=a?i+t[n+1].charAt(0).toUpperCase()+t[n+1].slice(1):t;if(e.isPlainObject(l[o])&&n!=a)l=l[o];else{if(void 0!==l[o])return r=l[o],!1;if(!e.isPlainObject(l[i])||n==a)return void 0!==l[i]?(r=l[i],!1):(f.error(h.method,t),!1);l=l[i]}})),e.isFunction(r)?s=r.apply(o,n):void 0!==r&&(s=r),e.isArray(i)?i.push(s):void 0!==i?i=[i,s]:void 0!==s&&(i=s),r}},f.preinitialize(),l?(void 0===S&&f.initialize(),f.invoke(s)):(void 0!==S&&S.invoke("destroy"),f.initialize())}),void 0!==i?i:this},e.fn.dimmer.settings={name:"Dimmer",namespace:"dimmer",silent:!1,debug:!1,verbose:!1,performance:!0,dimmerName:!1,variation:!1,closable:"auto",useCSS:!0,transition:"fade",on:!1,opacity:"auto",duration:{show:500,hide:500},onChange:function(){},onShow:function(){},onHide:function(){},error:{method:"The method you called is not defined."},className:{active:"active",animating:"animating",dimmable:"dimmable",dimmed:"dimmed",dimmer:"dimmer",disabled:"disabled",hide:"hide",pageDimmer:"page",show:"show"},selector:{dimmer:"> .ui.dimmer",content:".ui.dimmer > .content, .ui.dimmer > .content > .center"},template:{dimmer:function(){return e("<div />").attr("class","ui dimmer")}}}}(jQuery,window,document),function(e,t,n,i){"use strict";t=void 0!==t&&t.Math==Math?t:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")(),e.fn.dropdown=function(i){var o,a=e(this),r=e(n),s=a.selector||"",l="ontouchstart"in n.documentElement,c=(new Date).getTime(),u=[],d=arguments[0],f="string"==typeof d,m=[].slice.call(arguments,1);return a.each(function(g){var v,p,h,b,y,x,C,w,k=e.isPlainObject(i)?e.extend(!0,{},e.fn.dropdown.settings,i):e.extend({},e.fn.dropdown.settings),S=k.className,T=k.message,A=k.fields,R=k.keys,P=k.metadata,E=k.namespace,F=k.regExp,O=k.selector,D=k.error,q=k.templates,j="."+E,z="module-"+E,I=e(this),M=e(k.context),L=I.find(O.text),V=I.find(O.search),N=I.find(O.sizer),H=I.find(O.input),U=I.find(O.icon),W=I.prev().find(O.text).length>0?I.prev().find(O.text):I.prev(),B=I.children(O.menu),Q=B.find(O.item),X=!1,$=!1,Y=!1,Z=this,K=I.data(z);w={initialize:function(){w.debug("Initializing dropdown",k),w.is.alreadySetup()?w.setup.reference():(w.setup.layout(),w.refreshData(),w.save.defaults(),w.restore.selected(),w.create.id(),w.bind.events(),w.observeChanges(),w.instantiate())},instantiate:function(){w.verbose("Storing instance of dropdown",w),K=w,I.data(z,w)},destroy:function(){w.verbose("Destroying previous dropdown",I),w.remove.tabbable(),I.off(j).removeData(z),B.off(j),r.off(b),w.disconnect.menuObserver(),w.disconnect.selectObserver()},observeChanges:function(){"MutationObserver"in t&&(x=new MutationObserver(w.event.select.mutation),C=new MutationObserver(w.event.menu.mutation),w.debug("Setting up mutation observer",x,C),w.observe.select(),w.observe.menu())},disconnect:{menuObserver:function(){C&&C.disconnect()},selectObserver:function(){x&&x.disconnect()}},observe:{select:function(){w.has.input()&&x.observe(H[0],{childList:!0,subtree:!0})},menu:function(){w.has.menu()&&C.observe(B[0],{childList:!0,subtree:!0})}},create:{id:function(){y=(Math.random().toString(16)+"000000000").substr(2,8),b="."+y,w.verbose("Creating unique id for element",y)},userChoice:function(t){var n,i,o;return!!(t=t||w.get.userValues())&&(t=e.isArray(t)?t:[t],e.each(t,function(t,a){!1===w.get.item(a)&&(o=k.templates.addition(w.add.variables(T.addResult,a)),i=e("<div />").html(o).attr("data-"+P.value,a).attr("data-"+P.text,a).addClass(S.addition).addClass(S.item),k.hideAdditions&&i.addClass(S.hidden),n=void 0===n?i:n.add(i),w.verbose("Creating user choices for value",a,i))}),n)},userLabels:function(t){var n=w.get.userValues();n&&(w.debug("Adding user labels",n),e.each(n,function(e,t){w.verbose("Adding custom user value"),w.add.label(t,t)}))},menu:function(){B=e("<div />").addClass(S.menu).appendTo(I)},sizer:function(){N=e("<span />").addClass(S.sizer).insertAfter(V)}},search:function(e){e=void 0!==e?e:w.get.query(),w.verbose("Searching for query",e),w.has.minCharacters(e)?w.filter(e):w.hide()},select:{firstUnfiltered:function(){w.verbose("Selecting first non-filtered element"),w.remove.selectedItem(),Q.not(O.unselectable).not(O.addition+O.hidden).eq(0).addClass(S.selected)},nextAvailable:function(e){e=e.eq(0);var t=e.nextAll(O.item).not(O.unselectable).eq(0),n=e.prevAll(O.item).not(O.unselectable).eq(0);t.length>0?(w.verbose("Moving selection to",t),t.addClass(S.selected)):(w.verbose("Moving selection to",n),n.addClass(S.selected))}},setup:{api:function(){var e={debug:k.debug,urlData:{value:w.get.value(),query:w.get.query()},on:!1};w.verbose("First request, initializing API"),I.api(e)},layout:function(){I.is("select")&&(w.setup.select(),w.setup.returnedObject()),w.has.menu()||w.create.menu(),w.is.search()&&!w.has.search()&&(w.verbose("Adding search input"),V=e("<input />").addClass(S.search).prop("autocomplete","off").insertBefore(L)),w.is.multiple()&&w.is.searchSelection()&&!w.has.sizer()&&w.create.sizer(),k.allowTab&&w.set.tabbable()},select:function(){var t=w.get.selectValues();w.debug("Dropdown initialized on a select",t),I.is("select")&&(H=I),H.parent(O.dropdown).length>0?(w.debug("UI dropdown already exists. Creating dropdown menu only"),I=H.closest(O.dropdown),w.has.menu()||w.create.menu(),B=I.children(O.menu),w.setup.menu(t)):(w.debug("Creating entire dropdown from select"),I=e("<div />").attr("class",H.attr("class")).addClass(S.selection).addClass(S.dropdown).html(q.dropdown(t)).insertBefore(H),H.hasClass(S.multiple)&&!1===H.prop("multiple")&&(w.error(D.missingMultiple),H.prop("multiple",!0)),H.is("[multiple]")&&w.set.multiple(),H.prop("disabled")&&(w.debug("Disabling dropdown"),I.addClass(S.disabled)),H.removeAttr("class").detach().prependTo(I)),w.refresh()},menu:function(e){B.html(q.menu(e,A)),Q=B.find(O.item)},reference:function(){w.debug("Dropdown behavior was called on select, replacing with closest dropdown"),I=I.parent(O.dropdown),w.refresh(),w.setup.returnedObject(),f&&(K=w,w.invoke(d))},returnedObject:function(){var e=a.slice(0,g),t=a.slice(g+1);a=e.add(I).add(t)}},refresh:function(){w.refreshSelectors(),w.refreshData()},refreshItems:function(){Q=B.find(O.item)},refreshSelectors:function(){w.verbose("Refreshing selector cache"),L=I.find(O.text),V=I.find(O.search),H=I.find(O.input),U=I.find(O.icon),W=I.prev().find(O.text).length>0?I.prev().find(O.text):I.prev(),B=I.children(O.menu),Q=B.find(O.item)},refreshData:function(){w.verbose("Refreshing cached metadata"),Q.removeData(P.text).removeData(P.value)},clearData:function(){w.verbose("Clearing metadata"),Q.removeData(P.text).removeData(P.value),I.removeData(P.defaultText).removeData(P.defaultValue).removeData(P.placeholderText)},toggle:function(){w.verbose("Toggling menu visibility"),w.is.active()?w.hide():w.show()},show:function(t){if(t=e.isFunction(t)?t:function(){},!w.can.show()&&w.is.remote()&&(w.debug("No API results retrieved, searching before show"),w.queryRemote(w.get.query(),w.show)),w.can.show()&&!w.is.active()){if(w.debug("Showing dropdown"),!w.has.message()||w.has.maxSelections()||w.has.allResultsFiltered()||w.remove.message(),w.is.allFiltered())return!0;!1!==k.onShow.call(Z)&&w.animate.show(function(){w.can.click()&&w.bind.intent(),w.has.menuSearch()&&w.focusSearch(),w.set.visible(),t.call(Z)})}},hide:function(t){t=e.isFunction(t)?t:function(){},w.is.active()&&(w.debug("Hiding dropdown"),!1!==k.onHide.call(Z)&&w.animate.hide(function(){w.remove.visible(),t.call(Z)}))},hideOthers:function(){w.verbose("Finding other dropdowns to hide"),a.not(I).has(O.menu+"."+S.visible).dropdown("hide")},hideMenu:function(){w.verbose("Hiding menu  instantaneously"),w.remove.active(),w.remove.visible(),B.transition("hide")},hideSubMenus:function(){var e=B.children(O.item).find(O.menu);w.verbose("Hiding sub menus",e),e.transition("hide")},bind:{events:function(){l&&w.bind.touchEvents(),w.bind.keyboardEvents(),w.bind.inputEvents(),w.bind.mouseEvents()},touchEvents:function(){w.debug("Touch device detected binding additional touch events"),w.is.searchSelection()||w.is.single()&&I.on("touchstart"+j,w.event.test.toggle),B.on("touchstart"+j,O.item,w.event.item.mouseenter)},keyboardEvents:function(){w.verbose("Binding keyboard events"),I.on("keydown"+j,w.event.keydown),w.has.search()&&I.on(w.get.inputEvent()+j,O.search,w.event.input),w.is.multiple()&&r.on("keydown"+b,w.event.document.keydown)},inputEvents:function(){w.verbose("Binding input change events"),I.on("change"+j,O.input,w.event.change)},mouseEvents:function(){w.verbose("Binding mouse events"),w.is.multiple()&&I.on("click"+j,O.label,w.event.label.click).on("click"+j,O.remove,w.event.remove.click),w.is.searchSelection()?(I.on("mousedown"+j,w.event.mousedown).on("mouseup"+j,w.event.mouseup).on("mousedown"+j,O.menu,w.event.menu.mousedown).on("mouseup"+j,O.menu,w.event.menu.mouseup).on("click"+j,O.icon,w.event.icon.click).on("focus"+j,O.search,w.event.search.focus).on("click"+j,O.search,w.event.search.focus).on("blur"+j,O.search,w.event.search.blur).on("click"+j,O.text,w.event.text.focus),w.is.multiple()&&I.on("click"+j,w.event.click)):("click"==k.on?I.on("click"+j,O.icon,w.event.icon.click).on("click"+j,w.event.test.toggle):"hover"==k.on?I.on("mouseenter"+j,w.delay.show).on("mouseleave"+j,w.delay.hide):I.on(k.on+j,w.toggle),I.on("mousedown"+j,w.event.mousedown).on("mouseup"+j,w.event.mouseup).on("focus"+j,w.event.focus),w.has.menuSearch()?I.on("blur"+j,O.search,w.event.search.blur):I.on("blur"+j,w.event.blur)),B.on("mouseenter"+j,O.item,w.event.item.mouseenter).on("mouseleave"+j,O.item,w.event.item.mouseleave).on("click"+j,O.item,w.event.item.click)},intent:function(){w.verbose("Binding hide intent event to document"),l&&r.on("touchstart"+b,w.event.test.touch).on("touchmove"+b,w.event.test.touch),r.on("click"+b,w.event.test.hide)}},unbind:{intent:function(){w.verbose("Removing hide intent event from document"),l&&r.off("touchstart"+b).off("touchmove"+b),r.off("click"+b)}},filter:function(e){var t=void 0!==e?e:w.get.query(),n=function(){w.is.multiple()&&w.filterActive(),w.select.firstUnfiltered(),w.has.allResultsFiltered()?k.onNoResults.call(Z,t)?k.allowAdditions?k.hideAdditions&&(w.verbose("User addition with no menu, setting empty style"),w.set.empty(),w.hideMenu()):(w.verbose("All items filtered, showing message",t),w.add.message(T.noResults)):(w.verbose("All items filtered, hiding dropdown",t),w.hideMenu()):(w.remove.empty(),w.remove.message()),k.allowAdditions&&w.add.userSuggestion(e),w.is.searchSelection()&&w.can.show()&&w.is.focusedOnSearch()&&w.show()};k.useLabels&&w.has.maxSelections()||(k.apiSettings?w.can.useAPI()?w.queryRemote(t,function(){k.filterRemoteData&&w.filterItems(t),n()}):w.error(D.noAPI):(w.filterItems(t),n()))},queryRemote:function(t,n){var i={errorDuration:!1,cache:"local",throttle:k.throttle,urlData:{query:t},onError:function(){w.add.message(T.serverError),n()},onFailure:function(){w.add.message(T.serverError),n()},onSuccess:function(e){w.remove.message(),w.setup.menu({values:e[A.remoteValues]}),n()}};I.api("get request")||w.setup.api(),i=e.extend(!0,{},i,k.apiSettings),I.api("setting",i).api("query")},filterItems:function(t){var n=void 0!==t?t:w.get.query(),i=null,o=w.escape.string(n),a=new RegExp("^"+o,"igm");w.has.query()&&(i=[],w.verbose("Searching for matching values",n),Q.each(function(){var t,o,r=e(this);if("both"==k.match||"text"==k.match){if(t=String(w.get.choiceText(r,!1)),-1!==t.search(a))return i.push(this),!0;if("exact"===k.fullTextSearch&&w.exactSearch(n,t))return i.push(this),!0;if(!0===k.fullTextSearch&&w.fuzzySearch(n,t))return i.push(this),!0}if("both"==k.match||"value"==k.match){if(o=String(w.get.choiceValue(r,t)),-1!==o.search(a))return i.push(this),!0;if("exact"===k.fullTextSearch&&w.exactSearch(n,o))return i.push(this),!0;if(!0===k.fullTextSearch&&w.fuzzySearch(n,o))return i.push(this),!0}})),w.debug("Showing only matched items",n),w.remove.filteredItem(),i&&Q.not(i).addClass(S.filtered)},fuzzySearch:function(e,t){var n=t.length,i=e.length;if(e=e.toLowerCase(),t=t.toLowerCase(),i>n)return!1;if(i===n)return e===t;e:for(var o=0,a=0;o<i;o++){for(var r=e.charCodeAt(o);a<n;)if(t.charCodeAt(a++)===r)continue e;return!1}return!0},exactSearch:function(e,t){return e=e.toLowerCase(),t=t.toLowerCase(),t.indexOf(e)>-1},filterActive:function(){k.useLabels&&Q.filter("."+S.active).addClass(S.filtered)},focusSearch:function(e){w.has.search()&&!w.is.focusedOnSearch()&&(e?(I.off("focus"+j,O.search),V.focus(),I.on("focus"+j,O.search,w.event.search.focus)):V.focus())},forceSelection:function(){
var e=Q.not(S.filtered).filter("."+S.selected).eq(0),t=Q.not(S.filtered).filter("."+S.active).eq(0),n=e.length>0?e:t;if(n.length>0&&!w.is.multiple())return w.debug("Forcing partial selection to selected item",n),void w.event.item.click.call(n,{},!0);k.allowAdditions?(w.set.selected(w.get.query()),w.remove.searchTerm()):w.remove.searchTerm()},event:{change:function(){Y||(w.debug("Input changed, updating selection"),w.set.selected())},focus:function(){k.showOnFocus&&!X&&w.is.hidden()&&!p&&w.show()},blur:function(e){p=n.activeElement===this,X||p||(w.remove.activeLabel(),w.hide())},mousedown:function(){w.is.searchSelection()?h=!0:X=!0},mouseup:function(){w.is.searchSelection()?h=!1:X=!1},click:function(t){e(t.target).is(I)&&(w.is.focusedOnSearch()?w.show():w.focusSearch())},search:{focus:function(){X=!0,w.is.multiple()&&w.remove.activeLabel(),k.showOnFocus&&w.search()},blur:function(e){p=n.activeElement===this,w.is.searchSelection()&&!h&&($||p||(k.forceSelection&&w.forceSelection(),w.hide())),h=!1}},icon:{click:function(e){w.toggle()}},text:{focus:function(e){X=!0,w.focusSearch()}},input:function(e){(w.is.multiple()||w.is.searchSelection())&&w.set.filtered(),clearTimeout(w.timer),w.timer=setTimeout(w.search,k.delay.search)},label:{click:function(t){var n=e(this),i=I.find(O.label),o=i.filter("."+S.active),a=n.nextAll("."+S.active),r=n.prevAll("."+S.active),s=a.length>0?n.nextUntil(a).add(o).add(n):n.prevUntil(r).add(o).add(n);t.shiftKey?(o.removeClass(S.active),s.addClass(S.active)):t.ctrlKey?n.toggleClass(S.active):(o.removeClass(S.active),n.addClass(S.active)),k.onLabelSelect.apply(this,i.filter("."+S.active))}},remove:{click:function(){var t=e(this).parent();t.hasClass(S.active)?w.remove.activeLabels():w.remove.activeLabels(t)}},test:{toggle:function(e){var t=w.is.multiple()?w.show:w.toggle;w.is.bubbledLabelClick(e)||w.is.bubbledIconClick(e)||w.determine.eventOnElement(e,t)&&e.preventDefault()},touch:function(e){w.determine.eventOnElement(e,function(){"touchstart"==e.type?w.timer=setTimeout(function(){w.hide()},k.delay.touch):"touchmove"==e.type&&clearTimeout(w.timer)}),e.stopPropagation()},hide:function(e){w.determine.eventInModule(e,w.hide)}},select:{mutation:function(e){w.debug("<select> modified, recreating menu"),w.setup.select()}},menu:{mutation:function(t){var n=t[0],i=e(n.addedNodes?n.addedNodes[0]:!1),o=e(n.removedNodes?n.removedNodes[0]:!1),a=i.add(o),r=a.is(O.addition)||a.closest(O.addition).length>0,s=a.is(O.message)||a.closest(O.message).length>0;r||s?(w.debug("Updating item selector cache"),w.refreshItems()):(w.debug("Menu modified, updating selector cache"),w.refresh())},mousedown:function(){$=!0},mouseup:function(){$=!1}},item:{mouseenter:function(t){var n=e(t.target),i=e(this),o=i.children(O.menu),a=i.siblings(O.item).children(O.menu),r=o.length>0;!(o.find(n).length>0)&&r&&(clearTimeout(w.itemTimer),w.itemTimer=setTimeout(function(){w.verbose("Showing sub-menu",o),e.each(a,function(){w.animate.hide(!1,e(this))}),w.animate.show(!1,o)},k.delay.show),t.preventDefault())},mouseleave:function(t){var n=e(this).children(O.menu);n.length>0&&(clearTimeout(w.itemTimer),w.itemTimer=setTimeout(function(){w.verbose("Hiding sub-menu",n),w.animate.hide(!1,n)},k.delay.hide))},click:function(t,i){var o=e(this),a=e(t?t.target:""),r=o.find(O.menu),s=w.get.choiceText(o),l=w.get.choiceValue(o,s),c=r.length>0,u=r.find(a).length>0;w.has.menuSearch()&&e(n.activeElement).blur(),u||c&&!k.allowCategorySelection||(w.is.searchSelection()&&(k.allowAdditions&&w.remove.userAddition(),w.remove.searchTerm(),w.is.focusedOnSearch()||1==i||w.focusSearch(!0)),k.useLabels||(w.remove.filteredItem(),w.set.scrollPosition(o)),w.determine.selectAction.call(this,s,l))}},document:{keydown:function(e){var t=e.which;if(w.is.inObject(t,R)){var n=I.find(O.label),i=n.filter("."+S.active),o=(i.data(P.value),n.index(i)),a=n.length,r=i.length>0,s=i.length>1,l=0===o,c=o+1==a,u=w.is.searchSelection(),d=w.is.focusedOnSearch(),f=w.is.focused(),m=d&&0===w.get.caretPosition();if(u&&!r&&!d)return;t==R.leftArrow?!f&&!m||r?r&&(e.shiftKey?w.verbose("Adding previous label to selection"):(w.verbose("Selecting previous label"),n.removeClass(S.active)),l&&!s?i.addClass(S.active):i.prev(O.siblingLabel).addClass(S.active).end(),e.preventDefault()):(w.verbose("Selecting previous label"),n.last().addClass(S.active)):t==R.rightArrow?(f&&!r&&n.first().addClass(S.active),r&&(e.shiftKey?w.verbose("Adding next label to selection"):(w.verbose("Selecting next label"),n.removeClass(S.active)),c?u?d?n.removeClass(S.active):w.focusSearch():s?i.next(O.siblingLabel).addClass(S.active):i.addClass(S.active):i.next(O.siblingLabel).addClass(S.active),e.preventDefault())):t==R.deleteKey||t==R.backspace?r?(w.verbose("Removing active labels"),c&&u&&!d&&w.focusSearch(),i.last().next(O.siblingLabel).addClass(S.active),w.remove.activeLabels(i),e.preventDefault()):m&&!r&&t==R.backspace&&(w.verbose("Removing last label on input backspace"),i=n.last().addClass(S.active),w.remove.activeLabels(i)):i.removeClass(S.active)}}},keydown:function(e){var t=e.which;if(w.is.inObject(t,R)){var n,i=Q.not(O.unselectable).filter("."+S.selected).eq(0),o=B.children("."+S.active).eq(0),a=i.length>0?i:o,r=a.length>0?a.siblings(":not(."+S.filtered+")").addBack():B.children(":not(."+S.filtered+")"),s=a.children(O.menu),l=a.closest(O.menu),c=l.hasClass(S.visible)||l.hasClass(S.animating)||l.parent(O.menu).length>0,u=s.length>0,d=a.length>0,f=a.not(O.unselectable).length>0,m=t==R.delimiter&&k.allowAdditions&&w.is.multiple(),g=k.allowAdditions&&k.hideAdditions&&(t==R.enter||m)&&f;if(g&&(w.verbose("Selecting item from keyboard shortcut",a),w.event.item.click.call(a,e),w.is.searchSelection()&&w.remove.searchTerm()),w.is.visible()){if((t==R.enter||m)&&(t==R.enter&&d&&u&&!k.allowCategorySelection?(w.verbose("Pressed enter on unselectable category, opening sub menu"),t=R.rightArrow):f&&(w.verbose("Selecting item from keyboard shortcut",a),w.event.item.click.call(a,e),w.is.searchSelection()&&w.remove.searchTerm()),e.preventDefault()),d&&(t==R.leftArrow&&l[0]!==B[0]&&(w.verbose("Left key pressed, closing sub-menu"),w.animate.hide(!1,l),a.removeClass(S.selected),l.closest(O.item).addClass(S.selected),e.preventDefault()),t==R.rightArrow&&u&&(w.verbose("Right key pressed, opening sub-menu"),w.animate.show(!1,s),a.removeClass(S.selected),s.find(O.item).eq(0).addClass(S.selected),e.preventDefault())),t==R.upArrow){if(n=d&&c?a.prevAll(O.item+":not("+O.unselectable+")").eq(0):Q.eq(0),r.index(n)<0)return w.verbose("Up key pressed but reached top of current menu"),void e.preventDefault();w.verbose("Up key pressed, changing active item"),a.removeClass(S.selected),n.addClass(S.selected),w.set.scrollPosition(n),k.selectOnKeydown&&w.is.single()&&w.set.selectedItem(n),e.preventDefault()}if(t==R.downArrow){if(n=d&&c?n=a.nextAll(O.item+":not("+O.unselectable+")").eq(0):Q.eq(0),0===n.length)return w.verbose("Down key pressed but reached bottom of current menu"),void e.preventDefault();w.verbose("Down key pressed, changing active item"),Q.removeClass(S.selected),n.addClass(S.selected),w.set.scrollPosition(n),k.selectOnKeydown&&w.is.single()&&w.set.selectedItem(n),e.preventDefault()}t==R.pageUp&&(w.scrollPage("up"),e.preventDefault()),t==R.pageDown&&(w.scrollPage("down"),e.preventDefault()),t==R.escape&&(w.verbose("Escape key pressed, closing dropdown"),w.hide())}else m&&e.preventDefault(),t!=R.downArrow||w.is.visible()||(w.verbose("Down key pressed, showing dropdown"),w.select.firstUnfiltered(),w.show(),e.preventDefault())}else w.has.search()||w.set.selectedLetter(String.fromCharCode(t))}},trigger:{change:function(){var e=n.createEvent("HTMLEvents"),t=H[0];t&&(w.verbose("Triggering native change event"),e.initEvent("change",!0,!1),t.dispatchEvent(e))}},determine:{selectAction:function(t,n){w.verbose("Determining action",k.action),e.isFunction(w.action[k.action])?(w.verbose("Triggering preset action",k.action,t,n),w.action[k.action].call(Z,t,n,this)):e.isFunction(k.action)?(w.verbose("Triggering user action",k.action,t,n),k.action.call(Z,t,n,this)):w.error(D.action,k.action)},eventInModule:function(t,i){var o=e(t.target),a=o.closest(n.documentElement).length>0,r=o.closest(I).length>0;return i=e.isFunction(i)?i:function(){},a&&!r?(w.verbose("Triggering event",i),i(),!0):(w.verbose("Event occurred in dropdown, canceling callback"),!1)},eventOnElement:function(t,i){var o=e(t.target),a=o.closest(O.siblingLabel),r=n.body.contains(t.target),s=0===I.find(a).length,l=0===o.closest(B).length;return i=e.isFunction(i)?i:function(){},r&&s&&l?(w.verbose("Triggering event",i),i(),!0):(w.verbose("Event occurred in dropdown menu, canceling callback"),!1)}},action:{nothing:function(){},activate:function(t,n,i){if(n=void 0!==n?n:t,w.can.activate(e(i))){if(w.set.selected(n,e(i)),w.is.multiple()&&!w.is.allFiltered())return;w.hideAndClear()}},select:function(t,n,i){if(n=void 0!==n?n:t,w.can.activate(e(i))){if(w.set.value(n,e(i)),w.is.multiple()&&!w.is.allFiltered())return;w.hideAndClear()}},combo:function(t,n,i){n=void 0!==n?n:t,w.set.selected(n,e(i)),w.hideAndClear()},hide:function(e,t,n){w.set.value(t,e),w.hideAndClear()}},get:{id:function(){return y},defaultText:function(){return I.data(P.defaultText)},defaultValue:function(){return I.data(P.defaultValue)},placeholderText:function(){return I.data(P.placeholderText)||""},text:function(){return L.text()},query:function(){return e.trim(V.val())},searchWidth:function(e){return e=void 0!==e?e:V.val(),N.text(e),Math.ceil(N.width()+1)},selectionCount:function(){var t=w.get.values();return w.is.multiple()?e.isArray(t)?t.length:0:""!==w.get.value()?1:0},transition:function(e){return"auto"==k.transition?w.is.upward(e)?"slide up":"slide down":k.transition},userValues:function(){var t=w.get.values();return!!t&&(t=e.isArray(t)?t:[t],e.grep(t,function(e){return!1===w.get.item(e)}))},uniqueArray:function(t){return e.grep(t,function(n,i){return e.inArray(n,t)===i})},caretPosition:function(){var e,t,i=V.get(0);return"selectionStart"in i?i.selectionStart:n.selection?(i.focus(),e=n.selection.createRange(),t=e.text.length,e.moveStart("character",-i.value.length),e.text.length-t):void 0},value:function(){var t=H.length>0?H.val():I.data(P.value),n=e.isArray(t)&&1===t.length&&""===t[0];return void 0===t||n?"":t},values:function(){var e=w.get.value();return""===e?"":!w.has.selectInput()&&w.is.multiple()?"string"==typeof e?e.split(k.delimiter):"":e},remoteValues:function(){var t=w.get.values(),n=!1;return t&&("string"==typeof t&&(t=[t]),e.each(t,function(e,t){var i=w.read.remoteData(t);w.verbose("Restoring value from session data",i,t),i&&(n||(n={}),n[t]=i)})),n},choiceText:function(t,n){if(n=void 0!==n?n:k.preserveHTML,t)return t.find(O.menu).length>0&&(w.verbose("Retrieving text of element with sub-menu"),t=t.clone(),t.find(O.menu).remove(),t.find(O.menuIcon).remove()),void 0!==t.data(P.text)?t.data(P.text):n?e.trim(t.html()):e.trim(t.text())},choiceValue:function(t,n){return n=n||w.get.choiceText(t),!!t&&(void 0!==t.data(P.value)?String(t.data(P.value)):"string"==typeof n?e.trim(n.toLowerCase()):String(n))},inputEvent:function(){var e=V[0];return!!e&&(void 0!==e.oninput?"input":void 0!==e.onpropertychange?"propertychange":"keyup")},selectValues:function(){var t={};return t.values=[],I.find("option").each(function(){var n=e(this),i=n.html(),o=n.attr("disabled"),a=void 0!==n.attr("value")?n.attr("value"):i;"auto"===k.placeholder&&""===a?t.placeholder=i:t.values.push({name:i,value:a,disabled:o})}),k.placeholder&&"auto"!==k.placeholder&&(w.debug("Setting placeholder value to",k.placeholder),t.placeholder=k.placeholder),k.sortSelect?(t.values.sort(function(e,t){return e.name>t.name?1:-1}),w.debug("Retrieved and sorted values from select",t)):w.debug("Retrieved values from select",t),t},activeItem:function(){return Q.filter("."+S.active)},selectedItem:function(){var e=Q.not(O.unselectable).filter("."+S.selected);return e.length>0?e:Q.eq(0)},itemWithAdditions:function(e){var t=w.get.item(e),n=w.create.userChoice(e);return n&&n.length>0&&(t=t.length>0?t.add(n):n),t},item:function(t,n){var i,o,a=!1;return t=void 0!==t?t:void 0!==w.get.values()?w.get.values():w.get.text(),i=o?t.length>0:void 0!==t&&null!==t,o=w.is.multiple()&&e.isArray(t),n=""===t||0===t||(n||!1),i&&Q.each(function(){var i=e(this),r=w.get.choiceText(i),s=w.get.choiceValue(i,r);if(null!==s&&void 0!==s)if(o)-1===e.inArray(String(s),t)&&-1===e.inArray(r,t)||(a=a?a.add(i):i);else if(n){if(w.verbose("Ambiguous dropdown value using strict type check",i,t),s===t||r===t)return a=i,!0}else if(String(s)==String(t)||r==t)return w.verbose("Found select item by value",s,t),a=i,!0}),a}},check:{maxSelections:function(e){return!k.maxSelections||(e=void 0!==e?e:w.get.selectionCount(),e>=k.maxSelections?(w.debug("Maximum selection count reached"),k.useLabels&&(Q.addClass(S.filtered),w.add.message(T.maxSelections)),!0):(w.verbose("No longer at maximum selection count"),w.remove.message(),w.remove.filteredItem(),w.is.searchSelection()&&w.filterItems(),!1))}},restore:{defaults:function(){w.clear(),w.restore.defaultText(),w.restore.defaultValue()},defaultText:function(){var e=w.get.defaultText();e===w.get.placeholderText?(w.debug("Restoring default placeholder text",e),w.set.placeholderText(e)):(w.debug("Restoring default text",e),w.set.text(e))},placeholderText:function(){w.set.placeholderText()},defaultValue:function(){var e=w.get.defaultValue();void 0!==e&&(w.debug("Restoring default value",e),""!==e?(w.set.value(e),w.set.selected()):(w.remove.activeItem(),w.remove.selectedItem()))},labels:function(){k.allowAdditions&&(k.useLabels||(w.error(D.labels),k.useLabels=!0),w.debug("Restoring selected values"),w.create.userLabels()),w.check.maxSelections()},selected:function(){w.restore.values(),w.is.multiple()?(w.debug("Restoring previously selected values and labels"),w.restore.labels()):w.debug("Restoring previously selected values")},values:function(){w.set.initialLoad(),k.apiSettings&&k.saveRemoteData&&w.get.remoteValues()?w.restore.remoteValues():w.set.selected(),w.remove.initialLoad()},remoteValues:function(){var t=w.get.remoteValues();w.debug("Recreating selected from session data",t),t&&(w.is.single()?e.each(t,function(e,t){w.set.text(t)}):e.each(t,function(e,t){w.add.label(e,t)}))}},read:{remoteData:function(e){var n;return void 0===t.Storage?void w.error(D.noStorage):void 0!==(n=sessionStorage.getItem(e))&&n}},save:{defaults:function(){w.save.defaultText(),w.save.placeholderText(),w.save.defaultValue()},defaultValue:function(){var e=w.get.value();w.verbose("Saving default value as",e),I.data(P.defaultValue,e)},defaultText:function(){var e=w.get.text();w.verbose("Saving default text as",e),I.data(P.defaultText,e)},placeholderText:function(){var e;!1!==k.placeholder&&L.hasClass(S.placeholder)&&(e=w.get.text(),w.verbose("Saving placeholder text as",e),I.data(P.placeholderText,e))},remoteData:function(e,n){if(void 0===t.Storage)return void w.error(D.noStorage);w.verbose("Saving remote data to session storage",n,e),sessionStorage.setItem(n,e)}},clear:function(){w.is.multiple()&&k.useLabels?w.remove.labels():(w.remove.activeItem(),w.remove.selectedItem()),w.set.placeholderText(),w.clearValue()},clearValue:function(){w.set.value("")},scrollPage:function(e,t){var n,i,o,a=t||w.get.selectedItem(),r=a.closest(O.menu),s=r.outerHeight(),l=r.scrollTop(),c=Q.eq(0).outerHeight(),u=Math.floor(s/c),d=(r.prop("scrollHeight"),"up"==e?l-c*u:l+c*u),f=Q.not(O.unselectable);o="up"==e?f.index(a)-u:f.index(a)+u,n="up"==e?o>=0:o<f.length,i=n?f.eq(o):"up"==e?f.first():f.last(),i.length>0&&(w.debug("Scrolling page",e,i),a.removeClass(S.selected),i.addClass(S.selected),k.selectOnKeydown&&w.is.single()&&w.set.selectedItem(i),r.scrollTop(d))},set:{filtered:function(){var e=w.is.multiple(),t=w.is.searchSelection(),n=e&&t,i=t?w.get.query():"",o="string"==typeof i&&i.length>0,a=w.get.searchWidth(),r=""!==i;e&&o&&(w.verbose("Adjusting input width",a,k.glyphWidth),V.css("width",a)),o||n&&r?(w.verbose("Hiding placeholder text"),L.addClass(S.filtered)):(!e||n&&!r)&&(w.verbose("Showing placeholder text"),L.removeClass(S.filtered))},empty:function(){I.addClass(S.empty)},loading:function(){I.addClass(S.loading)},placeholderText:function(e){e=e||w.get.placeholderText(),w.debug("Setting placeholder text",e),w.set.text(e),L.addClass(S.placeholder)},tabbable:function(){w.is.searchSelection()?(w.debug("Added tabindex to searchable dropdown"),V.val("").attr("tabindex",0),B.attr("tabindex",-1)):(w.debug("Added tabindex to dropdown"),void 0===I.attr("tabindex")&&(I.attr("tabindex",0),B.attr("tabindex",-1)))},initialLoad:function(){w.verbose("Setting initial load"),v=!0},activeItem:function(e){k.allowAdditions&&e.filter(O.addition).length>0?e.addClass(S.filtered):e.addClass(S.active)},partialSearch:function(e){var t=w.get.query().length;V.val(e.substr(0,t))},scrollPosition:function(e,t){var n,i,o,a,r,s,l,c,u;e=e||w.get.selectedItem(),n=e.closest(O.menu),i=e&&e.length>0,t=void 0!==t&&t,e&&n.length>0&&i&&(a=e.position().top,n.addClass(S.loading),s=n.scrollTop(),r=n.offset().top,a=e.offset().top,o=s-r+a,t||(l=n.height(),u=s+l<o+5,c=o-5<s),w.debug("Scrolling to active item",o),(t||c||u)&&n.scrollTop(o),n.removeClass(S.loading))},text:function(e){"select"!==k.action&&("combo"==k.action?(w.debug("Changing combo button text",e,W),k.preserveHTML?W.html(e):W.text(e)):(e!==w.get.placeholderText()&&L.removeClass(S.placeholder),w.debug("Changing text",e,L),L.removeClass(S.filtered),k.preserveHTML?L.html(e):L.text(e)))},selectedItem:function(e){var t=w.get.choiceValue(e),n=w.get.choiceText(e,!1),i=w.get.choiceText(e,!0);w.debug("Setting user selection to item",e),w.remove.activeItem(),w.set.partialSearch(n),w.set.activeItem(e),w.set.selected(t,e),w.set.text(i)},selectedLetter:function(t){var n,i=Q.filter("."+S.selected),o=i.length>0&&w.has.firstLetter(i,t),a=!1;o&&(n=i.nextAll(Q).eq(0),w.has.firstLetter(n,t)&&(a=n)),a||Q.each(function(){if(w.has.firstLetter(e(this),t))return a=e(this),!1}),a&&(w.verbose("Scrolling to next value with letter",t),w.set.scrollPosition(a),i.removeClass(S.selected),a.addClass(S.selected),k.selectOnKeydown&&w.is.single()&&w.set.selectedItem(a))},direction:function(e){"auto"==k.direction?w.is.onScreen(e)?w.remove.upward(e):w.set.upward(e):"upward"==k.direction&&w.set.upward(e)},upward:function(e){(e||I).addClass(S.upward)},value:function(e,t,n){var i=w.escape.value(e),o=H.length>0,a=(w.has.value(e),w.get.values()),r=void 0!==e?String(e):e;if(o){if(!k.allowReselection&&r==a&&(w.verbose("Skipping value update already same value",e,a),!w.is.initialLoad()))return;w.is.single()&&w.has.selectInput()&&w.can.extendSelect()&&(w.debug("Adding user option",e),w.add.optionValue(e)),w.debug("Updating input value",i,a),Y=!0,H.val(i),!1===k.fireOnInit&&w.is.initialLoad()?w.debug("Input native change event ignored on initial load"):w.trigger.change(),Y=!1}else w.verbose("Storing value in metadata",i,H),i!==a&&I.data(P.value,r);!1===k.fireOnInit&&w.is.initialLoad()?w.verbose("No callback on initial load",k.onChange):k.onChange.call(Z,e,t,n)},active:function(){I.addClass(S.active)},multiple:function(){I.addClass(S.multiple)},visible:function(){I.addClass(S.visible)},exactly:function(e,t){w.debug("Setting selected to exact values"),w.clear(),w.set.selected(e,t)},selected:function(t,n){var i=w.is.multiple();(n=k.allowAdditions?n||w.get.itemWithAdditions(t):n||w.get.item(t))&&(w.debug("Setting selected menu item to",n),w.is.multiple()&&w.remove.searchWidth(),w.is.single()?(w.remove.activeItem(),w.remove.selectedItem()):k.useLabels&&w.remove.selectedItem(),n.each(function(){var t=e(this),o=w.get.choiceText(t),a=w.get.choiceValue(t,o),r=t.hasClass(S.filtered),s=t.hasClass(S.active),l=t.hasClass(S.addition),c=i&&1==n.length;i?!s||l?(k.apiSettings&&k.saveRemoteData&&w.save.remoteData(o,a),k.useLabels?(w.add.value(a,o,t),w.add.label(a,o,c),w.set.activeItem(t),w.filterActive(),w.select.nextAvailable(n)):(w.add.value(a,o,t),w.set.text(w.add.variables(T.count)),w.set.activeItem(t))):r||(w.debug("Selected active value, removing label"),w.remove.selected(a)):(k.apiSettings&&k.saveRemoteData&&w.save.remoteData(o,a),w.set.text(o),w.set.value(a,o,t),t.addClass(S.active).addClass(S.selected))}))}},add:{label:function(t,n,i){var o,a=w.is.searchSelection()?V:L,r=w.escape.value(t);if(o=e("<a />").addClass(S.label).attr("data-"+P.value,r).html(q.label(r,n)),o=k.onLabelCreate.call(o,r,n),w.has.label(t))return void w.debug("Label already exists, skipping",r);k.label.variation&&o.addClass(k.label.variation),!0===i?(w.debug("Animating in label",o),o.addClass(S.hidden).insertBefore(a).transition(k.label.transition,k.label.duration)):(w.debug("Adding selection label",o),o.insertBefore(a))},message:function(t){var n=B.children(O.message),i=k.templates.message(w.add.variables(t));n.length>0?n.html(i):n=e("<div/>").html(i).addClass(S.message).appendTo(B)},optionValue:function(t){var n=w.escape.value(t);H.find('option[value="'+w.escape.string(n)+'"]').length>0||(w.disconnect.selectObserver(),w.is.single()&&(w.verbose("Removing previous user addition"),H.find("option."+S.addition).remove()),e("<option/>").prop("value",n).addClass(S.addition).html(t).appendTo(H),w.verbose("Adding user addition as an <option>",t),w.observe.select())},userSuggestion:function(e){var t,n=B.children(O.addition),i=w.get.item(e),o=i&&i.not(O.addition).length,a=n.length>0;if(!k.useLabels||!w.has.maxSelections()){if(""===e||o)return void n.remove();a?(n.data(P.value,e).data(P.text,e).attr("data-"+P.value,e).attr("data-"+P.text,e).removeClass(S.filtered),k.hideAdditions||(t=k.templates.addition(w.add.variables(T.addResult,e)),n.html(t)),w.verbose("Replacing user suggestion with new value",n)):(n=w.create.userChoice(e),n.prependTo(B),w.verbose("Adding item choice to menu corresponding with user choice addition",n)),k.hideAdditions&&!w.is.allFiltered()||n.addClass(S.selected).siblings().removeClass(S.selected),w.refreshItems()}},variables:function(e,t){var n,i,o=-1!==e.search("{count}"),a=-1!==e.search("{maxCount}"),r=-1!==e.search("{term}");return w.verbose("Adding templated variables to message",e),o&&(n=w.get.selectionCount(),e=e.replace("{count}",n)),a&&(n=w.get.selectionCount(),e=e.replace("{maxCount}",k.maxSelections)),r&&(i=t||w.get.query(),e=e.replace("{term}",i)),e},value:function(t,n,i){var o,a=w.get.values();if(""===t)return void w.debug("Cannot select blank values from multiselect");e.isArray(a)?(o=a.concat([t]),o=w.get.uniqueArray(o)):o=[t],w.has.selectInput()?w.can.extendSelect()&&(w.debug("Adding value to select",t,o,H),w.add.optionValue(t)):(o=o.join(k.delimiter),w.debug("Setting hidden input to delimited value",o,H)),!1===k.fireOnInit&&w.is.initialLoad()?w.verbose("Skipping onadd callback on initial load",k.onAdd):k.onAdd.call(Z,t,n,i),w.set.value(o,t,n,i),w.check.maxSelections()}},remove:{active:function(){I.removeClass(S.active)},activeLabel:function(){I.find(O.label).removeClass(S.active)},empty:function(){I.removeClass(S.empty)},loading:function(){I.removeClass(S.loading)},initialLoad:function(){v=!1},upward:function(e){(e||I).removeClass(S.upward)},visible:function(){I.removeClass(S.visible)},activeItem:function(){Q.removeClass(S.active)},filteredItem:function(){k.useLabels&&w.has.maxSelections()||(k.useLabels&&w.is.multiple()?Q.not("."+S.active).removeClass(S.filtered):Q.removeClass(S.filtered),w.remove.empty())},optionValue:function(e){var t=w.escape.value(e),n=H.find('option[value="'+w.escape.string(t)+'"]');n.length>0&&n.hasClass(S.addition)&&(x&&(x.disconnect(),w.verbose("Temporarily disconnecting mutation observer")),n.remove(),w.verbose("Removing user addition as an <option>",t),x&&x.observe(H[0],{childList:!0,subtree:!0}))},message:function(){B.children(O.message).remove()},searchWidth:function(){V.css("width","")},searchTerm:function(){w.verbose("Cleared search term"),V.val(""),w.set.filtered()},userAddition:function(){Q.filter(O.addition).remove()},selected:function(t,n){if(!(n=k.allowAdditions?n||w.get.itemWithAdditions(t):n||w.get.item(t)))return!1;n.each(function(){var t=e(this),n=w.get.choiceText(t),i=w.get.choiceValue(t,n);w.is.multiple()?k.useLabels?(w.remove.value(i,n,t),w.remove.label(i)):(w.remove.value(i,n,t),0===w.get.selectionCount()?w.set.placeholderText():w.set.text(w.add.variables(T.count))):w.remove.value(i,n,t),t.removeClass(S.filtered).removeClass(S.active),k.useLabels&&t.removeClass(S.selected)})},selectedItem:function(){Q.removeClass(S.selected)},value:function(e,t,n){var i,o=w.get.values();w.has.selectInput()?(w.verbose("Input is <select> removing selected option",e),i=w.remove.arrayValue(e,o),w.remove.optionValue(e)):(w.verbose("Removing from delimited values",e),i=w.remove.arrayValue(e,o),i=i.join(k.delimiter)),!1===k.fireOnInit&&w.is.initialLoad()?w.verbose("No callback on initial load",k.onRemove):k.onRemove.call(Z,e,t,n),w.set.value(i,t,n),w.check.maxSelections()},arrayValue:function(t,n){return e.isArray(n)||(n=[n]),n=e.grep(n,function(e){return t!=e}),w.verbose("Removed value from delimited string",t,n),n},label:function(e,t){var n=I.find(O.label),i=n.filter("[data-"+P.value+'="'+w.escape.string(e)+'"]');w.verbose("Removing label",i),i.remove()},activeLabels:function(e){e=e||I.find(O.label).filter("."+S.active),w.verbose("Removing active label selections",e),w.remove.labels(e)},labels:function(t){t=t||I.find(O.label),w.verbose("Removing labels",t),t.each(function(){var t=e(this),n=t.data(P.value),i=void 0!==n?String(n):n,o=w.is.userValue(i);if(!1===k.onLabelRemove.call(t,n))return void w.debug("Label remove callback cancelled removal");w.remove.message(),o?(w.remove.value(i),w.remove.label(i)):w.remove.selected(i)})},tabbable:function(){w.is.searchSelection()?(w.debug("Searchable dropdown initialized"),V.removeAttr("tabindex"),B.removeAttr("tabindex")):(w.debug("Simple selection dropdown initialized"),I.removeAttr("tabindex"),B.removeAttr("tabindex"))}},has:{menuSearch:function(){return w.has.search()&&V.closest(B).length>0},search:function(){return V.length>0},sizer:function(){return N.length>0},selectInput:function(){return H.is("select")},minCharacters:function(e){return!k.minCharacters||(e=void 0!==e?String(e):String(w.get.query()),e.length>=k.minCharacters)},firstLetter:function(e,t){var n,i;return!(!e||0===e.length||"string"!=typeof t)&&(n=w.get.choiceText(e,!1),t=t.toLowerCase(),i=String(n).charAt(0).toLowerCase(),t==i)},input:function(){return H.length>0},items:function(){return Q.length>0},menu:function(){return B.length>0},message:function(){return 0!==B.children(O.message).length},label:function(e){var t=w.escape.value(e);return I.find(O.label).filter("[data-"+P.value+'="'+w.escape.string(t)+'"]').length>0},maxSelections:function(){return k.maxSelections&&w.get.selectionCount()>=k.maxSelections},allResultsFiltered:function(){var e=Q.not(O.addition);return e.filter(O.unselectable).length===e.length},userSuggestion:function(){return B.children(O.addition).length>0},query:function(){return""!==w.get.query()},value:function(t){var n=w.get.values();return!!(e.isArray(n)?n&&-1!==e.inArray(t,n):n==t)}},is:{active:function(){return I.hasClass(S.active)},bubbledLabelClick:function(t){return e(t.target).is("select, input")&&I.closest("label").length>0},bubbledIconClick:function(t){return e(t.target).closest(U).length>0},alreadySetup:function(){return I.is("select")&&I.parent(O.dropdown).length>0&&0===I.prev().length},animating:function(e){return e?e.transition&&e.transition("is animating"):B.transition&&B.transition("is animating")},disabled:function(){return I.hasClass(S.disabled)},focused:function(){return n.activeElement===I[0]},focusedOnSearch:function(){return n.activeElement===V[0]},allFiltered:function(){return(w.is.multiple()||w.has.search())&&!(0==k.hideAdditions&&w.has.userSuggestion())&&!w.has.message()&&w.has.allResultsFiltered()},hidden:function(e){return!w.is.visible(e)},initialLoad:function(){return v},onScreen:function(e){var t,n=e||B,i=!0,o={};return n.addClass(S.loading),t={context:{scrollTop:M.scrollTop(),height:M.outerHeight()},menu:{offset:n.offset(),height:n.outerHeight()}},w.is.verticallyScrollableContext()&&(t.menu.offset.top+=t.context.scrollTop),o={above:t.context.scrollTop<=t.menu.offset.top-t.menu.height,below:t.context.scrollTop+t.context.height>=t.menu.offset.top+t.menu.height},o.below?(w.verbose("Dropdown can fit in context downward",o),i=!0):o.below||o.above?(w.verbose("Dropdown cannot fit below, opening upward",o),i=!1):(w.verbose("Dropdown cannot fit in either direction, favoring downward",o),i=!0),n.removeClass(S.loading),i},inObject:function(t,n){var i=!1;return e.each(n,function(e,n){if(n==t)return i=!0,!0}),i},multiple:function(){return I.hasClass(S.multiple)},remote:function(){return k.apiSettings&&w.can.useAPI()},single:function(){return!w.is.multiple()},selectMutation:function(t){var n=!1;return e.each(t,function(t,i){if(i.target&&e(i.target).is("select"))return n=!0,!0}),n},search:function(){return I.hasClass(S.search)},searchSelection:function(){return w.has.search()&&1===V.parent(O.dropdown).length},selection:function(){return I.hasClass(S.selection)},userValue:function(t){return-1!==e.inArray(t,w.get.userValues())},upward:function(e){return(e||I).hasClass(S.upward)},visible:function(e){return e?e.hasClass(S.visible):B.hasClass(S.visible)},verticallyScrollableContext:function(){var e=M.get(0)!==t&&M.css("overflow-y");return"auto"==e||"scroll"==e}},can:{activate:function(e){return!!k.useLabels||(!w.has.maxSelections()||!(!w.has.maxSelections()||!e.hasClass(S.active)))},click:function(){return l||"click"==k.on},extendSelect:function(){return k.allowAdditions||k.apiSettings},show:function(){return!w.is.disabled()&&(w.has.items()||w.has.message())},useAPI:function(){return void 0!==e.fn.api}},animate:{show:function(t,n){var i,o=n||B,a=n?function(){}:function(){w.hideSubMenus(),w.hideOthers(),w.set.active()};t=e.isFunction(t)?t:function(){},w.verbose("Doing menu show animation",o),w.set.direction(n),i=w.get.transition(n),w.is.selection()&&w.set.scrollPosition(w.get.selectedItem(),!0),(w.is.hidden(o)||w.is.animating(o))&&("none"==i?(a(),o.transition("show"),t.call(Z)):void 0!==e.fn.transition&&I.transition("is supported")?o.transition({animation:i+" in",debug:k.debug,verbose:k.verbose,duration:k.duration,queue:!0,onStart:a,onComplete:function(){t.call(Z)}}):w.error(D.noTransition,i))},hide:function(t,n){var i=n||B,o=(n?k.duration:k.duration,n?function(){}:function(){w.can.click()&&w.unbind.intent(),w.remove.active()}),a=w.get.transition(n);t=e.isFunction(t)?t:function(){},(w.is.visible(i)||w.is.animating(i))&&(w.verbose("Doing menu hide animation",i),"none"==a?(o(),i.transition("hide"),t.call(Z)):void 0!==e.fn.transition&&I.transition("is supported")?i.transition({animation:a+" out",duration:k.duration,debug:k.debug,verbose:k.verbose,queue:!0,onStart:o,onComplete:function(){"auto"==k.direction&&w.remove.upward(n),t.call(Z)}}):w.error(D.transition))}},hideAndClear:function(){w.remove.searchTerm(),w.has.maxSelections()||(w.has.search()?w.hide(function(){w.remove.filteredItem()}):w.hide())},delay:{show:function(){w.verbose("Delaying show event to ensure user intent"),clearTimeout(w.timer),w.timer=setTimeout(w.show,k.delay.show)},hide:function(){w.verbose("Delaying hide event to ensure user intent"),clearTimeout(w.timer),w.timer=setTimeout(w.hide,k.delay.hide)}},escape:{value:function(t){var n=e.isArray(t),i="string"==typeof t,o=!i&&!n,a=i&&-1!==t.search(F.quote),r=[];return o||!a?t:(w.debug("Encoding quote values for use in select",t),n?(e.each(t,function(e,t){r.push(t.replace(F.quote,"&quot;"))}),r):t.replace(F.quote,"&quot;"))},string:function(e){return e=String(e),e.replace(F.escape,"\\$&")}},setting:function(t,n){if(w.debug("Changing setting",t,n),e.isPlainObject(t))e.extend(!0,k,t);else{if(void 0===n)return k[t];e.isPlainObject(k[t])?e.extend(!0,k[t],n):k[t]=n}},internal:function(t,n){if(e.isPlainObject(t))e.extend(!0,w,t);else{if(void 0===n)return w[t];w[t]=n}},
debug:function(){!k.silent&&k.debug&&(k.performance?w.performance.log(arguments):(w.debug=Function.prototype.bind.call(console.info,console,k.name+":"),w.debug.apply(console,arguments)))},verbose:function(){!k.silent&&k.verbose&&k.debug&&(k.performance?w.performance.log(arguments):(w.verbose=Function.prototype.bind.call(console.info,console,k.name+":"),w.verbose.apply(console,arguments)))},error:function(){k.silent||(w.error=Function.prototype.bind.call(console.error,console,k.name+":"),w.error.apply(console,arguments))},performance:{log:function(e){var t,n,i;k.performance&&(t=(new Date).getTime(),i=c||t,n=t-i,c=t,u.push({Name:e[0],Arguments:[].slice.call(e,1)||"",Element:Z,"Execution Time":n})),clearTimeout(w.performance.timer),w.performance.timer=setTimeout(w.performance.display,500)},display:function(){var t=k.name+":",n=0;c=!1,clearTimeout(w.performance.timer),e.each(u,function(e,t){n+=t["Execution Time"]}),t+=" "+n+"ms",s&&(t+=" '"+s+"'"),(void 0!==console.group||void 0!==console.table)&&u.length>0&&(console.groupCollapsed(t),console.table?console.table(u):e.each(u,function(e,t){console.log(t.Name+": "+t["Execution Time"]+"ms")}),console.groupEnd()),u=[]}},invoke:function(t,n,i){var a,r,s,l=K;return n=n||m,i=Z||i,"string"==typeof t&&void 0!==l&&(t=t.split(/[\. ]/),a=t.length-1,e.each(t,function(n,i){var o=n!=a?i+t[n+1].charAt(0).toUpperCase()+t[n+1].slice(1):t;if(e.isPlainObject(l[o])&&n!=a)l=l[o];else{if(void 0!==l[o])return r=l[o],!1;if(!e.isPlainObject(l[i])||n==a)return void 0!==l[i]?(r=l[i],!1):(w.error(D.method,t),!1);l=l[i]}})),e.isFunction(r)?s=r.apply(i,n):void 0!==r&&(s=r),e.isArray(o)?o.push(s):void 0!==o?o=[o,s]:void 0!==s&&(o=s),r}},f?(void 0===K&&w.initialize(),w.invoke(d)):(void 0!==K&&K.invoke("destroy"),w.initialize())}),void 0!==o?o:a},e.fn.dropdown.settings={silent:!1,debug:!1,verbose:!1,performance:!0,on:"click",action:"activate",apiSettings:!1,selectOnKeydown:!0,minCharacters:0,filterRemoteData:!1,saveRemoteData:!0,throttle:200,context:t,direction:"auto",keepOnScreen:!0,match:"both",fullTextSearch:!1,placeholder:"auto",preserveHTML:!0,sortSelect:!1,forceSelection:!0,allowAdditions:!1,hideAdditions:!0,maxSelections:!1,useLabels:!0,delimiter:",",showOnFocus:!0,allowReselection:!1,allowTab:!0,allowCategorySelection:!1,fireOnInit:!1,transition:"auto",duration:200,glyphWidth:1.037,label:{transition:"scale",duration:200,variation:!1},delay:{hide:300,show:200,search:20,touch:50},onChange:function(e,t,n){},onAdd:function(e,t,n){},onRemove:function(e,t,n){},onLabelSelect:function(e){},onLabelCreate:function(t,n){return e(this)},onLabelRemove:function(e){return!0},onNoResults:function(e){return!0},onShow:function(){},onHide:function(){},name:"Dropdown",namespace:"dropdown",message:{addResult:"Add <b>{term}</b>",count:"{count} selected",maxSelections:"Max {maxCount} selections",noResults:"No results found.",serverError:"There was an error contacting the server"},error:{action:"You called a dropdown action that was not defined",alreadySetup:"Once a select has been initialized behaviors must be called on the created ui dropdown",labels:"Allowing user additions currently requires the use of labels.",missingMultiple:"<select> requires multiple property to be set to correctly preserve multiple values",method:"The method you called is not defined.",noAPI:"The API module is required to load resources remotely",noStorage:"Saving remote data requires session storage",noTransition:"This module requires ui transitions <https://github.com/Semantic-Org/UI-Transition>"},regExp:{escape:/[-[\]{}()*+?.,\\^$|#\s]/g,quote:/"/g},metadata:{defaultText:"defaultText",defaultValue:"defaultValue",placeholderText:"placeholder",text:"text",value:"value"},fields:{remoteValues:"results",values:"values",disabled:"disabled",name:"name",value:"value",text:"text"},keys:{backspace:8,delimiter:188,deleteKey:46,enter:13,escape:27,pageUp:33,pageDown:34,leftArrow:37,upArrow:38,rightArrow:39,downArrow:40},selector:{addition:".addition",dropdown:".ui.dropdown",hidden:".hidden",icon:"> .dropdown.icon",input:'> input[type="hidden"], > select',item:".item",label:"> .label",remove:"> .label > .delete.icon",siblingLabel:".label",menu:".menu",message:".message",menuIcon:".dropdown.icon",search:"input.search, .menu > .search > input, .menu input.search",sizer:"> input.sizer",text:"> .text:not(.icon)",unselectable:".disabled, .filtered"},className:{active:"active",addition:"addition",animating:"animating",disabled:"disabled",empty:"empty",dropdown:"ui dropdown",filtered:"filtered",hidden:"hidden transition",item:"item",label:"ui label",loading:"loading",menu:"menu",message:"message",multiple:"multiple",placeholder:"default",sizer:"sizer",search:"search",selected:"selected",selection:"selection",upward:"upward",visible:"visible"}},e.fn.dropdown.settings.templates={dropdown:function(t){var n=t.placeholder||!1,i=(t.values,"");return i+='<i class="dropdown icon"></i>',t.placeholder?i+='<div class="default text">'+n+"</div>":i+='<div class="text"></div>',i+='<div class="menu">',e.each(t.values,function(e,t){i+=t.disabled?'<div class="disabled item" data-value="'+t.value+'">'+t.name+"</div>":'<div class="item" data-value="'+t.value+'">'+t.name+"</div>"}),i+="</div>"},menu:function(t,n){var i=t[n.values]||{},o="";return e.each(i,function(e,t){var i=t[n.text]?'data-text="'+t[n.text]+'"':"",a=t[n.disabled]?"disabled ":"";o+='<div class="'+a+'item" data-value="'+t[n.value]+'"'+i+">",o+=t[n.name],o+="</div>"}),o},label:function(e,t){return t+'<i class="delete icon"></i>'},message:function(e){return e},addition:function(e){return e}}}(jQuery,window,document),function(e,t,n,i){"use strict";t=void 0!==t&&t.Math==Math?t:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")(),e.fn.embed=function(n){var i,o=e(this),a=o.selector||"",r=(new Date).getTime(),s=[],l=arguments[0],c="string"==typeof l,u=[].slice.call(arguments,1);return o.each(function(){var d,f=e.isPlainObject(n)?e.extend(!0,{},e.fn.embed.settings,n):e.extend({},e.fn.embed.settings),m=f.selector,g=f.className,v=f.sources,p=f.error,h=f.metadata,b=f.namespace,y=f.templates,x="."+b,C="module-"+b,w=(e(t),e(this)),k=w.find(m.placeholder),S=w.find(m.icon),T=w.find(m.embed),A=this,R=w.data(C);d={initialize:function(){d.debug("Initializing embed"),d.determine.autoplay(),d.create(),d.bind.events(),d.instantiate()},instantiate:function(){d.verbose("Storing instance of module",d),R=d,w.data(C,d)},destroy:function(){d.verbose("Destroying previous instance of embed"),d.reset(),w.removeData(C).off(x)},refresh:function(){d.verbose("Refreshing selector cache"),k=w.find(m.placeholder),S=w.find(m.icon),T=w.find(m.embed)},bind:{events:function(){d.has.placeholder()&&(d.debug("Adding placeholder events"),w.on("click"+x,m.placeholder,d.createAndShow).on("click"+x,m.icon,d.createAndShow))}},create:function(){d.get.placeholder()?d.createPlaceholder():d.createAndShow()},createPlaceholder:function(e){var t=d.get.icon(),n=d.get.url();d.generate.embed(n);e=e||d.get.placeholder(),w.html(y.placeholder(e,t)),d.debug("Creating placeholder for embed",e,t)},createEmbed:function(t){d.refresh(),t=t||d.get.url(),T=e("<div/>").addClass(g.embed).html(d.generate.embed(t)).appendTo(w),f.onCreate.call(A,t),d.debug("Creating embed object",T)},changeEmbed:function(e){T.html(d.generate.embed(e))},createAndShow:function(){d.createEmbed(),d.show()},change:function(e,t,n){d.debug("Changing video to ",e,t,n),w.data(h.source,e).data(h.id,t),n?w.data(h.url,n):w.removeData(h.url),d.has.embed()?d.changeEmbed():d.create()},reset:function(){d.debug("Clearing embed and showing placeholder"),d.remove.active(),d.remove.embed(),d.showPlaceholder(),f.onReset.call(A)},show:function(){d.debug("Showing embed"),d.set.active(),f.onDisplay.call(A)},hide:function(){d.debug("Hiding embed"),d.showPlaceholder()},showPlaceholder:function(){d.debug("Showing placeholder image"),d.remove.active(),f.onPlaceholderDisplay.call(A)},get:{id:function(){return f.id||w.data(h.id)},placeholder:function(){return f.placeholder||w.data(h.placeholder)},icon:function(){return f.icon?f.icon:void 0!==w.data(h.icon)?w.data(h.icon):d.determine.icon()},source:function(e){return f.source?f.source:void 0!==w.data(h.source)?w.data(h.source):d.determine.source()},type:function(){var e=d.get.source();return void 0!==v[e]&&v[e].type},url:function(){return f.url?f.url:void 0!==w.data(h.url)?w.data(h.url):d.determine.url()}},determine:{autoplay:function(){d.should.autoplay()&&(f.autoplay=!0)},source:function(t){var n=!1;return t=t||d.get.url(),t&&e.each(v,function(e,i){if(-1!==t.search(i.domain))return n=e,!1}),n},icon:function(){var e=d.get.source();return void 0!==v[e]&&v[e].icon},url:function(){var e,t=f.id||w.data(h.id),n=f.source||w.data(h.source);return e=void 0!==v[n]&&v[n].url.replace("{id}",t),e&&w.data(h.url,e),e}},set:{active:function(){w.addClass(g.active)}},remove:{active:function(){w.removeClass(g.active)},embed:function(){T.empty()}},encode:{parameters:function(e){var t,n=[];for(t in e)n.push(encodeURIComponent(t)+"="+encodeURIComponent(e[t]));return n.join("&amp;")}},generate:{embed:function(e){d.debug("Generating embed html");var t,n,i=d.get.source();return e=d.get.url(e),e?(n=d.generate.parameters(i),t=y.iframe(e,n)):d.error(p.noURL,w),t},parameters:function(t,n){var i=v[t]&&void 0!==v[t].parameters?v[t].parameters(f):{};return n=n||f.parameters,n&&(i=e.extend({},i,n)),i=f.onEmbed(i),d.encode.parameters(i)}},has:{embed:function(){return T.length>0},placeholder:function(){return f.placeholder||w.data(h.placeholder)}},should:{autoplay:function(){return"auto"===f.autoplay?f.placeholder||void 0!==w.data(h.placeholder):f.autoplay}},is:{video:function(){return"video"==d.get.type()}},setting:function(t,n){if(d.debug("Changing setting",t,n),e.isPlainObject(t))e.extend(!0,f,t);else{if(void 0===n)return f[t];e.isPlainObject(f[t])?e.extend(!0,f[t],n):f[t]=n}},internal:function(t,n){if(e.isPlainObject(t))e.extend(!0,d,t);else{if(void 0===n)return d[t];d[t]=n}},debug:function(){!f.silent&&f.debug&&(f.performance?d.performance.log(arguments):(d.debug=Function.prototype.bind.call(console.info,console,f.name+":"),d.debug.apply(console,arguments)))},verbose:function(){!f.silent&&f.verbose&&f.debug&&(f.performance?d.performance.log(arguments):(d.verbose=Function.prototype.bind.call(console.info,console,f.name+":"),d.verbose.apply(console,arguments)))},error:function(){f.silent||(d.error=Function.prototype.bind.call(console.error,console,f.name+":"),d.error.apply(console,arguments))},performance:{log:function(e){var t,n,i;f.performance&&(t=(new Date).getTime(),i=r||t,n=t-i,r=t,s.push({Name:e[0],Arguments:[].slice.call(e,1)||"",Element:A,"Execution Time":n})),clearTimeout(d.performance.timer),d.performance.timer=setTimeout(d.performance.display,500)},display:function(){var t=f.name+":",n=0;r=!1,clearTimeout(d.performance.timer),e.each(s,function(e,t){n+=t["Execution Time"]}),t+=" "+n+"ms",a&&(t+=" '"+a+"'"),o.length>1&&(t+=" ("+o.length+")"),(void 0!==console.group||void 0!==console.table)&&s.length>0&&(console.groupCollapsed(t),console.table?console.table(s):e.each(s,function(e,t){console.log(t.Name+": "+t["Execution Time"]+"ms")}),console.groupEnd()),s=[]}},invoke:function(t,n,o){var a,r,s,l=R;return n=n||u,o=A||o,"string"==typeof t&&void 0!==l&&(t=t.split(/[\. ]/),a=t.length-1,e.each(t,function(n,i){var o=n!=a?i+t[n+1].charAt(0).toUpperCase()+t[n+1].slice(1):t;if(e.isPlainObject(l[o])&&n!=a)l=l[o];else{if(void 0!==l[o])return r=l[o],!1;if(!e.isPlainObject(l[i])||n==a)return void 0!==l[i]?(r=l[i],!1):(d.error(p.method,t),!1);l=l[i]}})),e.isFunction(r)?s=r.apply(o,n):void 0!==r&&(s=r),e.isArray(i)?i.push(s):void 0!==i?i=[i,s]:void 0!==s&&(i=s),r}},c?(void 0===R&&d.initialize(),d.invoke(l)):(void 0!==R&&R.invoke("destroy"),d.initialize())}),void 0!==i?i:this},e.fn.embed.settings={name:"Embed",namespace:"embed",silent:!1,debug:!1,verbose:!1,performance:!0,icon:!1,source:!1,url:!1,id:!1,autoplay:"auto",color:"#444444",hd:!0,brandedUI:!1,parameters:!1,onDisplay:function(){},onPlaceholderDisplay:function(){},onReset:function(){},onCreate:function(e){},onEmbed:function(e){return e},metadata:{id:"id",icon:"icon",placeholder:"placeholder",source:"source",url:"url"},error:{noURL:"No URL specified",method:"The method you called is not defined"},className:{active:"active",embed:"embed"},selector:{embed:".embed",placeholder:".placeholder",icon:".icon"},sources:{youtube:{name:"youtube",type:"video",icon:"video play",domain:"youtube.com",url:"//www.youtube.com/embed/{id}",parameters:function(e){return{autohide:!e.brandedUI,autoplay:e.autoplay,color:e.color||void 0,hq:e.hd,jsapi:e.api,modestbranding:!e.brandedUI}}},vimeo:{name:"vimeo",type:"video",icon:"video play",domain:"vimeo.com",url:"//player.vimeo.com/video/{id}",parameters:function(e){return{api:e.api,autoplay:e.autoplay,byline:e.brandedUI,color:e.color||void 0,portrait:e.brandedUI,title:e.brandedUI}}}},templates:{iframe:function(e,t){var n=e;return t&&(n+="?"+t),'<iframe src="'+n+'" width="100%" height="100%" frameborder="0" scrolling="no" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>'},placeholder:function(e,t){var n="";return t&&(n+='<i class="'+t+' icon"></i>'),e&&(n+='<img class="placeholder" src="'+e+'">'),n}},api:!1,onPause:function(){},onPlay:function(){},onStop:function(){}}}(jQuery,window,document),function(e,t,n,i){"use strict";t=void 0!==t&&t.Math==Math?t:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")(),e.fn.modal=function(i){var o,a=e(this),r=e(t),s=e(n),l=e("body"),c=a.selector||"",u=(new Date).getTime(),d=[],f=arguments[0],m="string"==typeof f,g=[].slice.call(arguments,1),v=t.requestAnimationFrame||t.mozRequestAnimationFrame||t.webkitRequestAnimationFrame||t.msRequestAnimationFrame||function(e){setTimeout(e,0)};return a.each(function(){var a,p,h,b,y,x,C,w,k,S=e.isPlainObject(i)?e.extend(!0,{},e.fn.modal.settings,i):e.extend({},e.fn.modal.settings),T=S.selector,A=S.className,R=S.namespace,P=S.error,E="."+R,F="module-"+R,O=e(this),D=e(S.context),q=O.find(T.close),j=this,z=O.data(F),I=!1;k={initialize:function(){k.verbose("Initializing dimmer",D),k.create.id(),k.create.dimmer(),k.refreshModals(),k.bind.events(),S.observeChanges&&k.observeChanges(),k.instantiate()},instantiate:function(){k.verbose("Storing instance of modal"),z=k,O.data(F,z)},create:{dimmer:function(){var t={debug:S.debug,dimmerName:"modals",duration:{show:S.duration,hide:S.duration}},n=e.extend(!0,t,S.dimmerSettings);if(S.inverted&&(n.variation=void 0!==n.variation?n.variation+" inverted":"inverted"),void 0===e.fn.dimmer)return void k.error(P.dimmer);k.debug("Creating dimmer with settings",n),b=D.dimmer(n),S.detachable?(k.verbose("Modal is detachable, moving content into dimmer"),b.dimmer("add content",O)):k.set.undetached(),S.blurring&&b.addClass(A.blurring),y=b.dimmer("get dimmer")},id:function(){C=(Math.random().toString(16)+"000000000").substr(2,8),x="."+C,k.verbose("Creating unique id for element",C)}},destroy:function(){k.verbose("Destroying previous modal"),O.removeData(F).off(E),r.off(x),y.off(x),q.off(E),D.dimmer("destroy")},observeChanges:function(){"MutationObserver"in t&&(w=new MutationObserver(function(e){k.debug("DOM tree modified, refreshing"),k.refresh()}),w.observe(j,{childList:!0,subtree:!0}),k.debug("Setting up mutation observer",w))},refresh:function(){k.remove.scrolling(),k.cacheSizes(),k.set.screenHeight(),k.set.type(),k.set.position()},refreshModals:function(){p=O.siblings(T.modal),a=p.add(O)},attachEvents:function(t,n){var i=e(t);n=e.isFunction(k[n])?k[n]:k.toggle,i.length>0?(k.debug("Attaching modal events to element",t,n),i.off(E).on("click"+E,n)):k.error(P.notFound,t)},bind:{events:function(){k.verbose("Attaching events"),O.on("click"+E,T.close,k.event.close).on("click"+E,T.approve,k.event.approve).on("click"+E,T.deny,k.event.deny),r.on("resize"+x,k.event.resize)}},get:{id:function(){return(Math.random().toString(16)+"000000000").substr(2,8)}},event:{approve:function(){if(I||!1===S.onApprove.call(j,e(this)))return void k.verbose("Approve callback returned false cancelling hide");I=!0,k.hide(function(){I=!1})},deny:function(){if(I||!1===S.onDeny.call(j,e(this)))return void k.verbose("Deny callback returned false cancelling hide");I=!0,k.hide(function(){I=!1})},close:function(){k.hide()},click:function(t){var i=e(t.target),o=i.closest(T.modal).length>0,a=e.contains(n.documentElement,t.target);!o&&a&&(k.debug("Dimmer clicked, hiding all modals"),k.is.active()&&(k.remove.clickaway(),S.allowMultiple?k.hide():k.hideAll()))},debounce:function(e,t){clearTimeout(k.timer),k.timer=setTimeout(e,t)},keyboard:function(e){27==e.which&&(S.closable?(k.debug("Escape key pressed hiding modal"),k.hide()):k.debug("Escape key pressed, but closable is set to false"),e.preventDefault())},resize:function(){b.dimmer("is active")&&v(k.refresh)}},toggle:function(){k.is.active()||k.is.animating()?k.hide():k.show()},show:function(t){t=e.isFunction(t)?t:function(){},k.refreshModals(),k.showModal(t)},hide:function(t){t=e.isFunction(t)?t:function(){},k.refreshModals(),k.hideModal(t)},showModal:function(t){t=e.isFunction(t)?t:function(){},k.is.animating()||!k.is.active()?(k.showDimmer(),k.cacheSizes(),k.set.position(),k.set.screenHeight(),k.set.type(),k.set.clickaway(),!S.allowMultiple&&k.others.active()?k.hideOthers(k.showModal):(S.onShow.call(j),S.transition&&void 0!==e.fn.transition&&O.transition("is supported")?(k.debug("Showing modal with css animations"),O.transition({debug:S.debug,animation:S.transition+" in",queue:S.queue,duration:S.duration,useFailSafe:!0,onComplete:function(){S.onVisible.apply(j),S.keyboardShortcuts&&k.add.keyboardShortcuts(),k.save.focus(),k.set.active(),S.autofocus&&k.set.autofocus(),t()}})):k.error(P.noTransition))):k.debug("Modal is already visible")},hideModal:function(t,n){if(t=e.isFunction(t)?t:function(){},k.debug("Hiding modal"),!1===S.onHide.call(j,e(this)))return void k.verbose("Hide callback returned false cancelling hide");(k.is.animating()||k.is.active())&&(S.transition&&void 0!==e.fn.transition&&O.transition("is supported")?(k.remove.active(),O.transition({debug:S.debug,animation:S.transition+" out",queue:S.queue,duration:S.duration,useFailSafe:!0,onStart:function(){k.others.active()||n||k.hideDimmer(),S.keyboardShortcuts&&k.remove.keyboardShortcuts()},onComplete:function(){S.onHidden.call(j),k.restore.focus(),t()}})):k.error(P.noTransition))},showDimmer:function(){b.dimmer("is animating")||!b.dimmer("is active")?(k.debug("Showing dimmer"),b.dimmer("show")):k.debug("Dimmer already visible")},hideDimmer:function(){if(!b.dimmer("is animating")&&!b.dimmer("is active"))return void k.debug("Dimmer is not visible cannot hide");b.dimmer("hide",function(){k.remove.clickaway(),k.remove.screenHeight()})},hideAll:function(t){var n=a.filter("."+A.active+", ."+A.animating);t=e.isFunction(t)?t:function(){},n.length>0&&(k.debug("Hiding all visible modals"),k.hideDimmer(),n.modal("hide modal",t))},hideOthers:function(t){var n=p.filter("."+A.active+", ."+A.animating);t=e.isFunction(t)?t:function(){},n.length>0&&(k.debug("Hiding other modals",p),n.modal("hide modal",t,!0))},others:{active:function(){return p.filter("."+A.active).length>0},animating:function(){return p.filter("."+A.animating).length>0}},add:{keyboardShortcuts:function(){k.verbose("Adding keyboard shortcuts"),s.on("keyup"+E,k.event.keyboard)}},save:{focus:function(){h=e(n.activeElement).blur()}},restore:{focus:function(){h&&h.length>0&&h.focus()}},remove:{active:function(){O.removeClass(A.active)},clickaway:function(){S.closable&&y.off("click"+x)},bodyStyle:function(){""===l.attr("style")&&(k.verbose("Removing style attribute"),l.removeAttr("style"))},screenHeight:function(){k.debug("Removing page height"),l.css("height","")},keyboardShortcuts:function(){k.verbose("Removing keyboard shortcuts"),s.off("keyup"+E)},scrolling:function(){b.removeClass(A.scrolling),O.removeClass(A.scrolling)}},cacheSizes:function(){var i=O.outerHeight();void 0!==k.cache&&0===i||(k.cache={pageHeight:e(n).outerHeight(),height:i+S.offset,contextHeight:"body"==S.context?e(t).height():b.height()}),k.debug("Caching modal and container sizes",k.cache)},can:{fit:function(){return k.cache.height+2*S.padding<k.cache.contextHeight}},is:{active:function(){return O.hasClass(A.active)},animating:function(){return O.transition("is supported")?O.transition("is animating"):O.is(":visible")},scrolling:function(){return b.hasClass(A.scrolling)},modernBrowser:function(){return!(t.ActiveXObject||"ActiveXObject"in t)}},set:{autofocus:function(){var e=O.find("[tabindex], :input").filter(":visible"),t=e.filter("[autofocus]"),n=t.length>0?t.first():e.first();n.length>0&&n.focus()},clickaway:function(){S.closable&&y.on("click"+x,k.event.click)},screenHeight:function(){k.can.fit()?l.css("height",""):(k.debug("Modal is taller than page content, resizing page height"),l.css("height",k.cache.height+2*S.padding))},active:function(){O.addClass(A.active)},scrolling:function(){b.addClass(A.scrolling),O.addClass(A.scrolling)},type:function(){k.can.fit()?(k.verbose("Modal fits on screen"),k.others.active()||k.others.animating()||k.remove.scrolling()):(k.verbose("Modal cannot fit on screen setting to scrolling"),k.set.scrolling())},position:function(){k.verbose("Centering modal on page",k.cache),k.can.fit()?O.css({top:"",marginTop:-k.cache.height/2}):O.css({marginTop:"",top:s.scrollTop()})},undetached:function(){b.addClass(A.undetached)}},setting:function(t,n){if(k.debug("Changing setting",t,n),e.isPlainObject(t))e.extend(!0,S,t);else{if(void 0===n)return S[t];e.isPlainObject(S[t])?e.extend(!0,S[t],n):S[t]=n}},internal:function(t,n){if(e.isPlainObject(t))e.extend(!0,k,t);else{if(void 0===n)return k[t];k[t]=n}},debug:function(){!S.silent&&S.debug&&(S.performance?k.performance.log(arguments):(k.debug=Function.prototype.bind.call(console.info,console,S.name+":"),k.debug.apply(console,arguments)))},verbose:function(){!S.silent&&S.verbose&&S.debug&&(S.performance?k.performance.log(arguments):(k.verbose=Function.prototype.bind.call(console.info,console,S.name+":"),k.verbose.apply(console,arguments)))},error:function(){S.silent||(k.error=Function.prototype.bind.call(console.error,console,S.name+":"),k.error.apply(console,arguments))},performance:{log:function(e){var t,n,i;S.performance&&(t=(new Date).getTime(),i=u||t,n=t-i,u=t,d.push({Name:e[0],Arguments:[].slice.call(e,1)||"",Element:j,"Execution Time":n})),clearTimeout(k.performance.timer),k.performance.timer=setTimeout(k.performance.display,500)},display:function(){var t=S.name+":",n=0;u=!1,clearTimeout(k.performance.timer),e.each(d,function(e,t){n+=t["Execution Time"]}),t+=" "+n+"ms",c&&(t+=" '"+c+"'"),(void 0!==console.group||void 0!==console.table)&&d.length>0&&(console.groupCollapsed(t),console.table?console.table(d):e.each(d,function(e,t){console.log(t.Name+": "+t["Execution Time"]+"ms")}),console.groupEnd()),d=[]}},invoke:function(t,n,i){var a,r,s,l=z;return n=n||g,i=j||i,"string"==typeof t&&void 0!==l&&(t=t.split(/[\. ]/),a=t.length-1,e.each(t,function(n,i){var o=n!=a?i+t[n+1].charAt(0).toUpperCase()+t[n+1].slice(1):t;if(e.isPlainObject(l[o])&&n!=a)l=l[o];else{if(void 0!==l[o])return r=l[o],!1;if(!e.isPlainObject(l[i])||n==a)return void 0!==l[i]&&(r=l[i],!1);l=l[i]}})),e.isFunction(r)?s=r.apply(i,n):void 0!==r&&(s=r),e.isArray(o)?o.push(s):void 0!==o?o=[o,s]:void 0!==s&&(o=s),r}},m?(void 0===z&&k.initialize(),k.invoke(f)):(void 0!==z&&z.invoke("destroy"),k.initialize())}),void 0!==o?o:this},e.fn.modal.settings={name:"Modal",namespace:"modal",silent:!1,debug:!1,verbose:!1,performance:!0,observeChanges:!1,allowMultiple:!1,detachable:!0,closable:!0,autofocus:!0,inverted:!1,blurring:!1,dimmerSettings:{closable:!1,useCSS:!0},keyboardShortcuts:!0,context:"body",queue:!1,duration:500,offset:0,transition:"scale",padding:50,onShow:function(){},onVisible:function(){},onHide:function(){return!0},onHidden:function(){},onApprove:function(){return!0},onDeny:function(){return!0},selector:{close:"> .close",approve:".actions .positive, .actions .approve, .actions .ok",deny:".actions .negative, .actions .deny, .actions .cancel",modal:".ui.modal"},error:{dimmer:"UI Dimmer, a required component is not included in this page",method:"The method you called is not defined.",notFound:"The element you specified could not be found"},className:{active:"active",animating:"animating",blurring:"blurring",scrolling:"scrolling",undetached:"undetached"}}}(jQuery,window,document),function(e,t,n,i){"use strict";t=void 0!==t&&t.Math==Math?t:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")(),e.fn.nag=function(n){var i,o=e(this),a=o.selector||"",r=(new Date).getTime(),s=[],l=arguments[0],c="string"==typeof l,u=[].slice.call(arguments,1);return o.each(function(){var o,d=e.isPlainObject(n)?e.extend(!0,{},e.fn.nag.settings,n):e.extend({},e.fn.nag.settings),f=(d.className,d.selector),m=d.error,g=d.namespace,v="."+g,p=g+"-module",h=e(this),b=(h.find(f.close),e(d.context?d.context:"body")),y=this,x=h.data(p);t.requestAnimationFrame||t.mozRequestAnimationFrame||t.webkitRequestAnimationFrame||t.msRequestAnimationFrame;o={initialize:function(){o.verbose("Initializing element"),h.on("click"+v,f.close,o.dismiss).data(p,o),d.detachable&&h.parent()[0]!==b[0]&&h.detach().prependTo(b),d.displayTime>0&&setTimeout(o.hide,d.displayTime),o.show()},destroy:function(){o.verbose("Destroying instance"),h.removeData(p).off(v)},show:function(){o.should.show()&&!h.is(":visible")&&(o.debug("Showing nag",d.animation.show),"fade"==d.animation.show?h.fadeIn(d.duration,d.easing):h.slideDown(d.duration,d.easing))},hide:function(){o.debug("Showing nag",d.animation.hide),"fade"==d.animation.show?h.fadeIn(d.duration,d.easing):h.slideUp(d.duration,d.easing)},onHide:function(){o.debug("Removing nag",d.animation.hide),h.remove(),d.onHide&&d.onHide()},dismiss:function(e){d.storageMethod&&o.storage.set(d.key,d.value),o.hide(),e.stopImmediatePropagation(),e.preventDefault()},should:{show:function(){return d.persist?(o.debug("Persistent nag is set, can show nag"),!0):o.storage.get(d.key)!=d.value.toString()?(o.debug("Stored value is not set, can show nag",o.storage.get(d.key)),!0):(o.debug("Stored value is set, cannot show nag",o.storage.get(d.key)),!1)}},get:{storageOptions:function(){var e={};return d.expires&&(e.expires=d.expires),d.domain&&(e.domain=d.domain),d.path&&(e.path=d.path),e}},clear:function(){o.storage.remove(d.key)},storage:{set:function(n,i){var a=o.get.storageOptions();if("localstorage"==d.storageMethod&&void 0!==t.localStorage)t.localStorage.setItem(n,i),o.debug("Value stored using local storage",n,i);else if("sessionstorage"==d.storageMethod&&void 0!==t.sessionStorage)t.sessionStorage.setItem(n,i),o.debug("Value stored using session storage",n,i);else{if(void 0===e.cookie)return void o.error(m.noCookieStorage);e.cookie(n,i,a),o.debug("Value stored using cookie",n,i,a)}},get:function(n,i){var a;return"localstorage"==d.storageMethod&&void 0!==t.localStorage?a=t.localStorage.getItem(n):"sessionstorage"==d.storageMethod&&void 0!==t.sessionStorage?a=t.sessionStorage.getItem(n):void 0!==e.cookie?a=e.cookie(n):o.error(m.noCookieStorage),"undefined"!=a&&"null"!=a&&void 0!==a&&null!==a||(a=void 0),a},remove:function(n){var i=o.get.storageOptions();"localstorage"==d.storageMethod&&void 0!==t.localStorage?t.localStorage.removeItem(n):"sessionstorage"==d.storageMethod&&void 0!==t.sessionStorage?t.sessionStorage.removeItem(n):void 0!==e.cookie?e.removeCookie(n,i):o.error(m.noStorage)}},setting:function(t,n){if(o.debug("Changing setting",t,n),e.isPlainObject(t))e.extend(!0,d,t);else{if(void 0===n)return d[t];e.isPlainObject(d[t])?e.extend(!0,d[t],n):d[t]=n}},internal:function(t,n){if(e.isPlainObject(t))e.extend(!0,o,t);else{if(void 0===n)return o[t];o[t]=n}},debug:function(){!d.silent&&d.debug&&(d.performance?o.performance.log(arguments):(o.debug=Function.prototype.bind.call(console.info,console,d.name+":"),o.debug.apply(console,arguments)))},verbose:function(){!d.silent&&d.verbose&&d.debug&&(d.performance?o.performance.log(arguments):(o.verbose=Function.prototype.bind.call(console.info,console,d.name+":"),o.verbose.apply(console,arguments)))},error:function(){d.silent||(o.error=Function.prototype.bind.call(console.error,console,d.name+":"),o.error.apply(console,arguments))},performance:{log:function(e){var t,n,i;d.performance&&(t=(new Date).getTime(),i=r||t,n=t-i,r=t,s.push({Name:e[0],Arguments:[].slice.call(e,1)||"",Element:y,"Execution Time":n})),clearTimeout(o.performance.timer),o.performance.timer=setTimeout(o.performance.display,500)},display:function(){var t=d.name+":",n=0;r=!1,clearTimeout(o.performance.timer),e.each(s,function(e,t){n+=t["Execution Time"]}),t+=" "+n+"ms",a&&(t+=" '"+a+"'"),(void 0!==console.group||void 0!==console.table)&&s.length>0&&(console.groupCollapsed(t),console.table?console.table(s):e.each(s,function(e,t){console.log(t.Name+": "+t["Execution Time"]+"ms")}),console.groupEnd()),s=[]}},invoke:function(t,n,a){var r,s,l,c=x;return n=n||u,a=y||a,"string"==typeof t&&void 0!==c&&(t=t.split(/[\. ]/),r=t.length-1,e.each(t,function(n,i){var a=n!=r?i+t[n+1].charAt(0).toUpperCase()+t[n+1].slice(1):t;if(e.isPlainObject(c[a])&&n!=r)c=c[a];else{if(void 0!==c[a])return s=c[a],!1;if(!e.isPlainObject(c[i])||n==r)return void 0!==c[i]?(s=c[i],!1):(o.error(m.method,t),!1);c=c[i]}})),e.isFunction(s)?l=s.apply(a,n):void 0!==s&&(l=s),e.isArray(i)?i.push(l):void 0!==i?i=[i,l]:void 0!==l&&(i=l),s}},c?(void 0===x&&o.initialize(),o.invoke(l)):(void 0!==x&&x.invoke("destroy"),o.initialize())}),void 0!==i?i:this},e.fn.nag.settings={name:"Nag",silent:!1,debug:!1,verbose:!1,performance:!0,namespace:"Nag",persist:!1,displayTime:0,animation:{show:"slide",hide:"slide"},context:!1,detachable:!1,expires:30,domain:!1,path:"/",storageMethod:"cookie",key:"nag",value:"dismiss",error:{noCookieStorage:"$.cookie is not included. A storage solution is required.",noStorage:"Neither $.cookie or store is defined. A storage solution is required for storing state",method:"The method you called is not defined."},className:{bottom:"bottom",fixed:"fixed"},selector:{close:".close.icon"},speed:500,easing:"easeOutQuad",onHide:function(){}},e.extend(e.easing,{easeOutQuad:function(e,t,n,i,o){return-i*(t/=o)*(t-2)+n}})}(jQuery,window,document),function(e,t,n,i){"use strict";t=void 0!==t&&t.Math==Math?t:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")(),e.fn.popup=function(i){var o,a=e(this),r=e(n),s=e(t),l=e("body"),c=a.selector||"",u=(new Date).getTime(),d=[],f=arguments[0],m="string"==typeof f,g=[].slice.call(arguments,1);return a.each(function(){var a,v,p,h,b,y,x=e.isPlainObject(i)?e.extend(!0,{},e.fn.popup.settings,i):e.extend({},e.fn.popup.settings),C=x.selector,w=x.className,k=x.error,S=x.metadata,T=x.namespace,A="."+x.namespace,R="module-"+T,P=e(this),E=e(x.context),F=e(x.scrollContext),O=e(x.boundary),D=x.target?e(x.target):P,q=0,j=!1,z=!1,I=this,M=P.data(R);y={initialize:function(){y.debug("Initializing",P),y.createID(),y.bind.events(),!y.exists()&&x.preserve&&y.create(),x.observeChanges&&y.observeChanges(),y.instantiate()},instantiate:function(){y.verbose("Storing instance",y),M=y,P.data(R,M)},observeChanges:function(){"MutationObserver"in t&&(p=new MutationObserver(y.event.documentChanged),p.observe(n,{childList:!0,subtree:!0}),y.debug("Setting up mutation observer",p))},refresh:function(){x.popup?a=e(x.popup).eq(0):x.inline&&(a=D.nextAll(C.popup).eq(0),x.popup=a),x.popup?(a.addClass(w.loading),v=y.get.offsetParent(),a.removeClass(w.loading),x.movePopup&&y.has.popup()&&y.get.offsetParent(a)[0]!==v[0]&&(y.debug("Moving popup to the same offset parent as activating element"),a.detach().appendTo(v))):v=x.inline?y.get.offsetParent(D):y.has.popup()?y.get.offsetParent(a):l,v.is("html")&&v[0]!==l[0]&&(y.debug("Setting page as offset parent"),v=l),y.get.variation()&&y.set.variation()},reposition:function(){y.refresh(),y.set.position()},destroy:function(){
y.debug("Destroying previous module"),p&&p.disconnect(),a&&!x.preserve&&y.removePopup(),clearTimeout(y.hideTimer),clearTimeout(y.showTimer),y.unbind.close(),y.unbind.events(),P.removeData(R)},event:{start:function(t){var n=e.isPlainObject(x.delay)?x.delay.show:x.delay;clearTimeout(y.hideTimer),z||(y.showTimer=setTimeout(y.show,n))},end:function(){var t=e.isPlainObject(x.delay)?x.delay.hide:x.delay;clearTimeout(y.showTimer),y.hideTimer=setTimeout(y.hide,t)},touchstart:function(e){z=!0,y.show()},resize:function(){y.is.visible()&&y.set.position()},documentChanged:function(t){[].forEach.call(t,function(t){t.removedNodes&&[].forEach.call(t.removedNodes,function(t){(t==I||e(t).find(I).length>0)&&(y.debug("Element removed from DOM, tearing down events"),y.destroy())})})},hideGracefully:function(t){var i=e(t.target),o=e.contains(n.documentElement,t.target),a=i.closest(C.popup).length>0;t&&!a&&o?(y.debug("Click occurred outside popup hiding popup"),y.hide()):y.debug("Click was inside popup, keeping popup open")}},create:function(){var t=y.get.html(),n=y.get.title(),i=y.get.content();t||i||n?(y.debug("Creating pop-up html"),t||(t=x.templates.popup({title:n,content:i})),a=e("<div/>").addClass(w.popup).data(S.activator,P).html(t),x.inline?(y.verbose("Inserting popup element inline",a),a.insertAfter(P)):(y.verbose("Appending popup element to body",a),a.appendTo(E)),y.refresh(),y.set.variation(),x.hoverable&&y.bind.popup(),x.onCreate.call(a,I)):0!==D.next(C.popup).length?(y.verbose("Pre-existing popup found"),x.inline=!0,x.popup=D.next(C.popup).data(S.activator,P),y.refresh(),x.hoverable&&y.bind.popup()):x.popup?(e(x.popup).data(S.activator,P),y.verbose("Used popup specified in settings"),y.refresh(),x.hoverable&&y.bind.popup()):y.debug("No content specified skipping display",I)},createID:function(){b=(Math.random().toString(16)+"000000000").substr(2,8),h="."+b,y.verbose("Creating unique id for element",b)},toggle:function(){y.debug("Toggling pop-up"),y.is.hidden()?(y.debug("Popup is hidden, showing pop-up"),y.unbind.close(),y.show()):(y.debug("Popup is visible, hiding pop-up"),y.hide())},show:function(e){if(e=e||function(){},y.debug("Showing pop-up",x.transition),y.is.hidden()&&(!y.is.active()||!y.is.dropdown())){if(y.exists()||y.create(),!1===x.onShow.call(a,I))return void y.debug("onShow callback returned false, cancelling popup animation");x.preserve||x.popup||y.refresh(),a&&y.set.position()&&(y.save.conditions(),x.exclusive&&y.hideAll(),y.animate.show(e))}},hide:function(e){if(e=e||function(){},y.is.visible()||y.is.animating()){if(!1===x.onHide.call(a,I))return void y.debug("onHide callback returned false, cancelling popup animation");y.remove.visible(),y.unbind.close(),y.restore.conditions(),y.animate.hide(e)}},hideAll:function(){e(C.popup).filter("."+w.visible).each(function(){e(this).data(S.activator).popup("hide")})},exists:function(){return!!a&&(x.inline||x.popup?y.has.popup():a.closest(E).length>=1)},removePopup:function(){y.has.popup()&&!x.popup&&(y.debug("Removing popup",a),a.remove(),a=void 0,x.onRemove.call(a,I))},save:{conditions:function(){y.cache={title:P.attr("title")},y.cache.title&&P.removeAttr("title"),y.verbose("Saving original attributes",y.cache.title)}},restore:{conditions:function(){return y.cache&&y.cache.title&&(P.attr("title",y.cache.title),y.verbose("Restoring original attributes",y.cache.title)),!0}},supports:{svg:function(){return void 0===typeof SVGGraphicsElement}},animate:{show:function(t){t=e.isFunction(t)?t:function(){},x.transition&&void 0!==e.fn.transition&&P.transition("is supported")?(y.set.visible(),a.transition({animation:x.transition+" in",queue:!1,debug:x.debug,verbose:x.verbose,duration:x.duration,onComplete:function(){y.bind.close(),t.call(a,I),x.onVisible.call(a,I)}})):y.error(k.noTransition)},hide:function(t){if(t=e.isFunction(t)?t:function(){},y.debug("Hiding pop-up"),!1===x.onHide.call(a,I))return void y.debug("onHide callback returned false, cancelling popup animation");x.transition&&void 0!==e.fn.transition&&P.transition("is supported")?a.transition({animation:x.transition+" out",queue:!1,duration:x.duration,debug:x.debug,verbose:x.verbose,onComplete:function(){y.reset(),t.call(a,I),x.onHidden.call(a,I)}}):y.error(k.noTransition)}},change:{content:function(e){a.html(e)}},get:{html:function(){return P.removeData(S.html),P.data(S.html)||x.html},title:function(){return P.removeData(S.title),P.data(S.title)||x.title},content:function(){return P.removeData(S.content),P.data(S.content)||P.attr("title")||x.content},variation:function(){return P.removeData(S.variation),P.data(S.variation)||x.variation},popup:function(){return a},popupOffset:function(){return a.offset()},calculations:function(){var e,n=D[0],i=O[0]==t,o=x.inline||x.popup&&x.movePopup?D.position():D.offset(),r=i?{top:0,left:0}:O.offset(),l={},c=i?{top:s.scrollTop(),left:s.scrollLeft()}:{top:0,left:0};return l={target:{element:D[0],width:D.outerWidth(),height:D.outerHeight(),top:o.top,left:o.left,margin:{}},popup:{width:a.outerWidth(),height:a.outerHeight()},parent:{width:v.outerWidth(),height:v.outerHeight()},screen:{top:r.top,left:r.left,scroll:{top:c.top,left:c.left},width:O.width(),height:O.height()}},x.setFluidWidth&&y.is.fluid()&&(l.container={width:a.parent().outerWidth()},l.popup.width=l.container.width),l.target.margin.top=x.inline?parseInt(t.getComputedStyle(n).getPropertyValue("margin-top"),10):0,l.target.margin.left=x.inline?y.is.rtl()?parseInt(t.getComputedStyle(n).getPropertyValue("margin-right"),10):parseInt(t.getComputedStyle(n).getPropertyValue("margin-left"),10):0,e=l.screen,l.boundary={top:e.top+e.scroll.top,bottom:e.top+e.scroll.top+e.height,left:e.left+e.scroll.left,right:e.left+e.scroll.left+e.width},l},id:function(){return b},startEvent:function(){return"hover"==x.on?"mouseenter":"focus"==x.on&&"focus"},scrollEvent:function(){return"scroll"},endEvent:function(){return"hover"==x.on?"mouseleave":"focus"==x.on&&"blur"},distanceFromBoundary:function(e,t){var n,i,o={};return t=t||y.get.calculations(),n=t.popup,i=t.boundary,e&&(o={top:e.top-i.top,left:e.left-i.left,right:i.right-(e.left+n.width),bottom:i.bottom-(e.top+n.height)},y.verbose("Distance from boundaries determined",e,o)),o},offsetParent:function(t){var n=void 0!==t?t[0]:P[0],i=n.parentNode,o=e(i);if(i)for(var a="none"===o.css("transform"),r="static"===o.css("position"),s=o.is("html");i&&!s&&r&&a;)i=i.parentNode,o=e(i),a="none"===o.css("transform"),r="static"===o.css("position"),s=o.is("html");return o&&o.length>0?o:e()},positions:function(){return{"top left":!1,"top center":!1,"top right":!1,"bottom left":!1,"bottom center":!1,"bottom right":!1,"left center":!1,"right center":!1}},nextPosition:function(e){var t=e.split(" "),n=t[0],i=t[1],o={top:"bottom",bottom:"top",left:"right",right:"left"},a={left:"center",center:"right",right:"left"},r={"top left":"top center","top center":"top right","top right":"right center","right center":"bottom right","bottom right":"bottom center","bottom center":"bottom left","bottom left":"left center","left center":"top left"},s="top"==n||"bottom"==n,l=!1,c=!1,u=!1;return j||(y.verbose("All available positions available"),j=y.get.positions()),y.debug("Recording last position tried",e),j[e]=!0,"opposite"===x.prefer&&(u=[o[n],i],u=u.join(" "),l=!0===j[u],y.debug("Trying opposite strategy",u)),"adjacent"===x.prefer&&s&&(u=[n,a[i]],u=u.join(" "),c=!0===j[u],y.debug("Trying adjacent strategy",u)),(c||l)&&(y.debug("Using backup position",u),u=r[e]),u}},set:{position:function(e,t){if(0===D.length||0===a.length)return void y.error(k.notFound);var n,i,o,r,s,l,c,u;if(t=t||y.get.calculations(),e=e||P.data(S.position)||x.position,n=P.data(S.offset)||x.offset,i=x.distanceAway,o=t.target,r=t.popup,s=t.parent,0===o.width&&0===o.height&&!y.is.svg(o.element))return y.debug("Popup target is hidden, no action taken"),!1;switch(x.inline&&(y.debug("Adding margin to calculation",o.margin),"left center"==e||"right center"==e?(n+=o.margin.top,i+=-o.margin.left):"top left"==e||"top center"==e||"top right"==e?(n+=o.margin.left,i-=o.margin.top):(n+=o.margin.left,i+=o.margin.top)),y.debug("Determining popup position from calculations",e,t),y.is.rtl()&&(e=e.replace(/left|right/g,function(e){return"left"==e?"right":"left"}),y.debug("RTL: Popup position updated",e)),q==x.maxSearchDepth&&"string"==typeof x.lastResort&&(e=x.lastResort),e){case"top left":l={top:"auto",bottom:s.height-o.top+i,left:o.left+n,right:"auto"};break;case"top center":l={bottom:s.height-o.top+i,left:o.left+o.width/2-r.width/2+n,top:"auto",right:"auto"};break;case"top right":l={bottom:s.height-o.top+i,right:s.width-o.left-o.width-n,top:"auto",left:"auto"};break;case"left center":l={top:o.top+o.height/2-r.height/2+n,right:s.width-o.left+i,left:"auto",bottom:"auto"};break;case"right center":l={top:o.top+o.height/2-r.height/2+n,left:o.left+o.width+i,bottom:"auto",right:"auto"};break;case"bottom left":l={top:o.top+o.height+i,left:o.left+n,bottom:"auto",right:"auto"};break;case"bottom center":l={top:o.top+o.height+i,left:o.left+o.width/2-r.width/2+n,bottom:"auto",right:"auto"};break;case"bottom right":l={top:o.top+o.height+i,right:s.width-o.left-o.width-n,left:"auto",bottom:"auto"}}if(void 0===l&&y.error(k.invalidPosition,e),y.debug("Calculated popup positioning values",l),a.css(l).removeClass(w.position).addClass(e).addClass(w.loading),c=y.get.popupOffset(),u=y.get.distanceFromBoundary(c,t),y.is.offstage(u,e)){if(y.debug("Position is outside viewport",e),q<x.maxSearchDepth)return q++,e=y.get.nextPosition(e),y.debug("Trying new position",e),!!a&&y.set.position(e,t);if(!x.lastResort)return y.debug("Popup could not find a position to display",a),y.error(k.cannotPlace,I),y.remove.attempts(),y.remove.loading(),y.reset(),x.onUnplaceable.call(a,I),!1;y.debug("No position found, showing with last position")}return y.debug("Position is on stage",e),y.remove.attempts(),y.remove.loading(),x.setFluidWidth&&y.is.fluid()&&y.set.fluidWidth(t),!0},fluidWidth:function(e){e=e||y.get.calculations(),y.debug("Automatically setting element width to parent width",e.parent.width),a.css("width",e.container.width)},variation:function(e){(e=e||y.get.variation())&&y.has.popup()&&(y.verbose("Adding variation to popup",e),a.addClass(e))},visible:function(){P.addClass(w.visible)}},remove:{loading:function(){a.removeClass(w.loading)},variation:function(e){(e=e||y.get.variation())&&(y.verbose("Removing variation",e),a.removeClass(e))},visible:function(){P.removeClass(w.visible)},attempts:function(){y.verbose("Resetting all searched positions"),q=0,j=!1}},bind:{events:function(){y.debug("Binding popup events to module"),"click"==x.on&&P.on("click"+A,y.toggle),"hover"==x.on&&P.on("touchstart"+A,y.event.touchstart),y.get.startEvent()&&P.on(y.get.startEvent()+A,y.event.start).on(y.get.endEvent()+A,y.event.end),x.target&&y.debug("Target set to element",D),s.on("resize"+h,y.event.resize)},popup:function(){y.verbose("Allowing hover events on popup to prevent closing"),a&&y.has.popup()&&a.on("mouseenter"+A,y.event.start).on("mouseleave"+A,y.event.end)},close:function(){(!0===x.hideOnScroll||"auto"==x.hideOnScroll&&"click"!=x.on)&&F.one(y.get.scrollEvent()+h,y.event.hideGracefully),"hover"==x.on&&z&&(y.verbose("Binding popup close event to document"),r.on("touchstart"+h,function(e){y.verbose("Touched away from popup"),y.event.hideGracefully.call(I,e)})),"click"==x.on&&x.closable&&(y.verbose("Binding popup close event to document"),r.on("click"+h,function(e){y.verbose("Clicked away from popup"),y.event.hideGracefully.call(I,e)}))}},unbind:{events:function(){s.off(h),P.off(A)},close:function(){r.off(h),F.off(h)}},has:{popup:function(){return a&&a.length>0}},is:{offstage:function(t,n){var i=[];return e.each(t,function(e,t){t<-x.jitter&&(y.debug("Position exceeds allowable distance from edge",e,t,n),i.push(e))}),i.length>0},svg:function(e){return y.supports.svg()&&e instanceof SVGGraphicsElement},active:function(){return P.hasClass(w.active)},animating:function(){return void 0!==a&&a.hasClass(w.animating)},fluid:function(){return void 0!==a&&a.hasClass(w.fluid)},visible:function(){return void 0!==a&&a.hasClass(w.visible)},dropdown:function(){return P.hasClass(w.dropdown)},hidden:function(){return!y.is.visible()},rtl:function(){return"rtl"==P.css("direction")}},reset:function(){y.remove.visible(),x.preserve?void 0!==e.fn.transition&&a.transition("remove transition"):y.removePopup()},setting:function(t,n){if(e.isPlainObject(t))e.extend(!0,x,t);else{if(void 0===n)return x[t];x[t]=n}},internal:function(t,n){if(e.isPlainObject(t))e.extend(!0,y,t);else{if(void 0===n)return y[t];y[t]=n}},debug:function(){!x.silent&&x.debug&&(x.performance?y.performance.log(arguments):(y.debug=Function.prototype.bind.call(console.info,console,x.name+":"),y.debug.apply(console,arguments)))},verbose:function(){!x.silent&&x.verbose&&x.debug&&(x.performance?y.performance.log(arguments):(y.verbose=Function.prototype.bind.call(console.info,console,x.name+":"),y.verbose.apply(console,arguments)))},error:function(){x.silent||(y.error=Function.prototype.bind.call(console.error,console,x.name+":"),y.error.apply(console,arguments))},performance:{log:function(e){var t,n,i;x.performance&&(t=(new Date).getTime(),i=u||t,n=t-i,u=t,d.push({Name:e[0],Arguments:[].slice.call(e,1)||"",Element:I,"Execution Time":n})),clearTimeout(y.performance.timer),y.performance.timer=setTimeout(y.performance.display,500)},display:function(){var t=x.name+":",n=0;u=!1,clearTimeout(y.performance.timer),e.each(d,function(e,t){n+=t["Execution Time"]}),t+=" "+n+"ms",c&&(t+=" '"+c+"'"),(void 0!==console.group||void 0!==console.table)&&d.length>0&&(console.groupCollapsed(t),console.table?console.table(d):e.each(d,function(e,t){console.log(t.Name+": "+t["Execution Time"]+"ms")}),console.groupEnd()),d=[]}},invoke:function(t,n,i){var a,r,s,l=M;return n=n||g,i=I||i,"string"==typeof t&&void 0!==l&&(t=t.split(/[\. ]/),a=t.length-1,e.each(t,function(n,i){var o=n!=a?i+t[n+1].charAt(0).toUpperCase()+t[n+1].slice(1):t;if(e.isPlainObject(l[o])&&n!=a)l=l[o];else{if(void 0!==l[o])return r=l[o],!1;if(!e.isPlainObject(l[i])||n==a)return void 0!==l[i]&&(r=l[i],!1);l=l[i]}})),e.isFunction(r)?s=r.apply(i,n):void 0!==r&&(s=r),e.isArray(o)?o.push(s):void 0!==o?o=[o,s]:void 0!==s&&(o=s),r}},m?(void 0===M&&y.initialize(),y.invoke(f)):(void 0!==M&&M.invoke("destroy"),y.initialize())}),void 0!==o?o:this},e.fn.popup.settings={name:"Popup",silent:!1,debug:!1,verbose:!1,performance:!0,namespace:"popup",observeChanges:!0,onCreate:function(){},onRemove:function(){},onShow:function(){},onVisible:function(){},onHide:function(){},onUnplaceable:function(){},onHidden:function(){},on:"hover",boundary:t,addTouchEvents:!0,position:"top left",variation:"",movePopup:!0,target:!1,popup:!1,inline:!1,preserve:!1,hoverable:!1,content:!1,html:!1,title:!1,closable:!0,hideOnScroll:"auto",exclusive:!1,context:"body",scrollContext:t,prefer:"opposite",lastResort:!1,delay:{show:50,hide:70},setFluidWidth:!0,duration:200,transition:"scale",distanceAway:0,jitter:2,offset:0,maxSearchDepth:15,error:{invalidPosition:"The position you specified is not a valid position",cannotPlace:"Popup does not fit within the boundaries of the viewport",method:"The method you called is not defined.",noTransition:"This module requires ui transitions <https://github.com/Semantic-Org/UI-Transition>",notFound:"The target or popup you specified does not exist on the page"},metadata:{activator:"activator",content:"content",html:"html",offset:"offset",position:"position",title:"title",variation:"variation"},className:{active:"active",animating:"animating",dropdown:"dropdown",fluid:"fluid",loading:"loading",popup:"ui popup",position:"top left center bottom right",visible:"visible"},selector:{popup:".ui.popup"},templates:{escape:function(e){var t=/[&<>"'`]/g,n=/[&<>"'`]/,i={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","`":"&#x60;"},o=function(e){return i[e]};return n.test(e)?e.replace(t,o):e},popup:function(t){var n="",i=e.fn.popup.settings.templates.escape;return void 0!==typeof t&&(void 0!==typeof t.title&&t.title&&(t.title=i(t.title),n+='<div class="header">'+t.title+"</div>"),void 0!==typeof t.content&&t.content&&(t.content=i(t.content),n+='<div class="content">'+t.content+"</div>")),n}}}}(jQuery,window,document),function(e,t,n,i){"use strict";t=void 0!==t&&t.Math==Math?t:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();void 0!==t&&t.Math==Math||("undefined"!=typeof self&&self.Math==Math?self:Function("return this")());e.fn.progress=function(t){var i,o=e(this),a=o.selector||"",r=(new Date).getTime(),s=[],l=arguments[0],c="string"==typeof l,u=[].slice.call(arguments,1);return o.each(function(){var o,d,f=e.isPlainObject(t)?e.extend(!0,{},e.fn.progress.settings,t):e.extend({},e.fn.progress.settings),m=f.className,g=f.metadata,v=f.namespace,p=f.selector,h=f.error,b="."+v,y="module-"+v,x=e(this),C=e(this).find(p.bar),w=e(this).find(p.progress),k=e(this).find(p.label),S=this,T=x.data(y),A=!1;d={initialize:function(){d.debug("Initializing progress bar",f),d.set.duration(),d.set.transitionEvent(),d.read.metadata(),d.read.settings(),d.instantiate()},instantiate:function(){d.verbose("Storing instance of progress",d),T=d,x.data(y,d)},destroy:function(){d.verbose("Destroying previous progress for",x),clearInterval(T.interval),d.remove.state(),x.removeData(y),T=void 0},reset:function(){d.remove.nextValue(),d.update.progress(0)},complete:function(){(void 0===d.percent||d.percent<100)&&(d.remove.progressPoll(),d.set.percent(100))},read:{metadata:function(){var e={percent:x.data(g.percent),total:x.data(g.total),value:x.data(g.value)};e.percent&&(d.debug("Current percent value set from metadata",e.percent),d.set.percent(e.percent)),e.total&&(d.debug("Total value set from metadata",e.total),d.set.total(e.total)),e.value&&(d.debug("Current value set from metadata",e.value),d.set.value(e.value),d.set.progress(e.value))},settings:function(){!1!==f.total&&(d.debug("Current total set in settings",f.total),d.set.total(f.total)),!1!==f.value&&(d.debug("Current value set in settings",f.value),d.set.value(f.value),d.set.progress(d.value)),!1!==f.percent&&(d.debug("Current percent set in settings",f.percent),d.set.percent(f.percent))}},bind:{transitionEnd:function(e){var t=d.get.transitionEnd();C.one(t+b,function(t){clearTimeout(d.failSafeTimer),e.call(this,t)}),d.failSafeTimer=setTimeout(function(){C.triggerHandler(t)},f.duration+f.failSafeDelay),d.verbose("Adding fail safe timer",d.timer)}},increment:function(e){var t,n;d.has.total()?(t=d.get.value(),e=e||1,n=t+e):(t=d.get.percent(),e=e||d.get.randomValue(),n=t+e,100,d.debug("Incrementing percentage by",t,n)),n=d.get.normalizedValue(n),d.set.progress(n)},decrement:function(e){var t,n,i=d.get.total();i?(t=d.get.value(),e=e||1,n=t-e,d.debug("Decrementing value by",e,t)):(t=d.get.percent(),e=e||d.get.randomValue(),n=t-e,d.debug("Decrementing percentage by",e,t)),n=d.get.normalizedValue(n),d.set.progress(n)},has:{progressPoll:function(){return d.progressPoll},total:function(){return!1!==d.get.total()}},get:{text:function(e){var t=d.value||0,n=d.total||0,i=A?d.get.displayPercent():d.percent||0,o=d.total>0?n-t:100-i;return e=e||"",e=e.replace("{value}",t).replace("{total}",n).replace("{left}",o).replace("{percent}",i),d.verbose("Adding variables to progress bar text",e),e},normalizedValue:function(e){if(e<0)return d.debug("Value cannot decrement below 0"),0;if(d.has.total()){if(e>d.total)return d.debug("Value cannot increment above total",d.total),d.total}else if(e>100)return d.debug("Value cannot increment above 100 percent"),100;return e},updateInterval:function(){return"auto"==f.updateInterval?f.duration:f.updateInterval},randomValue:function(){return d.debug("Generating random increment percentage"),Math.floor(Math.random()*f.random.max+f.random.min)},numericValue:function(e){return"string"==typeof e?""!==e.replace(/[^\d.]/g,"")&&+e.replace(/[^\d.]/g,""):e},transitionEnd:function(){var e,t=n.createElement("element"),i={transition:"transitionend",OTransition:"oTransitionEnd",MozTransition:"transitionend",WebkitTransition:"webkitTransitionEnd"};for(e in i)if(void 0!==t.style[e])return i[e]},displayPercent:function(){var e=C.width(),t=x.width(),n=parseInt(C.css("min-width"),10),i=e>n?e/t*100:d.percent;return f.precision>0?Math.round(i*(10*f.precision))/(10*f.precision):Math.round(i)},percent:function(){return d.percent||0},value:function(){return d.nextValue||d.value||0},total:function(){return d.total||!1}},create:{progressPoll:function(){d.progressPoll=setTimeout(function(){d.update.toNextValue(),d.remove.progressPoll()},d.get.updateInterval())}},is:{complete:function(){return d.is.success()||d.is.warning()||d.is.error()},success:function(){return x.hasClass(m.success)},warning:function(){return x.hasClass(m.warning)},error:function(){return x.hasClass(m.error)},active:function(){return x.hasClass(m.active)},visible:function(){return x.is(":visible")}},remove:{progressPoll:function(){d.verbose("Removing progress poll timer"),d.progressPoll&&(clearTimeout(d.progressPoll),delete d.progressPoll)},nextValue:function(){d.verbose("Removing progress value stored for next update"),delete d.nextValue},state:function(){d.verbose("Removing stored state"),delete d.total,delete d.percent,delete d.value},active:function(){d.verbose("Removing active state"),x.removeClass(m.active)},success:function(){d.verbose("Removing success state"),x.removeClass(m.success)},warning:function(){d.verbose("Removing warning state"),x.removeClass(m.warning)},error:function(){d.verbose("Removing error state"),x.removeClass(m.error)}},set:{barWidth:function(e){e>100?d.error(h.tooHigh,e):e<0?d.error(h.tooLow,e):(C.css("width",e+"%"),x.attr("data-percent",parseInt(e,10)))},duration:function(e){e=e||f.duration,e="number"==typeof e?e+"ms":e,d.verbose("Setting progress bar transition duration",e),C.css({"transition-duration":e})},percent:function(e){e="string"==typeof e?+e.replace("%",""):e,e=f.precision>0?Math.round(e*(10*f.precision))/(10*f.precision):Math.round(e),d.percent=e,d.has.total()||(d.value=f.precision>0?Math.round(e/100*d.total*(10*f.precision))/(10*f.precision):Math.round(e/100*d.total*10)/10,f.limitValues&&(d.value=d.value>100?100:d.value<0?0:d.value)),d.set.barWidth(e),d.set.labelInterval(),d.set.labels(),f.onChange.call(S,e,d.value,d.total)},labelInterval:function(){var t=function(){d.verbose("Bar finished animating, removing continuous label updates"),clearInterval(d.interval),A=!1,d.set.labels()};clearInterval(d.interval),d.bind.transitionEnd(t),A=!0,d.interval=setInterval(function(){e.contains(n.documentElement,S)||(clearInterval(d.interval),A=!1),d.set.labels()},f.framerate)},labels:function(){d.verbose("Setting both bar progress and outer label text"),d.set.barLabel(),d.set.state()},label:function(e){(e=e||"")&&(e=d.get.text(e),d.verbose("Setting label to text",e),k.text(e))},state:function(e){e=void 0!==e?e:d.percent,100===e?f.autoSuccess&&!(d.is.warning()||d.is.error()||d.is.success())?(d.set.success(),d.debug("Automatically triggering success at 100%")):(d.verbose("Reached 100% removing active state"),d.remove.active(),d.remove.progressPoll()):e>0?(d.verbose("Adjusting active progress bar label",e),d.set.active()):(d.remove.active(),d.set.label(f.text.active))},barLabel:function(e){void 0!==e?w.text(d.get.text(e)):"ratio"==f.label&&d.total?(d.verbose("Adding ratio to bar label"),w.text(d.get.text(f.text.ratio))):"percent"==f.label&&(d.verbose("Adding percentage to bar label"),w.text(d.get.text(f.text.percent)))},active:function(e){e=e||f.text.active,d.debug("Setting active state"),f.showActivity&&!d.is.active()&&x.addClass(m.active),d.remove.warning(),d.remove.error(),d.remove.success(),e=f.onLabelUpdate("active",e,d.value,d.total),e&&d.set.label(e),d.bind.transitionEnd(function(){f.onActive.call(S,d.value,d.total)})},success:function(e){e=e||f.text.success||f.text.active,d.debug("Setting success state"),x.addClass(m.success),d.remove.active(),d.remove.warning(),d.remove.error(),d.complete(),f.text.success?(e=f.onLabelUpdate("success",e,d.value,d.total),d.set.label(e)):(e=f.onLabelUpdate("active",e,d.value,d.total),d.set.label(e)),d.bind.transitionEnd(function(){f.onSuccess.call(S,d.total)})},warning:function(e){e=e||f.text.warning,d.debug("Setting warning state"),x.addClass(m.warning),d.remove.active(),d.remove.success(),d.remove.error(),d.complete(),e=f.onLabelUpdate("warning",e,d.value,d.total),e&&d.set.label(e),d.bind.transitionEnd(function(){f.onWarning.call(S,d.value,d.total)})},error:function(e){e=e||f.text.error,d.debug("Setting error state"),x.addClass(m.error),d.remove.active(),d.remove.success(),d.remove.warning(),d.complete(),e=f.onLabelUpdate("error",e,d.value,d.total),e&&d.set.label(e),d.bind.transitionEnd(function(){f.onError.call(S,d.value,d.total)})},transitionEvent:function(){o=d.get.transitionEnd()},total:function(e){d.total=e},value:function(e){d.value=e},progress:function(e){d.has.progressPoll()?(d.debug("Updated within interval, setting next update to use new value",e),d.set.nextValue(e)):(d.debug("First update in progress update interval, immediately updating",e),d.update.progress(e),d.create.progressPoll())},nextValue:function(e){d.nextValue=e}},update:{toNextValue:function(){var e=d.nextValue;e&&(d.debug("Update interval complete using last updated value",e),d.update.progress(e),d.remove.nextValue())},progress:function(e){var t;e=d.get.numericValue(e),!1===e&&d.error(h.nonNumeric,e),e=d.get.normalizedValue(e),d.has.total()?(d.set.value(e),t=e/d.total*100,d.debug("Calculating percent complete from total",t),d.set.percent(t)):(t=e,d.debug("Setting value to exact percentage value",t),d.set.percent(t))}},setting:function(t,n){if(d.debug("Changing setting",t,n),e.isPlainObject(t))e.extend(!0,f,t);else{if(void 0===n)return f[t];e.isPlainObject(f[t])?e.extend(!0,f[t],n):f[t]=n}},internal:function(t,n){if(e.isPlainObject(t))e.extend(!0,d,t);else{if(void 0===n)return d[t];d[t]=n}},debug:function(){!f.silent&&f.debug&&(f.performance?d.performance.log(arguments):(d.debug=Function.prototype.bind.call(console.info,console,f.name+":"),d.debug.apply(console,arguments)))},verbose:function(){!f.silent&&f.verbose&&f.debug&&(f.performance?d.performance.log(arguments):(d.verbose=Function.prototype.bind.call(console.info,console,f.name+":"),d.verbose.apply(console,arguments)))},error:function(){f.silent||(d.error=Function.prototype.bind.call(console.error,console,f.name+":"),d.error.apply(console,arguments))},performance:{log:function(e){var t,n,i;f.performance&&(t=(new Date).getTime(),i=r||t,n=t-i,r=t,s.push({Name:e[0],Arguments:[].slice.call(e,1)||"",Element:S,"Execution Time":n})),clearTimeout(d.performance.timer),d.performance.timer=setTimeout(d.performance.display,500)},display:function(){var t=f.name+":",n=0;r=!1,clearTimeout(d.performance.timer),e.each(s,function(e,t){n+=t["Execution Time"]}),t+=" "+n+"ms",a&&(t+=" '"+a+"'"),(void 0!==console.group||void 0!==console.table)&&s.length>0&&(console.groupCollapsed(t),console.table?console.table(s):e.each(s,function(e,t){console.log(t.Name+": "+t["Execution Time"]+"ms")}),console.groupEnd()),s=[]}},invoke:function(t,n,o){var a,r,s,l=T;return n=n||u,o=S||o,"string"==typeof t&&void 0!==l&&(t=t.split(/[\. ]/),a=t.length-1,e.each(t,function(n,i){var o=n!=a?i+t[n+1].charAt(0).toUpperCase()+t[n+1].slice(1):t;if(e.isPlainObject(l[o])&&n!=a)l=l[o];else{if(void 0!==l[o])return r=l[o],!1;if(!e.isPlainObject(l[i])||n==a)return void 0!==l[i]?(r=l[i],!1):(d.error(h.method,t),!1);l=l[i]}})),e.isFunction(r)?s=r.apply(o,n):void 0!==r&&(s=r),e.isArray(i)?i.push(s):void 0!==i?i=[i,s]:void 0!==s&&(i=s),r}},c?(void 0===T&&d.initialize(),d.invoke(l)):(void 0!==T&&T.invoke("destroy"),d.initialize())}),void 0!==i?i:this},e.fn.progress.settings={name:"Progress",namespace:"progress",silent:!1,debug:!1,verbose:!1,performance:!0,random:{min:2,max:5},duration:300,updateInterval:"auto",autoSuccess:!0,showActivity:!0,limitValues:!0,label:"percent",precision:0,framerate:1e3/30,percent:!1,total:!1,value:!1,failSafeDelay:100,onLabelUpdate:function(e,t,n,i){return t},onChange:function(e,t,n){},onSuccess:function(e){},onActive:function(e,t){},onError:function(e,t){},onWarning:function(e,t){},error:{method:"The method you called is not defined.",nonNumeric:"Progress value is non numeric",tooHigh:"Value specified is above 100%",tooLow:"Value specified is below 0%"},regExp:{variable:/\{\$*[A-z0-9]+\}/g},metadata:{percent:"percent",total:"total",value:"value"},selector:{bar:"> .bar",label:"> .label",progress:".bar > .progress"},text:{active:!1,error:!1,success:!1,warning:!1,percent:"{percent}%",ratio:"{value} of {total}"},className:{active:"active",error:"error",success:"success",warning:"warning"}}}(jQuery,window,document),function(e,t,n,i){"use strict";t=void 0!==t&&t.Math==Math?t:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")(),e.fn.rating=function(t){var n,i=e(this),o=i.selector||"",a=(new Date).getTime(),r=[],s=arguments[0],l="string"==typeof s,c=[].slice.call(arguments,1);return i.each(function(){var u,d,f=e.isPlainObject(t)?e.extend(!0,{},e.fn.rating.settings,t):e.extend({},e.fn.rating.settings),m=f.namespace,g=f.className,v=f.metadata,p=f.selector,h=(f.error,"."+m),b="module-"+m,y=this,x=e(this).data(b),C=e(this),w=C.find(p.icon);d={initialize:function(){d.verbose("Initializing rating module",f),0===w.length&&d.setup.layout(),f.interactive?d.enable():d.disable(),d.set.initialLoad(),d.set.rating(d.get.initialRating()),d.remove.initialLoad(),d.instantiate()},instantiate:function(){d.verbose("Instantiating module",f),x=d,C.data(b,d)},destroy:function(){d.verbose("Destroying previous instance",x),d.remove.events(),C.removeData(b)},refresh:function(){w=C.find(p.icon)},setup:{layout:function(){var t=d.get.maxRating(),n=e.fn.rating.settings.templates.icon(t);d.debug("Generating icon html dynamically"),C.html(n),d.refresh()}},event:{mouseenter:function(){var t=e(this);t.nextAll().removeClass(g.selected),C.addClass(g.selected),t.addClass(g.selected).prevAll().addClass(g.selected)},mouseleave:function(){C.removeClass(g.selected),w.removeClass(g.selected)},click:function(){var t=e(this),n=d.get.rating(),i=w.index(t)+1;("auto"==f.clearable?1===w.length:f.clearable)&&n==i?d.clearRating():d.set.rating(i)}},clearRating:function(){d.debug("Clearing current rating"),d.set.rating(0)},bind:{events:function(){d.verbose("Binding events"),C.on("mouseenter"+h,p.icon,d.event.mouseenter).on("mouseleave"+h,p.icon,d.event.mouseleave).on("click"+h,p.icon,d.event.click)}},remove:{events:function(){d.verbose("Removing events"),C.off(h)},initialLoad:function(){u=!1}},enable:function(){d.debug("Setting rating to interactive mode"),d.bind.events(),C.removeClass(g.disabled)},disable:function(){d.debug("Setting rating to read-only mode"),d.remove.events(),C.addClass(g.disabled)},is:{initialLoad:function(){return u}},get:{initialRating:function(){return void 0!==C.data(v.rating)?(C.removeData(v.rating),C.data(v.rating)):f.initialRating},maxRating:function(){return void 0!==C.data(v.maxRating)?(C.removeData(v.maxRating),C.data(v.maxRating)):f.maxRating},rating:function(){var e=w.filter("."+g.active).length;return d.verbose("Current rating retrieved",e),e}},set:{rating:function(e){var t=e-1>=0?e-1:0,n=w.eq(t);C.removeClass(g.selected),w.removeClass(g.selected).removeClass(g.active),e>0&&(d.verbose("Setting current rating to",e),n.prevAll().addBack().addClass(g.active)),d.is.initialLoad()||f.onRate.call(y,e)},initialLoad:function(){u=!0}},setting:function(t,n){if(d.debug("Changing setting",t,n),e.isPlainObject(t))e.extend(!0,f,t);else{if(void 0===n)return f[t];e.isPlainObject(f[t])?e.extend(!0,f[t],n):f[t]=n}},internal:function(t,n){if(e.isPlainObject(t))e.extend(!0,d,t);else{if(void 0===n)return d[t];d[t]=n}},debug:function(){!f.silent&&f.debug&&(f.performance?d.performance.log(arguments):(d.debug=Function.prototype.bind.call(console.info,console,f.name+":"),
d.debug.apply(console,arguments)))},verbose:function(){!f.silent&&f.verbose&&f.debug&&(f.performance?d.performance.log(arguments):(d.verbose=Function.prototype.bind.call(console.info,console,f.name+":"),d.verbose.apply(console,arguments)))},error:function(){f.silent||(d.error=Function.prototype.bind.call(console.error,console,f.name+":"),d.error.apply(console,arguments))},performance:{log:function(e){var t,n,i;f.performance&&(t=(new Date).getTime(),i=a||t,n=t-i,a=t,r.push({Name:e[0],Arguments:[].slice.call(e,1)||"",Element:y,"Execution Time":n})),clearTimeout(d.performance.timer),d.performance.timer=setTimeout(d.performance.display,500)},display:function(){var t=f.name+":",n=0;a=!1,clearTimeout(d.performance.timer),e.each(r,function(e,t){n+=t["Execution Time"]}),t+=" "+n+"ms",o&&(t+=" '"+o+"'"),i.length>1&&(t+=" ("+i.length+")"),(void 0!==console.group||void 0!==console.table)&&r.length>0&&(console.groupCollapsed(t),console.table?console.table(r):e.each(r,function(e,t){console.log(t.Name+": "+t["Execution Time"]+"ms")}),console.groupEnd()),r=[]}},invoke:function(t,i,o){var a,r,s,l=x;return i=i||c,o=y||o,"string"==typeof t&&void 0!==l&&(t=t.split(/[\. ]/),a=t.length-1,e.each(t,function(n,i){var o=n!=a?i+t[n+1].charAt(0).toUpperCase()+t[n+1].slice(1):t;if(e.isPlainObject(l[o])&&n!=a)l=l[o];else{if(void 0!==l[o])return r=l[o],!1;if(!e.isPlainObject(l[i])||n==a)return void 0!==l[i]&&(r=l[i],!1);l=l[i]}})),e.isFunction(r)?s=r.apply(o,i):void 0!==r&&(s=r),e.isArray(n)?n.push(s):void 0!==n?n=[n,s]:void 0!==s&&(n=s),r}},l?(void 0===x&&d.initialize(),d.invoke(s)):(void 0!==x&&x.invoke("destroy"),d.initialize())}),void 0!==n?n:this},e.fn.rating.settings={name:"Rating",namespace:"rating",slent:!1,debug:!1,verbose:!1,performance:!0,initialRating:0,interactive:!0,maxRating:4,clearable:"auto",fireOnInit:!1,onRate:function(e){},error:{method:"The method you called is not defined",noMaximum:"No maximum rating specified. Cannot generate HTML automatically"},metadata:{rating:"rating",maxRating:"maxRating"},className:{active:"active",disabled:"disabled",selected:"selected",loading:"loading"},selector:{icon:".icon"},templates:{icon:function(e){for(var t=1,n="";t<=e;)n+='<i class="icon"></i>',t++;return n}}}}(jQuery,window,document),function(e,t,n,i){"use strict";t=void 0!==t&&t.Math==Math?t:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")(),e.fn.search=function(i){var o,a=e(this),r=a.selector||"",s=(new Date).getTime(),l=[],c=arguments[0],u="string"==typeof c,d=[].slice.call(arguments,1);return e(this).each(function(){var f,m=e.isPlainObject(i)?e.extend(!0,{},e.fn.search.settings,i):e.extend({},e.fn.search.settings),g=m.className,v=m.metadata,p=m.regExp,h=m.fields,b=m.selector,y=m.error,x=m.namespace,C="."+x,w=x+"-module",k=e(this),S=k.find(b.prompt),T=k.find(b.searchButton),A=k.find(b.results),R=k.find(b.result),P=k.find(b.category),E=this,F=k.data(w),O=!1,D=!1;f={initialize:function(){f.verbose("Initializing module"),f.determine.searchFields(),f.bind.events(),f.set.type(),f.create.results(),f.instantiate()},instantiate:function(){f.verbose("Storing instance of module",f),F=f,k.data(w,f)},destroy:function(){f.verbose("Destroying instance"),k.off(C).removeData(w)},refresh:function(){f.debug("Refreshing selector cache"),S=k.find(b.prompt),T=k.find(b.searchButton),P=k.find(b.category),A=k.find(b.results),R=k.find(b.result)},refreshResults:function(){A=k.find(b.results),R=k.find(b.result)},bind:{events:function(){f.verbose("Binding events to search"),m.automatic&&(k.on(f.get.inputEvent()+C,b.prompt,f.event.input),S.attr("autocomplete","off")),k.on("focus"+C,b.prompt,f.event.focus).on("blur"+C,b.prompt,f.event.blur).on("keydown"+C,b.prompt,f.handleKeyboard).on("click"+C,b.searchButton,f.query).on("mousedown"+C,b.results,f.event.result.mousedown).on("mouseup"+C,b.results,f.event.result.mouseup).on("click"+C,b.result,f.event.result.click)}},determine:{searchFields:function(){i&&void 0!==i.searchFields&&(m.searchFields=i.searchFields)}},event:{input:function(){clearTimeout(f.timer),f.timer=setTimeout(f.query,m.searchDelay)},focus:function(){f.set.focus(),m.searchOnFocus&&f.has.minimumCharacters()&&f.query(function(){f.can.show()&&f.showResults()})},blur:function(e){var t=n.activeElement===this,i=function(){f.cancel.query(),f.remove.focus(),f.timer=setTimeout(f.hideResults,m.hideDelay)};t||(D=!1,f.resultsClicked?(f.debug("Determining if user action caused search to close"),k.one("click.close"+C,b.results,function(e){if(f.is.inMessage(e)||O)return void S.focus();O=!1,f.is.animating()||f.is.hidden()||i()})):(f.debug("Input blurred without user action, closing results"),i()))},result:{mousedown:function(){f.resultsClicked=!0},mouseup:function(){f.resultsClicked=!1},click:function(n){f.debug("Search result selected");var i=e(this),o=i.find(b.title).eq(0),a=i.is("a[href]")?i:i.find("a[href]").eq(0),r=a.attr("href")||!1,s=a.attr("target")||!1,l=(o.html(),o.length>0&&o.text()),c=f.get.results(),u=i.data(v.result)||f.get.result(l,c);if(e.isFunction(m.onSelect)&&!1===m.onSelect.call(E,u,c))return f.debug("Custom onSelect callback cancelled default select action"),void(O=!0);f.hideResults(),l&&f.set.value(l),r&&(f.verbose("Opening search link found in result",a),"_blank"==s||n.ctrlKey?t.open(r):t.location.href=r)}}},handleKeyboard:function(e){var t,n=k.find(b.result),i=k.find(b.category),o=n.filter("."+g.active),a=n.index(o),r=n.length,s=o.length>0,l=e.which,c={backspace:8,enter:13,escape:27,upArrow:38,downArrow:40};if(l==c.escape&&(f.verbose("Escape key pressed, blurring search field"),f.hideResults(),D=!0),f.is.visible())if(l==c.enter){if(f.verbose("Enter key pressed, selecting active result"),n.filter("."+g.active).length>0)return f.event.result.click.call(n.filter("."+g.active),e),e.preventDefault(),!1}else l==c.upArrow&&s?(f.verbose("Up key pressed, changing active result"),t=a-1<0?a:a-1,i.removeClass(g.active),n.removeClass(g.active).eq(t).addClass(g.active).closest(i).addClass(g.active),e.preventDefault()):l==c.downArrow&&(f.verbose("Down key pressed, changing active result"),t=a+1>=r?a:a+1,i.removeClass(g.active),n.removeClass(g.active).eq(t).addClass(g.active).closest(i).addClass(g.active),e.preventDefault());else l==c.enter&&(f.verbose("Enter key pressed, executing query"),f.query(),f.set.buttonPressed(),S.one("keyup",f.remove.buttonFocus))},setup:{api:function(t,n){var i={debug:m.debug,on:!1,cache:!0,action:"search",urlData:{query:t},onSuccess:function(e){f.parse.response.call(E,e,t),n()},onFailure:function(){f.displayMessage(y.serverError),n()},onAbort:function(e){},onError:f.error};e.extend(!0,i,m.apiSettings),f.verbose("Setting up API request",i),k.api(i)}},can:{useAPI:function(){return void 0!==e.fn.api},show:function(){return f.is.focused()&&!f.is.visible()&&!f.is.empty()},transition:function(){return m.transition&&void 0!==e.fn.transition&&k.transition("is supported")}},is:{animating:function(){return A.hasClass(g.animating)},hidden:function(){return A.hasClass(g.hidden)},inMessage:function(t){if(t.target){var i=e(t.target);return e.contains(n.documentElement,t.target)&&i.closest(b.message).length>0}},empty:function(){return""===A.html()},visible:function(){return A.filter(":visible").length>0},focused:function(){return S.filter(":focus").length>0}},get:{inputEvent:function(){var e=S[0];return void 0!==e&&void 0!==e.oninput?"input":void 0!==e&&void 0!==e.onpropertychange?"propertychange":"keyup"},value:function(){return S.val()},results:function(){return k.data(v.results)},result:function(t,n){var i=["title","id"],o=!1;return t=void 0!==t?t:f.get.value(),n=void 0!==n?n:f.get.results(),"category"===m.type?(f.debug("Finding result that matches",t),e.each(n,function(n,a){if(e.isArray(a.results)&&(o=f.search.object(t,a.results,i)[0]))return!1})):(f.debug("Finding result in results object",t),o=f.search.object(t,n,i)[0]),o||!1}},select:{firstResult:function(){f.verbose("Selecting first result"),R.first().addClass(g.active)}},set:{focus:function(){k.addClass(g.focus)},loading:function(){k.addClass(g.loading)},value:function(e){f.verbose("Setting search input value",e),S.val(e)},type:function(e){e=e||m.type,"category"==m.type&&k.addClass(m.type)},buttonPressed:function(){T.addClass(g.pressed)}},remove:{loading:function(){k.removeClass(g.loading)},focus:function(){k.removeClass(g.focus)},buttonPressed:function(){T.removeClass(g.pressed)}},query:function(t){t=e.isFunction(t)?t:function(){};var n=f.get.value(),i=f.read.cache(n);t=t||function(){},f.has.minimumCharacters()?(i?(f.debug("Reading result from cache",n),f.save.results(i.results),f.addResults(i.html),f.inject.id(i.results),t()):(f.debug("Querying for",n),e.isPlainObject(m.source)||e.isArray(m.source)?(f.search.local(n),t()):f.can.useAPI()?f.search.remote(n,t):(f.error(y.source),t())),m.onSearchQuery.call(E,n)):f.hideResults()},search:{local:function(e){var t,n=f.search.object(e,m.content);f.set.loading(),f.save.results(n),f.debug("Returned local search results",n),t=f.generateResults({results:n}),f.remove.loading(),f.addResults(t),f.inject.id(n),f.write.cache(e,{html:t,results:n})},remote:function(t,n){n=e.isFunction(n)?n:function(){},k.api("is loading")&&k.api("abort"),f.setup.api(t,n),k.api("query")},object:function(t,n,i){var o=[],a=[],r=t.toString().replace(p.escape,"\\$&"),s=new RegExp(p.beginsWith+r,"i"),l=function(t,n){var i=-1==e.inArray(n,o),r=-1==e.inArray(n,a);i&&r&&t.push(n)};return n=n||m.source,i=void 0!==i?i:m.searchFields,e.isArray(i)||(i=[i]),void 0===n||!1===n?(f.error(y.source),[]):(e.each(i,function(i,r){e.each(n,function(e,n){"string"==typeof n[r]&&(-1!==n[r].search(s)?l(o,n):m.searchFullText&&f.fuzzySearch(t,n[r])&&l(a,n))})}),e.merge(o,a))}},fuzzySearch:function(e,t){var n=t.length,i=e.length;if("string"!=typeof e)return!1;if(e=e.toLowerCase(),t=t.toLowerCase(),i>n)return!1;if(i===n)return e===t;e:for(var o=0,a=0;o<i;o++){for(var r=e.charCodeAt(o);a<n;)if(t.charCodeAt(a++)===r)continue e;return!1}return!0},parse:{response:function(e,t){var n=f.generateResults(e);f.verbose("Parsing server response",e),void 0!==e&&void 0!==t&&void 0!==e[h.results]&&(f.addResults(n),f.inject.id(e[h.results]),f.write.cache(t,{html:n,results:e[h.results]}),f.save.results(e[h.results]))}},cancel:{query:function(){f.can.useAPI()&&k.api("abort")}},has:{minimumCharacters:function(){return f.get.value().length>=m.minCharacters},results:function(){return 0!==A.length&&""!=A.html()}},clear:{cache:function(e){var t=k.data(v.cache);e?e&&t&&t[e]&&(f.debug("Removing value from cache",e),delete t[e],k.data(v.cache,t)):(f.debug("Clearing cache",e),k.removeData(v.cache))}},read:{cache:function(e){var t=k.data(v.cache);return!!m.cache&&(f.verbose("Checking cache for generated html for query",e),"object"==typeof t&&void 0!==t[e]&&t[e])}},create:{id:function(e,t){var n,i,o=e+1;return void 0!==t?(n=String.fromCharCode(97+t),i=n+o,f.verbose("Creating category result id",i)):(i=o,f.verbose("Creating result id",i)),i},results:function(){0===A.length&&(A=e("<div />").addClass(g.results).appendTo(k))}},inject:{result:function(e,t,n){f.verbose("Injecting result into results");var i=void 0!==n?A.children().eq(n).children(b.result).eq(t):A.children(b.result).eq(t);f.verbose("Injecting results metadata",i),i.data(v.result,e)},id:function(t){f.debug("Injecting unique ids into results");var n=0,i=0;return"category"===m.type?e.each(t,function(t,o){i=0,e.each(o.results,function(e,t){var a=o.results[e];void 0===a.id&&(a.id=f.create.id(i,n)),f.inject.result(a,i,n),i++}),n++}):e.each(t,function(e,n){var o=t[e];void 0===o.id&&(o.id=f.create.id(i)),f.inject.result(o,i),i++}),t}},save:{results:function(e){f.verbose("Saving current search results to metadata",e),k.data(v.results,e)}},write:{cache:function(e,t){var n=void 0!==k.data(v.cache)?k.data(v.cache):{};m.cache&&(f.verbose("Writing generated html to cache",e,t),n[e]=t,k.data(v.cache,n))}},addResults:function(t){if(e.isFunction(m.onResultsAdd)&&!1===m.onResultsAdd.call(A,t))return f.debug("onResultsAdd callback cancelled default action"),!1;t?(A.html(t),f.refreshResults(),m.selectFirstResult&&f.select.firstResult(),f.showResults()):f.hideResults(function(){A.empty()})},showResults:function(t){t=e.isFunction(t)?t:function(){},D||!f.is.visible()&&f.has.results()&&(f.can.transition()?(f.debug("Showing results with css animations"),A.transition({animation:m.transition+" in",debug:m.debug,verbose:m.verbose,duration:m.duration,onComplete:function(){t()},queue:!0})):(f.debug("Showing results with javascript"),A.stop().fadeIn(m.duration,m.easing)),m.onResultsOpen.call(A))},hideResults:function(t){t=e.isFunction(t)?t:function(){},f.is.visible()&&(f.can.transition()?(f.debug("Hiding results with css animations"),A.transition({animation:m.transition+" out",debug:m.debug,verbose:m.verbose,duration:m.duration,onComplete:function(){t()},queue:!0})):(f.debug("Hiding results with javascript"),A.stop().fadeOut(m.duration,m.easing)),m.onResultsClose.call(A))},generateResults:function(t){f.debug("Generating html from response",t);var n=m.templates[m.type],i=e.isPlainObject(t[h.results])&&!e.isEmptyObject(t[h.results]),o=e.isArray(t[h.results])&&t[h.results].length>0,a="";return i||o?(m.maxResults>0&&(i?"standard"==m.type&&f.error(y.maxResults):t[h.results]=t[h.results].slice(0,m.maxResults)),e.isFunction(n)?a=n(t,h):f.error(y.noTemplate,!1)):m.showNoResults&&(a=f.displayMessage(y.noResults,"empty")),m.onResults.call(E,t),a},displayMessage:function(e,t){return t=t||"standard",f.debug("Displaying message",e,t),f.addResults(m.templates.message(e,t)),m.templates.message(e,t)},setting:function(t,n){if(e.isPlainObject(t))e.extend(!0,m,t);else{if(void 0===n)return m[t];m[t]=n}},internal:function(t,n){if(e.isPlainObject(t))e.extend(!0,f,t);else{if(void 0===n)return f[t];f[t]=n}},debug:function(){!m.silent&&m.debug&&(m.performance?f.performance.log(arguments):(f.debug=Function.prototype.bind.call(console.info,console,m.name+":"),f.debug.apply(console,arguments)))},verbose:function(){!m.silent&&m.verbose&&m.debug&&(m.performance?f.performance.log(arguments):(f.verbose=Function.prototype.bind.call(console.info,console,m.name+":"),f.verbose.apply(console,arguments)))},error:function(){m.silent||(f.error=Function.prototype.bind.call(console.error,console,m.name+":"),f.error.apply(console,arguments))},performance:{log:function(e){var t,n,i;m.performance&&(t=(new Date).getTime(),i=s||t,n=t-i,s=t,l.push({Name:e[0],Arguments:[].slice.call(e,1)||"",Element:E,"Execution Time":n})),clearTimeout(f.performance.timer),f.performance.timer=setTimeout(f.performance.display,500)},display:function(){var t=m.name+":",n=0;s=!1,clearTimeout(f.performance.timer),e.each(l,function(e,t){n+=t["Execution Time"]}),t+=" "+n+"ms",r&&(t+=" '"+r+"'"),a.length>1&&(t+=" ("+a.length+")"),(void 0!==console.group||void 0!==console.table)&&l.length>0&&(console.groupCollapsed(t),console.table?console.table(l):e.each(l,function(e,t){console.log(t.Name+": "+t["Execution Time"]+"ms")}),console.groupEnd()),l=[]}},invoke:function(t,n,i){var a,r,s,l=F;return n=n||d,i=E||i,"string"==typeof t&&void 0!==l&&(t=t.split(/[\. ]/),a=t.length-1,e.each(t,function(n,i){var o=n!=a?i+t[n+1].charAt(0).toUpperCase()+t[n+1].slice(1):t;if(e.isPlainObject(l[o])&&n!=a)l=l[o];else{if(void 0!==l[o])return r=l[o],!1;if(!e.isPlainObject(l[i])||n==a)return void 0!==l[i]&&(r=l[i],!1);l=l[i]}})),e.isFunction(r)?s=r.apply(i,n):void 0!==r&&(s=r),e.isArray(o)?o.push(s):void 0!==o?o=[o,s]:void 0!==s&&(o=s),r}},u?(void 0===F&&f.initialize(),f.invoke(c)):(void 0!==F&&F.invoke("destroy"),f.initialize())}),void 0!==o?o:this},e.fn.search.settings={name:"Search",namespace:"search",silent:!1,debug:!1,verbose:!1,performance:!0,type:"standard",minCharacters:1,selectFirstResult:!1,apiSettings:!1,source:!1,searchOnFocus:!0,searchFields:["title","description"],displayField:"",searchFullText:!0,automatic:!0,hideDelay:0,searchDelay:200,maxResults:7,cache:!0,showNoResults:!0,transition:"scale",duration:200,easing:"easeOutExpo",onSelect:!1,onResultsAdd:!1,onSearchQuery:function(e){},onResults:function(e){},onResultsOpen:function(){},onResultsClose:function(){},className:{animating:"animating",active:"active",empty:"empty",focus:"focus",hidden:"hidden",loading:"loading",results:"results",pressed:"down"},error:{source:"Cannot search. No source used, and Semantic API module was not included",noResults:"Your search returned no results",logging:"Error in debug logging, exiting.",noEndpoint:"No search endpoint was specified",noTemplate:"A valid template name was not specified.",serverError:"There was an issue querying the server.",maxResults:"Results must be an array to use maxResults setting",method:"The method you called is not defined."},metadata:{cache:"cache",results:"results",result:"result"},regExp:{escape:/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,beginsWith:"(?:s|^)"},fields:{categories:"results",categoryName:"name",categoryResults:"results",description:"description",image:"image",price:"price",results:"results",title:"title",url:"url",action:"action",actionText:"text",actionURL:"url"},selector:{prompt:".prompt",searchButton:".search.button",results:".results",message:".results > .message",category:".category",result:".result",title:".title, .name"},templates:{escape:function(e){var t=/[&<>"'`]/g,n=/[&<>"'`]/,i={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","`":"&#x60;"},o=function(e){return i[e]};return n.test(e)?e.replace(t,o):e},message:function(e,t){var n="";return void 0!==e&&void 0!==t&&(n+='<div class="message '+t+'">',n+="empty"==t?'<div class="header">No Results</div class="header"><div class="description">'+e+'</div class="description">':' <div class="description">'+e+"</div>",n+="</div>"),n},category:function(t,n){var i="";e.fn.search.settings.templates.escape;return void 0!==t[n.categoryResults]&&(e.each(t[n.categoryResults],function(t,o){void 0!==o[n.results]&&o.results.length>0&&(i+='<div class="category">',void 0!==o[n.categoryName]&&(i+='<div class="name">'+o[n.categoryName]+"</div>"),e.each(o.results,function(e,t){t[n.url]?i+='<a class="result" href="'+t[n.url]+'">':i+='<a class="result">',void 0!==t[n.image]&&(i+='<div class="image"> <img src="'+t[n.image]+'"></div>'),i+='<div class="content">',void 0!==t[n.price]&&(i+='<div class="price">'+t[n.price]+"</div>"),void 0!==t[n.title]&&(i+='<div class="title">'+t[n.title]+"</div>"),void 0!==t[n.description]&&(i+='<div class="description">'+t[n.description]+"</div>"),i+="</div>",i+="</a>"}),i+="</div>")}),t[n.action]&&(i+='<a href="'+t[n.action][n.actionURL]+'" class="action">'+t[n.action][n.actionText]+"</a>"),i)},standard:function(t,n){var i="";return void 0!==t[n.results]&&(e.each(t[n.results],function(e,t){t[n.url]?i+='<a class="result" href="'+t[n.url]+'">':i+='<a class="result">',void 0!==t[n.image]&&(i+='<div class="image"> <img src="'+t[n.image]+'"></div>'),i+='<div class="content">',void 0!==t[n.price]&&(i+='<div class="price">'+t[n.price]+"</div>"),void 0!==t[n.title]&&(i+='<div class="title">'+t[n.title]+"</div>"),void 0!==t[n.description]&&(i+='<div class="description">'+t[n.description]+"</div>"),i+="</div>",i+="</a>"}),t[n.action]&&(i+='<a href="'+t[n.action][n.actionURL]+'" class="action">'+t[n.action][n.actionText]+"</a>"),i)}}}}(jQuery,window,document),function(e,t,n,i){"use strict";t=void 0!==t&&t.Math==Math?t:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")(),e.fn.shape=function(i){var o,a=e(this),r=(e("body"),(new Date).getTime()),s=[],l=arguments[0],c="string"==typeof l,u=[].slice.call(arguments,1),d=t.requestAnimationFrame||t.mozRequestAnimationFrame||t.webkitRequestAnimationFrame||t.msRequestAnimationFrame||function(e){setTimeout(e,0)};return a.each(function(){var t,f,m,g=a.selector||"",v=e.isPlainObject(i)?e.extend(!0,{},e.fn.shape.settings,i):e.extend({},e.fn.shape.settings),p=v.namespace,h=v.selector,b=v.error,y=v.className,x="."+p,C="module-"+p,w=e(this),k=w.find(h.sides),S=w.find(h.side),T=!1,A=this,R=w.data(C);m={initialize:function(){m.verbose("Initializing module for",A),m.set.defaultSide(),m.instantiate()},instantiate:function(){m.verbose("Storing instance of module",m),R=m,w.data(C,R)},destroy:function(){m.verbose("Destroying previous module for",A),w.removeData(C).off(x)},refresh:function(){m.verbose("Refreshing selector cache for",A),w=e(A),k=e(this).find(h.shape),S=e(this).find(h.side)},repaint:function(){m.verbose("Forcing repaint event");var e=k[0]||n.createElement("div");e.offsetWidth},animate:function(e,n){m.verbose("Animating box with properties",e),n=n||function(e){m.verbose("Executing animation callback"),void 0!==e&&e.stopPropagation(),m.reset(),m.set.active()},v.beforeChange.call(f[0]),m.get.transitionEvent()?(m.verbose("Starting CSS animation"),w.addClass(y.animating),k.css(e).one(m.get.transitionEvent(),n),m.set.duration(v.duration),d(function(){w.addClass(y.animating),t.addClass(y.hidden)})):n()},queue:function(e){m.debug("Queueing animation of",e),k.one(m.get.transitionEvent(),function(){m.debug("Executing queued animation"),setTimeout(function(){w.shape(e)},0)})},reset:function(){m.verbose("Animating states reset"),w.removeClass(y.animating).attr("style","").removeAttr("style"),k.attr("style","").removeAttr("style"),S.attr("style","").removeAttr("style").removeClass(y.hidden),f.removeClass(y.animating).attr("style","").removeAttr("style")},is:{complete:function(){return S.filter("."+y.active)[0]==f[0]},animating:function(){return w.hasClass(y.animating)}},set:{defaultSide:function(){t=w.find("."+v.className.active),f=t.next(h.side).length>0?t.next(h.side):w.find(h.side).first(),T=!1,m.verbose("Active side set to",t),m.verbose("Next side set to",f)},duration:function(e){e=e||v.duration,e="number"==typeof e?e+"ms":e,m.verbose("Setting animation duration",e),(v.duration||0===v.duration)&&k.add(S).css({"-webkit-transition-duration":e,"-moz-transition-duration":e,"-ms-transition-duration":e,"-o-transition-duration":e,"transition-duration":e})},currentStageSize:function(){var e=w.find("."+v.className.active),t=e.outerWidth(!0),n=e.outerHeight(!0);w.css({width:t,height:n})},stageSize:function(){var e=w.clone().addClass(y.loading),t=e.find("."+v.className.active),n=T?e.find(h.side).eq(T):t.next(h.side).length>0?t.next(h.side):e.find(h.side).first(),i="next"==v.width?n.outerWidth(!0):"initial"==v.width?w.width():v.width,o="next"==v.height?n.outerHeight(!0):"initial"==v.height?w.height():v.height;t.removeClass(y.active),n.addClass(y.active),e.insertAfter(w),e.remove(),"auto"!=v.width&&(w.css("width",i+v.jitter),m.verbose("Specifying width during animation",i)),"auto"!=v.height&&(w.css("height",o+v.jitter),m.verbose("Specifying height during animation",o))},nextSide:function(e){T=e,f=S.filter(e),T=S.index(f),0===f.length&&(m.set.defaultSide(),m.error(b.side)),m.verbose("Next side manually set to",f)},active:function(){m.verbose("Setting new side to active",f),S.removeClass(y.active),f.addClass(y.active),v.onChange.call(f[0]),m.set.defaultSide()}},flip:{up:function(){if(m.is.complete()&&!m.is.animating()&&!v.allowRepeats)return void m.debug("Side already visible",f);if(m.is.animating())m.queue("flip up");else{m.debug("Flipping up",f);var e=m.get.transform.up();m.set.stageSize(),m.stage.above(),m.animate(e)}},down:function(){if(m.is.complete()&&!m.is.animating()&&!v.allowRepeats)return void m.debug("Side already visible",f);if(m.is.animating())m.queue("flip down");else{m.debug("Flipping down",f);var e=m.get.transform.down();m.set.stageSize(),m.stage.below(),m.animate(e)}},left:function(){if(m.is.complete()&&!m.is.animating()&&!v.allowRepeats)return void m.debug("Side already visible",f);if(m.is.animating())m.queue("flip left");else{m.debug("Flipping left",f);var e=m.get.transform.left();m.set.stageSize(),m.stage.left(),m.animate(e)}},right:function(){if(m.is.complete()&&!m.is.animating()&&!v.allowRepeats)return void m.debug("Side already visible",f);if(m.is.animating())m.queue("flip right");else{m.debug("Flipping right",f);var e=m.get.transform.right();m.set.stageSize(),m.stage.right(),m.animate(e)}},over:function(){if(m.is.complete()&&!m.is.animating()&&!v.allowRepeats)return void m.debug("Side already visible",f);m.is.animating()?m.queue("flip over"):(m.debug("Flipping over",f),m.set.stageSize(),m.stage.behind(),m.animate(m.get.transform.over()))},back:function(){if(m.is.complete()&&!m.is.animating()&&!v.allowRepeats)return void m.debug("Side already visible",f);m.is.animating()?m.queue("flip back"):(m.debug("Flipping back",f),m.set.stageSize(),m.stage.behind(),m.animate(m.get.transform.back()))}},get:{transform:{up:function(){var e={y:-(t.outerHeight(!0)-f.outerHeight(!0))/2,z:-t.outerHeight(!0)/2};return{transform:"translateY("+e.y+"px) translateZ("+e.z+"px) rotateX(-90deg)"}},down:function(){var e={y:-(t.outerHeight(!0)-f.outerHeight(!0))/2,z:-t.outerHeight(!0)/2};return{transform:"translateY("+e.y+"px) translateZ("+e.z+"px) rotateX(90deg)"}},left:function(){var e={x:-(t.outerWidth(!0)-f.outerWidth(!0))/2,z:-t.outerWidth(!0)/2};return{transform:"translateX("+e.x+"px) translateZ("+e.z+"px) rotateY(90deg)"}},right:function(){var e={x:-(t.outerWidth(!0)-f.outerWidth(!0))/2,z:-t.outerWidth(!0)/2};return{transform:"translateX("+e.x+"px) translateZ("+e.z+"px) rotateY(-90deg)"}},over:function(){return{transform:"translateX("+{x:-(t.outerWidth(!0)-f.outerWidth(!0))/2}.x+"px) rotateY(180deg)"}},back:function(){return{transform:"translateX("+{x:-(t.outerWidth(!0)-f.outerWidth(!0))/2}.x+"px) rotateY(-180deg)"}}},transitionEvent:function(){var e,t=n.createElement("element"),i={transition:"transitionend",OTransition:"oTransitionEnd",MozTransition:"transitionend",WebkitTransition:"webkitTransitionEnd"};for(e in i)if(void 0!==t.style[e])return i[e]},nextSide:function(){return t.next(h.side).length>0?t.next(h.side):w.find(h.side).first()}},stage:{above:function(){var e={origin:(t.outerHeight(!0)-f.outerHeight(!0))/2,depth:{active:f.outerHeight(!0)/2,next:t.outerHeight(!0)/2}};m.verbose("Setting the initial animation position as above",f,e),k.css({transform:"translateZ(-"+e.depth.active+"px)"}),t.css({transform:"rotateY(0deg) translateZ("+e.depth.active+"px)"}),f.addClass(y.animating).css({top:e.origin+"px",transform:"rotateX(90deg) translateZ("+e.depth.next+"px)"})},below:function(){var e={origin:(t.outerHeight(!0)-f.outerHeight(!0))/2,depth:{active:f.outerHeight(!0)/2,next:t.outerHeight(!0)/2}};m.verbose("Setting the initial animation position as below",f,e),k.css({transform:"translateZ(-"+e.depth.active+"px)"}),t.css({transform:"rotateY(0deg) translateZ("+e.depth.active+"px)"}),f.addClass(y.animating).css({top:e.origin+"px",transform:"rotateX(-90deg) translateZ("+e.depth.next+"px)"})},left:function(){var e={active:t.outerWidth(!0),next:f.outerWidth(!0)},n={origin:(e.active-e.next)/2,depth:{active:e.next/2,next:e.active/2}};m.verbose("Setting the initial animation position as left",f,n),k.css({transform:"translateZ(-"+n.depth.active+"px)"}),t.css({transform:"rotateY(0deg) translateZ("+n.depth.active+"px)"}),f.addClass(y.animating).css({left:n.origin+"px",transform:"rotateY(-90deg) translateZ("+n.depth.next+"px)"})},right:function(){var e={active:t.outerWidth(!0),next:f.outerWidth(!0)},n={origin:(e.active-e.next)/2,depth:{active:e.next/2,next:e.active/2}};m.verbose("Setting the initial animation position as left",f,n),k.css({transform:"translateZ(-"+n.depth.active+"px)"}),t.css({transform:"rotateY(0deg) translateZ("+n.depth.active+"px)"}),f.addClass(y.animating).css({left:n.origin+"px",transform:"rotateY(90deg) translateZ("+n.depth.next+"px)"})},behind:function(){var e={active:t.outerWidth(!0),next:f.outerWidth(!0)},n={origin:(e.active-e.next)/2,depth:{active:e.next/2,next:e.active/2}};m.verbose("Setting the initial animation position as behind",f,n),t.css({transform:"rotateY(0deg)"}),f.addClass(y.animating).css({left:n.origin+"px",transform:"rotateY(-180deg)"})}},setting:function(t,n){if(m.debug("Changing setting",t,n),e.isPlainObject(t))e.extend(!0,v,t);else{if(void 0===n)return v[t];e.isPlainObject(v[t])?e.extend(!0,v[t],n):v[t]=n}},internal:function(t,n){if(e.isPlainObject(t))e.extend(!0,m,t);else{if(void 0===n)return m[t];m[t]=n}},debug:function(){!v.silent&&v.debug&&(v.performance?m.performance.log(arguments):(m.debug=Function.prototype.bind.call(console.info,console,v.name+":"),m.debug.apply(console,arguments)))},verbose:function(){!v.silent&&v.verbose&&v.debug&&(v.performance?m.performance.log(arguments):(m.verbose=Function.prototype.bind.call(console.info,console,v.name+":"),m.verbose.apply(console,arguments)))},error:function(){v.silent||(m.error=Function.prototype.bind.call(console.error,console,v.name+":"),m.error.apply(console,arguments))},performance:{log:function(e){var t,n,i;v.performance&&(t=(new Date).getTime(),i=r||t,n=t-i,r=t,s.push({Name:e[0],Arguments:[].slice.call(e,1)||"",Element:A,"Execution Time":n})),clearTimeout(m.performance.timer),m.performance.timer=setTimeout(m.performance.display,500)},display:function(){var t=v.name+":",n=0;r=!1,clearTimeout(m.performance.timer),e.each(s,function(e,t){n+=t["Execution Time"]}),t+=" "+n+"ms",g&&(t+=" '"+g+"'"),a.length>1&&(t+=" ("+a.length+")"),(void 0!==console.group||void 0!==console.table)&&s.length>0&&(console.groupCollapsed(t),console.table?console.table(s):e.each(s,function(e,t){console.log(t.Name+": "+t["Execution Time"]+"ms")}),console.groupEnd()),s=[]}},invoke:function(t,n,i){var a,r,s,l=R;return n=n||u,i=A||i,"string"==typeof t&&void 0!==l&&(t=t.split(/[\. ]/),a=t.length-1,e.each(t,function(n,i){var o=n!=a?i+t[n+1].charAt(0).toUpperCase()+t[n+1].slice(1):t;if(e.isPlainObject(l[o])&&n!=a)l=l[o];else{if(void 0!==l[o])return r=l[o],!1;if(!e.isPlainObject(l[i])||n==a)return void 0!==l[i]&&(r=l[i],!1);l=l[i]}})),e.isFunction(r)?s=r.apply(i,n):void 0!==r&&(s=r),e.isArray(o)?o.push(s):void 0!==o?o=[o,s]:void 0!==s&&(o=s),r}},c?(void 0===R&&m.initialize(),m.invoke(l)):(void 0!==R&&R.invoke("destroy"),m.initialize())}),void 0!==o?o:this},e.fn.shape.settings={name:"Shape",silent:!1,debug:!1,verbose:!1,jitter:0,performance:!0,namespace:"shape",width:"initial",height:"initial",beforeChange:function(){},onChange:function(){},allowRepeats:!1,duration:!1,error:{side:"You tried to switch to a side that does not exist.",method:"The method you called is not defined"},className:{animating:"animating",hidden:"hidden",loading:"loading",active:"active"},selector:{sides:".sides",side:".side"}}}(jQuery,window,document),function(e,t,n,i){"use strict";t=void 0!==t&&t.Math==Math?t:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")(),e.fn.sidebar=function(i){var o,a=e(this),r=e(t),s=e(n),l=e("html"),c=e("head"),u=a.selector||"",d=(new Date).getTime(),f=[],m=arguments[0],g="string"==typeof m,v=[].slice.call(arguments,1),p=t.requestAnimationFrame||t.mozRequestAnimationFrame||t.webkitRequestAnimationFrame||t.msRequestAnimationFrame||function(e){setTimeout(e,0)};return a.each(function(){var a,h,b,y,x,C,w=e.isPlainObject(i)?e.extend(!0,{},e.fn.sidebar.settings,i):e.extend({},e.fn.sidebar.settings),k=w.selector,S=w.className,T=w.namespace,A=w.regExp,R=w.error,P="."+T,E="module-"+T,F=e(this),O=e(w.context),D=F.children(k.sidebar),q=O.children(k.fixed),j=O.children(k.pusher),z=this,I=F.data(E);C={initialize:function(){C.debug("Initializing sidebar",i),C.create.id(),x=C.get.transitionEvent(),C.is.ios()&&C.set.ios(),w.delaySetup?p(C.setup.layout):C.setup.layout(),p(function(){C.setup.cache()}),C.instantiate()},instantiate:function(){C.verbose("Storing instance of module",C),I=C,F.data(E,C)},create:{id:function(){b=(Math.random().toString(16)+"000000000").substr(2,8),h="."+b,C.verbose("Creating unique id for element",b)}},destroy:function(){C.verbose("Destroying previous module for",F),F.off(P).removeData(E),C.is.ios()&&C.remove.ios(),O.off(h),r.off(h),s.off(h)},event:{clickaway:function(e){var t=j.find(e.target).length>0||j.is(e.target),n=O.is(e.target);t&&(C.verbose("User clicked on dimmed page"),C.hide()),
n&&(C.verbose("User clicked on dimmable context (scaled out page)"),C.hide())},touch:function(e){},containScroll:function(e){z.scrollTop<=0&&(z.scrollTop=1),z.scrollTop+z.offsetHeight>=z.scrollHeight&&(z.scrollTop=z.scrollHeight-z.offsetHeight-1)},scroll:function(t){0===e(t.target).closest(k.sidebar).length&&t.preventDefault()}},bind:{clickaway:function(){C.verbose("Adding clickaway events to context",O),w.closable&&O.on("click"+h,C.event.clickaway).on("touchend"+h,C.event.clickaway)},scrollLock:function(){w.scrollLock&&(C.debug("Disabling page scroll"),r.on("DOMMouseScroll"+h,C.event.scroll)),C.verbose("Adding events to contain sidebar scroll"),s.on("touchmove"+h,C.event.touch),F.on("scroll"+P,C.event.containScroll)}},unbind:{clickaway:function(){C.verbose("Removing clickaway events from context",O),O.off(h)},scrollLock:function(){C.verbose("Removing scroll lock from page"),s.off(h),r.off(h),F.off("scroll"+P)}},add:{inlineCSS:function(){var t,n=C.cache.width||F.outerWidth(),i=C.cache.height||F.outerHeight(),o=C.is.rtl(),r=C.get.direction(),s={left:n,right:-n,top:i,bottom:-i};o&&(C.verbose("RTL detected, flipping widths"),s.left=-n,s.right=n),t="<style>","left"===r||"right"===r?(C.debug("Adding CSS rules for animation distance",n),t+=" .ui.visible."+r+".sidebar ~ .fixed, .ui.visible."+r+".sidebar ~ .pusher {   -webkit-transform: translate3d("+s[r]+"px, 0, 0);           transform: translate3d("+s[r]+"px, 0, 0); }"):"top"!==r&&"bottom"!=r||(t+=" .ui.visible."+r+".sidebar ~ .fixed, .ui.visible."+r+".sidebar ~ .pusher {   -webkit-transform: translate3d(0, "+s[r]+"px, 0);           transform: translate3d(0, "+s[r]+"px, 0); }"),C.is.ie()&&("left"===r||"right"===r?(C.debug("Adding CSS rules for animation distance",n),t+=" body.pushable > .ui.visible."+r+".sidebar ~ .pusher:after {   -webkit-transform: translate3d("+s[r]+"px, 0, 0);           transform: translate3d("+s[r]+"px, 0, 0); }"):"top"!==r&&"bottom"!=r||(t+=" body.pushable > .ui.visible."+r+".sidebar ~ .pusher:after {   -webkit-transform: translate3d(0, "+s[r]+"px, 0);           transform: translate3d(0, "+s[r]+"px, 0); }"),t+=" body.pushable > .ui.visible.left.sidebar ~ .ui.visible.right.sidebar ~ .pusher:after, body.pushable > .ui.visible.right.sidebar ~ .ui.visible.left.sidebar ~ .pusher:after {   -webkit-transform: translate3d(0px, 0, 0);           transform: translate3d(0px, 0, 0); }"),t+="</style>",a=e(t).appendTo(c),C.debug("Adding sizing css to head",a)}},refresh:function(){C.verbose("Refreshing selector cache"),O=e(w.context),D=O.children(k.sidebar),j=O.children(k.pusher),q=O.children(k.fixed),C.clear.cache()},refreshSidebars:function(){C.verbose("Refreshing other sidebars"),D=O.children(k.sidebar)},repaint:function(){C.verbose("Forcing repaint event"),z.style.display="none";z.offsetHeight;z.scrollTop=z.scrollTop,z.style.display=""},setup:{cache:function(){C.cache={width:F.outerWidth(),height:F.outerHeight(),rtl:"rtl"==F.css("direction")}},layout:function(){0===O.children(k.pusher).length&&(C.debug("Adding wrapper element for sidebar"),C.error(R.pusher),j=e('<div class="pusher" />'),O.children().not(k.omitted).not(D).wrapAll(j),C.refresh()),0!==F.nextAll(k.pusher).length&&F.nextAll(k.pusher)[0]===j[0]||(C.debug("Moved sidebar to correct parent element"),C.error(R.movedSidebar,z),F.detach().prependTo(O),C.refresh()),C.clear.cache(),C.set.pushable(),C.set.direction()}},attachEvents:function(t,n){var i=e(t);n=e.isFunction(C[n])?C[n]:C.toggle,i.length>0?(C.debug("Attaching sidebar events to element",t,n),i.on("click"+P,n)):C.error(R.notFound,t)},show:function(t){if(t=e.isFunction(t)?t:function(){},C.is.hidden()){if(C.refreshSidebars(),w.overlay&&(C.error(R.overlay),w.transition="overlay"),C.refresh(),C.othersActive())if(C.debug("Other sidebars currently visible"),w.exclusive){if("overlay"!=w.transition)return void C.hideOthers(C.show);C.hideOthers()}else w.transition="overlay";C.pushPage(function(){t.call(z),w.onShow.call(z)}),w.onChange.call(z),w.onVisible.call(z)}else C.debug("Sidebar is already visible")},hide:function(t){t=e.isFunction(t)?t:function(){},(C.is.visible()||C.is.animating())&&(C.debug("Hiding sidebar",t),C.refreshSidebars(),C.pullPage(function(){t.call(z),w.onHidden.call(z)}),w.onChange.call(z),w.onHide.call(z))},othersAnimating:function(){return D.not(F).filter("."+S.animating).length>0},othersVisible:function(){return D.not(F).filter("."+S.visible).length>0},othersActive:function(){return C.othersVisible()||C.othersAnimating()},hideOthers:function(e){var t=D.not(F).filter("."+S.visible),n=t.length,i=0;e=e||function(){},t.sidebar("hide",function(){++i==n&&e()})},toggle:function(){C.verbose("Determining toggled direction"),C.is.hidden()?C.show():C.hide()},pushPage:function(t){var n,i,o,a=C.get.transition(),r="overlay"===a||C.othersActive()?F:j;t=e.isFunction(t)?t:function(){},"scale down"==w.transition&&C.scrollToTop(),C.set.transition(a),C.repaint(),n=function(){C.bind.clickaway(),C.add.inlineCSS(),C.set.animating(),C.set.visible()},i=function(){C.set.dimmed()},o=function(e){e.target==r[0]&&(r.off(x+h,o),C.remove.animating(),C.bind.scrollLock(),t.call(z))},r.off(x+h),r.on(x+h,o),p(n),w.dimPage&&!C.othersVisible()&&p(i)},pullPage:function(t){var n,i,o=C.get.transition(),a="overlay"==o||C.othersActive()?F:j;t=e.isFunction(t)?t:function(){},C.verbose("Removing context push state",C.get.direction()),C.unbind.clickaway(),C.unbind.scrollLock(),n=function(){C.set.transition(o),C.set.animating(),C.remove.visible(),w.dimPage&&!C.othersVisible()&&j.removeClass(S.dimmed)},i=function(e){e.target==a[0]&&(a.off(x+h,i),C.remove.animating(),C.remove.transition(),C.remove.inlineCSS(),("scale down"==o||w.returnScroll&&C.is.mobile())&&C.scrollBack(),t.call(z))},a.off(x+h),a.on(x+h,i),p(n)},scrollToTop:function(){C.verbose("Scrolling to top of page to avoid animation issues"),y=e(t).scrollTop(),F.scrollTop(0),t.scrollTo(0,0)},scrollBack:function(){C.verbose("Scrolling back to original page position"),t.scrollTo(0,y)},clear:{cache:function(){C.verbose("Clearing cached dimensions"),C.cache={}}},set:{ios:function(){l.addClass(S.ios)},pushed:function(){O.addClass(S.pushed)},pushable:function(){O.addClass(S.pushable)},dimmed:function(){j.addClass(S.dimmed)},active:function(){F.addClass(S.active)},animating:function(){F.addClass(S.animating)},transition:function(e){e=e||C.get.transition(),F.addClass(e)},direction:function(e){e=e||C.get.direction(),F.addClass(S[e])},visible:function(){F.addClass(S.visible)},overlay:function(){F.addClass(S.overlay)}},remove:{inlineCSS:function(){C.debug("Removing inline css styles",a),a&&a.length>0&&a.remove()},ios:function(){l.removeClass(S.ios)},pushed:function(){O.removeClass(S.pushed)},pushable:function(){O.removeClass(S.pushable)},active:function(){F.removeClass(S.active)},animating:function(){F.removeClass(S.animating)},transition:function(e){e=e||C.get.transition(),F.removeClass(e)},direction:function(e){e=e||C.get.direction(),F.removeClass(S[e])},visible:function(){F.removeClass(S.visible)},overlay:function(){F.removeClass(S.overlay)}},get:{direction:function(){return F.hasClass(S.top)?S.top:F.hasClass(S.right)?S.right:F.hasClass(S.bottom)?S.bottom:S.left},transition:function(){var e,t=C.get.direction();return e=C.is.mobile()?"auto"==w.mobileTransition?w.defaultTransition.mobile[t]:w.mobileTransition:"auto"==w.transition?w.defaultTransition.computer[t]:w.transition,C.verbose("Determined transition",e),e},transitionEvent:function(){var e,t=n.createElement("element"),i={transition:"transitionend",OTransition:"oTransitionEnd",MozTransition:"transitionend",WebkitTransition:"webkitTransitionEnd"};for(e in i)if(void 0!==t.style[e])return i[e]}},is:{ie:function(){var e=!t.ActiveXObject&&"ActiveXObject"in t,n="ActiveXObject"in t;return e||n},ios:function(){var e=navigator.userAgent,t=e.match(A.ios),n=e.match(A.mobileChrome);return!(!t||n)&&(C.verbose("Browser was found to be iOS",e),!0)},mobile:function(){var e=navigator.userAgent;return e.match(A.mobile)?(C.verbose("Browser was found to be mobile",e),!0):(C.verbose("Browser is not mobile, using regular transition",e),!1)},hidden:function(){return!C.is.visible()},visible:function(){return F.hasClass(S.visible)},open:function(){return C.is.visible()},closed:function(){return C.is.hidden()},vertical:function(){return F.hasClass(S.top)},animating:function(){return O.hasClass(S.animating)},rtl:function(){return void 0===C.cache.rtl&&(C.cache.rtl="rtl"==F.css("direction")),C.cache.rtl}},setting:function(t,n){if(C.debug("Changing setting",t,n),e.isPlainObject(t))e.extend(!0,w,t);else{if(void 0===n)return w[t];e.isPlainObject(w[t])?e.extend(!0,w[t],n):w[t]=n}},internal:function(t,n){if(e.isPlainObject(t))e.extend(!0,C,t);else{if(void 0===n)return C[t];C[t]=n}},debug:function(){!w.silent&&w.debug&&(w.performance?C.performance.log(arguments):(C.debug=Function.prototype.bind.call(console.info,console,w.name+":"),C.debug.apply(console,arguments)))},verbose:function(){!w.silent&&w.verbose&&w.debug&&(w.performance?C.performance.log(arguments):(C.verbose=Function.prototype.bind.call(console.info,console,w.name+":"),C.verbose.apply(console,arguments)))},error:function(){w.silent||(C.error=Function.prototype.bind.call(console.error,console,w.name+":"),C.error.apply(console,arguments))},performance:{log:function(e){var t,n,i;w.performance&&(t=(new Date).getTime(),i=d||t,n=t-i,d=t,f.push({Name:e[0],Arguments:[].slice.call(e,1)||"",Element:z,"Execution Time":n})),clearTimeout(C.performance.timer),C.performance.timer=setTimeout(C.performance.display,500)},display:function(){var t=w.name+":",n=0;d=!1,clearTimeout(C.performance.timer),e.each(f,function(e,t){n+=t["Execution Time"]}),t+=" "+n+"ms",u&&(t+=" '"+u+"'"),(void 0!==console.group||void 0!==console.table)&&f.length>0&&(console.groupCollapsed(t),console.table?console.table(f):e.each(f,function(e,t){console.log(t.Name+": "+t["Execution Time"]+"ms")}),console.groupEnd()),f=[]}},invoke:function(t,n,i){var a,r,s,l=I;return n=n||v,i=z||i,"string"==typeof t&&void 0!==l&&(t=t.split(/[\. ]/),a=t.length-1,e.each(t,function(n,i){var o=n!=a?i+t[n+1].charAt(0).toUpperCase()+t[n+1].slice(1):t;if(e.isPlainObject(l[o])&&n!=a)l=l[o];else{if(void 0!==l[o])return r=l[o],!1;if(!e.isPlainObject(l[i])||n==a)return void 0!==l[i]?(r=l[i],!1):(C.error(R.method,t),!1);l=l[i]}})),e.isFunction(r)?s=r.apply(i,n):void 0!==r&&(s=r),e.isArray(o)?o.push(s):void 0!==o?o=[o,s]:void 0!==s&&(o=s),r}},g?(void 0===I&&C.initialize(),C.invoke(m)):(void 0!==I&&C.invoke("destroy"),C.initialize())}),void 0!==o?o:this},e.fn.sidebar.settings={name:"Sidebar",namespace:"sidebar",silent:!1,debug:!1,verbose:!1,performance:!0,transition:"auto",mobileTransition:"auto",defaultTransition:{computer:{left:"uncover",right:"uncover",top:"overlay",bottom:"overlay"},mobile:{left:"uncover",right:"uncover",top:"overlay",bottom:"overlay"}},context:"body",exclusive:!1,closable:!0,dimPage:!0,scrollLock:!1,returnScroll:!1,delaySetup:!1,duration:500,onChange:function(){},onShow:function(){},onHide:function(){},onHidden:function(){},onVisible:function(){},className:{active:"active",animating:"animating",dimmed:"dimmed",ios:"ios",pushable:"pushable",pushed:"pushed",right:"right",top:"top",left:"left",bottom:"bottom",visible:"visible"},selector:{fixed:".fixed",omitted:"script, link, style, .ui.modal, .ui.dimmer, .ui.nag, .ui.fixed",pusher:".pusher",sidebar:".ui.sidebar"},regExp:{ios:/(iPad|iPhone|iPod)/g,mobileChrome:/(CriOS)/g,mobile:/Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/g},error:{method:"The method you called is not defined.",pusher:"Had to add pusher element. For optimal performance make sure body content is inside a pusher element",movedSidebar:"Had to move sidebar. For optimal performance make sure sidebar and pusher are direct children of your body tag",overlay:"The overlay setting is no longer supported, use animation: overlay",notFound:"There were no elements that matched the specified selector"}}}(jQuery,window,document),function(e,t,n,i){"use strict";t=void 0!==t&&t.Math==Math?t:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")(),e.fn.sticky=function(i){var o,a=e(this),r=a.selector||"",s=(new Date).getTime(),l=[],c=arguments[0],u="string"==typeof c,d=[].slice.call(arguments,1);return a.each(function(){var a,f,m,g,v,p=e.isPlainObject(i)?e.extend(!0,{},e.fn.sticky.settings,i):e.extend({},e.fn.sticky.settings),h=p.className,b=p.namespace,y=p.error,x="."+b,C="module-"+b,w=e(this),k=e(t),S=e(p.scrollContext),T=(w.selector,w.data(C)),A=t.requestAnimationFrame||t.mozRequestAnimationFrame||t.webkitRequestAnimationFrame||t.msRequestAnimationFrame||function(e){setTimeout(e,0)},R=this;v={initialize:function(){v.determineContainer(),v.determineContext(),v.verbose("Initializing sticky",p,a),v.save.positions(),v.checkErrors(),v.bind.events(),p.observeChanges&&v.observeChanges(),v.instantiate()},instantiate:function(){v.verbose("Storing instance of module",v),T=v,w.data(C,v)},destroy:function(){v.verbose("Destroying previous instance"),v.reset(),m&&m.disconnect(),g&&g.disconnect(),k.off("load"+x,v.event.load).off("resize"+x,v.event.resize),S.off("scrollchange"+x,v.event.scrollchange),w.removeData(C)},observeChanges:function(){"MutationObserver"in t&&(m=new MutationObserver(v.event.documentChanged),g=new MutationObserver(v.event.changed),m.observe(n,{childList:!0,subtree:!0}),g.observe(R,{childList:!0,subtree:!0}),g.observe(f[0],{childList:!0,subtree:!0}),v.debug("Setting up mutation observer",g))},determineContainer:function(){a=p.container?e(p.container):w.offsetParent()},determineContext:function(){if(f=p.context?e(p.context):a,0===f.length)return void v.error(y.invalidContext,p.context,w)},checkErrors:function(){if(v.is.hidden()&&v.error(y.visible,w),v.cache.element.height>v.cache.context.height)return v.reset(),void v.error(y.elementSize,w)},bind:{events:function(){k.on("load"+x,v.event.load).on("resize"+x,v.event.resize),S.off("scroll"+x).on("scroll"+x,v.event.scroll).on("scrollchange"+x,v.event.scrollchange)}},event:{changed:function(e){clearTimeout(v.timer),v.timer=setTimeout(function(){v.verbose("DOM tree modified, updating sticky menu",e),v.refresh()},100)},documentChanged:function(t){[].forEach.call(t,function(t){t.removedNodes&&[].forEach.call(t.removedNodes,function(t){(t==R||e(t).find(R).length>0)&&(v.debug("Element removed from DOM, tearing down events"),v.destroy())})})},load:function(){v.verbose("Page contents finished loading"),A(v.refresh)},resize:function(){v.verbose("Window resized"),A(v.refresh)},scroll:function(){A(function(){S.triggerHandler("scrollchange"+x,S.scrollTop())})},scrollchange:function(e,t){v.stick(t),p.onScroll.call(R)}},refresh:function(e){v.reset(),p.context||v.determineContext(),e&&v.determineContainer(),v.save.positions(),v.stick(),p.onReposition.call(R)},supports:{sticky:function(){var t=e("<div/>");t[0];return t.addClass(h.supported),t.css("position").match("sticky")}},save:{lastScroll:function(e){v.lastScroll=e},elementScroll:function(e){v.elementScroll=e},positions:function(){var e={height:S.height()},t={margin:{top:parseInt(w.css("margin-top"),10),bottom:parseInt(w.css("margin-bottom"),10)},offset:w.offset(),width:w.outerWidth(),height:w.outerHeight()},n={offset:f.offset(),height:f.outerHeight()};a.outerHeight();v.is.standardScroll()||(v.debug("Non-standard scroll. Removing scroll offset from element offset"),e.top=S.scrollTop(),e.left=S.scrollLeft(),t.offset.top+=e.top,n.offset.top+=e.top,t.offset.left+=e.left,n.offset.left+=e.left),v.cache={fits:t.height<e.height,scrollContext:{height:e.height},element:{margin:t.margin,top:t.offset.top-t.margin.top,left:t.offset.left,width:t.width,height:t.height,bottom:t.offset.top+t.height},context:{top:n.offset.top,height:n.height,bottom:n.offset.top+n.height}},v.set.containerSize(),v.set.size(),v.stick(),v.debug("Caching element positions",v.cache)}},get:{direction:function(e){var t="down";return e=e||S.scrollTop(),void 0!==v.lastScroll&&(v.lastScroll<e?t="down":v.lastScroll>e&&(t="up")),t},scrollChange:function(e){return e=e||S.scrollTop(),v.lastScroll?e-v.lastScroll:0},currentElementScroll:function(){return v.elementScroll?v.elementScroll:v.is.top()?Math.abs(parseInt(w.css("top"),10))||0:Math.abs(parseInt(w.css("bottom"),10))||0},elementScroll:function(e){e=e||S.scrollTop();var t=v.cache.element,n=v.cache.scrollContext,i=v.get.scrollChange(e),o=t.height-n.height+p.offset,a=v.get.currentElementScroll(),r=a+i;return a=v.cache.fits||r<0?0:r>o?o:r}},remove:{lastScroll:function(){delete v.lastScroll},elementScroll:function(e){delete v.elementScroll},offset:function(){w.css("margin-top","")}},set:{offset:function(){v.verbose("Setting offset on element",p.offset),w.css("margin-top",p.offset)},containerSize:function(){var e=a.get(0).tagName;"HTML"===e||"body"==e?v.determineContainer():Math.abs(a.outerHeight()-v.cache.context.height)>p.jitter&&(v.debug("Context has padding, specifying exact height for container",v.cache.context.height),a.css({height:v.cache.context.height}))},minimumSize:function(){var e=v.cache.element;a.css("min-height",e.height)},scroll:function(e){v.debug("Setting scroll on element",e),v.elementScroll!=e&&(v.is.top()&&w.css("bottom","").css("top",-e),v.is.bottom()&&w.css("top","").css("bottom",e))},size:function(){0!==v.cache.element.height&&0!==v.cache.element.width&&(R.style.setProperty("width",v.cache.element.width+"px","important"),R.style.setProperty("height",v.cache.element.height+"px","important"))}},is:{standardScroll:function(){return S[0]==t},top:function(){return w.hasClass(h.top)},bottom:function(){return w.hasClass(h.bottom)},initialPosition:function(){return!v.is.fixed()&&!v.is.bound()},hidden:function(){return!w.is(":visible")},bound:function(){return w.hasClass(h.bound)},fixed:function(){return w.hasClass(h.fixed)}},stick:function(e){var t=e||S.scrollTop(),n=v.cache,i=n.fits,o=n.element,a=n.scrollContext,r=n.context,s=v.is.bottom()&&p.pushing?p.bottomOffset:p.offset,e={top:t+s,bottom:t+s+a.height},l=(v.get.direction(e.top),i?0:v.get.elementScroll(e.top)),c=!i;0!==o.height&&(v.is.initialPosition()?e.top>=r.bottom?(v.debug("Initial element position is bottom of container"),v.bindBottom()):e.top>o.top&&(o.height+e.top-l>=r.bottom?(v.debug("Initial element position is bottom of container"),v.bindBottom()):(v.debug("Initial element position is fixed"),v.fixTop())):v.is.fixed()?v.is.top()?e.top<=o.top?(v.debug("Fixed element reached top of container"),v.setInitialPosition()):o.height+e.top-l>=r.bottom?(v.debug("Fixed element reached bottom of container"),v.bindBottom()):c&&(v.set.scroll(l),v.save.lastScroll(e.top),v.save.elementScroll(l)):v.is.bottom()&&(e.bottom-o.height<=o.top?(v.debug("Bottom fixed rail has reached top of container"),v.setInitialPosition()):e.bottom>=r.bottom?(v.debug("Bottom fixed rail has reached bottom of container"),v.bindBottom()):c&&(v.set.scroll(l),v.save.lastScroll(e.top),v.save.elementScroll(l))):v.is.bottom()&&(e.top<=o.top?(v.debug("Jumped from bottom fixed to top fixed, most likely used home/end button"),v.setInitialPosition()):p.pushing?v.is.bound()&&e.bottom<=r.bottom&&(v.debug("Fixing bottom attached element to bottom of browser."),v.fixBottom()):v.is.bound()&&e.top<=r.bottom-o.height&&(v.debug("Fixing bottom attached element to top of browser."),v.fixTop())))},bindTop:function(){v.debug("Binding element to top of parent container"),v.remove.offset(),w.css({left:"",top:"",marginBottom:""}).removeClass(h.fixed).removeClass(h.bottom).addClass(h.bound).addClass(h.top),p.onTop.call(R),p.onUnstick.call(R)},bindBottom:function(){v.debug("Binding element to bottom of parent container"),v.remove.offset(),w.css({left:"",top:""}).removeClass(h.fixed).removeClass(h.top).addClass(h.bound).addClass(h.bottom),p.onBottom.call(R),p.onUnstick.call(R)},setInitialPosition:function(){v.debug("Returning to initial position"),v.unfix(),v.unbind()},fixTop:function(){v.debug("Fixing element to top of page"),v.set.minimumSize(),v.set.offset(),w.css({left:v.cache.element.left,bottom:"",marginBottom:""}).removeClass(h.bound).removeClass(h.bottom).addClass(h.fixed).addClass(h.top),p.onStick.call(R)},fixBottom:function(){v.debug("Sticking element to bottom of page"),v.set.minimumSize(),v.set.offset(),w.css({left:v.cache.element.left,bottom:"",marginBottom:""}).removeClass(h.bound).removeClass(h.top).addClass(h.fixed).addClass(h.bottom),p.onStick.call(R)},unbind:function(){v.is.bound()&&(v.debug("Removing container bound position on element"),v.remove.offset(),w.removeClass(h.bound).removeClass(h.top).removeClass(h.bottom))},unfix:function(){v.is.fixed()&&(v.debug("Removing fixed position on element"),v.remove.offset(),w.removeClass(h.fixed).removeClass(h.top).removeClass(h.bottom),p.onUnstick.call(R))},reset:function(){v.debug("Resetting elements position"),v.unbind(),v.unfix(),v.resetCSS(),v.remove.offset(),v.remove.lastScroll()},resetCSS:function(){w.css({width:"",height:""}),a.css({height:""})},setting:function(t,n){if(e.isPlainObject(t))e.extend(!0,p,t);else{if(void 0===n)return p[t];p[t]=n}},internal:function(t,n){if(e.isPlainObject(t))e.extend(!0,v,t);else{if(void 0===n)return v[t];v[t]=n}},debug:function(){!p.silent&&p.debug&&(p.performance?v.performance.log(arguments):(v.debug=Function.prototype.bind.call(console.info,console,p.name+":"),v.debug.apply(console,arguments)))},verbose:function(){!p.silent&&p.verbose&&p.debug&&(p.performance?v.performance.log(arguments):(v.verbose=Function.prototype.bind.call(console.info,console,p.name+":"),v.verbose.apply(console,arguments)))},error:function(){p.silent||(v.error=Function.prototype.bind.call(console.error,console,p.name+":"),v.error.apply(console,arguments))},performance:{log:function(e){var t,n,i;p.performance&&(t=(new Date).getTime(),i=s||t,n=t-i,s=t,l.push({Name:e[0],Arguments:[].slice.call(e,1)||"",Element:R,"Execution Time":n})),clearTimeout(v.performance.timer),v.performance.timer=setTimeout(v.performance.display,0)},display:function(){var t=p.name+":",n=0;s=!1,clearTimeout(v.performance.timer),e.each(l,function(e,t){n+=t["Execution Time"]}),t+=" "+n+"ms",r&&(t+=" '"+r+"'"),(void 0!==console.group||void 0!==console.table)&&l.length>0&&(console.groupCollapsed(t),console.table?console.table(l):e.each(l,function(e,t){console.log(t.Name+": "+t["Execution Time"]+"ms")}),console.groupEnd()),l=[]}},invoke:function(t,n,i){var a,r,s,l=T;return n=n||d,i=R||i,"string"==typeof t&&void 0!==l&&(t=t.split(/[\. ]/),a=t.length-1,e.each(t,function(n,i){var o=n!=a?i+t[n+1].charAt(0).toUpperCase()+t[n+1].slice(1):t;if(e.isPlainObject(l[o])&&n!=a)l=l[o];else{if(void 0!==l[o])return r=l[o],!1;if(!e.isPlainObject(l[i])||n==a)return void 0!==l[i]&&(r=l[i],!1);l=l[i]}})),e.isFunction(r)?s=r.apply(i,n):void 0!==r&&(s=r),e.isArray(o)?o.push(s):void 0!==o?o=[o,s]:void 0!==s&&(o=s),r}},u?(void 0===T&&v.initialize(),v.invoke(c)):(void 0!==T&&T.invoke("destroy"),v.initialize())}),void 0!==o?o:this},e.fn.sticky.settings={name:"Sticky",namespace:"sticky",silent:!1,debug:!1,verbose:!0,performance:!0,pushing:!1,context:!1,container:!1,scrollContext:t,offset:0,bottomOffset:0,jitter:5,observeChanges:!1,onReposition:function(){},onScroll:function(){},onStick:function(){},onUnstick:function(){},onTop:function(){},onBottom:function(){},error:{container:"Sticky element must be inside a relative container",visible:"Element is hidden, you must call refresh after element becomes visible. Use silent setting to surpress this warning in production.",method:"The method you called is not defined.",invalidContext:"Context specified does not exist",elementSize:"Sticky element is larger than its container, cannot create sticky."},className:{bound:"bound",fixed:"fixed",supported:"native",top:"top",bottom:"bottom"}}}(jQuery,window,document),function(e,t,n,i){"use strict";t=void 0!==t&&t.Math==Math?t:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")(),e.fn.tab=function(i){var o,a=e(e.isFunction(this)?t:this),r=a.selector||"",s=(new Date).getTime(),l=[],c=arguments[0],u="string"==typeof c,d=[].slice.call(arguments,1),f=!1;return a.each(function(){var m,g,v,p,h,b,y=e.isPlainObject(i)?e.extend(!0,{},e.fn.tab.settings,i):e.extend({},e.fn.tab.settings),x=y.className,C=y.metadata,w=y.selector,k=y.error,S="."+y.namespace,T="module-"+y.namespace,A=e(this),R={},P=!0,E=0,F=this,O=A.data(T);h={initialize:function(){h.debug("Initializing tab menu item",A),h.fix.callbacks(),h.determineTabs(),h.debug("Determining tabs",y.context,g),y.auto&&h.set.auto(),h.bind.events(),y.history&&!f&&(h.initializeHistory(),f=!0),h.instantiate()},instantiate:function(){h.verbose("Storing instance of module",h),O=h,A.data(T,h)},destroy:function(){h.debug("Destroying tabs",A),A.removeData(T).off(S)},bind:{events:function(){e.isWindow(F)||(h.debug("Attaching tab activation events to element",A),A.on("click"+S,h.event.click))}},determineTabs:function(){var t;"parent"===y.context?(A.closest(w.ui).length>0?(t=A.closest(w.ui),h.verbose("Using closest UI element as parent",t)):t=A,m=t.parent(),h.verbose("Determined parent element for creating context",m)):y.context?(m=e(y.context),h.verbose("Using selector for tab context",y.context,m)):m=e("body"),y.childrenOnly?(g=m.children(w.tabs),h.debug("Searching tab context children for tabs",m,g)):(g=m.find(w.tabs),h.debug("Searching tab context for tabs",m,g))},fix:{callbacks:function(){e.isPlainObject(i)&&(i.onTabLoad||i.onTabInit)&&(i.onTabLoad&&(i.onLoad=i.onTabLoad,delete i.onTabLoad,h.error(k.legacyLoad,i.onLoad)),i.onTabInit&&(i.onFirstLoad=i.onTabInit,delete i.onTabInit,h.error(k.legacyInit,i.onFirstLoad)),y=e.extend(!0,{},e.fn.tab.settings,i))}},initializeHistory:function(){if(h.debug("Initializing page state"),void 0===e.address)return h.error(k.state),!1;if("state"==y.historyType){if(h.debug("Using HTML5 to manage state"),!1===y.path)return h.error(k.path),!1;e.address.history(!0).state(y.path)}e.address.bind("change",h.event.history.change)},event:{click:function(t){var n=e(this).data(C.tab);void 0!==n?(y.history?(h.verbose("Updating page state",t),e.address.value(n)):(h.verbose("Changing tab",t),h.changeTab(n)),t.preventDefault()):h.debug("No tab specified")},history:{change:function(t){var n=t.pathNames.join("/")||h.get.initialPath(),i=y.templates.determineTitle(n)||!1;h.performance.display(),h.debug("History change event",n,t),b=t,void 0!==n&&h.changeTab(n),i&&e.address.title(i)}}},refresh:function(){v&&(h.debug("Refreshing tab",v),h.changeTab(v))},cache:{read:function(e){return void 0!==e&&R[e]},add:function(e,t){e=e||v,h.debug("Adding cached content for",e),R[e]=t},remove:function(e){e=e||v,h.debug("Removing cached content for",e),delete R[e]}},set:{auto:function(){var t="string"==typeof y.path?y.path.replace(/\/$/,"")+"/{$tab}":"/{$tab}";h.verbose("Setting up automatic tab retrieval from server",t),e.isPlainObject(y.apiSettings)?y.apiSettings.url=t:y.apiSettings={url:t}},loading:function(e){var t=h.get.tabElement(e);t.hasClass(x.loading)||(h.verbose("Setting loading state for",t),t.addClass(x.loading).siblings(g).removeClass(x.active+" "+x.loading),t.length>0&&y.onRequest.call(t[0],e))},state:function(t){e.address.value(t)}},changeTab:function(n){var i=t.history&&t.history.pushState,o=i&&y.ignoreFirstLoad&&P,a=y.auto||e.isPlainObject(y.apiSettings),r=a&&!o?h.utilities.pathToArray(n):h.get.defaultPathArray(n);n=h.utilities.arrayToPath(r),e.each(r,function(t,i){var s,l,c,u,d=r.slice(0,t+1),f=h.utilities.arrayToPath(d),g=h.is.tab(f),w=t+1==r.length,S=h.get.tabElement(f);if(h.verbose("Looking for tab",i),g){if(h.verbose("Tab was found",i),v=f,p=h.utilities.filterArray(r,d),w?u=!0:(l=r.slice(0,t+2),c=h.utilities.arrayToPath(l),(u=!h.is.tab(c))&&h.verbose("Tab parameters found",l)),u&&a)return o?(h.debug("Ignoring remote content on first tab load",f),P=!1,h.cache.add(n,S.html()),h.activate.all(f),y.onFirstLoad.call(S[0],f,p,b),y.onLoad.call(S[0],f,p,b)):(h.activate.navigation(f),h.fetch.content(f,n)),!1;h.debug("Opened local tab",f),h.activate.all(f),h.cache.read(f)||(h.cache.add(f,!0),h.debug("First time tab loaded calling tab init"),y.onFirstLoad.call(S[0],f,p,b)),y.onLoad.call(S[0],f,p,b)}else{if(-1!=n.search("/")||""===n)return h.error(k.missingTab,A,m,f),!1;if(s=e("#"+n+', a[name="'+n+'"]'),f=s.closest("[data-tab]").data(C.tab),S=h.get.tabElement(f),s&&s.length>0&&f)return h.debug("Anchor link used, opening parent tab",S,s),S.hasClass(x.active)||setTimeout(function(){h.scrollTo(s)},0),h.activate.all(f),h.cache.read(f)||(h.cache.add(f,!0),h.debug("First time tab loaded calling tab init"),y.onFirstLoad.call(S[0],f,p,b)),y.onLoad.call(S[0],f,p,b),!1}})},scrollTo:function(t){var i=!!(t&&t.length>0)&&t.offset().top;!1!==i&&(h.debug("Forcing scroll to an in-page link in a hidden tab",i,t),e(n).scrollTop(i))},update:{content:function(t,n,i){var o=h.get.tabElement(t),a=o[0];i=void 0!==i?i:y.evaluateScripts,"string"==typeof y.cacheType&&"dom"==y.cacheType.toLowerCase()&&"string"!=typeof n?o.empty().append(e(n).clone(!0)):i?(h.debug("Updating HTML and evaluating inline scripts",t,n),o.html(n)):(h.debug("Updating HTML",t,n),a.innerHTML=n)}},fetch:{content:function(t,n){var i,o,a=h.get.tabElement(t),r={dataType:"html",encodeParameters:!1,on:"now",cache:y.alwaysRefresh,headers:{"X-Remote":!0},onSuccess:function(e){"response"==y.cacheType&&h.cache.add(n,e),h.update.content(t,e),t==v?(h.debug("Content loaded",t),h.activate.tab(t)):h.debug("Content loaded in background",t),y.onFirstLoad.call(a[0],t,p,b),y.onLoad.call(a[0],t,p,b),y.loadOnce?h.cache.add(n,!0):"string"==typeof y.cacheType&&"dom"==y.cacheType.toLowerCase()&&a.children().length>0?setTimeout(function(){var e=a.children().clone(!0);e=e.not("script"),h.cache.add(n,e)},0):h.cache.add(n,a.html())},urlData:{tab:n}},s=a.api("get request")||!1,l=s&&"pending"===s.state();n=n||t,o=h.cache.read(n),y.cache&&o?(h.activate.tab(t),h.debug("Adding cached content",n),y.loadOnce||("once"==y.evaluateScripts?h.update.content(t,o,!1):h.update.content(t,o)),y.onLoad.call(a[0],t,p,b)):l?(h.set.loading(t),h.debug("Content is already loading",n)):void 0!==e.api?(i=e.extend(!0,{},y.apiSettings,r),h.debug("Retrieving remote content",n,i),h.set.loading(t),a.api(i)):h.error(k.api)}},activate:{all:function(e){h.activate.tab(e),h.activate.navigation(e)},tab:function(e){var t=h.get.tabElement(e),n="siblings"==y.deactivate?t.siblings(g):g.not(t),i=t.hasClass(x.active);h.verbose("Showing tab content for",t),i||(t.addClass(x.active),n.removeClass(x.active+" "+x.loading),t.length>0&&y.onVisible.call(t[0],e))},navigation:function(e){var t=h.get.navElement(e),n="siblings"==y.deactivate?t.siblings(a):a.not(t),i=t.hasClass(x.active);h.verbose("Activating tab navigation for",t,e),i||(t.addClass(x.active),n.removeClass(x.active+" "+x.loading))}},deactivate:{all:function(){h.deactivate.navigation(),h.deactivate.tabs()},navigation:function(){a.removeClass(x.active)},tabs:function(){g.removeClass(x.active+" "+x.loading)}},is:{tab:function(e){return void 0!==e&&h.get.tabElement(e).length>0}},get:{initialPath:function(){return a.eq(0).data(C.tab)||g.eq(0).data(C.tab)},path:function(){return e.address.value()},defaultPathArray:function(e){return h.utilities.pathToArray(h.get.defaultPath(e))},defaultPath:function(e){var t=a.filter("[data-"+C.tab+'^="'+e+'/"]').eq(0),n=t.data(C.tab)||!1;if(n){if(h.debug("Found default tab",n),E<y.maxDepth)return E++,h.get.defaultPath(n);h.error(k.recursion)}else h.debug("No default tabs found for",e,g);return E=0,e},navElement:function(e){return e=e||v,a.filter("[data-"+C.tab+'="'+e+'"]')},tabElement:function(e){var t,n,i,o;return e=e||v,i=h.utilities.pathToArray(e),o=h.utilities.last(i),t=g.filter("[data-"+C.tab+'="'+e+'"]'),n=g.filter("[data-"+C.tab+'="'+o+'"]'),t.length>0?t:n},tab:function(){return v}},utilities:{filterArray:function(t,n){return e.grep(t,function(t){return-1==e.inArray(t,n)})},last:function(t){return!!e.isArray(t)&&t[t.length-1]},
pathToArray:function(e){return void 0===e&&(e=v),"string"==typeof e?e.split("/"):[e]},arrayToPath:function(t){return!!e.isArray(t)&&t.join("/")}},setting:function(t,n){if(h.debug("Changing setting",t,n),e.isPlainObject(t))e.extend(!0,y,t);else{if(void 0===n)return y[t];e.isPlainObject(y[t])?e.extend(!0,y[t],n):y[t]=n}},internal:function(t,n){if(e.isPlainObject(t))e.extend(!0,h,t);else{if(void 0===n)return h[t];h[t]=n}},debug:function(){!y.silent&&y.debug&&(y.performance?h.performance.log(arguments):(h.debug=Function.prototype.bind.call(console.info,console,y.name+":"),h.debug.apply(console,arguments)))},verbose:function(){!y.silent&&y.verbose&&y.debug&&(y.performance?h.performance.log(arguments):(h.verbose=Function.prototype.bind.call(console.info,console,y.name+":"),h.verbose.apply(console,arguments)))},error:function(){y.silent||(h.error=Function.prototype.bind.call(console.error,console,y.name+":"),h.error.apply(console,arguments))},performance:{log:function(e){var t,n,i;y.performance&&(t=(new Date).getTime(),i=s||t,n=t-i,s=t,l.push({Name:e[0],Arguments:[].slice.call(e,1)||"",Element:F,"Execution Time":n})),clearTimeout(h.performance.timer),h.performance.timer=setTimeout(h.performance.display,500)},display:function(){var t=y.name+":",n=0;s=!1,clearTimeout(h.performance.timer),e.each(l,function(e,t){n+=t["Execution Time"]}),t+=" "+n+"ms",r&&(t+=" '"+r+"'"),(void 0!==console.group||void 0!==console.table)&&l.length>0&&(console.groupCollapsed(t),console.table?console.table(l):e.each(l,function(e,t){console.log(t.Name+": "+t["Execution Time"]+"ms")}),console.groupEnd()),l=[]}},invoke:function(t,n,i){var a,r,s,l=O;return n=n||d,i=F||i,"string"==typeof t&&void 0!==l&&(t=t.split(/[\. ]/),a=t.length-1,e.each(t,function(n,i){var o=n!=a?i+t[n+1].charAt(0).toUpperCase()+t[n+1].slice(1):t;if(e.isPlainObject(l[o])&&n!=a)l=l[o];else{if(void 0!==l[o])return r=l[o],!1;if(!e.isPlainObject(l[i])||n==a)return void 0!==l[i]?(r=l[i],!1):(h.error(k.method,t),!1);l=l[i]}})),e.isFunction(r)?s=r.apply(i,n):void 0!==r&&(s=r),e.isArray(o)?o.push(s):void 0!==o?o=[o,s]:void 0!==s&&(o=s),r}},u?(void 0===O&&h.initialize(),h.invoke(c)):(void 0!==O&&O.invoke("destroy"),h.initialize())}),void 0!==o?o:this},e.tab=function(){e(t).tab.apply(this,arguments)},e.fn.tab.settings={name:"Tab",namespace:"tab",silent:!1,debug:!1,verbose:!1,performance:!0,auto:!1,history:!1,historyType:"hash",path:!1,context:!1,childrenOnly:!1,maxDepth:25,deactivate:"siblings",alwaysRefresh:!1,cache:!0,loadOnce:!1,cacheType:"response",ignoreFirstLoad:!1,apiSettings:!1,evaluateScripts:"once",onFirstLoad:function(e,t,n){},onLoad:function(e,t,n){},onVisible:function(e,t,n){},onRequest:function(e,t,n){},templates:{determineTitle:function(e){}},error:{api:"You attempted to load content without API module",method:"The method you called is not defined",missingTab:"Activated tab cannot be found. Tabs are case-sensitive.",noContent:"The tab you specified is missing a content url.",path:"History enabled, but no path was specified",recursion:"Max recursive depth reached",legacyInit:"onTabInit has been renamed to onFirstLoad in 2.0, please adjust your code.",legacyLoad:"onTabLoad has been renamed to onLoad in 2.0. Please adjust your code",state:"History requires Asual's Address library <https://github.com/asual/jquery-address>"},metadata:{tab:"tab",loaded:"loaded",promise:"promise"},className:{loading:"loading",active:"active"},selector:{tabs:".ui.tab",ui:".ui"}}}(jQuery,window,document),function(e,t,n,i){"use strict";t=void 0!==t&&t.Math==Math?t:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")(),e.fn.transition=function(){var i,o=e(this),a=o.selector||"",r=(new Date).getTime(),s=[],l=arguments,c=l[0],u=[].slice.call(arguments,1),d="string"==typeof c;t.requestAnimationFrame||t.mozRequestAnimationFrame||t.webkitRequestAnimationFrame||t.msRequestAnimationFrame;return o.each(function(t){var f,m,g,v,p,h,b,y,x,C=e(this),w=this;x={initialize:function(){f=x.get.settings.apply(w,l),v=f.className,g=f.error,p=f.metadata,y="."+f.namespace,b="module-"+f.namespace,m=C.data(b)||x,h=x.get.animationEndEvent(),d&&(d=x.invoke(c)),!1===d&&(x.verbose("Converted arguments into settings object",f),f.interval?x.delay(f.animate):x.animate(),x.instantiate())},instantiate:function(){x.verbose("Storing instance of module",x),m=x,C.data(b,m)},destroy:function(){x.verbose("Destroying previous module for",w),C.removeData(b)},refresh:function(){x.verbose("Refreshing display type on next animation"),delete x.displayType},forceRepaint:function(){x.verbose("Forcing element repaint");var e=C.parent(),t=C.next();0===t.length?C.detach().appendTo(e):C.detach().insertBefore(t)},repaint:function(){x.verbose("Repainting element");w.offsetWidth},delay:function(e){var n,i,a=x.get.animationDirection();a||(a=x.can.transition()?x.get.direction():"static"),e=void 0!==e?e:f.interval,n="auto"==f.reverse&&a==v.outward,i=n||1==f.reverse?(o.length-t)*f.interval:t*f.interval,x.debug("Delaying animation by",i),setTimeout(x.animate,i)},animate:function(e){if(f=e||f,!x.is.supported())return x.error(g.support),!1;if(x.debug("Preparing animation",f.animation),x.is.animating()){if(f.queue)return!f.allowRepeats&&x.has.direction()&&x.is.occurring()&&!0!==x.queuing?x.debug("Animation is currently occurring, preventing queueing same animation",f.animation):x.queue(f.animation),!1;if(!f.allowRepeats&&x.is.occurring())return x.debug("Animation is already occurring, will not execute repeated animation",f.animation),!1;x.debug("New animation started, completing previous early",f.animation),m.complete()}x.can.animate()?x.set.animating(f.animation):x.error(g.noAnimation,f.animation,w)},reset:function(){x.debug("Resetting animation to beginning conditions"),x.remove.animationCallbacks(),x.restore.conditions(),x.remove.animating()},queue:function(e){x.debug("Queueing animation of",e),x.queuing=!0,C.one(h+".queue"+y,function(){x.queuing=!1,x.repaint(),x.animate.apply(this,f)})},complete:function(e){x.debug("Animation complete",f.animation),x.remove.completeCallback(),x.remove.failSafe(),x.is.looping()||(x.is.outward()?(x.verbose("Animation is outward, hiding element"),x.restore.conditions(),x.hide()):x.is.inward()?(x.verbose("Animation is outward, showing element"),x.restore.conditions(),x.show()):(x.verbose("Static animation completed"),x.restore.conditions(),f.onComplete.call(w)))},force:{visible:function(){var e=C.attr("style"),t=x.get.userStyle(),n=x.get.displayType(),i=t+"display: "+n+" !important;",o=C.css("display"),a=void 0===e||""===e;o!==n?(x.verbose("Overriding default display to show element",n),C.attr("style",i)):a&&C.removeAttr("style")},hidden:function(){var e=C.attr("style"),t=C.css("display"),n=void 0===e||""===e;"none"===t||x.is.hidden()?n&&C.removeAttr("style"):(x.verbose("Overriding default display to hide element"),C.css("display","none"))}},has:{direction:function(t){var n=!1;return t=t||f.animation,"string"==typeof t&&(t=t.split(" "),e.each(t,function(e,t){t!==v.inward&&t!==v.outward||(n=!0)})),n},inlineDisplay:function(){var t=C.attr("style")||"";return e.isArray(t.match(/display.*?;/,""))}},set:{animating:function(e){var t;x.remove.completeCallback(),e=e||f.animation,t=x.get.animationClass(e),x.save.animation(t),x.force.visible(),x.remove.hidden(),x.remove.direction(),x.start.animation(t)},duration:function(e,t){t=t||f.duration,((t="number"==typeof t?t+"ms":t)||0===t)&&(x.verbose("Setting animation duration",t),C.css({"animation-duration":t}))},direction:function(e){e=e||x.get.direction(),e==v.inward?x.set.inward():x.set.outward()},looping:function(){x.debug("Transition set to loop"),C.addClass(v.looping)},hidden:function(){C.addClass(v.transition).addClass(v.hidden)},inward:function(){x.debug("Setting direction to inward"),C.removeClass(v.outward).addClass(v.inward)},outward:function(){x.debug("Setting direction to outward"),C.removeClass(v.inward).addClass(v.outward)},visible:function(){C.addClass(v.transition).addClass(v.visible)}},start:{animation:function(e){e=e||x.get.animationClass(),x.debug("Starting tween",e),C.addClass(e).one(h+".complete"+y,x.complete),f.useFailSafe&&x.add.failSafe(),x.set.duration(f.duration),f.onStart.call(w)}},save:{animation:function(e){x.cache||(x.cache={}),x.cache.animation=e},displayType:function(e){"none"!==e&&C.data(p.displayType,e)},transitionExists:function(t,n){e.fn.transition.exists[t]=n,x.verbose("Saving existence of transition",t,n)}},restore:{conditions:function(){var e=x.get.currentAnimation();e&&(C.removeClass(e),x.verbose("Removing animation class",x.cache)),x.remove.duration()}},add:{failSafe:function(){var e=x.get.duration();x.timer=setTimeout(function(){C.triggerHandler(h)},e+f.failSafeDelay),x.verbose("Adding fail safe timer",x.timer)}},remove:{animating:function(){C.removeClass(v.animating)},animationCallbacks:function(){x.remove.queueCallback(),x.remove.completeCallback()},queueCallback:function(){C.off(".queue"+y)},completeCallback:function(){C.off(".complete"+y)},display:function(){C.css("display","")},direction:function(){C.removeClass(v.inward).removeClass(v.outward)},duration:function(){C.css("animation-duration","")},failSafe:function(){x.verbose("Removing fail safe timer",x.timer),x.timer&&clearTimeout(x.timer)},hidden:function(){C.removeClass(v.hidden)},visible:function(){C.removeClass(v.visible)},looping:function(){x.debug("Transitions are no longer looping"),x.is.looping()&&(x.reset(),C.removeClass(v.looping))},transition:function(){C.removeClass(v.visible).removeClass(v.hidden)}},get:{settings:function(t,n,i){return"object"==typeof t?e.extend(!0,{},e.fn.transition.settings,t):"function"==typeof i?e.extend({},e.fn.transition.settings,{animation:t,onComplete:i,duration:n}):"string"==typeof n||"number"==typeof n?e.extend({},e.fn.transition.settings,{animation:t,duration:n}):"object"==typeof n?e.extend({},e.fn.transition.settings,n,{animation:t}):"function"==typeof n?e.extend({},e.fn.transition.settings,{animation:t,onComplete:n}):e.extend({},e.fn.transition.settings,{animation:t})},animationClass:function(e){var t=e||f.animation,n=x.can.transition()&&!x.has.direction()?x.get.direction()+" ":"";return v.animating+" "+v.transition+" "+n+t},currentAnimation:function(){return!(!x.cache||void 0===x.cache.animation)&&x.cache.animation},currentDirection:function(){return x.is.inward()?v.inward:v.outward},direction:function(){return x.is.hidden()||!x.is.visible()?v.inward:v.outward},animationDirection:function(t){var n;return t=t||f.animation,"string"==typeof t&&(t=t.split(" "),e.each(t,function(e,t){t===v.inward?n=v.inward:t===v.outward&&(n=v.outward)})),n||!1},duration:function(e){return e=e||f.duration,!1===e&&(e=C.css("animation-duration")||0),"string"==typeof e?e.indexOf("ms")>-1?parseFloat(e):1e3*parseFloat(e):e},displayType:function(e){return e=void 0===e||e,f.displayType?f.displayType:(e&&void 0===C.data(p.displayType)&&x.can.transition(!0),C.data(p.displayType))},userStyle:function(e){return e=e||C.attr("style")||"",e.replace(/display.*?;/,"")},transitionExists:function(t){return e.fn.transition.exists[t]},animationStartEvent:function(){var e,t=n.createElement("div"),i={animation:"animationstart",OAnimation:"oAnimationStart",MozAnimation:"mozAnimationStart",WebkitAnimation:"webkitAnimationStart"};for(e in i)if(void 0!==t.style[e])return i[e];return!1},animationEndEvent:function(){var e,t=n.createElement("div"),i={animation:"animationend",OAnimation:"oAnimationEnd",MozAnimation:"mozAnimationEnd",WebkitAnimation:"webkitAnimationEnd"};for(e in i)if(void 0!==t.style[e])return i[e];return!1}},can:{transition:function(t){var n,i,o,a,r,s,l=f.animation,c=x.get.transitionExists(l),u=x.get.displayType(!1);if(void 0===c||t){if(x.verbose("Determining whether animation exists"),n=C.attr("class"),i=C.prop("tagName"),o=e("<"+i+" />").addClass(n).insertAfter(C),a=o.addClass(l).removeClass(v.inward).removeClass(v.outward).addClass(v.animating).addClass(v.transition).css("animationName"),r=o.addClass(v.inward).css("animationName"),u||(u=o.attr("class",n).removeAttr("style").removeClass(v.hidden).removeClass(v.visible).show().css("display"),x.verbose("Determining final display state",u),x.save.displayType(u)),o.remove(),a!=r)x.debug("Direction exists for animation",l),s=!0;else{if("none"==a||!a)return void x.debug("No animation defined in css",l);x.debug("Static animation found",l,u),s=!1}x.save.transitionExists(l,s)}return void 0!==c?c:s},animate:function(){return void 0!==x.can.transition()}},is:{animating:function(){return C.hasClass(v.animating)},inward:function(){return C.hasClass(v.inward)},outward:function(){return C.hasClass(v.outward)},looping:function(){return C.hasClass(v.looping)},occurring:function(e){return e=e||f.animation,e="."+e.replace(" ","."),C.filter(e).length>0},visible:function(){return C.is(":visible")},hidden:function(){return"hidden"===C.css("visibility")},supported:function(){return!1!==h}},hide:function(){x.verbose("Hiding element"),x.is.animating()&&x.reset(),w.blur(),x.remove.display(),x.remove.visible(),x.set.hidden(),x.force.hidden(),f.onHide.call(w),f.onComplete.call(w)},show:function(e){x.verbose("Showing element",e),x.remove.hidden(),x.set.visible(),x.force.visible(),f.onShow.call(w),f.onComplete.call(w)},toggle:function(){x.is.visible()?x.hide():x.show()},stop:function(){x.debug("Stopping current animation"),C.triggerHandler(h)},stopAll:function(){x.debug("Stopping all animation"),x.remove.queueCallback(),C.triggerHandler(h)},clear:{queue:function(){x.debug("Clearing animation queue"),x.remove.queueCallback()}},enable:function(){x.verbose("Starting animation"),C.removeClass(v.disabled)},disable:function(){x.debug("Stopping animation"),C.addClass(v.disabled)},setting:function(t,n){if(x.debug("Changing setting",t,n),e.isPlainObject(t))e.extend(!0,f,t);else{if(void 0===n)return f[t];e.isPlainObject(f[t])?e.extend(!0,f[t],n):f[t]=n}},internal:function(t,n){if(e.isPlainObject(t))e.extend(!0,x,t);else{if(void 0===n)return x[t];x[t]=n}},debug:function(){!f.silent&&f.debug&&(f.performance?x.performance.log(arguments):(x.debug=Function.prototype.bind.call(console.info,console,f.name+":"),x.debug.apply(console,arguments)))},verbose:function(){!f.silent&&f.verbose&&f.debug&&(f.performance?x.performance.log(arguments):(x.verbose=Function.prototype.bind.call(console.info,console,f.name+":"),x.verbose.apply(console,arguments)))},error:function(){f.silent||(x.error=Function.prototype.bind.call(console.error,console,f.name+":"),x.error.apply(console,arguments))},performance:{log:function(e){var t,n,i;f.performance&&(t=(new Date).getTime(),i=r||t,n=t-i,r=t,s.push({Name:e[0],Arguments:[].slice.call(e,1)||"",Element:w,"Execution Time":n})),clearTimeout(x.performance.timer),x.performance.timer=setTimeout(x.performance.display,500)},display:function(){var t=f.name+":",n=0;r=!1,clearTimeout(x.performance.timer),e.each(s,function(e,t){n+=t["Execution Time"]}),t+=" "+n+"ms",a&&(t+=" '"+a+"'"),o.length>1&&(t+=" ("+o.length+")"),(void 0!==console.group||void 0!==console.table)&&s.length>0&&(console.groupCollapsed(t),console.table?console.table(s):e.each(s,function(e,t){console.log(t.Name+": "+t["Execution Time"]+"ms")}),console.groupEnd()),s=[]}},invoke:function(t,n,o){var a,r,s,l=m;return n=n||u,o=w||o,"string"==typeof t&&void 0!==l&&(t=t.split(/[\. ]/),a=t.length-1,e.each(t,function(n,i){var o=n!=a?i+t[n+1].charAt(0).toUpperCase()+t[n+1].slice(1):t;if(e.isPlainObject(l[o])&&n!=a)l=l[o];else{if(void 0!==l[o])return r=l[o],!1;if(!e.isPlainObject(l[i])||n==a)return void 0!==l[i]&&(r=l[i],!1);l=l[i]}})),e.isFunction(r)?s=r.apply(o,n):void 0!==r&&(s=r),e.isArray(i)?i.push(s):void 0!==i?i=[i,s]:void 0!==s&&(i=s),void 0!==r&&r}},x.initialize()}),void 0!==i?i:this},e.fn.transition.exists={},e.fn.transition.settings={name:"Transition",silent:!1,debug:!1,verbose:!1,performance:!0,namespace:"transition",interval:0,reverse:"auto",onStart:function(){},onComplete:function(){},onShow:function(){},onHide:function(){},useFailSafe:!0,failSafeDelay:100,allowRepeats:!1,displayType:!1,animation:"fade",duration:!1,queue:!0,metadata:{displayType:"display"},className:{animating:"animating",disabled:"disabled",hidden:"hidden",inward:"in",loading:"loading",looping:"looping",outward:"out",transition:"transition",visible:"visible"},error:{noAnimation:"Element is no longer attached to DOM. Unable to animate.  Use silent setting to surpress this warning in production.",repeated:"That animation is already occurring, cancelling repeated animation",method:"The method you called is not defined",support:"This browser does not support CSS animations"}}}(jQuery,window,document),function(e,t,n,i){"use strict";var t=void 0!==t&&t.Math==Math?t:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();e.api=e.fn.api=function(n){var i,o=e(e.isFunction(this)?t:this),a=o.selector||"",r=(new Date).getTime(),s=[],l=arguments[0],c="string"==typeof l,u=[].slice.call(arguments,1);return o.each(function(){var o,d,f,m,g,v=e.isPlainObject(n)?e.extend(!0,{},e.fn.api.settings,n):e.extend({},e.fn.api.settings),p=v.namespace,h=v.metadata,b=v.selector,y=v.error,x=v.className,C="."+p,w="module-"+p,k=e(this),S=k.closest(b.form),T=v.stateContext?e(v.stateContext):k,A=this,R=T[0],P=k.data(w);g={initialize:function(){c||g.bind.events(),g.instantiate()},instantiate:function(){g.verbose("Storing instance of module",g),P=g,k.data(w,P)},destroy:function(){g.verbose("Destroying previous module for",A),k.removeData(w).off(C)},bind:{events:function(){var e=g.get.event();e?(g.verbose("Attaching API events to element",e),k.on(e+C,g.event.trigger)):"now"==v.on&&(g.debug("Querying API endpoint immediately"),g.query())}},decode:{json:function(e){if(void 0!==e&&"string"==typeof e)try{e=JSON.parse(e)}catch(e){}return e}},read:{cachedResponse:function(e){var n;return void 0===t.Storage?void g.error(y.noStorage):(n=sessionStorage.getItem(e),g.debug("Using cached response",e,n),n=g.decode.json(n))}},write:{cachedResponse:function(n,i){return i&&""===i?void g.debug("Response empty, not caching",i):void 0===t.Storage?void g.error(y.noStorage):(e.isPlainObject(i)&&(i=JSON.stringify(i)),sessionStorage.setItem(n,i),void g.verbose("Storing cached response for url",n,i))}},query:function(){if(g.is.disabled())return void g.debug("Element is disabled API request aborted");if(g.is.loading()){if(!v.interruptRequests)return void g.debug("Cancelling request, previous request is still pending");g.debug("Interrupting previous request"),g.abort()}if(v.defaultData&&e.extend(!0,v.urlData,g.get.defaultData()),v.serializeForm&&(v.data=g.add.formData(v.data)),!1===(d=g.get.settings()))return g.cancelled=!0,void g.error(y.beforeSend);if(g.cancelled=!1,!(f=g.get.templatedURL())&&!g.is.mocked())return void g.error(y.missingURL);if((f=g.add.urlData(f))||g.is.mocked()){if(d.url=v.base+f,o=e.extend(!0,{},v,{type:v.method||v.type,data:void 0,url:v.base+f,beforeSend:v.beforeXHR,success:function(){},failure:function(){},complete:function(){}}),g.debug("Querying URL",o.url),g.verbose("Using AJAX settings",o),"local"===v.cache&&g.read.cachedResponse(f))return g.debug("Response returned from local cache"),g.request=g.create.request(),void g.request.resolveWith(R,[g.read.cachedResponse(f)]);v.throttle?v.throttleFirstRequest||g.timer?(g.debug("Throttling request",v.throttle),clearTimeout(g.timer),g.timer=setTimeout(function(){g.timer&&delete g.timer,g.debug("Sending throttled request",void 0,o.method),g.send.request()},v.throttle)):(g.debug("Sending request",void 0,o.method),g.send.request(),g.timer=setTimeout(function(){},v.throttle)):(g.debug("Sending request",void 0,o.method),g.send.request())}},should:{removeError:function(){return!0===v.hideError||"auto"===v.hideError&&!g.is.form()}},is:{disabled:function(){return k.filter(b.disabled).length>0},expectingJSON:function(){return"json"===v.dataType||"jsonp"===v.dataType},form:function(){return k.is("form")||T.is("form")},mocked:function(){return v.mockResponse||v.mockResponseAsync||v.response||v.responseAsync},input:function(){return k.is("input")},loading:function(){return!!g.request&&"pending"==g.request.state()},abortedRequest:function(e){return e&&void 0!==e.readyState&&0===e.readyState?(g.verbose("XHR request determined to be aborted"),!0):(g.verbose("XHR request was not aborted"),!1)},validResponse:function(t){return g.is.expectingJSON()&&e.isFunction(v.successTest)?(g.debug("Checking JSON returned success",v.successTest,t),v.successTest(t)?(g.debug("Response passed success test",t),!0):(g.debug("Response failed success test",t),!1)):(g.verbose("Response is not JSON, skipping validation",v.successTest,t),!0)}},was:{cancelled:function(){return g.cancelled||!1},succesful:function(){return g.request&&"resolved"==g.request.state()},failure:function(){return g.request&&"rejected"==g.request.state()},complete:function(){return g.request&&("resolved"==g.request.state()||"rejected"==g.request.state())}},add:{urlData:function(t,n){var i,o;return t&&(i=t.match(v.regExp.required),o=t.match(v.regExp.optional),n=n||v.urlData,i&&(g.debug("Looking for required URL variables",i),e.each(i,function(i,o){var a=-1!==o.indexOf("$")?o.substr(2,o.length-3):o.substr(1,o.length-2),r=e.isPlainObject(n)&&void 0!==n[a]?n[a]:void 0!==k.data(a)?k.data(a):void 0!==T.data(a)?T.data(a):n[a];if(void 0===r)return g.error(y.requiredParameter,a,t),t=!1,!1;g.verbose("Found required variable",a,r),r=v.encodeParameters?g.get.urlEncodedValue(r):r,t=t.replace(o,r)})),o&&(g.debug("Looking for optional URL variables",i),e.each(o,function(i,o){var a=-1!==o.indexOf("$")?o.substr(3,o.length-4):o.substr(2,o.length-3),r=e.isPlainObject(n)&&void 0!==n[a]?n[a]:void 0!==k.data(a)?k.data(a):void 0!==T.data(a)?T.data(a):n[a];void 0!==r?(g.verbose("Optional variable Found",a,r),t=t.replace(o,r)):(g.verbose("Optional variable not found",a),t=-1!==t.indexOf("/"+o)?t.replace("/"+o,""):t.replace(o,""))}))),t},formData:function(t){var n,i=void 0!==e.fn.serializeObject,o=i?S.serializeObject():S.serialize();return t=t||v.data,n=e.isPlainObject(t),n?i?(g.debug("Extending existing data with form data",t,o),t=e.extend(!0,{},t,o)):(g.error(y.missingSerialize),g.debug("Cant extend data. Replacing data with form data",t,o),t=o):(g.debug("Adding form data",o),t=o),t}},send:{request:function(){g.set.loading(),g.request=g.create.request(),g.is.mocked()?g.mockedXHR=g.create.mockedXHR():g.xhr=g.create.xhr(),v.onRequest.call(R,g.request,g.xhr)}},event:{trigger:function(e){g.query(),"submit"!=e.type&&"click"!=e.type||e.preventDefault()},xhr:{always:function(){},done:function(t,n,i){var o=this,a=(new Date).getTime()-m,r=v.loadingDuration-a,s=!!e.isFunction(v.onResponse)&&(g.is.expectingJSON()?v.onResponse.call(o,e.extend(!0,{},t)):v.onResponse.call(o,t));r=r>0?r:0,s&&(g.debug("Modified API response in onResponse callback",v.onResponse,s,t),t=s),r>0&&g.debug("Response completed early delaying state change by",r),setTimeout(function(){g.is.validResponse(t)?g.request.resolveWith(o,[t,i]):g.request.rejectWith(o,[i,"invalid"])},r)},fail:function(e,t,n){var i=this,o=(new Date).getTime()-m,a=v.loadingDuration-o;a=a>0?a:0,a>0&&g.debug("Response completed early delaying state change by",a),setTimeout(function(){g.is.abortedRequest(e)?g.request.rejectWith(i,[e,"aborted",n]):g.request.rejectWith(i,[e,"error",t,n])},a)}},request:{done:function(e,t){g.debug("Successful API Response",e),"local"===v.cache&&f&&(g.write.cachedResponse(f,e),g.debug("Saving server response locally",g.cache)),v.onSuccess.call(R,e,k,t)},complete:function(e,t){var n,i;g.was.succesful()?(i=e,n=t):(n=e,i=g.get.responseFromXHR(n)),g.remove.loading(),v.onComplete.call(R,i,k,n)},fail:function(e,t,n){var i=g.get.responseFromXHR(e),a=g.get.errorFromRequest(i,t,n);if("aborted"==t)return g.debug("XHR Aborted (Most likely caused by page navigation or CORS Policy)",t,n),v.onAbort.call(R,t,k,e),!0;"invalid"==t?g.debug("JSON did not pass success test. A server-side error has most likely occurred",i):"error"==t&&void 0!==e&&(g.debug("XHR produced a server error",t,n),200!=e.status&&void 0!==n&&""!==n&&g.error(y.statusMessage+n,o.url),v.onError.call(R,a,k,e)),v.errorDuration&&"aborted"!==t&&(g.debug("Adding error state"),g.set.error(),g.should.removeError()&&setTimeout(g.remove.error,v.errorDuration)),g.debug("API Request failed",a,e),v.onFailure.call(R,i,k,e)}}},create:{request:function(){return e.Deferred().always(g.event.request.complete).done(g.event.request.done).fail(g.event.request.fail)},mockedXHR:function(){var t,n,i,o=v.mockResponse||v.response,a=v.mockResponseAsync||v.responseAsync;return i=e.Deferred().always(g.event.xhr.complete).done(g.event.xhr.done).fail(g.event.xhr.fail),o?(e.isFunction(o)?(g.debug("Using specified synchronous callback",o),n=o.call(R,d)):(g.debug("Using settings specified response",o),n=o),i.resolveWith(R,[n,!1,{responseText:n}])):e.isFunction(a)&&(t=function(e){g.debug("Async callback returned response",e),e?i.resolveWith(R,[e,!1,{responseText:e}]):i.rejectWith(R,[{responseText:e},!1,!1])},g.debug("Using specified async response callback",a),a.call(R,d,t)),i},xhr:function(){var t;return t=e.ajax(o).always(g.event.xhr.always).done(g.event.xhr.done).fail(g.event.xhr.fail),g.verbose("Created server request",t,o),t}},set:{error:function(){g.verbose("Adding error state to element",T),T.addClass(x.error)},loading:function(){g.verbose("Adding loading state to element",T),T.addClass(x.loading),m=(new Date).getTime()}},remove:{error:function(){g.verbose("Removing error state from element",T),T.removeClass(x.error)},loading:function(){g.verbose("Removing loading state from element",T),T.removeClass(x.loading)}},get:{responseFromXHR:function(t){return!!e.isPlainObject(t)&&(g.is.expectingJSON()?g.decode.json(t.responseText):t.responseText)},errorFromRequest:function(t,n,i){return e.isPlainObject(t)&&void 0!==t.error?t.error:void 0!==v.error[n]?v.error[n]:i},request:function(){return g.request||!1},xhr:function(){return g.xhr||!1},settings:function(){var t;return t=v.beforeSend.call(R,v),t&&(void 0!==t.success&&(g.debug("Legacy success callback detected",t),g.error(y.legacyParameters,t.success),t.onSuccess=t.success),void 0!==t.failure&&(g.debug("Legacy failure callback detected",t),g.error(y.legacyParameters,t.failure),t.onFailure=t.failure),void 0!==t.complete&&(g.debug("Legacy complete callback detected",t),g.error(y.legacyParameters,t.complete),t.onComplete=t.complete)),void 0===t&&g.error(y.noReturnedValue),!1===t?t:void 0!==t?e.extend(!0,{},t):e.extend(!0,{},v)},urlEncodedValue:function(e){var n=t.decodeURIComponent(e),i=t.encodeURIComponent(e);return n!==e?(g.debug("URL value is already encoded, avoiding double encoding",e),e):(g.verbose("Encoding value using encodeURIComponent",e,i),i)},defaultData:function(){var t={};return e.isWindow(A)||(g.is.input()?t.value=k.val():g.is.form()||(t.text=k.text())),t},event:function(){return e.isWindow(A)||"now"==v.on?(g.debug("API called without element, no events attached"),!1):"auto"==v.on?k.is("input")?void 0!==A.oninput?"input":void 0!==A.onpropertychange?"propertychange":"keyup":k.is("form")?"submit":"click":v.on},templatedURL:function(e){if(e=e||k.data(h.action)||v.action||!1,f=k.data(h.url)||v.url||!1)return g.debug("Using specified url",f),f;if(e){if(g.debug("Looking up url for action",e,v.api),void 0===v.api[e]&&!g.is.mocked())return void g.error(y.missingAction,v.action,v.api);f=v.api[e]}else g.is.form()&&(f=k.attr("action")||T.attr("action")||!1,g.debug("No url or action specified, defaulting to form action",f));return f}},abort:function(){var e=g.get.xhr();e&&"resolved"!==e.state()&&(g.debug("Cancelling API request"),e.abort())},reset:function(){g.remove.error(),g.remove.loading()},setting:function(t,n){if(g.debug("Changing setting",t,n),e.isPlainObject(t))e.extend(!0,v,t);else{if(void 0===n)return v[t];e.isPlainObject(v[t])?e.extend(!0,v[t],n):v[t]=n}},internal:function(t,n){if(e.isPlainObject(t))e.extend(!0,g,t);else{if(void 0===n)return g[t];g[t]=n}},debug:function(){!v.silent&&v.debug&&(v.performance?g.performance.log(arguments):(g.debug=Function.prototype.bind.call(console.info,console,v.name+":"),g.debug.apply(console,arguments)))},verbose:function(){!v.silent&&v.verbose&&v.debug&&(v.performance?g.performance.log(arguments):(g.verbose=Function.prototype.bind.call(console.info,console,v.name+":"),g.verbose.apply(console,arguments)))},error:function(){v.silent||(g.error=Function.prototype.bind.call(console.error,console,v.name+":"),g.error.apply(console,arguments))},performance:{log:function(e){var t,n,i;v.performance&&(t=(new Date).getTime(),i=r||t,n=t-i,r=t,s.push({Name:e[0],Arguments:[].slice.call(e,1)||"","Execution Time":n})),clearTimeout(g.performance.timer),g.performance.timer=setTimeout(g.performance.display,500)},display:function(){var t=v.name+":",n=0;r=!1,clearTimeout(g.performance.timer),e.each(s,function(e,t){n+=t["Execution Time"]}),t+=" "+n+"ms",a&&(t+=" '"+a+"'"),(void 0!==console.group||void 0!==console.table)&&s.length>0&&(console.groupCollapsed(t),console.table?console.table(s):e.each(s,function(e,t){console.log(t.Name+": "+t["Execution Time"]+"ms")}),console.groupEnd()),s=[]}},invoke:function(t,n,o){var a,r,s,l=P;return n=n||u,o=A||o,"string"==typeof t&&void 0!==l&&(t=t.split(/[\. ]/),a=t.length-1,e.each(t,function(n,i){var o=n!=a?i+t[n+1].charAt(0).toUpperCase()+t[n+1].slice(1):t;if(e.isPlainObject(l[o])&&n!=a)l=l[o];else{if(void 0!==l[o])return r=l[o],!1;if(!e.isPlainObject(l[i])||n==a)return void 0!==l[i]?(r=l[i],!1):(g.error(y.method,t),!1);l=l[i]}})),e.isFunction(r)?s=r.apply(o,n):void 0!==r&&(s=r),e.isArray(i)?i.push(s):void 0!==i?i=[i,s]:void 0!==s&&(i=s),r}},c?(void 0===P&&g.initialize(),g.invoke(l)):(void 0!==P&&P.invoke("destroy"),g.initialize())}),void 0!==i?i:this},e.api.settings={name:"API",namespace:"api",debug:!1,verbose:!1,performance:!0,api:{},cache:!0,interruptRequests:!0,on:"auto",stateContext:!1,loadingDuration:0,hideError:"auto",errorDuration:2e3,encodeParameters:!0,action:!1,url:!1,base:"",urlData:{},defaultData:!0,serializeForm:!1,throttle:0,throttleFirstRequest:!0,method:"get",data:{},dataType:"json",mockResponse:!1,mockResponseAsync:!1,response:!1,responseAsync:!1,beforeSend:function(e){return e},beforeXHR:function(e){},onRequest:function(e,t){},onResponse:!1,onSuccess:function(e,t){},onComplete:function(e,t){},onFailure:function(e,t){},onError:function(e,t){},onAbort:function(e,t){},successTest:!1,error:{beforeSend:"The before send function has aborted the request",error:"There was an error with your request",exitConditions:"API Request Aborted. Exit conditions met",JSONParse:"JSON could not be parsed during error handling",legacyParameters:"You are using legacy API success callback names",method:"The method you called is not defined",missingAction:"API action used but no url was defined",missingSerialize:"jquery-serialize-object is required to add form data to an existing data object",missingURL:"No URL specified for api event",noReturnedValue:"The beforeSend callback must return a settings object, beforeSend ignored.",noStorage:"Caching responses locally requires session storage",parseError:"There was an error parsing your request",requiredParameter:"Missing a required URL parameter: ",statusMessage:"Server gave an error: ",timeout:"Your request timed out"},regExp:{required:/\{\$*[A-z0-9]+\}/g,optional:/\{\/\$*[A-z0-9]+\}/g},className:{loading:"loading",error:"error"},selector:{disabled:".disabled",form:"form"},metadata:{action:"action",url:"url"}}}(jQuery,window,document),function(e,t,n,i){"use strict";t=void 0!==t&&t.Math==Math?t:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")(),e.fn.state=function(t){var i,o=e(this),a=o.selector||"",r=(n.documentElement,(new Date).getTime()),s=[],l=arguments[0],c="string"==typeof l,u=[].slice.call(arguments,1);return o.each(function(){
var n,d=e.isPlainObject(t)?e.extend(!0,{},e.fn.state.settings,t):e.extend({},e.fn.state.settings),f=d.error,m=d.metadata,g=d.className,v=d.namespace,p=d.states,h=d.text,b="."+v,y=v+"-module",x=e(this),C=this,w=x.data(y);n={initialize:function(){n.verbose("Initializing module"),d.automatic&&n.add.defaults(),d.context&&""!==a?e(d.context).on(a,"mouseenter"+b,n.change.text).on(a,"mouseleave"+b,n.reset.text).on(a,"click"+b,n.toggle.state):x.on("mouseenter"+b,n.change.text).on("mouseleave"+b,n.reset.text).on("click"+b,n.toggle.state),n.instantiate()},instantiate:function(){n.verbose("Storing instance of module",n),w=n,x.data(y,n)},destroy:function(){n.verbose("Destroying previous module",w),x.off(b).removeData(y)},refresh:function(){n.verbose("Refreshing selector cache"),x=e(C)},add:{defaults:function(){var i=t&&e.isPlainObject(t.states)?t.states:{};e.each(d.defaults,function(t,o){void 0!==n.is[t]&&n.is[t]()&&(n.verbose("Adding default states",t,C),e.extend(d.states,o,i))})}},is:{active:function(){return x.hasClass(g.active)},loading:function(){return x.hasClass(g.loading)},inactive:function(){return!x.hasClass(g.active)},state:function(e){return void 0!==g[e]&&x.hasClass(g[e])},enabled:function(){return!x.is(d.filter.active)},disabled:function(){return x.is(d.filter.active)},textEnabled:function(){return!x.is(d.filter.text)},button:function(){return x.is(".button:not(a, .submit)")},input:function(){return x.is("input")},progress:function(){return x.is(".ui.progress")}},allow:function(e){n.debug("Now allowing state",e),p[e]=!0},disallow:function(e){n.debug("No longer allowing",e),p[e]=!1},allows:function(e){return p[e]||!1},enable:function(){x.removeClass(g.disabled)},disable:function(){x.addClass(g.disabled)},setState:function(e){n.allows(e)&&x.addClass(g[e])},removeState:function(e){n.allows(e)&&x.removeClass(g[e])},toggle:{state:function(){var t;if(n.allows("active")&&n.is.enabled()){if(n.refresh(),void 0!==e.fn.api)if(t=x.api("get request"),x.api("was cancelled"))n.debug("API Request cancelled by beforesend"),d.activateTest=function(){return!1},d.deactivateTest=function(){return!1};else if(t)return void n.listenTo(t);n.change.state()}}},listenTo:function(t){n.debug("API request detected, waiting for state signal",t),t&&(h.loading&&n.update.text(h.loading),e.when(t).then(function(){"resolved"==t.state()?(n.debug("API request succeeded"),d.activateTest=function(){return!0},d.deactivateTest=function(){return!0}):(n.debug("API request failed"),d.activateTest=function(){return!1},d.deactivateTest=function(){return!1}),n.change.state()}))},change:{state:function(){n.debug("Determining state change direction"),n.is.inactive()?n.activate():n.deactivate(),d.sync&&n.sync(),d.onChange.call(C)},text:function(){n.is.textEnabled()&&(n.is.disabled()?(n.verbose("Changing text to disabled text",h.hover),n.update.text(h.disabled)):n.is.active()?h.hover?(n.verbose("Changing text to hover text",h.hover),n.update.text(h.hover)):h.deactivate&&(n.verbose("Changing text to deactivating text",h.deactivate),n.update.text(h.deactivate)):h.hover?(n.verbose("Changing text to hover text",h.hover),n.update.text(h.hover)):h.activate&&(n.verbose("Changing text to activating text",h.activate),n.update.text(h.activate)))}},activate:function(){d.activateTest.call(C)&&(n.debug("Setting state to active"),x.addClass(g.active),n.update.text(h.active),d.onActivate.call(C))},deactivate:function(){d.deactivateTest.call(C)&&(n.debug("Setting state to inactive"),x.removeClass(g.active),n.update.text(h.inactive),d.onDeactivate.call(C))},sync:function(){n.verbose("Syncing other buttons to current state"),n.is.active()?o.not(x).state("activate"):o.not(x).state("deactivate")},get:{text:function(){return d.selector.text?x.find(d.selector.text).text():x.html()},textFor:function(e){return h[e]||!1}},flash:{text:function(e,t,i){var o=n.get.text();n.debug("Flashing text message",e,t),e=e||d.text.flash,t=t||d.flashDuration,i=i||function(){},n.update.text(e),setTimeout(function(){n.update.text(o),i.call(C)},t)}},reset:{text:function(){var e=h.active||x.data(m.storedText),t=h.inactive||x.data(m.storedText);n.is.textEnabled()&&(n.is.active()&&e?(n.verbose("Resetting active text",e),n.update.text(e)):t&&(n.verbose("Resetting inactive text",e),n.update.text(t)))}},update:{text:function(e){var t=n.get.text();e&&e!==t?(n.debug("Updating text",e),d.selector.text?x.data(m.storedText,e).find(d.selector.text).text(e):x.data(m.storedText,e).html(e)):n.debug("Text is already set, ignoring update",e)}},setting:function(t,i){if(n.debug("Changing setting",t,i),e.isPlainObject(t))e.extend(!0,d,t);else{if(void 0===i)return d[t];e.isPlainObject(d[t])?e.extend(!0,d[t],i):d[t]=i}},internal:function(t,i){if(e.isPlainObject(t))e.extend(!0,n,t);else{if(void 0===i)return n[t];n[t]=i}},debug:function(){!d.silent&&d.debug&&(d.performance?n.performance.log(arguments):(n.debug=Function.prototype.bind.call(console.info,console,d.name+":"),n.debug.apply(console,arguments)))},verbose:function(){!d.silent&&d.verbose&&d.debug&&(d.performance?n.performance.log(arguments):(n.verbose=Function.prototype.bind.call(console.info,console,d.name+":"),n.verbose.apply(console,arguments)))},error:function(){d.silent||(n.error=Function.prototype.bind.call(console.error,console,d.name+":"),n.error.apply(console,arguments))},performance:{log:function(e){var t,i,o;d.performance&&(t=(new Date).getTime(),o=r||t,i=t-o,r=t,s.push({Name:e[0],Arguments:[].slice.call(e,1)||"",Element:C,"Execution Time":i})),clearTimeout(n.performance.timer),n.performance.timer=setTimeout(n.performance.display,500)},display:function(){var t=d.name+":",i=0;r=!1,clearTimeout(n.performance.timer),e.each(s,function(e,t){i+=t["Execution Time"]}),t+=" "+i+"ms",a&&(t+=" '"+a+"'"),(void 0!==console.group||void 0!==console.table)&&s.length>0&&(console.groupCollapsed(t),console.table?console.table(s):e.each(s,function(e,t){console.log(t.Name+": "+t["Execution Time"]+"ms")}),console.groupEnd()),s=[]}},invoke:function(t,o,a){var r,s,l,c=w;return o=o||u,a=C||a,"string"==typeof t&&void 0!==c&&(t=t.split(/[\. ]/),r=t.length-1,e.each(t,function(i,o){var a=i!=r?o+t[i+1].charAt(0).toUpperCase()+t[i+1].slice(1):t;if(e.isPlainObject(c[a])&&i!=r)c=c[a];else{if(void 0!==c[a])return s=c[a],!1;if(!e.isPlainObject(c[o])||i==r)return void 0!==c[o]?(s=c[o],!1):(n.error(f.method,t),!1);c=c[o]}})),e.isFunction(s)?l=s.apply(a,o):void 0!==s&&(l=s),e.isArray(i)?i.push(l):void 0!==i?i=[i,l]:void 0!==l&&(i=l),s}},c?(void 0===w&&n.initialize(),n.invoke(l)):(void 0!==w&&w.invoke("destroy"),n.initialize())}),void 0!==i?i:this},e.fn.state.settings={name:"State",debug:!1,verbose:!1,namespace:"state",performance:!0,onActivate:function(){},onDeactivate:function(){},onChange:function(){},activateTest:function(){return!0},deactivateTest:function(){return!0},automatic:!0,sync:!1,flashDuration:1e3,filter:{text:".loading, .disabled",active:".disabled"},context:!1,error:{beforeSend:"The before send function has cancelled state change",method:"The method you called is not defined."},metadata:{promise:"promise",storedText:"stored-text"},className:{active:"active",disabled:"disabled",error:"error",loading:"loading",success:"success",warning:"warning"},selector:{text:!1},defaults:{input:{disabled:!0,loading:!0,active:!0},button:{disabled:!0,loading:!0,active:!0},progress:{active:!0,success:!0,warning:!0,error:!0}},states:{active:!0,disabled:!0,error:!0,loading:!0,success:!0,warning:!0},text:{disabled:!1,flash:!1,hover:!1,active:!1,inactive:!1,activate:!1,deactivate:!1}}}(jQuery,window,document),function(e,t,n,i){"use strict";t=void 0!==t&&t.Math==Math?t:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")(),e.fn.visibility=function(i){var o,a=e(this),r=a.selector||"",s=(new Date).getTime(),l=[],c=arguments[0],u="string"==typeof c,d=[].slice.call(arguments,1),f=a.length,m=0;return a.each(function(){var a,g,v,p,h=e.isPlainObject(i)?e.extend(!0,{},e.fn.visibility.settings,i):e.extend({},e.fn.visibility.settings),b=h.className,y=h.namespace,x=h.error,C=h.metadata,w="."+y,k="module-"+y,S=e(t),T=e(this),A=e(h.context),R=(T.selector,T.data(k)),P=t.requestAnimationFrame||t.mozRequestAnimationFrame||t.webkitRequestAnimationFrame||t.msRequestAnimationFrame||function(e){setTimeout(e,0)},E=this,F=!1;p={initialize:function(){p.debug("Initializing",h),p.setup.cache(),p.should.trackChanges()&&("image"==h.type&&p.setup.image(),"fixed"==h.type&&p.setup.fixed(),h.observeChanges&&p.observeChanges(),p.bind.events()),p.save.position(),p.is.visible()||p.error(x.visible,T),h.initialCheck&&p.checkVisibility(),p.instantiate()},instantiate:function(){p.debug("Storing instance",p),T.data(k,p),R=p},destroy:function(){p.verbose("Destroying previous module"),v&&v.disconnect(),g&&g.disconnect(),S.off("load"+w,p.event.load).off("resize"+w,p.event.resize),A.off("scroll"+w,p.event.scroll).off("scrollchange"+w,p.event.scrollchange),"fixed"==h.type&&(p.resetFixed(),p.remove.placeholder()),T.off(w).removeData(k)},observeChanges:function(){"MutationObserver"in t&&(g=new MutationObserver(p.event.contextChanged),v=new MutationObserver(p.event.changed),g.observe(n,{childList:!0,subtree:!0}),v.observe(E,{childList:!0,subtree:!0}),p.debug("Setting up mutation observer",v))},bind:{events:function(){p.verbose("Binding visibility events to scroll and resize"),h.refreshOnLoad&&S.on("load"+w,p.event.load),S.on("resize"+w,p.event.resize),A.off("scroll"+w).on("scroll"+w,p.event.scroll).on("scrollchange"+w,p.event.scrollchange)}},event:{changed:function(e){p.verbose("DOM tree modified, updating visibility calculations"),p.timer=setTimeout(function(){p.verbose("DOM tree modified, updating sticky menu"),p.refresh()},100)},contextChanged:function(t){[].forEach.call(t,function(t){t.removedNodes&&[].forEach.call(t.removedNodes,function(t){(t==E||e(t).find(E).length>0)&&(p.debug("Element removed from DOM, tearing down events"),p.destroy())})})},resize:function(){p.debug("Window resized"),h.refreshOnResize&&P(p.refresh)},load:function(){p.debug("Page finished loading"),P(p.refresh)},scroll:function(){h.throttle?(clearTimeout(p.timer),p.timer=setTimeout(function(){A.triggerHandler("scrollchange"+w,[A.scrollTop()])},h.throttle)):P(function(){A.triggerHandler("scrollchange"+w,[A.scrollTop()])})},scrollchange:function(e,t){p.checkVisibility(t)}},precache:function(t,i){t instanceof Array||(t=[t]);for(var o=t.length,a=0,r=[],s=n.createElement("img"),l=function(){++a>=t.length&&e.isFunction(i)&&i()};o--;)s=n.createElement("img"),s.onload=l,s.onerror=l,s.src=t[o],r.push(s)},enableCallbacks:function(){p.debug("Allowing callbacks to occur"),F=!1},disableCallbacks:function(){p.debug("Disabling all callbacks temporarily"),F=!0},should:{trackChanges:function(){return u?(p.debug("One time query, no need to bind events"),!1):(p.debug("Callbacks being attached"),!0)}},setup:{cache:function(){p.cache={occurred:{},screen:{},element:{}}},image:function(){var e=T.data(C.src);e&&(p.verbose("Lazy loading image",e),h.once=!0,h.observeChanges=!1,h.onOnScreen=function(){p.debug("Image on screen",E),p.precache(e,function(){p.set.image(e,function(){m++,m==f&&h.onAllLoaded.call(this),h.onLoad.call(this)})})})},fixed:function(){p.debug("Setting up fixed"),h.once=!1,h.observeChanges=!1,h.initialCheck=!0,h.refreshOnLoad=!0,i.transition||(h.transition=!1),p.create.placeholder(),p.debug("Added placeholder",a),h.onTopPassed=function(){p.debug("Element passed, adding fixed position",T),p.show.placeholder(),p.set.fixed(),h.transition&&void 0!==e.fn.transition&&T.transition(h.transition,h.duration)},h.onTopPassedReverse=function(){p.debug("Element returned to position, removing fixed",T),p.hide.placeholder(),p.remove.fixed()}}},create:{placeholder:function(){p.verbose("Creating fixed position placeholder"),a=T.clone(!1).css("display","none").addClass(b.placeholder).insertAfter(T)}},show:{placeholder:function(){p.verbose("Showing placeholder"),a.css("display","block").css("visibility","hidden")}},hide:{placeholder:function(){p.verbose("Hiding placeholder"),a.css("display","none").css("visibility","")}},set:{fixed:function(){p.verbose("Setting element to fixed position"),T.addClass(b.fixed).css({position:"fixed",top:h.offset+"px",left:"auto",zIndex:h.zIndex}),h.onFixed.call(E)},image:function(t,n){if(T.attr("src",t),h.transition)if(void 0!==e.fn.transition){if(T.hasClass(b.visible))return void p.debug("Transition already occurred on this image, skipping animation");T.transition(h.transition,h.duration,n)}else T.fadeIn(h.duration,n);else T.show()}},is:{onScreen:function(){return p.get.elementCalculations().onScreen},offScreen:function(){return p.get.elementCalculations().offScreen},visible:function(){return!(!p.cache||!p.cache.element)&&!(0===p.cache.element.width&&0===p.cache.element.offset.top)},verticallyScrollableContext:function(){var e=A.get(0)!==t&&A.css("overflow-y");return"auto"==e||"scroll"==e},horizontallyScrollableContext:function(){var e=A.get(0)!==t&&A.css("overflow-x");return"auto"==e||"scroll"==e}},refresh:function(){p.debug("Refreshing constants (width/height)"),"fixed"==h.type&&p.resetFixed(),p.reset(),p.save.position(),h.checkOnRefresh&&p.checkVisibility(),h.onRefresh.call(E)},resetFixed:function(){p.remove.fixed(),p.remove.occurred()},reset:function(){p.verbose("Resetting all cached values"),e.isPlainObject(p.cache)&&(p.cache.screen={},p.cache.element={})},checkVisibility:function(e){p.verbose("Checking visibility of element",p.cache.element),!F&&p.is.visible()&&(p.save.scroll(e),p.save.calculations(),p.passed(),p.passingReverse(),p.topVisibleReverse(),p.bottomVisibleReverse(),p.topPassedReverse(),p.bottomPassedReverse(),p.onScreen(),p.offScreen(),p.passing(),p.topVisible(),p.bottomVisible(),p.topPassed(),p.bottomPassed(),h.onUpdate&&h.onUpdate.call(E,p.get.elementCalculations()))},passed:function(t,n){var i=p.get.elementCalculations();if(t&&n)h.onPassed[t]=n;else{if(void 0!==t)return p.get.pixelsPassed(t)>i.pixelsPassed;i.passing&&e.each(h.onPassed,function(e,t){i.bottomVisible||i.pixelsPassed>p.get.pixelsPassed(e)?p.execute(t,e):h.once||p.remove.occurred(t)})}},onScreen:function(e){var t=p.get.elementCalculations(),n=e||h.onOnScreen;if(e&&(p.debug("Adding callback for onScreen",e),h.onOnScreen=e),t.onScreen?p.execute(n,"onScreen"):h.once||p.remove.occurred("onScreen"),void 0!==e)return t.onOnScreen},offScreen:function(e){var t=p.get.elementCalculations(),n=e||h.onOffScreen;if(e&&(p.debug("Adding callback for offScreen",e),h.onOffScreen=e),t.offScreen?p.execute(n,"offScreen"):h.once||p.remove.occurred("offScreen"),void 0!==e)return t.onOffScreen},passing:function(e){var t=p.get.elementCalculations(),n=e||h.onPassing;if(e&&(p.debug("Adding callback for passing",e),h.onPassing=e),t.passing?p.execute(n,"passing"):h.once||p.remove.occurred("passing"),void 0!==e)return t.passing},topVisible:function(e){var t=p.get.elementCalculations(),n=e||h.onTopVisible;if(e&&(p.debug("Adding callback for top visible",e),h.onTopVisible=e),t.topVisible?p.execute(n,"topVisible"):h.once||p.remove.occurred("topVisible"),void 0===e)return t.topVisible},bottomVisible:function(e){var t=p.get.elementCalculations(),n=e||h.onBottomVisible;if(e&&(p.debug("Adding callback for bottom visible",e),h.onBottomVisible=e),t.bottomVisible?p.execute(n,"bottomVisible"):h.once||p.remove.occurred("bottomVisible"),void 0===e)return t.bottomVisible},topPassed:function(e){var t=p.get.elementCalculations(),n=e||h.onTopPassed;if(e&&(p.debug("Adding callback for top passed",e),h.onTopPassed=e),t.topPassed?p.execute(n,"topPassed"):h.once||p.remove.occurred("topPassed"),void 0===e)return t.topPassed},bottomPassed:function(e){var t=p.get.elementCalculations(),n=e||h.onBottomPassed;if(e&&(p.debug("Adding callback for bottom passed",e),h.onBottomPassed=e),t.bottomPassed?p.execute(n,"bottomPassed"):h.once||p.remove.occurred("bottomPassed"),void 0===e)return t.bottomPassed},passingReverse:function(e){var t=p.get.elementCalculations(),n=e||h.onPassingReverse;if(e&&(p.debug("Adding callback for passing reverse",e),h.onPassingReverse=e),t.passing?h.once||p.remove.occurred("passingReverse"):p.get.occurred("passing")&&p.execute(n,"passingReverse"),void 0!==e)return!t.passing},topVisibleReverse:function(e){var t=p.get.elementCalculations(),n=e||h.onTopVisibleReverse;if(e&&(p.debug("Adding callback for top visible reverse",e),h.onTopVisibleReverse=e),t.topVisible?h.once||p.remove.occurred("topVisibleReverse"):p.get.occurred("topVisible")&&p.execute(n,"topVisibleReverse"),void 0===e)return!t.topVisible},bottomVisibleReverse:function(e){var t=p.get.elementCalculations(),n=e||h.onBottomVisibleReverse;if(e&&(p.debug("Adding callback for bottom visible reverse",e),h.onBottomVisibleReverse=e),t.bottomVisible?h.once||p.remove.occurred("bottomVisibleReverse"):p.get.occurred("bottomVisible")&&p.execute(n,"bottomVisibleReverse"),void 0===e)return!t.bottomVisible},topPassedReverse:function(e){var t=p.get.elementCalculations(),n=e||h.onTopPassedReverse;if(e&&(p.debug("Adding callback for top passed reverse",e),h.onTopPassedReverse=e),t.topPassed?h.once||p.remove.occurred("topPassedReverse"):p.get.occurred("topPassed")&&p.execute(n,"topPassedReverse"),void 0===e)return!t.onTopPassed},bottomPassedReverse:function(e){var t=p.get.elementCalculations(),n=e||h.onBottomPassedReverse;if(e&&(p.debug("Adding callback for bottom passed reverse",e),h.onBottomPassedReverse=e),t.bottomPassed?h.once||p.remove.occurred("bottomPassedReverse"):p.get.occurred("bottomPassed")&&p.execute(n,"bottomPassedReverse"),void 0===e)return!t.bottomPassed},execute:function(e,t){var n=p.get.elementCalculations(),i=p.get.screenCalculations();e=e||!1,e&&(h.continuous?(p.debug("Callback being called continuously",t,n),e.call(E,n,i)):p.get.occurred(t)||(p.debug("Conditions met",t,n),e.call(E,n,i))),p.save.occurred(t)},remove:{fixed:function(){p.debug("Removing fixed position"),T.removeClass(b.fixed).css({position:"",top:"",left:"",zIndex:""}),h.onUnfixed.call(E)},placeholder:function(){p.debug("Removing placeholder content"),a&&a.remove()},occurred:function(e){if(e){var t=p.cache.occurred;void 0!==t[e]&&!0===t[e]&&(p.debug("Callback can now be called again",e),p.cache.occurred[e]=!1)}else p.cache.occurred={}}},save:{calculations:function(){p.verbose("Saving all calculations necessary to determine positioning"),p.save.direction(),p.save.screenCalculations(),p.save.elementCalculations()},occurred:function(e){e&&(void 0!==p.cache.occurred[e]&&!0===p.cache.occurred[e]||(p.verbose("Saving callback occurred",e),p.cache.occurred[e]=!0))},scroll:function(e){e=e+h.offset||A.scrollTop()+h.offset,p.cache.scroll=e},direction:function(){var e,t=p.get.scroll(),n=p.get.lastScroll();return e=t>n&&n?"down":t<n&&n?"up":"static",p.cache.direction=e,p.cache.direction},elementPosition:function(){var e=p.cache.element,t=p.get.screenSize();return p.verbose("Saving element position"),e.fits=e.height<t.height,e.offset=T.offset(),e.width=T.outerWidth(),e.height=T.outerHeight(),p.is.verticallyScrollableContext()&&(e.offset.top+=A.scrollTop()-A.offset().top),p.is.horizontallyScrollableContext()&&(e.offset.left+=A.scrollLeft-A.offset().left),p.cache.element=e,e},elementCalculations:function(){var e=p.get.screenCalculations(),t=p.get.elementPosition();return h.includeMargin?(t.margin={},t.margin.top=parseInt(T.css("margin-top"),10),t.margin.bottom=parseInt(T.css("margin-bottom"),10),t.top=t.offset.top-t.margin.top,t.bottom=t.offset.top+t.height+t.margin.bottom):(t.top=t.offset.top,t.bottom=t.offset.top+t.height),t.topPassed=e.top>=t.top,t.bottomPassed=e.top>=t.bottom,t.topVisible=e.bottom>=t.top&&!t.bottomPassed,t.bottomVisible=e.bottom>=t.bottom&&!t.topPassed,t.pixelsPassed=0,t.percentagePassed=0,t.onScreen=t.topVisible&&!t.bottomPassed,t.passing=t.topPassed&&!t.bottomPassed,t.offScreen=!t.onScreen,t.passing&&(t.pixelsPassed=e.top-t.top,t.percentagePassed=(e.top-t.top)/t.height),p.cache.element=t,p.verbose("Updated element calculations",t),t},screenCalculations:function(){var e=p.get.scroll();return p.save.direction(),p.cache.screen.top=e,p.cache.screen.bottom=e+p.cache.screen.height,p.cache.screen},screenSize:function(){p.verbose("Saving window position"),p.cache.screen={height:A.height()}},position:function(){p.save.screenSize(),p.save.elementPosition()}},get:{pixelsPassed:function(e){var t=p.get.elementCalculations();return e.search("%")>-1?t.height*(parseInt(e,10)/100):parseInt(e,10)},occurred:function(e){return void 0!==p.cache.occurred&&(p.cache.occurred[e]||!1)},direction:function(){return void 0===p.cache.direction&&p.save.direction(),p.cache.direction},elementPosition:function(){return void 0===p.cache.element&&p.save.elementPosition(),p.cache.element},elementCalculations:function(){return void 0===p.cache.element&&p.save.elementCalculations(),p.cache.element},screenCalculations:function(){return void 0===p.cache.screen&&p.save.screenCalculations(),p.cache.screen},screenSize:function(){return void 0===p.cache.screen&&p.save.screenSize(),p.cache.screen},scroll:function(){return void 0===p.cache.scroll&&p.save.scroll(),p.cache.scroll},lastScroll:function(){return void 0===p.cache.screen?(p.debug("First scroll event, no last scroll could be found"),!1):p.cache.screen.top}},setting:function(t,n){if(e.isPlainObject(t))e.extend(!0,h,t);else{if(void 0===n)return h[t];h[t]=n}},internal:function(t,n){if(e.isPlainObject(t))e.extend(!0,p,t);else{if(void 0===n)return p[t];p[t]=n}},debug:function(){!h.silent&&h.debug&&(h.performance?p.performance.log(arguments):(p.debug=Function.prototype.bind.call(console.info,console,h.name+":"),p.debug.apply(console,arguments)))},verbose:function(){!h.silent&&h.verbose&&h.debug&&(h.performance?p.performance.log(arguments):(p.verbose=Function.prototype.bind.call(console.info,console,h.name+":"),p.verbose.apply(console,arguments)))},error:function(){h.silent||(p.error=Function.prototype.bind.call(console.error,console,h.name+":"),p.error.apply(console,arguments))},performance:{log:function(e){var t,n,i;h.performance&&(t=(new Date).getTime(),i=s||t,n=t-i,s=t,l.push({Name:e[0],Arguments:[].slice.call(e,1)||"",Element:E,"Execution Time":n})),clearTimeout(p.performance.timer),p.performance.timer=setTimeout(p.performance.display,500)},display:function(){var t=h.name+":",n=0;s=!1,clearTimeout(p.performance.timer),e.each(l,function(e,t){n+=t["Execution Time"]}),t+=" "+n+"ms",r&&(t+=" '"+r+"'"),(void 0!==console.group||void 0!==console.table)&&l.length>0&&(console.groupCollapsed(t),console.table?console.table(l):e.each(l,function(e,t){console.log(t.Name+": "+t["Execution Time"]+"ms")}),console.groupEnd()),l=[]}},invoke:function(t,n,i){var a,r,s,l=R;return n=n||d,i=E||i,"string"==typeof t&&void 0!==l&&(t=t.split(/[\. ]/),a=t.length-1,e.each(t,function(n,i){var o=n!=a?i+t[n+1].charAt(0).toUpperCase()+t[n+1].slice(1):t;if(e.isPlainObject(l[o])&&n!=a)l=l[o];else{if(void 0!==l[o])return r=l[o],!1;if(!e.isPlainObject(l[i])||n==a)return void 0!==l[i]?(r=l[i],!1):(p.error(x.method,t),!1);l=l[i]}})),e.isFunction(r)?s=r.apply(i,n):void 0!==r&&(s=r),e.isArray(o)?o.push(s):void 0!==o?o=[o,s]:void 0!==s&&(o=s),r}},u?(void 0===R&&p.initialize(),R.save.scroll(),R.save.calculations(),p.invoke(c)):(void 0!==R&&R.invoke("destroy"),p.initialize())}),void 0!==o?o:this},e.fn.visibility.settings={name:"Visibility",namespace:"visibility",debug:!1,verbose:!1,performance:!0,observeChanges:!0,initialCheck:!0,refreshOnLoad:!0,refreshOnResize:!0,checkOnRefresh:!0,once:!0,continuous:!1,offset:0,includeMargin:!1,context:t,throttle:!1,type:!1,zIndex:"10",transition:"fade in",duration:1e3,onPassed:{},onOnScreen:!1,onOffScreen:!1,onPassing:!1,onTopVisible:!1,onBottomVisible:!1,onTopPassed:!1,onBottomPassed:!1,onPassingReverse:!1,onTopVisibleReverse:!1,onBottomVisibleReverse:!1,onTopPassedReverse:!1,onBottomPassedReverse:!1,onLoad:function(){},onAllLoaded:function(){},onFixed:function(){},onUnfixed:function(){},onUpdate:!1,onRefresh:function(){},metadata:{src:"src"},className:{fixed:"fixed",placeholder:"placeholder",visible:"visible"},error:{method:"The method you called is not defined.",visible:"Element is hidden, you must call refresh after element becomes visible"}}}(jQuery,window,document);
// WebcamJS v1.0.22
// Webcam library for capturing JPEG/PNG images in JavaScript
// Attempts getUserMedia, falls back to Flash
// Author: Joseph Huckaby: http://github.com/jhuckaby
// Based on JPEGCam: http://code.google.com/p/jpegcam/
// Copyright (c) 2012 - 2017 Joseph Huckaby
// Licensed under the MIT License

(function(window) {
var _userMedia;

// declare error types

// inheritance pattern here:
// https://stackoverflow.com/questions/783818/how-do-i-create-a-custom-error-in-javascript
function FlashError() {
	var temp = Error.apply(this, arguments);
	temp.name = this.name = "FlashError";
	this.stack = temp.stack;
	this.message = temp.message;
}

function WebcamError() {
	var temp = Error.apply(this, arguments);
	temp.name = this.name = "WebcamError";
	this.stack = temp.stack;
	this.message = temp.message;
}

IntermediateInheritor = function() {};
IntermediateInheritor.prototype = Error.prototype;

FlashError.prototype = new IntermediateInheritor();
WebcamError.prototype = new IntermediateInheritor();

var Webcam = {
	version: '1.0.22',
	
	// globals
	protocol: location.protocol.match(/https/i) ? 'https' : 'http',
	loaded: false,   // true when webcam movie finishes loading
	live: false,     // true when webcam is initialized and ready to snap
	userMedia: true, // true when getUserMedia is supported natively

	iOS: /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream,

	params: {
		width: 0,
		height: 0,
		dest_width: 0,         // size of captured image
		dest_height: 0,        // these default to width/height
		image_format: 'jpeg',  // image format (may be jpeg or png)
		jpeg_quality: 90,      // jpeg image quality from 0 (worst) to 100 (best)
		enable_flash: true,    // enable flash fallback,
		force_flash: false,    // force flash mode,
		flip_horiz: false,     // flip image horiz (mirror mode)
		fps: 30,               // camera frames per second
		upload_name: 'webcam', // name of file in upload post data
		constraints: null,     // custom user media constraints,
		swfURL: '',            // URI to webcam.swf movie (defaults to the js location)
		flashNotDetectedText: 'ERROR: No Adobe Flash Player detected.  Webcam.js relies on Flash for browsers that do not support getUserMedia (like yours).',
		noInterfaceFoundText: 'No supported webcam interface found.',
		unfreeze_snap: true,    // Whether to unfreeze the camera after snap (defaults to true)
		iosPlaceholderText: 'Click here to open camera.',
		user_callback: null,    // callback function for snapshot (used if no user_callback parameter given to snap function)
		user_canvas: null       // user provided canvas for snapshot (used if no user_canvas parameter given to snap function)
	},

	errors: {
		FlashError: FlashError,
		WebcamError: WebcamError
	},
	
	hooks: {}, // callback hook functions
	
	init: function() {
		// initialize, check for getUserMedia support
		var self = this;
		
		// Setup getUserMedia, with polyfill for older browsers
		// Adapted from: https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia
		this.mediaDevices = (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) ? 
			navigator.mediaDevices : ((navigator.mozGetUserMedia || navigator.webkitGetUserMedia) ? {
				getUserMedia: function(c) {
					return new Promise(function(y, n) {
						(navigator.mozGetUserMedia ||
						navigator.webkitGetUserMedia).call(navigator, c, y, n);
					});
				}
		} : null);
		
		window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;
		this.userMedia = this.userMedia && !!this.mediaDevices && !!window.URL;
		
		// Older versions of firefox (< 21) apparently claim support but user media does not actually work
		if (navigator.userAgent.match(/Firefox\D+(\d+)/)) {
			if (parseInt(RegExp.$1, 10) < 21) this.userMedia = null;
		}
		
		// Make sure media stream is closed when navigating away from page
		if (this.userMedia) {
			window.addEventListener( 'beforeunload', function(event) {
				self.reset();
			} );
		}
	},
	
	exifOrientation: function(binFile) {
		// extract orientation information from the image provided by iOS
		// algorithm based on exif-js
		var dataView = new DataView(binFile);
		if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {
			console.log('Not a valid JPEG file');
			return 0;
		}
		var offset = 2;
		var marker = null;
		while (offset < binFile.byteLength) {
			// find 0xFFE1 (225 marker)
			if (dataView.getUint8(offset) != 0xFF) {
				console.log('Not a valid marker at offset ' + offset + ', found: ' + dataView.getUint8(offset));
				return 0;
			}
			marker = dataView.getUint8(offset + 1);
			if (marker == 225) {
				offset += 4;
				var str = "";
				for (n = 0; n < 4; n++) {
					str += String.fromCharCode(dataView.getUint8(offset+n));
				}
				if (str != 'Exif') {
					console.log('Not valid EXIF data found');
					return 0;
				}
				
				offset += 6; // tiffOffset
				var bigEnd = null;

				// test for TIFF validity and endianness
				if (dataView.getUint16(offset) == 0x4949) {
					bigEnd = false;
				} else if (dataView.getUint16(offset) == 0x4D4D) {
					bigEnd = true;
				} else {
					console.log("Not valid TIFF data! (no 0x4949 or 0x4D4D)");
					return 0;
				}

				if (dataView.getUint16(offset+2, !bigEnd) != 0x002A) {
					console.log("Not valid TIFF data! (no 0x002A)");
					return 0;
				}

				var firstIFDOffset = dataView.getUint32(offset+4, !bigEnd);
				if (firstIFDOffset < 0x00000008) {
					console.log("Not valid TIFF data! (First offset less than 8)", dataView.getUint32(offset+4, !bigEnd));
					return 0;
				}

				// extract orientation data
				var dataStart = offset + firstIFDOffset;
				var entries = dataView.getUint16(dataStart, !bigEnd);
				for (var i=0; i<entries; i++) {
					var entryOffset = dataStart + i*12 + 2;
					if (dataView.getUint16(entryOffset, !bigEnd) == 0x0112) {
						var valueType = dataView.getUint16(entryOffset+2, !bigEnd);
						var numValues = dataView.getUint32(entryOffset+4, !bigEnd);
						if (valueType != 3 && numValues != 1) {
							console.log('Invalid EXIF orientation value type ('+valueType+') or count ('+numValues+')');
							return 0;
						}
						var value = dataView.getUint16(entryOffset + 8, !bigEnd);
						if (value < 1 || value > 8) {
							console.log('Invalid EXIF orientation value ('+value+')');
							return 0;
						}
						return value;
					}
				}
			} else {
				offset += 2+dataView.getUint16(offset+2);
			}
		}
		return 0;
	},
	
	fixOrientation: function(origObjURL, orientation, targetImg) {
		// fix image orientation based on exif orientation data
		// exif orientation information
		//    http://www.impulseadventure.com/photo/exif-orientation.html
		//    link source wikipedia (https://en.wikipedia.org/wiki/Exif#cite_note-20)
		var img = new Image();
		img.addEventListener('load', function(event) {
			var canvas = document.createElement('canvas');
			var ctx = canvas.getContext('2d');
			
			// switch width height if orientation needed
			if (orientation < 5) {
				canvas.width = img.width;
				canvas.height = img.height;
			} else {
				canvas.width = img.height;
				canvas.height = img.width;
			}

			// transform (rotate) image - see link at beginning this method
			switch (orientation) {
				case 2: ctx.transform(-1, 0, 0, 1, img.width, 0); break;
				case 3: ctx.transform(-1, 0, 0, -1, img.width, img.height); break;
				case 4: ctx.transform(1, 0, 0, -1, 0, img.height); break;
				case 5: ctx.transform(0, 1, 1, 0, 0, 0); break;
				case 6: ctx.transform(0, 1, -1, 0, img.height , 0); break;
				case 7: ctx.transform(0, -1, -1, 0, img.height, img.width); break;
				case 8: ctx.transform(0, -1, 1, 0, 0, img.width); break;
			}

			ctx.drawImage(img, 0, 0);
			// pass rotated image data to the target image container
			targetImg.src = canvas.toDataURL();
		}, false);
		// start transformation by load event
		img.src = origObjURL;
	},
	
	attach: function(elem) {
		// create webcam preview and attach to DOM element
		// pass in actual DOM reference, ID, or CSS selector
		if (typeof(elem) == 'string') {
			elem = document.getElementById(elem) || document.querySelector(elem);
		}
		if (!elem) {
			return this.dispatch('error', new WebcamError("Could not locate DOM element to attach to."));
		}
		this.container = elem;
		elem.innerHTML = ''; // start with empty element
		
		// insert "peg" so we can insert our preview canvas adjacent to it later on
		var peg = document.createElement('div');
		elem.appendChild( peg );
		this.peg = peg;
		
		// set width/height if not already set
		if (!this.params.width) this.params.width = elem.offsetWidth;
		if (!this.params.height) this.params.height = elem.offsetHeight;
		
		// make sure we have a nonzero width and height at this point
		if (!this.params.width || !this.params.height) {
			return this.dispatch('error', new WebcamError("No width and/or height for webcam.  Please call set() first, or attach to a visible element."));
		}
		
		// set defaults for dest_width / dest_height if not set
		if (!this.params.dest_width) this.params.dest_width = this.params.width;
		if (!this.params.dest_height) this.params.dest_height = this.params.height;
		
		this.userMedia = _userMedia === undefined ? this.userMedia : _userMedia;
		// if force_flash is set, disable userMedia
		if (this.params.force_flash) {
			_userMedia = this.userMedia;
			this.userMedia = null;
		}
		
		// check for default fps
		if (typeof this.params.fps !== "number") this.params.fps = 30;

		// adjust scale if dest_width or dest_height is different
		var scaleX = this.params.width / this.params.dest_width;
		var scaleY = this.params.height / this.params.dest_height;
		
		if (this.userMedia) {
			// setup webcam video container
			var video = document.createElement('video');
			video.setAttribute('autoplay', 'autoplay');
			video.style.width = '' + this.params.dest_width + 'px';
			video.style.height = '' + this.params.dest_height + 'px';
			
			if ((scaleX != 1.0) || (scaleY != 1.0)) {
				elem.style.overflow = 'hidden';
				video.style.webkitTransformOrigin = '0px 0px';
				video.style.mozTransformOrigin = '0px 0px';
				video.style.msTransformOrigin = '0px 0px';
				video.style.oTransformOrigin = '0px 0px';
				video.style.transformOrigin = '0px 0px';
				video.style.webkitTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
				video.style.mozTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
				video.style.msTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
				video.style.oTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
				video.style.transform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
			}
			
			// add video element to dom
			elem.appendChild( video );
			this.video = video;
			
			// ask user for access to their camera
			var self = this;
			this.mediaDevices.getUserMedia({
				"audio": false,
				"video": this.params.constraints || {
					mandatory: {
						minWidth: this.params.dest_width,
						minHeight: this.params.dest_height
					}
				}
			})
			.then( function(stream) {
				// got access, attach stream to video
				video.onloadedmetadata = function(e) {
					self.stream = stream;
					self.loaded = true;
					self.live = true;
					self.dispatch('load');
					self.dispatch('live');
					self.flip();
				};
				video.src = window.URL.createObjectURL( stream ) || stream;
			})
			.catch( function(err) {
				// JH 2016-07-31 Instead of dispatching error, now falling back to Flash if userMedia fails (thx @john2014)
				// JH 2016-08-07 But only if flash is actually installed -- if not, dispatch error here and now.
				if (self.params.enable_flash && self.detectFlash()) {
					setTimeout( function() { self.params.force_flash = 1; self.attach(elem); }, 1 );
				}
				else {
					self.dispatch('error', err);
				}
			});
		}
		else if (this.iOS) {
			// prepare HTML elements
			var div = document.createElement('div');
			div.id = this.container.id+'-ios_div';
			div.className = 'webcamjs-ios-placeholder';
			div.style.width = '' + this.params.width + 'px';
			div.style.height = '' + this.params.height + 'px';
			div.style.textAlign = 'center';
			div.style.display = 'table-cell';
			div.style.verticalAlign = 'middle';
			div.style.backgroundRepeat = 'no-repeat';
			div.style.backgroundSize = 'contain';
			div.style.backgroundPosition = 'center';
			var span = document.createElement('span');
			span.className = 'webcamjs-ios-text';
			span.innerHTML = this.params.iosPlaceholderText;
			div.appendChild(span);
			var img = document.createElement('img');
			img.id = this.container.id+'-ios_img';
			img.style.width = '' + this.params.dest_width + 'px';
			img.style.height = '' + this.params.dest_height + 'px';
			img.style.display = 'none';
			div.appendChild(img);
			var input = document.createElement('input');
			input.id = this.container.id+'-ios_input';
			input.setAttribute('type', 'file');
			input.setAttribute('accept', 'image/*');
			input.setAttribute('capture', 'camera');
			
			var self = this;
			var params = this.params;
			// add input listener to load the selected image
			input.addEventListener('change', function(event) {
				if (event.target.files.length > 0 && event.target.files[0].type.indexOf('image/') == 0) {
					var objURL = URL.createObjectURL(event.target.files[0]);

					// load image with auto scale and crop
					var image = new Image();
					image.addEventListener('load', function(event) {
						var canvas = document.createElement('canvas');
						canvas.width = params.dest_width;
						canvas.height = params.dest_height;
						var ctx = canvas.getContext('2d');

						// crop and scale image for final size
						ratio = Math.min(image.width / params.dest_width, image.height / params.dest_height);
						var sw = params.dest_width * ratio;
						var sh = params.dest_height * ratio;
						var sx = (image.width - sw) / 2;
						var sy = (image.height - sh) / 2;
						ctx.drawImage(image, sx, sy, sw, sh, 0, 0, params.dest_width, params.dest_height);

						var dataURL = canvas.toDataURL();
						img.src = dataURL;
						div.style.backgroundImage = "url('"+dataURL+"')";
					}, false);
					
					// read EXIF data
					var fileReader = new FileReader();
					fileReader.addEventListener('load', function(e) {
						var orientation = self.exifOrientation(e.target.result);
						if (orientation > 1) {
							// image need to rotate (see comments on fixOrientation method for more information)
							// transform image and load to image object
							self.fixOrientation(objURL, orientation, image);
						} else {
							// load image data to image object
							image.src = objURL;
						}
					}, false);
					
					// Convert image data to blob format
					var http = new XMLHttpRequest();
					http.open("GET", objURL, true);
					http.responseType = "blob";
					http.onload = function(e) {
						if (this.status == 200 || this.status === 0) {
							fileReader.readAsArrayBuffer(this.response);
						}
					};
					http.send();

				}
			}, false);
			input.style.display = 'none';
			elem.appendChild(input);
			// make div clickable for open camera interface
			div.addEventListener('click', function(event) {
				if (params.user_callback) {
					// global user_callback defined - create the snapshot
					self.snap(params.user_callback, params.user_canvas);
				} else {
					// no global callback definied for snapshot, load image and wait for external snap method call
					input.style.display = 'block';
					input.focus();
					input.click();
					input.style.display = 'none';
				}
			}, false);
			elem.appendChild(div);
			this.loaded = true;
			this.live = true;
		}
		else if (this.params.enable_flash && this.detectFlash()) {
			// flash fallback
			window.Webcam = Webcam; // needed for flash-to-js interface
			var div = document.createElement('div');
			div.innerHTML = this.getSWFHTML();
			elem.appendChild( div );
		}
		else {
			this.dispatch('error', new WebcamError( this.params.noInterfaceFoundText ));
		}
		
		// setup final crop for live preview
		if (this.params.crop_width && this.params.crop_height) {
			var scaled_crop_width = Math.floor( this.params.crop_width * scaleX );
			var scaled_crop_height = Math.floor( this.params.crop_height * scaleY );
			
			elem.style.width = '' + scaled_crop_width + 'px';
			elem.style.height = '' + scaled_crop_height + 'px';
			elem.style.overflow = 'hidden';
			
			elem.scrollLeft = Math.floor( (this.params.width / 2) - (scaled_crop_width / 2) );
			elem.scrollTop = Math.floor( (this.params.height / 2) - (scaled_crop_height / 2) );
		}
		else {
			// no crop, set size to desired
			elem.style.width = '' + this.params.width + 'px';
			elem.style.height = '' + this.params.height + 'px';
		}
	},
	
	reset: function() {
		// shutdown camera, reset to potentially attach again
		if (this.preview_active) this.unfreeze();
		
		// attempt to fix issue #64
		this.unflip();
		
		if (this.userMedia) {
			if (this.stream) {
				if (this.stream.getVideoTracks) {
					// get video track to call stop on it
					var tracks = this.stream.getVideoTracks();
					if (tracks && tracks[0] && tracks[0].stop) tracks[0].stop();
				}
				else if (this.stream.stop) {
					// deprecated, may be removed in future
					this.stream.stop();
				}
			}
			delete this.stream;
			delete this.video;
		}

		if ((this.userMedia !== true) && this.loaded && !this.iOS) {
			// call for turn off camera in flash
			var movie = this.getMovie();
			if (movie && movie._releaseCamera) movie._releaseCamera();
		}

		if (this.container) {
			this.container.innerHTML = '';
			delete this.container;
		}
	
		this.loaded = false;
		this.live = false;
	},
	
	set: function() {
		// set one or more params
		// variable argument list: 1 param = hash, 2 params = key, value
		if (arguments.length == 1) {
			for (var key in arguments[0]) {
				this.params[key] = arguments[0][key];
			}
		}
		else {
			this.params[ arguments[0] ] = arguments[1];
		}
	},
	
	on: function(name, callback) {
		// set callback hook
		name = name.replace(/^on/i, '').toLowerCase();
		if (!this.hooks[name]) this.hooks[name] = [];
		this.hooks[name].push( callback );
	},
	
	off: function(name, callback) {
		// remove callback hook
		name = name.replace(/^on/i, '').toLowerCase();
		if (this.hooks[name]) {
			if (callback) {
				// remove one selected callback from list
				var idx = this.hooks[name].indexOf(callback);
				if (idx > -1) this.hooks[name].splice(idx, 1);
			}
			else {
				// no callback specified, so clear all
				this.hooks[name] = [];
			}
		}
	},
	
	dispatch: function() {
		// fire hook callback, passing optional value to it
		var name = arguments[0].replace(/^on/i, '').toLowerCase();
		var args = Array.prototype.slice.call(arguments, 1);
		
		if (this.hooks[name] && this.hooks[name].length) {
			for (var idx = 0, len = this.hooks[name].length; idx < len; idx++) {
				var hook = this.hooks[name][idx];
				
				if (typeof(hook) == 'function') {
					// callback is function reference, call directly
					hook.apply(this, args);
				}
				else if ((typeof(hook) == 'object') && (hook.length == 2)) {
					// callback is PHP-style object instance method
					hook[0][hook[1]].apply(hook[0], args);
				}
				else if (window[hook]) {
					// callback is global function name
					window[ hook ].apply(window, args);
				}
			} // loop
			return true;
		}
		else if (name == 'error') {
			if ((args[0] instanceof FlashError) || (args[0] instanceof WebcamError)) {
				message = args[0].message;
			} else {
				message = "Could not access webcam: " + args[0].name + ": " + 
					args[0].message + " " + args[0].toString();
			}

			// default error handler if no custom one specified
			alert("Webcam.js Error: " + message);
		}
		
		return false; // no hook defined
	},

	setSWFLocation: function(value) {
		// for backward compatibility.
		this.set('swfURL', value);
	},
	
	detectFlash: function() {
		// return true if browser supports flash, false otherwise
		// Code snippet borrowed from: https://github.com/swfobject/swfobject
		var SHOCKWAVE_FLASH = "Shockwave Flash",
			SHOCKWAVE_FLASH_AX = "ShockwaveFlash.ShockwaveFlash",
        	FLASH_MIME_TYPE = "application/x-shockwave-flash",
        	win = window,
        	nav = navigator,
        	hasFlash = false;
        
        if (typeof nav.plugins !== "undefined" && typeof nav.plugins[SHOCKWAVE_FLASH] === "object") {
        	var desc = nav.plugins[SHOCKWAVE_FLASH].description;
        	if (desc && (typeof nav.mimeTypes !== "undefined" && nav.mimeTypes[FLASH_MIME_TYPE] && nav.mimeTypes[FLASH_MIME_TYPE].enabledPlugin)) {
        		hasFlash = true;
        	}
        }
        else if (typeof win.ActiveXObject !== "undefined") {
        	try {
        		var ax = new ActiveXObject(SHOCKWAVE_FLASH_AX);
        		if (ax) {
        			var ver = ax.GetVariable("$version");
        			if (ver) hasFlash = true;
        		}
        	}
        	catch (e) {;}
        }
        
        return hasFlash;
	},
	
	getSWFHTML: function() {
		// Return HTML for embedding flash based webcam capture movie		
		var html = '',
			swfURL = this.params.swfURL;
		
		// make sure we aren't running locally (flash doesn't work)
		if (location.protocol.match(/file/)) {
			this.dispatch('error', new FlashError("Flash does not work from local disk.  Please run from a web server."));
			return '<h3 style="color:red">ERROR: the Webcam.js Flash fallback does not work from local disk.  Please run it from a web server.</h3>';
		}
		
		// make sure we have flash
		if (!this.detectFlash()) {
			this.dispatch('error', new FlashError("Adobe Flash Player not found.  Please install from get.adobe.com/flashplayer and try again."));
			return '<h3 style="color:red">' + this.params.flashNotDetectedText + '</h3>';
		}
		
		// set default swfURL if not explicitly set
		if (!swfURL) {
			// find our script tag, and use that base URL
			var base_url = '';
			var scpts = document.getElementsByTagName('script');
			for (var idx = 0, len = scpts.length; idx < len; idx++) {
				var src = scpts[idx].getAttribute('src');
				if (src && src.match(/\/webcam(\.min)?\.js/)) {
					base_url = src.replace(/\/webcam(\.min)?\.js.*$/, '');
					idx = len;
				}
			}
			if (base_url) swfURL = base_url + '/webcam.swf';
			else swfURL = 'webcam.swf';
		}
		
		// if this is the user's first visit, set flashvar so flash privacy settings panel is shown first
		if (window.localStorage && !localStorage.getItem('visited')) {
			this.params.new_user = 1;
			localStorage.setItem('visited', 1);
		}
		
		// construct flashvars string
		var flashvars = '';
		for (var key in this.params) {
			if (flashvars) flashvars += '&';
			flashvars += key + '=' + escape(this.params[key]);
		}
		
		// construct object/embed tag
		html += '<object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" type="application/x-shockwave-flash" codebase="'+this.protocol+'://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=9,0,0,0" width="'+this.params.width+'" height="'+this.params.height+'" id="webcam_movie_obj" align="middle"><param name="wmode" value="opaque" /><param name="allowScriptAccess" value="always" /><param name="allowFullScreen" value="false" /><param name="movie" value="'+swfURL+'" /><param name="loop" value="false" /><param name="menu" value="false" /><param name="quality" value="best" /><param name="bgcolor" value="#ffffff" /><param name="flashvars" value="'+flashvars+'"/><embed id="webcam_movie_embed" src="'+swfURL+'" wmode="opaque" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="'+this.params.width+'" height="'+this.params.height+'" name="webcam_movie_embed" align="middle" allowScriptAccess="always" allowFullScreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="'+flashvars+'"></embed></object>';
		
		return html;
	},
	
	getMovie: function() {
		// get reference to movie object/embed in DOM
		if (!this.loaded) return this.dispatch('error', new FlashError("Flash Movie is not loaded yet"));
		var movie = document.getElementById('webcam_movie_obj');
		if (!movie || !movie._snap) movie = document.getElementById('webcam_movie_embed');
		if (!movie) this.dispatch('error', new FlashError("Cannot locate Flash movie in DOM"));
		return movie;
	},
	
	freeze: function() {
		// show preview, freeze camera
		var self = this;
		var params = this.params;
		
		// kill preview if already active
		if (this.preview_active) this.unfreeze();
		
		// determine scale factor
		var scaleX = this.params.width / this.params.dest_width;
		var scaleY = this.params.height / this.params.dest_height;
		
		// must unflip container as preview canvas will be pre-flipped
		this.unflip();
		
		// calc final size of image
		var final_width = params.crop_width || params.dest_width;
		var final_height = params.crop_height || params.dest_height;
		
		// create canvas for holding preview
		var preview_canvas = document.createElement('canvas');
		preview_canvas.width = final_width;
		preview_canvas.height = final_height;
		var preview_context = preview_canvas.getContext('2d');
		
		// save for later use
		this.preview_canvas = preview_canvas;
		this.preview_context = preview_context;
		
		// scale for preview size
		if ((scaleX != 1.0) || (scaleY != 1.0)) {
			preview_canvas.style.webkitTransformOrigin = '0px 0px';
			preview_canvas.style.mozTransformOrigin = '0px 0px';
			preview_canvas.style.msTransformOrigin = '0px 0px';
			preview_canvas.style.oTransformOrigin = '0px 0px';
			preview_canvas.style.transformOrigin = '0px 0px';
			preview_canvas.style.webkitTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
			preview_canvas.style.mozTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
			preview_canvas.style.msTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
			preview_canvas.style.oTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
			preview_canvas.style.transform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
		}
		
		// take snapshot, but fire our own callback
		this.snap( function() {
			// add preview image to dom, adjust for crop
			preview_canvas.style.position = 'relative';
			preview_canvas.style.left = '' + self.container.scrollLeft + 'px';
			preview_canvas.style.top = '' + self.container.scrollTop + 'px';
			
			self.container.insertBefore( preview_canvas, self.peg );
			self.container.style.overflow = 'hidden';
			
			// set flag for user capture (use preview)
			self.preview_active = true;
			
		}, preview_canvas );
	},
	
	unfreeze: function() {
		// cancel preview and resume live video feed
		if (this.preview_active) {
			// remove preview canvas
			this.container.removeChild( this.preview_canvas );
			delete this.preview_context;
			delete this.preview_canvas;
			
			// unflag
			this.preview_active = false;
			
			// re-flip if we unflipped before
			this.flip();
		}
	},
	
	flip: function() {
		// flip container horiz (mirror mode) if desired
		if (this.params.flip_horiz) {
			var sty = this.container.style;
			sty.webkitTransform = 'scaleX(-1)';
			sty.mozTransform = 'scaleX(-1)';
			sty.msTransform = 'scaleX(-1)';
			sty.oTransform = 'scaleX(-1)';
			sty.transform = 'scaleX(-1)';
			sty.filter = 'FlipH';
			sty.msFilter = 'FlipH';
		}
	},
	
	unflip: function() {
		// unflip container horiz (mirror mode) if desired
		if (this.params.flip_horiz) {
			var sty = this.container.style;
			sty.webkitTransform = 'scaleX(1)';
			sty.mozTransform = 'scaleX(1)';
			sty.msTransform = 'scaleX(1)';
			sty.oTransform = 'scaleX(1)';
			sty.transform = 'scaleX(1)';
			sty.filter = '';
			sty.msFilter = '';
		}
	},
	
	savePreview: function(user_callback, user_canvas) {
		// save preview freeze and fire user callback
		var params = this.params;
		var canvas = this.preview_canvas;
		var context = this.preview_context;
		
		// render to user canvas if desired
		if (user_canvas) {
			var user_context = user_canvas.getContext('2d');
			user_context.drawImage( canvas, 0, 0 );
		}
		
		// fire user callback if desired
		user_callback(
			user_canvas ? null : canvas.toDataURL('image/' + params.image_format, params.jpeg_quality / 100 ),
			canvas,
			context
		);
		
		// remove preview
		if (this.params.unfreeze_snap) this.unfreeze();
	},
	
	snap: function(user_callback, user_canvas) {
		// use global callback and canvas if not defined as parameter
		if (!user_callback) user_callback = this.params.user_callback;
		if (!user_canvas) user_canvas = this.params.user_canvas;
		
		// take snapshot and return image data uri
		var self = this;
		var params = this.params;
		
		if (!this.loaded) return this.dispatch('error', new WebcamError("Webcam is not loaded yet"));
		// if (!this.live) return this.dispatch('error', new WebcamError("Webcam is not live yet"));
		if (!user_callback) return this.dispatch('error', new WebcamError("Please provide a callback function or canvas to snap()"));
		
		// if we have an active preview freeze, use that
		if (this.preview_active) {
			this.savePreview( user_callback, user_canvas );
			return null;
		}
		
		// create offscreen canvas element to hold pixels
		var canvas = document.createElement('canvas');
		canvas.width = this.params.dest_width;
		canvas.height = this.params.dest_height;
		var context = canvas.getContext('2d');
		
		// flip canvas horizontally if desired
		if (this.params.flip_horiz) {
			context.translate( params.dest_width, 0 );
			context.scale( -1, 1 );
		}
		
		// create inline function, called after image load (flash) or immediately (native)
		var func = function() {
			// render image if needed (flash)
			if (this.src && this.width && this.height) {
				context.drawImage(this, 0, 0, params.dest_width, params.dest_height);
			}
			
			// crop if desired
			if (params.crop_width && params.crop_height) {
				var crop_canvas = document.createElement('canvas');
				crop_canvas.width = params.crop_width;
				crop_canvas.height = params.crop_height;
				var crop_context = crop_canvas.getContext('2d');
				
				crop_context.drawImage( canvas, 
					Math.floor( (params.dest_width / 2) - (params.crop_width / 2) ),
					Math.floor( (params.dest_height / 2) - (params.crop_height / 2) ),
					params.crop_width,
					params.crop_height,
					0,
					0,
					params.crop_width,
					params.crop_height
				);
				
				// swap canvases
				context = crop_context;
				canvas = crop_canvas;
			}
			
			// render to user canvas if desired
			if (user_canvas) {
				var user_context = user_canvas.getContext('2d');
				user_context.drawImage( canvas, 0, 0 );
			}
			
			// fire user callback if desired
			user_callback(
				user_canvas ? null : canvas.toDataURL('image/' + params.image_format, params.jpeg_quality / 100 ),
				canvas,
				context
			);
		};
		
		// grab image frame from userMedia or flash movie
		if (this.userMedia) {
			// native implementation
			context.drawImage(this.video, 0, 0, this.params.dest_width, this.params.dest_height);
			
			// fire callback right away
			func();
		}
		else if (this.iOS) {
			var div = document.getElementById(this.container.id+'-ios_div');
			var img = document.getElementById(this.container.id+'-ios_img');
			var input = document.getElementById(this.container.id+'-ios_input');
			// function for handle snapshot event (call user_callback and reset the interface)
			iFunc = function(event) {
				func.call(img);
				img.removeEventListener('load', iFunc);
				div.style.backgroundImage = 'none';
				img.removeAttribute('src');
				input.value = null;
			};
			if (!input.value) {
				// No image selected yet, activate input field
				img.addEventListener('load', iFunc);
				input.style.display = 'block';
				input.focus();
				input.click();
				input.style.display = 'none';
			} else {
				// Image already selected
				iFunc(null);
			}			
		}
		else {
			// flash fallback
			var raw_data = this.getMovie()._snap();
			
			// render to image, fire callback when complete
			var img = new Image();
			img.onload = func;
			img.src = 'data:image/'+this.params.image_format+';base64,' + raw_data;
		}
		
		return null;
	},
	
	configure: function(panel) {
		// open flash configuration panel -- specify tab name:
		// "camera", "privacy", "default", "localStorage", "microphone", "settingsManager"
		if (!panel) panel = "camera";
		this.getMovie()._configure(panel);
	},
	
	flashNotify: function(type, msg) {
		// receive notification from flash about event
		switch (type) {
			case 'flashLoadComplete':
				// movie loaded successfully
				this.loaded = true;
				this.dispatch('load');
				break;
			
			case 'cameraLive':
				// camera is live and ready to snap
				this.live = true;
				this.dispatch('live');
				break;

			case 'error':
				// Flash error
				this.dispatch('error', new FlashError(msg));
				break;

			default:
				// catch-all event, just in case
				// console.log("webcam flash_notify: " + type + ": " + msg);
				break;
		}
	},
	
	b64ToUint6: function(nChr) {
		// convert base64 encoded character to 6-bit integer
		// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding
		return nChr > 64 && nChr < 91 ? nChr - 65
			: nChr > 96 && nChr < 123 ? nChr - 71
			: nChr > 47 && nChr < 58 ? nChr + 4
			: nChr === 43 ? 62 : nChr === 47 ? 63 : 0;
	},

	base64DecToArr: function(sBase64, nBlocksSize) {
		// convert base64 encoded string to Uintarray
		// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding
		var sB64Enc = sBase64.replace(/[^A-Za-z0-9\+\/]/g, ""), nInLen = sB64Enc.length,
			nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2, 
			taBytes = new Uint8Array(nOutLen);
		
		for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
			nMod4 = nInIdx & 3;
			nUint24 |= this.b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4;
			if (nMod4 === 3 || nInLen - nInIdx === 1) {
				for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
					taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
				}
				nUint24 = 0;
			}
		}
		return taBytes;
	},
	
	upload: function(image_data_uri, target_url, callback) {
		// submit image data to server using binary AJAX
		var form_elem_name = this.params.upload_name || 'webcam';
		
		// detect image format from within image_data_uri
		var image_fmt = '';
		if (image_data_uri.match(/^data\:image\/(\w+)/))
			image_fmt = RegExp.$1;
		else
			throw "Cannot locate image format in Data URI";
		
		// extract raw base64 data from Data URI
		var raw_image_data = image_data_uri.replace(/^data\:image\/\w+\;base64\,/, '');
		
		// contruct use AJAX object
		var http = new XMLHttpRequest();
		http.open("POST", target_url, true);
		
		// setup progress events
		if (http.upload && http.upload.addEventListener) {
			http.upload.addEventListener( 'progress', function(e) {
				if (e.lengthComputable) {
					var progress = e.loaded / e.total;
					Webcam.dispatch('uploadProgress', progress, e);
				}
			}, false );
		}
		
		// completion handler
		var self = this;
		http.onload = function() {
			if (callback) callback.apply( self, [http.status, http.responseText, http.statusText] );
			Webcam.dispatch('uploadComplete', http.status, http.responseText, http.statusText);
		};
		
		// create a blob and decode our base64 to binary
		var blob = new Blob( [ this.base64DecToArr(raw_image_data) ], {type: 'image/'+image_fmt} );
		
		// stuff into a form, so servers can easily receive it as a standard file upload
		var form = new FormData();
		form.append( form_elem_name, blob, form_elem_name+"."+image_fmt.replace(/e/, '') );
		
		// send data to server
		http.send(form);
	}
	
};

Webcam.init();

if (typeof define === 'function' && define.amd) {
	define( function() { return Webcam; } );
} 
else if (typeof module === 'object' && module.exports) {
	module.exports = Webcam;
} 
else {
	window.Webcam = Webcam;
}

}(window));

/**
 * @version: 1.3.21
 * @author: Dan Grossman http://www.dangrossman.info/
 * @copyright: Copyright (c) 2012-2015 Dan Grossman. All rights reserved.
 * @license: Licensed under the MIT license. See http://www.opensource.org/licenses/mit-license.php
 * @website: https://www.improvely.com/
 */

(function (root, factory) {

    if(typeof define === 'function' && define.amd) {
        define(['moment', 'jquery', 'exports'], function (momentjs, $, exports) {
            root.daterangepicker = factory(root, exports, momentjs, $);
        });

    } else if(typeof exports !== 'undefined') {
        var momentjs = require('moment');
        var jQuery;
        try {
            jQuery = require('jquery');
        } catch(err) {
            jQuery = window.jQuery;
            if(!jQuery) throw new Error('jQuery dependency not found');
        }

        factory(root, exports, momentjs, jQuery);

        // Finally, as a browser global.
    } else {
        root.daterangepicker = factory(root, {}, root.moment, (root.jQuery || root.Zepto ||
            root.ender || root.$));
    }

}(this, function (root, daterangepicker, moment, $) {

    var DateRangePicker = function (element, options, cb, valid, inValid) {

        // by default, the daterangepicker element is placed at the bottom of HTML body
        this.parentEl = 'body';

        //element that triggered the date range picker
        this.element = $(element);

        //tracks visible state
        this.isShowing = false;

        //create the picker HTML object
        var DRPTemplate = '<div class="daterangepicker dropdown-menu">' +
            '<div class="ranges">' +
            '<div class="range_inputs">' +
            '<div class="daterangepicker_start_input">' +
            '<label for="daterangepicker_start"></label>' +
            '<input class="input-mini" type="text" name="daterangepicker_start" value="" />' +
            '</div>' +
            '<div class="daterangepicker_end_input">' +
            '<label for="daterangepicker_end"></label>' +
            '<input class="input-mini" type="text" name="daterangepicker_end" value="" />' +
            '</div>' +
            '<button class="applyBtn" disabled="disabled"></button>&nbsp;' +
            '<button class="cancelBtn"></button>' +
            '</div>' +
            '</div>' +
            '<div class="calendar first left"></div>' +   //VC move this line here to show the range section upper itself
            '<div class="calendar second right"></div>' + //VC move this line here to show the range section upper itself
            '</div>';

        //custom options
        if(typeof options !== 'object' || options === null)
            options = {};

        this.parentEl = (typeof options === 'object' && options.parentEl &&
            $(options.parentEl).length) ? $(options.parentEl) : $(this.parentEl);
        this.container = $(DRPTemplate).appendTo(this.parentEl);

        this.setOptions(options, cb, valid, inValid);

        //event listeners
        this.container.find('.calendar')
            .on('click.daterangepicker', '.prev', $.proxy(this.clickPrev,
                this))
            .on('click.daterangepicker', '.next', $.proxy(this.clickNext,
                this))
            .on('click.daterangepicker', 'td.available', $.proxy(this.clickDate,
                this))
            .on('mouseenter.daterangepicker', 'td.available', $.proxy(this.hoverDate,
                this))
            .on('mouseleave.daterangepicker', 'td.available', $.proxy(this.updateFormInputs,
                this))
            .on('change.daterangepicker', 'select.yearselect', $.proxy(this.updateMonthYear,
                this))
            .on('change.daterangepicker', 'select.monthselect', $.proxy(this
                .updateMonthYear, this))
            .on('change.daterangepicker',
                'select.hourselect,select.minuteselect,select.secondselect,select.ampmselect',
                $.proxy(this.updateTime, this));

        this.container.find('.ranges')
            .on('click.daterangepicker', 'button.applyBtn', $.proxy(this.clickApply,
                this))
            .on('click.daterangepicker', 'button.cancelBtn', $.proxy(this.clickCancel,
                this))
            .on('click.daterangepicker',
                '.daterangepicker_start_input,.daterangepicker_end_input', $
                .proxy(this.showCalendars, this))
            .on('change.daterangepicker',
                '.daterangepicker_start_input,.daterangepicker_end_input', $
                .proxy(this.inputsChanged, this))
            .on('keydown.daterangepicker',
                '.daterangepicker_start_input,.daterangepicker_end_input', $
                .proxy(this.inputsKeydown, this))
            .on('click.daterangepicker', 'li', $.proxy(this.clickRange, this))
            .on('mouseenter.daterangepicker', 'li', $.proxy(this.enterRange,
                this))
            .on('mouseleave.daterangepicker', 'li', $.proxy(this.updateFormInputs,
                this));

        if(this.element.is('input')) {
            this.element.on({
                'click.daterangepicker': $.proxy(this.show, this),
                'focus.daterangepicker': $.proxy(this.show, this),
                'keyup.daterangepicker': $.proxy(this.updateFromControl,
                    this),
                'keydown.daterangepicker': $.proxy(this.keydown,
                    this)
            });
        } else {
            this.element.on('click.daterangepicker', $.proxy(this.toggle,
                this));
        }

    };

    DateRangePicker.prototype = {

        constructor: DateRangePicker,

        setOptions: function (options, callback, valid, inValid) {

            this.startDate = moment().startOf('day');
            this.endDate = moment().endOf('day');
            this.timeZone = moment().utcOffset();
            this.minDate = false;
            this.maxDate = false;
            this.dateLimit = false;

            this.showDropdowns = false;
            this.showWeekNumbers = false;
            this.timePicker = false;
            this.timePickerSeconds = false;
            this.timePickerIncrement = 30;
            this.timePicker12Hour = true;
            this.singleDatePicker = false;
            this.ranges = {};
            this.thai = false;
            this.singleModeRange = false

            this.opens = 'right';
            if(this.element.hasClass('pull-right'))
                this.opens = 'left';

            this.drops = 'down';
            if(this.element.hasClass('dropup'))
                this.drops = 'up';

            this.buttonClasses = ['ui', 'compact', 'small', 'button'];
            this.applyClass = 'primary';
            this.cancelClass = 'secondary';

            this.format = 'DD/MM/YYYY';
            this.separator = ' - ';

            this.locale = {
                applyLabel: 'Apply',
                cancelLabel: 'Cancel',
                fromLabel: 'From',
                toLabel: 'To',
                weekLabel: 'W',
                customRangeLabel: 'Custom Range',
                daysOfWeek: moment.weekdaysMin(),
                monthNames: moment.monthsShort(),
                firstDay: moment.localeData()._week.dow
            };

            this.cb = function () {};

            //VC
            //set valid, invalid callback
            this.valid = valid;
            this.inValid = inValid;

            //VC 
            //thai option for showing thai style calendar
            if(typeof options.thai === 'boolean')
                this.thai = options.thai;
            
            //VC 
            //if singleModeRange is set to true, it will show range panel in single mode
            if(typeof options.singleModeRange === 'boolean')
                this.singleModeRange = options.singleModeRange;

            if(typeof options.format === 'string')
                this.format = options.format;
            
            if(typeof options.separator === 'string')
                this.separator = options.separator;

            if(typeof options.startDate === 'string'){
                //VC
                //if thai style minus startDate by 543
                this.startDate = moment(options.startDate, this.format);
                var _year  = Math.max(moment(options.startDate, this.format).year() - 543, 0);
                var _month = moment(options.startDate, this.format).month();
                var _day   = moment(options.startDate, this.format).date();
                var newStartDate = _day + "/" + _month + "/" + _year;
                if(this.thai) this.startDate = moment(newStartDate, this.format);
            }

            if(typeof options.endDate === 'string'){
                //VC
                //if thai style minus endDate by 543
                this.endDate = moment(options.endDate, this.format);
                var _year  = Math.max(moment(options.endDate, this.format).year() - 543, 0);
                var _month = moment(options.endDate, this.format).month();
                var _day   = moment(options.endDate, this.format).date();
                var newEndDate = _day + "/" + _month + "/" + _year;
                if(this.thai) this.endDate = moment(newEndDate, this.format);
            }

            if(typeof options.minDate === 'string'){
                //VC
                //if thai style minus minDate by 543
                this.minDate = moment(options.minDate, this.format);
                var _year  = Math.max(moment(options.minDate, this.format).year() - 543, 0);
                var _month = moment(options.minDate, this.format).month();
                var _day   = moment(options.minDate, this.format).date();
                var newMinDate = _day + "/" + _month + "/" + _year;
                if(this.thai) this.minDate = moment(newMinDate, this.format);
            }

            if(typeof options.maxDate === 'string'){
                this.maxDate = moment(options.maxDate, this.format);
                //VC
                //if thai style minus maxDate by 543
                var _year  = Math.max(moment(options.maxDate, this.format).year() - 543, 0);
                var _month = moment(options.maxDate, this.format).month();
                var _day   = moment(options.maxDate, this.format).date();
                var newMaxDate = _day + "/" + _month + "/" + _year;
                if(this.thai) this.maxDate = moment(newMaxDate, this.format);
            }

            if(typeof options.startDate === 'object'){
                this.startDate = moment(options.startDate);
                //VC
                //if thai style minus startDate by 543
                var _year  = Math.max(moment(options.startDate).year() - 543, 0);
                var _month = moment(options.startDate).month();
                var _day   = moment(options.startDate).date();
                var newStartDate = _day + "/" + _month + "/" + _year;
                if(this.thai) this.startDate = moment(newStartDate, this.format);
            }

            if(typeof options.endDate === 'object'){
                this.endDate = moment(options.endDate);
                //VC
                //if thai style minus endDate by 543
                var _year  = Math.max(moment(options.endDate).year() - 543, 0);
                var _month = moment(options.endDate).month();
                var _day   = moment(options.endDate).date();
                var newEndDate = _day + "/" + _month + "/" + _year;
                if(this.thai) this.endDate = moment(newEndDate, this.format);
            }

            if(typeof options.minDate === 'object'){
                this.minDate = moment(options.minDate);
                //VC
                //if thai style minus minDate by 543
                var _year  = Math.max(moment(options.minDate).year() - 543, 0);
                var _month = moment(options.minDate).month();
                var _day   = moment(options.minDate).date();
                var newMinDate = _day + "/" + _month + "/" + _year;
                if(options.thai) this.minDate = moment(newMinDate, this.format);
            }

            if(typeof options.maxDate === 'object'){
                this.maxDate = moment(options.maxDate);
            }

            if(typeof options.applyClass === 'string')
                this.applyClass = options.applyClass;

            if(typeof options.cancelClass === 'string')
                this.cancelClass = options.cancelClass;

            if(typeof options.dateLimit === 'object')
                this.dateLimit = options.dateLimit;
            
           

            if(typeof options.locale === 'object') {

                if(typeof options.locale.daysOfWeek === 'object') {
                    // Create a copy of daysOfWeek to avoid modification of original
                    // options object for reusability in multiple daterangepicker instances
                    this.locale.daysOfWeek = options.locale.daysOfWeek.slice();
                }

                if(typeof options.locale.monthNames === 'object') {
                    this.locale.monthNames = options.locale.monthNames.slice();
                }

                if(typeof options.locale.firstDay === 'number') {
                    this.locale.firstDay = options.locale.firstDay;
                }

                if(typeof options.locale.applyLabel === 'string') {
                    this.locale.applyLabel = options.locale.applyLabel;
                }

                if(typeof options.locale.cancelLabel === 'string') {
                    this.locale.cancelLabel = options.locale.cancelLabel;
                }

                if(typeof options.locale.fromLabel === 'string') {
                    this.locale.fromLabel = options.locale.fromLabel;
                }

                if(typeof options.locale.toLabel === 'string') {
                    this.locale.toLabel = options.locale.toLabel;
                }

                if(typeof options.locale.weekLabel === 'string') {
                    this.locale.weekLabel = options.locale.weekLabel;
                }

                if(typeof options.locale.customRangeLabel === 'string') {
                    this.locale.customRangeLabel = options.locale.customRangeLabel;
                }
            }

            if(typeof options.opens === 'string')
                this.opens = options.opens;

            if(typeof options.drops === 'string')
                this.drops = options.drops;

            if(typeof options.showWeekNumbers === 'boolean') {
                this.showWeekNumbers = options.showWeekNumbers;
            }

            if(typeof options.buttonClasses === 'string') {
                this.buttonClasses = [options.buttonClasses];
            }

            if(typeof options.buttonClasses === 'object') {
                this.buttonClasses = options.buttonClasses;
            }

            if(typeof options.showDropdowns === 'boolean') {
                this.showDropdowns = options.showDropdowns;
            }

            if(typeof options.singleDatePicker === 'boolean') {
                this.singleDatePicker = options.singleDatePicker;
                if(this.singleDatePicker) {
                    this.endDate = this.startDate.clone();
                }
            }

            if(typeof options.timePicker === 'boolean') {
                this.timePicker = options.timePicker;
            }

            if(typeof options.timePickerSeconds === 'boolean') {
                this.timePickerSeconds = options.timePickerSeconds;
            }

            if(typeof options.timePickerIncrement === 'number') {
                this.timePickerIncrement = options.timePickerIncrement;
            }

            if(typeof options.timePicker12Hour === 'boolean') {
                this.timePicker12Hour = options.timePicker12Hour;
            }

            // update day names order to firstDay
            if(this.locale.firstDay !== 0) {
                var iterator = this.locale.firstDay;
                while(iterator > 0) {
                    this.locale.daysOfWeek.push(this.locale.daysOfWeek.shift());
                    iterator--;
                }
            }

            var start, end, range;

            //if no start/end dates set, check if an input element contains initial values
            if(typeof options.startDate === 'undefined' && typeof options
                .endDate === 'undefined') {
                if($(this.element).is('input[type=text]')) {
                    var val = $(this.element).val(),
                        split = val.split(this.separator);
                    
                    start = end = null;

                    if(split.length == 2) {
                        start = moment(split[0], this.format);
                        end = moment(split[1], this.format);
                    } else if(this.singleDatePicker && val !== "") {
                        start = moment(val, this.format);
                        end = moment(val, this.format);
                    }
                    if(start !== null && end !== null) {
                        this.startDate = start.isValid() ? start : this.startDate;
                        this.endDate = end.isValid() ? end : this.endDate;
                    }

                    //VC
                    //if thai style, year - 543
                    //TODO fix problem about format
                    //this code can only use format like DD/MM/YYYY
                    if(this.thai && split.length == 2){
                        var _startDate = split[0].split("/");
                        var _sdate = Number(_startDate[0]);
                        var _smonth = Number(_startDate[1]);
                        var _syear = Number(_startDate[2]);

                        if( Number.isInteger(_sdate)   && 
                            Number.isInteger(_smonth) && 
                            Number.isInteger(_syear)  ){

                            _syear = Math.max(_syear - 543, 0);
                            _startDate = _sdate + "/" + _smonth + "/" + _syear;
                            _startDate = moment(_startDate, this.format);
                            this.startDate = _startDate.isValid() ? _startDate : this.startDate; 
                        } 

                        var _endDate = split[1].split("/");
                        var _eday = Number(_endDate[0]);
                        var _emonth = Number(_endDate[1]);
                        var _eyear = Number(_endDate[2]);

                        if( Number.isInteger(_eday)   && 
                            Number.isInteger(_emonth) && 
                            Number.isInteger(_eyear)  ){

                            _eyear = Math.max(_eyear - 543, 0);
                            _endDate = _eday + "/" + _emonth + "/" + _eyear;
                            _endDate = moment(_endDate, this.format);
                            this.endDate = _endDate.isValid() ? _endDate : this.endDate;
                        }
                    }
                    else if(this.thai && split.length == 1){
                        var value = split[0].split("/");
                        var _day = Number(value[0]);
                        var _month = Number(value[1]);
                        var _year = Number(value[2]);
                        var _date;

                        if( Number.isInteger(_day)   && 
                            Number.isInteger(_month) && 
                            Number.isInteger(_year)  ){

                            _year = Math.max(_year - 543, 0);
                            value = _day + "/" + _month + "/" + _year;
                            _date = moment(value, this.format);
                            this.startDate = _date.isValid() ? _date : this.startDate; 
                            this.endDate   = _date.isValid() ? _date : this.endDate;
                        } 
                    }
                }
            }

            // bind the time zone used to build the calendar to either the
            // timeZone passed in through the options or the zone of the
            // startDate (which will be the local time zone by default)
            if(typeof options.timeZone === 'string' || typeof options.timeZone ===
                'number') {
                if(typeof options.timeZone === 'string' && typeof moment
                    .tz !== 'undefined') {
                    this.timeZone = moment.tz.zone(options.timeZone).parse(
                        new Date()) * -1; // Offset is positive if the timezone is behind UTC and negative if it is ahead.
                } else {
                    this.timeZone = options.timeZone;
                }
                this.startDate.utcOffset(this.timeZone);
                this.endDate.utcOffset(this.timeZone);
            } else {
                this.timeZone = moment(this.startDate).utcOffset();
            }

            if(typeof options.ranges === 'object') {
                for(range in options.ranges) {

                    if(typeof options.ranges[range][0] === 'string')
                        start = moment(options.ranges[range][0], this.format);
                    else
                        start = moment(options.ranges[range][0]);

                    if(typeof options.ranges[range][1] === 'string')
                        end = moment(options.ranges[range][1], this.format);
                    else
                        end = moment(options.ranges[range][1]);
                    
                    //VC
                    //if thai style, year - 543
                    //TODO fix problem about format
                    //this code can only use format like DD/MM/YYYY
                    if(this.thai){
                        var _start = options.ranges[range][0].split("/");
                        var _end   = options.ranges[range][1].split("/");

                        var _sday   = parseInt(_start[0]),
                            _smonth = parseInt(_start[1]),
                            _syear  = Math.max(parseInt(_start[2]) - 543, 0),
                            _eday   = parseInt(_end[0]),
                            _emonth = parseInt(_end[1]),
                            _eyear  = Math.max(parseInt(_end[2]) - 543, 0),
                            _start  = _sday + "/" + _smonth + "/" + _syear,
                            _end    = _eday + "/" + _emonth + "/" + _eyear;

                        start = moment(_start, this.format);
                        end   = moment(_end, this.format);
                    }

                    // If we have a min/max date set, bound this range
                    // to it, but only if it would otherwise fall
                    // outside of the min/max.
                    if(this.minDate && start.isBefore(this.minDate))
                        start = moment(this.minDate);

                    if(this.maxDate && end.isAfter(this.maxDate))
                        end = moment(this.maxDate);

                    // If the end of the range is before the minimum (if min is set) OR
                    // the start of the range is after the max (also if set) don't display this
                    // range option.
                    if((this.minDate && end.isBefore(this.minDate)) || (
                            this.maxDate && start.isAfter(this.maxDate))) {
                        continue;
                    }

                    this.ranges[range] = [start, end];
                }

                var list = '<ul>';
                for(range in this.ranges) {
                    list += '<li>' + range + '</li>';
                }
                //VC
                //if singleModeRange it will not show custom label
                if(!this.singleModeRange){
                    list += '<li>' + this.locale.customRangeLabel + '</li>';
                }
                list += '</ul>';
                this.container.find('.ranges ul').remove();
                this.container.find('.ranges').prepend(list);
            }

            if(typeof callback === 'function') {
                this.cb = callback;
            }

            if(!this.timePicker) {
                this.startDate = this.startDate.startOf('day');
                this.endDate = this.endDate.endOf('day');
            }

            if(this.singleDatePicker) {
                this.opens = 'right';
                this.container.addClass('single');
                this.container.find('.calendar.right').show();
                this.container.find('.calendar.left').hide();
                if(!this.timePicker) {
                    //VC
                    //show ranges button on top of calendar in case single calendar
                    if(!this.singleModeRange){
                        this.container.find('.ranges').hide();
                    }else{
                        this.container.find('.ranges').show();
                        this.container.find('.calendar.right, .ranges .range_inputs').hide();
                    }
                } else {
                    this.container.find(
                        '.ranges .daterangepicker_start_input, .ranges .daterangepicker_end_input'
                    ).hide();
                }
                if(!this.container.find('.calendar.right').hasClass(
                        'single'))
                    this.container.find('.calendar.right').addClass(
                        'single');
            } else {
                this.container.removeClass('single');
                this.container.find('.calendar.right').removeClass(
                    'single');
                this.container.find('.ranges').show();
            }

            this.oldStartDate = this.startDate.clone();
            this.oldEndDate = this.endDate.clone();
            this.oldChosenLabel = this.chosenLabel;

            this.leftCalendar = {
                month: moment([this.startDate.year(), this.startDate
                    .month(), 1, this.startDate.hour(), this
                    .startDate.minute(), this.startDate.second()
                ]),
                calendar: []
            };

            this.rightCalendar = {
                month: moment([this.endDate.year(), this.endDate.month(),
                    1, this.endDate.hour(), this.endDate.minute(),
                    this.endDate.second()
                ]),
                calendar: []
            };

            if(this.opens == 'right' || this.opens == 'center') {
                //swap calendar positions
                var first = this.container.find('.calendar.first');
                var second = this.container.find('.calendar.second');

                if(second.hasClass('single')) {
                    second.removeClass('single');
                    first.addClass('single');
                }

                first.removeClass('left').addClass('right');
                second.removeClass('right').addClass('left');

                if(this.singleDatePicker) {
                    first.show();
                    second.hide();
                }
            }

            if(typeof options.ranges === 'undefined' && !this.singleDatePicker) {
                this.container.addClass('show-calendar');
            }

            this.container.removeClass('opensleft opensright').addClass(
                'opens' + this.opens);

            this.updateView();
            this.updateCalendars();

            //apply CSS classes and labels to buttons
            var c = this.container;
            $.each(this.buttonClasses, function (idx, val) {
                c.find('button').addClass(val);
            });
            this.container.find('.daterangepicker_start_input label').html(
                this.locale.fromLabel);
            this.container.find('.daterangepicker_end_input label').html(
                this.locale.toLabel);
            if(this.applyClass.length)
                this.container.find('.applyBtn').addClass(this.applyClass);
            if(this.cancelClass.length)
                this.container.find('.cancelBtn').addClass(this.cancelClass);
            this.container.find('.applyBtn').html(this.locale.applyLabel);
            this.container.find('.cancelBtn').html(this.locale.cancelLabel);
        },

        setStartDate: function (startDate) {
            if(typeof startDate === 'string')
                this.startDate = moment(startDate, this.format).utcOffset(
                    this.timeZone);

            if(typeof startDate === 'object')
                this.startDate = moment(startDate);

            if(!this.timePicker)
                this.startDate = this.startDate.startOf('day');

            this.oldStartDate = this.startDate.clone();

            this.updateView();
            this.updateCalendars();
            this.updateInputText();
        },

        setEndDate: function (endDate) {
            if(typeof endDate === 'string')
                this.endDate = moment(endDate, this.format).utcOffset(
                    this.timeZone);

            if(typeof endDate === 'object')
                this.endDate = moment(endDate);

            if(!this.timePicker)
                this.endDate = this.endDate.endOf('day');

            this.oldEndDate = this.endDate.clone();

            this.updateView();
            this.updateCalendars();
            this.updateInputText();
        },

        updateView: function () {
            this.leftCalendar.month.month(this.startDate.month()).year(
                this.startDate.year()).hour(this.startDate.hour()).minute(
                this.startDate.minute());
            this.rightCalendar.month.month(this.endDate.month()).year(
                this.endDate.year()).hour(this.endDate.hour()).minute(
                this.endDate.minute());
            this.updateFormInputs();
        },

        updateFormInputs: function () {
            this.container.find('input[name=daterangepicker_start]').val(
                this.startDate.format(this.format));
            this.container.find('input[name=daterangepicker_end]').val(
                this.endDate.format(this.format));

            //VC
            //if thai style, year in 2 textboxs = year + 543
            if(this.thai){
                var _sYear  = this.startDate.year()  + 543,
                    _sMonth = this.startDate.month() + 1,
                    _sDay   = this.startDate.date(),
                    _eYear  = this.endDate.year()  + 543,
                    _eMonth = this.endDate.month() + 1,
                    _eDay   = this.endDate.date(),
                    _sDate  = _sDay + "/" + _sMonth + "/" + _sYear,
                    _eDate  = _eDay + "/" + _eMonth + "/" + _eYear;

                //VC
                //TODO fix this problem [can't use this.format]
                this.container.find('input[name=daterangepicker_start]').val(_sDate);
                this.container.find('input[name=daterangepicker_end]').val(_eDate);
            }

            if(this.startDate.isSame(this.endDate) || this.startDate.isBefore(
                    this.endDate)) {
                this.container.find('button.applyBtn').removeAttr(
                    'disabled');
            } else {
                this.container.find('button.applyBtn').attr('disabled',
                    'disabled');
            }
        },

        updateFromControl: function () {
            var isValid = true;
            if(!this.element.is('input')) isValid = false;
            if(!this.element.val().length) isValid = false;

            if(!isValid){
                this.inValid();
                return;
            }

            var dateString = this.element.val().split(this.separator),
                start = null,
                end = null;
            
            //VC
            //if thai style, year - 543
            //TODO fix problem about format
            //this code can only use format like DD/MM/YYYY
            if(this.thai){
                if(dateString.length === 2){
                    var _start = dateString[0].split("/");
                    var _sdate  = parseInt(_start[0]);
                    var _smonth = parseInt(_start[1]);
                    var _syear  = parseInt(_start[2]);

                    _syear = Math.max(_syear - 543, 0);
                    _start = _sdate + "/" + _smonth + "/" + _syear;
                    start = moment(_start, this.format).utcOffset(this.timeZone);

                    var _end = dateString[1].split("/");
                    var _edate  = parseInt(_end[0]);
                    var _emonth = parseInt(_end[1]);
                    var _eyear  = parseInt(_end[2]);

                    _eyear = Math.max(_eyear - 543, 0);
                    _end = _edate + "/" + _emonth + "/" + _eyear;
                    end = moment(_end, this.format).utcOffset(this.timeZone);
                }
                else if(this.singleDatePicker || start === null || end === null){
                    var value  = this.element.val().split("/");
                    var _day = Number(value[0]);
                    var _month = Number(value[1]);
                    var _year = Number(value[2]);

                    //validate input
                    if(Number.isInteger(_day) && Number.isInteger(_month) && Number.isInteger(_year)){
                        if(("" + _day).length > 2) isValid = false;
                        if(("" + _month).length > 2) isValid = false;
                        if(("" + _year).length > 4) isValid = false;
                        if(_year < 543) isValid = false;
                    }
                    else{
                        isValid = false;
                    }

                    _year = Math.max(_year - 543, 0);
                    value = _day + "/" + _month + "/" + _year;
                    start = moment(value, this.format).utcOffset(this.timeZone);
                    end = start;

                    if(!start.isValid())
                        isValid = false;
                }
            }
            else{
                if(dateString.length === 2) {
                    start = moment(dateString[0], this.format).utcOffset(
                        this.timeZone);
                    end = moment(dateString[1], this.format).utcOffset(this.timeZone);
                }

                if(this.singleDatePicker || start === null || end === null) {
                    start = moment(this.element.val(), this.format).utcOffset(
                        this.timeZone);
                    end = start;
                }

                if(!start.isValid() || !end.isValid()) isValid = false;
            }

            //VC
            if(!isValid || end.isBefore(start)){
                this.inValid();
                return;
            }

            this.valid();
            
            this.oldStartDate = this.startDate.clone();
            this.oldEndDate = this.endDate.clone();

            this.startDate = start;
            this.endDate = end;

            if(!this.startDate.isSame(this.oldStartDate) || !this.endDate
                .isSame(this.oldEndDate))
                this.notify();

            this.updateCalendars();
        },

        keydown: function (e) {
            //hide on tab or enter
            if((e.keyCode === 9) || (e.keyCode === 13)) {
                this.hide();
            }
        },

        notify: function () {
            this.updateView();
            this.cb(this.startDate, this.endDate, this.chosenLabel);
        },

        move: function () {
            var parentOffset = {
                    top: 0,
                    left: 0
                },
                containerTop;
            var parentRightEdge = $(window).width();
            if(!this.parentEl.is('body')) {
                parentOffset = {
                    top: this.parentEl.offset().top - this.parentEl.scrollTop(),
                    left: this.parentEl.offset().left - this.parentEl
                        .scrollLeft()
                };
                parentRightEdge = this.parentEl[0].clientWidth + this.parentEl
                    .offset().left;
            }

            if(this.drops == 'up')
                containerTop = this.element.offset().top - this.container
                .outerHeight() - parentOffset.top;
            else
                containerTop = this.element.offset().top + this.element.outerHeight() -
                parentOffset.top;
            this.container[this.drops == 'up' ? 'addClass' :
                'removeClass']('dropup');

            if(this.opens == 'left') {
                this.container.css({
                    top: containerTop,
                    right: parentRightEdge - this.element.offset()
                        .left - this.element.outerWidth(),
                    left: 'auto'
                });
                if(this.container.offset().left < 0) {
                    this.container.css({
                        right: 'auto',
                        left: 9
                    });
                }
            } else if(this.opens == 'center') {
                this.container.css({
                    top: containerTop,
                    left: this.element.offset().left -
                        parentOffset.left + this.element.outerWidth() /
                        2 - this.container.outerWidth() / 2,
                    right: 'auto'
                });
                if(this.container.offset().left < 0) {
                    this.container.css({
                        right: 'auto',
                        left: 9
                    });
                }
            } else {
                this.container.css({
                    top: containerTop,
                    left: this.element.offset().left -
                        parentOffset.left,
                    right: 'auto'
                });
                if(this.container.offset().left + this.container.outerWidth() >
                    $(window).width()) {
                    this.container.css({
                        left: 'auto',
                        right: 0
                    });
                }
            }
        },

        toggle: function (e) {
            if(this.element.hasClass('active')) {
                this.hide();
            } else {
                this.show();
            }
        },

        show: function (e) {
            if(this.isShowing) return;

            this.element.addClass('active');
            this.container.show();
            this.move();

            // Create a click proxy that is private to this instance of datepicker, for unbinding
            this._outsideClickProxy = $.proxy(function (e) {
                this.outsideClick(e);
            }, this);
            // Bind global datepicker mousedown for hiding and
            $(document)
                .on('mousedown.daterangepicker', this._outsideClickProxy)
                // also support mobile devices
                .on('touchend.daterangepicker', this._outsideClickProxy)
                // also explicitly play nice with Bootstrap dropdowns, which stopPropagation when clicking them
                .on('click.daterangepicker', '[data-toggle=dropdown]',
                    this._outsideClickProxy)
                // and also close when focus changes to outside the picker (eg. tabbing between controls)
                .on('focusin.daterangepicker', this._outsideClickProxy);

            this.isShowing = true;
            this.element.trigger('show.daterangepicker', this);
        },

        outsideClick: function (e) {
            var target = $(e.target);
            // if the page is clicked anywhere except within the daterangerpicker/button
            // itself then call this.hide()
            if(
                // ie modal dialog fix
                e.type == "focusin" ||
                target.closest(this.element).length ||
                target.closest(this.container).length ||
                target.closest('.calendar-date').length
            ) return;
            this.hide();
        },

        hide: function (e) {
            if(!this.isShowing) return;

            $(document)
                .off('.daterangepicker');

            this.element.removeClass('active');
            this.container.hide();

            if(!this.startDate.isSame(this.oldStartDate) || !this.endDate
                .isSame(this.oldEndDate))
                this.notify();

            this.oldStartDate = this.startDate.clone();
            this.oldEndDate = this.endDate.clone();

            this.isShowing = false;
            this.element.trigger('hide.daterangepicker', this);
        },

        enterRange: function (e) {
            // mouse pointer has entered a range label
            var label = e.target.innerHTML;
            if(label == this.locale.customRangeLabel) {
                this.updateView();
            } else {
                var dates = this.ranges[label],
                    startDate = dates[0].format(this.format),
                    endDate   = dates[1].format(this.format);
                //VC
                //year + 543
                if(this.thai){
                    var _startDate = dates[0].format(this.format).split("/"),
                        _endDate   = dates[0].format(this.format).split("/"),
                        _sdate  = parseInt(_startDate[0]),
                        _edate  = parseInt(_endDate[0]),
                        _smonth = parseInt(_startDate[1]),
                        _emonth = parseInt(_endDate[1]),
                        _syear  = parseInt(_startDate[2]) + 543,
                        _eyear  = parseInt(_endDate[2]) + 543,
                        _startDate = _sdate + "/" + _smonth + "/" + _syear,
                        _endDate   = _sdate + "/" + _smonth + "/" + _syear;
                    
                    startDate = _startDate
                    endDate = _endDate

                }
                this.container.find('input[name=daterangepicker_start]').val(startDate);
                this.container.find('input[name=daterangepicker_end]').val(endDate);
            }
        },

        showCalendars: function () {
            this.container.addClass('show-calendar');
            this.move();
            this.element.trigger('showCalendar.daterangepicker', this);
        },

        hideCalendars: function () {
            this.container.removeClass('show-calendar');
            this.element.trigger('hideCalendar.daterangepicker', this);
        },

        // when a date is typed into the start to end date textboxes
        inputsChanged: function (e) {
            var el = $(e.target);
            var value = el.val();
            //VC
            //if thai style, year - 543
            //TODO fix problem about format
            //this code can only use format like DD/MM/YYYY
            if(this.thai){
                var splitedDate = value.split("/");
                if(splitedDate.length !== 3) return;
                var _day = Number(splitedDate[0]);
                var _month = Number(splitedDate[1]);
                var _year = Number(splitedDate[2]);

                if( ! (
                    Number.isInteger(_day)   && 
                    Number.isInteger(_month) && 
                    Number.isInteger(_year) 
                    )) return;
                
                _year = Math.max(_year - 543, 0);
                value = _day + "/" + _month + "/" + _year;
            }

            var date = moment(value, this.format);
            if(!date.isValid()) return;

            var startDate, endDate;
            if(el.attr('name') === 'daterangepicker_start') {
                startDate = (false !== this.minDate && date.isBefore(
                    this.minDate)) ? this.minDate : date;
                endDate = this.endDate;
            } else {
                startDate = this.startDate;
                endDate = (false !== this.maxDate && date.isAfter(this.maxDate)) ?
                    this.maxDate : date;
            }
            this.setCustomDates(startDate, endDate);
        },

        inputsKeydown: function (e) {
            if(e.keyCode === 13) {
                this.inputsChanged(e);
                this.notify();
            }
        },

        updateInputText: function () {
            var _startDate = this.startDate.format(this.format);
            var _endDate   = this.endDate.format(this.format);
            var _fullDate  = _startDate + this.separator + _endDate;
            
            //VC
            //if thai style, year in main textbox  = year + 543 
            if(this.thai){
                var _sYear  = this.startDate.year()  + 543,
                    _sMonth = this.startDate.month() + 1,
                    _sDay   = this.startDate.date(),
                    _eYear  = this.endDate.year()  + 543,
                    _eMonth = this.endDate.month() + 1,
                    _eDay   = this.endDate.date(),
                    _sDate  = this.pad(_sDay, 2) + "/" + this.pad(_sMonth, 2) + "/" + _sYear,
                    _eDate  = this.pad(_eDay, 2) + "/" + this.pad(_eMonth, 2) + "/" + _eYear;

                    _startDate = _sDate;
                    _endDate   = _eDate;
                    _fullDate  = _sDate + this.separator + _endDate
            }

            if(this.element.is('input') && !this.singleDatePicker) {
                this.element.val(_fullDate);
                this.element.trigger('change');
                this.element.trigger('dateChange', _fullDate);
            } else if(this.element.is('input')) {
                this.element.val(_endDate);
                this.element.trigger('change');
                this.element.trigger('dateChange', _endDate);
            }
        },

        pad: function(n, width, z) {
            z = z || '0';
            n = n + '';
            return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
        },

        clickRange: function (e) {
            var label = e.target.innerHTML;
            this.chosenLabel = label;
            if(label == this.locale.customRangeLabel) {
                this.showCalendars();
            } else {
                var dates = this.ranges[label];

                this.startDate = dates[0];
                this.endDate = dates[1];

                if(!this.timePicker) {
                    this.startDate.startOf('day');
                    this.endDate.endOf('day');
                }

                this.leftCalendar.month.month(this.startDate.month()).year(
                        this.startDate.year()).hour(this.startDate.hour())
                    .minute(this.startDate.minute());
                this.rightCalendar.month.month(this.endDate.month()).year(
                    this.endDate.year()).hour(this.endDate.hour()).minute(
                    this.endDate.minute());
                this.updateCalendars();

                this.updateInputText();

                this.hideCalendars();
                this.hide();
                this.element.trigger('apply.daterangepicker', this);
                //VC
                this.valid();
            }
        },

        clickPrev: function (e) {
            var cal = $(e.target).parents('.calendar');
            if(cal.hasClass('left')) {
                this.leftCalendar.month.subtract(1, 'month');
            } else {
                this.rightCalendar.month.subtract(1, 'month');
            }
            this.updateCalendars();
        },

        clickNext: function (e) {
            var cal = $(e.target).parents('.calendar');
            if(cal.hasClass('left')) {
                this.leftCalendar.month.add(1, 'month');
            } else {
                this.rightCalendar.month.add(1, 'month');
            }
            this.updateCalendars();
        },

        hoverDate: function (e) {
            var title = $(e.target).attr('data-title');
            var row = title.substr(1, 1);
            var col = title.substr(3, 1);
            var cal = $(e.target).parents('.calendar');

            var leftDate  = this.leftCalendar.calendar[row][col].format(this.format);
            var rightDate = this.rightCalendar.calendar[row][col].format(this.format);

            //VC
            //if thai style, year in 2 textboxs = year + 543
            if(this.thai){
                var _lYear  = this.leftCalendar.calendar[row][col].year()  + 543,
                    _lMonth = this.leftCalendar.calendar[row][col].month() + 1,
                    _lDay   = this.leftCalendar.calendar[row][col].date(),
                    _rYear  = this.rightCalendar.calendar[row][col].year()  + 543,
                    _rMonth = this.rightCalendar.calendar[row][col].month() + 1,
                    _rDay   = this.rightCalendar.calendar[row][col].date(),
                    _lDate  = _lDay + "/" + _lMonth + "/" + _lYear,
                    _rDate  = _rDay + "/" + _rMonth + "/" + _rYear;
                
                //VC
                //TODO fix this problem [can't use format]
                //ignore this.format 
                leftDate  = _lDate;
                rightDate = _rDate;
            }

            if(cal.hasClass('left')) {
                this.container.find('input[name=daterangepicker_start]').val(leftDate);
            } else {
                this.container.find('input[name=daterangepicker_end]').val(rightDate);
            }
        },

        setCustomDates: function (startDate, endDate) {
            this.chosenLabel = this.locale.customRangeLabel;
            if(startDate.isAfter(endDate)) {
                var difference = this.endDate.diff(this.startDate);
                endDate = moment(startDate).add(difference, 'ms');
                if(this.maxDate && endDate.isAfter(this.maxDate)) {
                    endDate = this.maxDate.clone();
                }
            }
            this.startDate = startDate;
            this.endDate = endDate;

            this.updateView();
            this.updateCalendars();
        },

        clickDate: function (e) {
            var title = $(e.target).attr('data-title');
            var row = title.substr(1, 1);
            var col = title.substr(3, 1);
            var cal = $(e.target).parents('.calendar');

            var startDate, endDate;
            if(cal.hasClass('left')) {
                startDate = this.leftCalendar.calendar[row][col];
                endDate = this.endDate;
                if(typeof this.dateLimit === 'object') {
                    var maxDate = moment(startDate).add(this.dateLimit).startOf(
                        'day');
                    if(endDate.isAfter(maxDate)) {
                        endDate = maxDate;
                    }
                }
            } else {
                startDate = this.startDate;
                endDate = this.rightCalendar.calendar[row][col];
                if(typeof this.dateLimit === 'object') {
                    var minDate = moment(endDate).subtract(this.dateLimit)
                        .startOf('day');
                    if(startDate.isBefore(minDate)) {
                        startDate = minDate;
                    }
                }
            }

            if(this.singleDatePicker && cal.hasClass('left')) {
                endDate = startDate.clone();
            } else if(this.singleDatePicker && cal.hasClass('right')) {
                startDate = endDate.clone();
            }

            cal.find('td').removeClass('active');

            $(e.target).addClass('active');

            this.setCustomDates(startDate, endDate);

            if(!this.timePicker)
                endDate.endOf('day');

            if(this.singleDatePicker && !this.timePicker)
                this.clickApply();
        },

        clickApply: function (e) {
            this.updateInputText();
            this.hide();
            this.element.trigger('apply.daterangepicker', this);
            //VC
            this.valid();
        },

        clickCancel: function (e) {
            this.startDate = this.oldStartDate;
            this.endDate = this.oldEndDate;
            this.chosenLabel = this.oldChosenLabel;
            this.updateView();
            this.updateCalendars();
            this.hide();
            this.element.trigger('cancel.daterangepicker', this);
        },

        updateMonthYear: function (e) {
            var isLeft = $(e.target).closest('.calendar').hasClass(
                    'left'),
                leftOrRight = isLeft ? 'left' : 'right',
                cal = this.container.find('.calendar.' + leftOrRight);

            // Month must be Number for new moment versions
            var month = parseInt(cal.find('.monthselect').val(), 10);
            var year = cal.find('.yearselect').val();

            if(!isLeft && !this.singleDatePicker) {
                if(year < this.startDate.year() || (year == this.startDate
                        .year() && month < this.startDate.month())) {
                    month = this.startDate.month();
                    year = this.startDate.year();
                }
            }

            if(this.minDate) {
                if(year < this.minDate.year() || (year == this.minDate.year() &&
                        month < this.minDate.month())) {
                    month = this.minDate.month();
                    year = this.minDate.year();
                }
            }

            if(this.maxDate) {
                if(year > this.maxDate.year() || (year == this.maxDate.year() &&
                        month > this.maxDate.month())) {
                    month = this.maxDate.month();
                    year = this.maxDate.year();
                }
            }

            this[leftOrRight + 'Calendar'].month.month(month).year(year);
            this.updateCalendars();
        },

        updateTime: function (e) {

            var cal = $(e.target).closest('.calendar'),
                isLeft = cal.hasClass('left');

            var hour = parseInt(cal.find('.hourselect').val(), 10);
            var minute = parseInt(cal.find('.minuteselect').val(), 10);
            var second = 0;

            if(this.timePickerSeconds) {
                second = parseInt(cal.find('.secondselect').val(), 10);
            }

            if(this.timePicker12Hour) {
                var ampm = cal.find('.ampmselect').val();
                if(ampm === 'PM' && hour < 12)
                    hour += 12;
                if(ampm === 'AM' && hour === 12)
                    hour = 0;
            }

            if(isLeft) {
                var start = this.startDate.clone();
                start.hour(hour);
                start.minute(minute);
                start.second(second);
                this.startDate = start;
                this.leftCalendar.month.hour(hour).minute(minute).second(
                    second);
                if(this.singleDatePicker)
                    this.endDate = start.clone();
            } else {
                var end = this.endDate.clone();
                end.hour(hour);
                end.minute(minute);
                end.second(second);
                this.endDate = end;
                if(this.singleDatePicker)
                    this.startDate = end.clone();
                this.rightCalendar.month.hour(hour).minute(minute).second(
                    second);
            }

            this.updateView();
            this.updateCalendars();
        },

        updateCalendars: function () {
            this.leftCalendar.calendar = this.buildCalendar(this.leftCalendar
                .month.month(), this.leftCalendar.month.year(), this
                .leftCalendar.month.hour(), this.leftCalendar.month.minute(),
                this.leftCalendar.month.second(), 'left');
            this.rightCalendar.calendar = this.buildCalendar(this.rightCalendar
                .month.month(), this.rightCalendar.month.year(),
                this.rightCalendar.month.hour(), this.rightCalendar.month
                .minute(), this.rightCalendar.month.second(),
                'right');
            this.container.find('.calendar.left').empty().html(this.renderCalendar(
                this.leftCalendar.calendar, this.startDate, this
                .minDate, this.maxDate, 'left'));
            this.container.find('.calendar.right').empty().html(this.renderCalendar(
                this.rightCalendar.calendar, this.endDate, this.singleDatePicker ?
                this.minDate : this.startDate, this.maxDate,
                'right'));

            this.container.find('.ranges li').removeClass('active');
            var customRange = true;
            var i = 0;
            for(var range in this.ranges) {
                if(this.timePicker) {
                    if(this.startDate.isSame(this.ranges[range][0]) &&
                        this.endDate.isSame(this.ranges[range][1])) {
                        customRange = false;
                        this.chosenLabel = this.container.find(
                                '.ranges li:eq(' + i + ')')
                            .addClass('active').html();
                    }
                } else {
                    //ignore times when comparing dates if time picker is not enabled
                    if(this.startDate.format('YYYY-MM-DD') == this.ranges[
                            range][0].format('YYYY-MM-DD') && this.endDate
                        .format('YYYY-MM-DD') == this.ranges[range][1].format(
                            'YYYY-MM-DD')) {
                        customRange = false;
                        this.chosenLabel = this.container.find(
                                '.ranges li:eq(' + i + ')')
                            .addClass('active').html();
                    }
                }
                i++;
            }
            if(customRange) {
                this.chosenLabel = this.container.find('.ranges li:last')
                    .addClass('active').html();
                this.showCalendars();
            }
        },

        buildCalendar: function (month, year, hour, minute, second, side) {
            var daysInMonth = moment([year, month]).daysInMonth();
            var firstDay = moment([year, month, 1]);
            var lastDay = moment([year, month, daysInMonth]);
            var lastMonth = moment(firstDay).subtract(1, 'month').month();
            var lastYear = moment(firstDay).subtract(1, 'month').year();

            var daysInLastMonth = moment([lastYear, lastMonth]).daysInMonth();

            var dayOfWeek = firstDay.day();

            var i;

            //initialize a 6 rows x 7 columns array for the calendar
            var calendar = [];
            calendar.firstDay = firstDay;
            calendar.lastDay = lastDay;

            for(i = 0; i < 6; i++) {
                calendar[i] = [];
            }

            //populate the calendar with date objects
            var startDay = daysInLastMonth - dayOfWeek + this.locale.firstDay +
                1;
            if(startDay > daysInLastMonth)
                startDay -= 7;

            if(dayOfWeek == this.locale.firstDay)
                startDay = daysInLastMonth - 6;

            var curDate = moment([lastYear, lastMonth, startDay, 12,
                minute, second
            ]).utcOffset(this.timeZone);

            var col, row;
            for(i = 0, col = 0, row = 0; i < 42; i++, col++, curDate =
                moment(curDate).add(24, 'hour')) {
                if(i > 0 && col % 7 === 0) {
                    col = 0;
                    row++;
                }
                calendar[row][col] = curDate.clone().hour(hour);
                curDate.hour(12);

                if(this.minDate && calendar[row][col].format(
                        'YYYY-MM-DD') == this.minDate.format(
                        'YYYY-MM-DD') && calendar[row][col].isBefore(
                        this.minDate) && side == 'left') {
                    calendar[row][col] = this.minDate.clone();
                }

                if(this.maxDate && calendar[row][col].format(
                        'YYYY-MM-DD') == this.maxDate.format(
                        'YYYY-MM-DD') && calendar[row][col].isAfter(this
                        .maxDate) && side == 'right') {
                    calendar[row][col] = this.maxDate.clone();
                }

            }

            return calendar;
        },

        renderDropdowns: function (selected, minDate, maxDate) {
            var currentMonth = selected.month();
            var currentYear = selected.year();
            //VC
            //render prev 50 years and render next 5 year in combobox
            var maxYear = (maxDate && maxDate.year()) || (currentYear +
                20);
            var minYear = (minDate && minDate.year()) || (currentYear -
                100);

            var monthHtml = '<select class="ui compact selection dropdown monthselect">';
            var inMinYear = currentYear == minYear;
            var inMaxYear = currentYear == maxYear;

            for(var m = 0; m < 12; m++) {
                if((!inMinYear || m >= minDate.month()) && (!inMaxYear ||
                        m <= maxDate.month())) {
                    monthHtml += "<option value='" + m + "'" +
                        (m === currentMonth ? " selected='selected'" :
                            "") +
                        ">" + this.locale.monthNames[m] + "</option>";
                }
            }
            monthHtml += "</select>";

            var yearHtml = '<select class="ui compact selection dropdown yearselect">';

            for(var y = minYear; y <= maxYear; y++) {
                yearHtml += '<option value="' + y + '"' +
                (y === currentYear ? ' selected="selected"' : '');
                
                //VC
                //if thai style year + 543
                if(this.thai){
                    yearHtml += '>' + (y + 543) + '</option>';
                }
                else{
                    yearHtml += '>' + y + '</option>';
                }
            }

            yearHtml += '</select>';

            return monthHtml + yearHtml;
        },

        renderCalendar: function (calendar, selected, minDate, maxDate, side) {

            var html = '<div class="calendar-date">';
            html += '<table class="table-condensed">';
            html += '<thead>';
            html += '<tr>';

            // add empty cell for week number
            if(this.showWeekNumbers)
                html += '<th></th>';

            if(!minDate || minDate.isBefore(calendar.firstDay)) {
                html +=
                    '<th class="prev available"><i class="left arrow icon"></i></th>';
            } else {
                html += '<th></th>';
            }

            //VC
            //date Html is a header section which shows month and year
            //ex. พฤศจิกายน 2016 (in case no dropdown option)
            var dateHtml = this.locale.monthNames[calendar[1][1].month()] +
                calendar[1][1].format(" YYYY");
            
            if(this.showDropdowns) {
                dateHtml = this.renderDropdowns(calendar[1][1], minDate,
                    maxDate);
            }

            html += '<th colspan="5" class="month">' + dateHtml +
                '</th>';
            if(!maxDate || maxDate.isAfter(calendar.lastDay)) {
                html +=
                    '<th class="next available"><i class="right arrow icon"></i></th>';
            } else {
                html += '<th></th>';
            }

            html += '</tr>';
            html += '<tr>';

            // add week number label
            if(this.showWeekNumbers)
                html += '<th class="week">' + this.locale.weekLabel +
                '</th>';

            $.each(this.locale.daysOfWeek, function (index, dayOfWeek) {
                html += '<th>' + dayOfWeek + '</th>';
            });

            html += '</tr>';
            html += '</thead>';
            html += '<tbody>';

            for(var row = 0; row < 6; row++) {
                html += '<tr>';

                // add week number
                if(this.showWeekNumbers)
                    html += '<td class="week">' + calendar[row][0].week() +
                    '</td>';

                for(var col = 0; col < 7; col++) {
                    var cname = 'available ';
                    cname += (calendar[row][col].month() == calendar[1][
                        1
                    ].month()) ? '' : 'off';

                    if((minDate && calendar[row][col].isBefore(minDate,
                            'day')) || (maxDate && calendar[row][col].isAfter(
                            maxDate, 'day'))) {
                        cname = ' off disabled ';
                    } else if(calendar[row][col].format('YYYY-MM-DD') ==
                        selected.format('YYYY-MM-DD')) {
                        cname += ' active ';
                        if(calendar[row][col].format('YYYY-MM-DD') ==
                            this.startDate.format('YYYY-MM-DD')) {
                            cname += ' start-date ';
                        }
                        if(calendar[row][col].format('YYYY-MM-DD') ==
                            this.endDate.format('YYYY-MM-DD')) {
                            cname += ' end-date ';
                        }
                    } else if(calendar[row][col] >= this.startDate &&
                        calendar[row][col] <= this.endDate) {
                        cname += ' in-range ';
                        if(calendar[row][col].isSame(this.startDate)) {
                            cname += ' start-date ';
                        }
                        if(calendar[row][col].isSame(this.endDate)) {
                            cname += ' end-date ';
                        }
                    }

                    var title = 'r' + row + 'c' + col;
                    html += '<td class="' + cname.replace(/\s+/g, ' ').replace(
                            /^\s?(.*?)\s?$/, '$1') + '" data-title="' +
                        title + '">' + calendar[row][col].date() +
                        '</td>';
                }
                html += '</tr>';
            }

            html += '</tbody>';
            html += '</table>';
            html += '</div>';

            var i;
            if(this.timePicker) {

                html += '<div class="calendar-time">';
                html += '<select class="ui compact upward selection dropdown hourselect">';

                // Disallow selections before the minDate or after the maxDate
                var min_hour = 0;
                var max_hour = 23;

                if(minDate && (side == 'left' || this.singleDatePicker) &&
                    selected.format('YYYY-MM-DD') == minDate.format(
                        'YYYY-MM-DD')) {
                    min_hour = minDate.hour();
                    if(selected.hour() < min_hour)
                        selected.hour(min_hour);
                    if(this.timePicker12Hour && min_hour >= 12 &&
                        selected.hour() >= 12)
                        min_hour -= 12;
                    if(this.timePicker12Hour && min_hour == 12)
                        min_hour = 1;
                }

                if(maxDate && (side == 'right' || this.singleDatePicker) &&
                    selected.format('YYYY-MM-DD') == maxDate.format(
                        'YYYY-MM-DD')) {
                    max_hour = maxDate.hour();
                    if(selected.hour() > max_hour)
                        selected.hour(max_hour);
                    if(this.timePicker12Hour && max_hour >= 12 &&
                        selected.hour() >= 12)
                        max_hour -= 12;
                }

                var start = 0;
                var end = 23;
                var selected_hour = selected.hour();
                if(this.timePicker12Hour) {
                    start = 1;
                    end = 12;
                    if(selected_hour >= 12)
                        selected_hour -= 12;
                    if(selected_hour === 0)
                        selected_hour = 12;
                }

                for(i = start; i <= end; i++) {

                    if(i == selected_hour) {
                        html += '<option value="' + i +
                            '" selected="selected">' + i + '</option>';
                    } else if(i < min_hour || i > max_hour) {
                        html += '<option value="' + i +
                            '" disabled="disabled" class="disabled">' +
                            i + '</option>';
                    } else {
                        html += '<option value="' + i + '">' + i +
                            '</option>';
                    }
                }

                html += '</select> : ';

                html += '<select class="ui compact upward selection dropdown minuteselect">';

                // Disallow selections before the minDate or after the maxDate
                var min_minute = 0;
                var max_minute = 59;

                if(minDate && (side == 'left' || this.singleDatePicker) &&
                    selected.format('YYYY-MM-DD h A') == minDate.format(
                        'YYYY-MM-DD h A')) {
                    min_minute = minDate.minute();
                    if(selected.minute() < min_minute)
                        selected.minute(min_minute);
                }

                if(maxDate && (side == 'right' || this.singleDatePicker) &&
                    selected.format('YYYY-MM-DD h A') == maxDate.format(
                        'YYYY-MM-DD h A')) {
                    max_minute = maxDate.minute();
                    if(selected.minute() > max_minute)
                        selected.minute(max_minute);
                }

                for(i = 0; i < 60; i += this.timePickerIncrement) {
                    var num = i;
                    if(num < 10)
                        num = '0' + num;
                    if(i == selected.minute()) {
                        html += '<option value="' + i +
                            '" selected="selected">' + num + '</option>';
                    } else if(i < min_minute || i > max_minute) {
                        html += '<option value="' + i +
                            '" disabled="disabled" class="disabled">' +
                            num + '</option>';
                    } else {
                        html += '<option value="' + i + '">' + num +
                            '</option>';
                    }
                }

                html += '</select> ';

                if(this.timePickerSeconds) {
                    html += ': <select class="ui compact upward selection dropdown secondselect">';

                    for(i = 0; i < 60; i += this.timePickerIncrement) {
                        var numbr = i;
                        if(numbr < 10)
                            numbr = '0' + numbr;
                        if(i == selected.second()) {
                            html += '<option value="' + i +
                                '" selected="selected">' + numbr +
                                '</option>';
                        } else {
                            html += '<option value="' + i + '">' + numbr +
                                '</option>';
                        }
                    }

                    html += '</select>';
                }

                if(this.timePicker12Hour) {
                    html += '<select class="ui compact upward selection dropdown ampmselect">';

                    // Disallow selection before the minDate or after the maxDate
                    var am_html = '';
                    var pm_html = '';

                    if(minDate && (side == 'left' || this.singleDatePicker) &&
                        selected.format('YYYY-MM-DD') == minDate.format(
                            'YYYY-MM-DD') && minDate.hour() >= 12) {
                        am_html =
                            ' disabled="disabled" class="disabled"';
                    }

                    if(maxDate && (side == 'right' || this.singleDatePicker) &&
                        selected.format('YYYY-MM-DD') == maxDate.format(
                            'YYYY-MM-DD') && maxDate.hour() < 12) {
                        pm_html =
                            ' disabled="disabled" class="disabled"';
                    }

                    if(selected.hour() >= 12) {
                        html += '<option value="AM"' + am_html +
                            '>AM</option><option value="PM" selected="selected"' +
                            pm_html + '>PM</option>';
                    } else {
                        html += '<option value="AM" selected="selected"' +
                            am_html + '>AM</option><option value="PM"' +
                            pm_html + '>PM</option>';
                    }
                    html += '</select>';
                }

                html += '</div>';

            }

            return html;

        },

        remove: function () {

            this.container.remove();
            this.element.off('.daterangepicker');
            this.element.removeData('daterangepicker');

        },

        updateDateText: function(){
            this.updateFromControl();
        }

    };

    $.fn.daterangepicker = function (options, cb, valid, inValid) {
        this.each(function () {
            var el = $(this);
            if(el.data('daterangepicker'))
                el.data('daterangepicker').remove();
            el.data('daterangepicker', new DateRangePicker(el,
                options, cb, valid, inValid));
        });
        return this;
    };

}));

/**
 * @version: 1.3.21
 * @author: Dan Grossman http://www.dangrossman.info/
 * @copyright: Copyright (c) 2012-2015 Dan Grossman. All rights reserved.
 * @license: Licensed under the MIT license. See http://www.opensource.org/licenses/mit-license.php
 * @website: https://www.improvely.com/
 */

(function (root, factory) {

    if(typeof define === 'function' && define.amd) {
        define(['moment', 'jquery', 'exports'], function (momentjs, $, exports) {
            root.vccalendar = factory(root, exports, momentjs, $);
        });

    } else if(typeof exports !== 'undefined') {
        var momentjs = require('moment');
        var jQuery;
        try {
            jQuery = require('jquery');
        } catch(err) {
            jQuery = window.jQuery;
            if(!jQuery) throw new Error('jQuery dependency not found');
        }

        factory(root, exports, momentjs, jQuery);

        // Finally, as a browser global.
    } else {
        root.vccalendar = factory(root, {}, root.moment, (root.jQuery || root.Zepto ||
            root.ender || root.$));
    }

}(this, function (root, vccalendar, moment, $) {

    var Calendar = function (element, options, cb) {

        //element that triggered the date range picker
        this.element = $(element);

        //tracks visible state
        this.isShowing = false;

        //custom options
        if(typeof options !== 'object' || options === null)
            options = {};

        this.container = $(element);

        this.setOptions(options, cb);

        //event listeners
        this.container.find('.calendar')
            .on('click.vccalendar', '.prev', $.proxy(this.clickPrev,
                this))
            .on('click.vccalendar', '.next', $.proxy(this.clickNext,
                this))
            .on('click.vccalendar', 'td.available', $.proxy(this.clickDate,
                this))
            .on('change.vccalendar', 'select.yearselect', $.proxy(this.updateMonthYear,
                this))
            .on('change.vccalendar', 'select.monthselect', $.proxy(this
                .updateMonthYear, this));

        this.container.find('.ranges')
            .on('click.vccalendar', 'li', $.proxy(this.clickRange, this));

        this.show();
    };

    Calendar.prototype = {

        constructor: Calendar,

        setOptions: function (options, callback) {

            this.startDate = moment().startOf('day');
            this.endDate = moment().endOf('day');
            this.timeZone = moment().utcOffset();
            this.minDate = false;
            this.maxDate = false;
            this.dateLimit = false;
            this.multipleSelect = false;
            this.dateSelectedArr = [];

            this.showDropdowns = true;
            this.showWeekNumbers = false;
            this.timePicker = false;
            this.timePickerSeconds = false;
            this.timePickerIncrement = 30;
            this.timePicker12Hour = true;
            this.singleDatePicker = false;
            this.ranges = {};

            this.buttonClasses = ['ui', 'compact', 'small', 'button'];
            this.applyClass = 'primary';
            this.cancelClass = 'secondary';

            this.format = 'DD/MM/YYYY';
            this.separator = ' - ';

            this.locale = {
                applyLabel: 'Apply',
                cancelLabel: 'Cancel',
                fromLabel: 'From',
                toLabel: 'To',
                weekLabel: 'W',
                customRangeLabel: 'Custom Range',
                daysOfWeek: moment.weekdaysMin(),
                monthNames: moment.monthsShort(),
                firstDay: moment.localeData()._week.dow
            };

            this.cb = function () {};

            if(typeof options.format === 'string')
                this.format = options.format;

            if(typeof options.separator === 'string')
                this.separator = options.separator;

            if (typeof options.multipleSelect === 'boolean')
                this.multipleSelect = options.multipleSelect;

            if(typeof options.startDate === 'string')
                this.startDate = moment(options.startDate, this.format);

            if(typeof options.endDate === 'string')
                this.endDate = moment(options.endDate, this.format);

            if(typeof options.minDate === 'string')
                this.minDate = moment(options.minDate, this.format);

            if(typeof options.maxDate === 'string')
                this.maxDate = moment(options.maxDate, this.format);

            if(typeof options.startDate === 'object')
                this.startDate = moment(options.startDate);

            if(typeof options.endDate === 'object')
                this.endDate = moment(options.endDate);

            if(typeof options.minDate === 'object')
                this.minDate = moment(options.minDate);

            if(typeof options.maxDate === 'object')
                this.maxDate = moment(options.maxDate);

            if(typeof options.applyClass === 'string')
                this.applyClass = options.applyClass;

            if(typeof options.cancelClass === 'string')
                this.cancelClass = options.cancelClass;

            if(typeof options.dateLimit === 'object')
                this.dateLimit = options.dateLimit;

            if(typeof options.locale === 'object') {

                if(typeof options.locale.daysOfWeek === 'object') {
                    // Create a copy of daysOfWeek to avoid modification of original
                    // options object for reusability in multiple vccalendar instances
                    this.locale.daysOfWeek = options.locale.daysOfWeek.slice();
                }

                if(typeof options.locale.monthNames === 'object') {
                    this.locale.monthNames = options.locale.monthNames.slice();
                }

                if(typeof options.locale.firstDay === 'number') {
                    this.locale.firstDay = options.locale.firstDay;
                }

                if(typeof options.locale.applyLabel === 'string') {
                    this.locale.applyLabel = options.locale.applyLabel;
                }

                if(typeof options.locale.cancelLabel === 'string') {
                    this.locale.cancelLabel = options.locale.cancelLabel;
                }

                if(typeof options.locale.fromLabel === 'string') {
                    this.locale.fromLabel = options.locale.fromLabel;
                }

                if(typeof options.locale.toLabel === 'string') {
                    this.locale.toLabel = options.locale.toLabel;
                }

                if(typeof options.locale.weekLabel === 'string') {
                    this.locale.weekLabel = options.locale.weekLabel;
                }

                if(typeof options.locale.customRangeLabel === 'string') {
                    this.locale.customRangeLabel = options.locale.customRangeLabel;
                }
            }

            if(typeof options.showWeekNumbers === 'boolean') {
                this.showWeekNumbers = options.showWeekNumbers;
            }

            if(typeof options.buttonClasses === 'string') {
                this.buttonClasses = [options.buttonClasses];
            }

            if(typeof options.buttonClasses === 'object') {
                this.buttonClasses = options.buttonClasses;
            }

            if(typeof options.showDropdowns === 'boolean') {
                this.showDropdowns = options.showDropdowns;
            }

            if(typeof options.singleDatePicker === 'boolean') {
                this.singleDatePicker = options.singleDatePicker;
                if(this.singleDatePicker) {
                    this.endDate = this.startDate.clone();
                }
            }

            // update day names order to firstDay
            if(this.locale.firstDay !== 0) {
                var iterator = this.locale.firstDay;
                while(iterator > 0) {
                    this.locale.daysOfWeek.push(this.locale.daysOfWeek.shift());
                    iterator--;
                }
            }

            var start, end, range;

            // bind the time zone used to build the calendar to either the
            // timeZone passed in through the options or the zone of the
            // startDate (which will be the local time zone by default)
            if(typeof options.timeZone === 'string' || typeof options.timeZone ===
                'number') {
                if(typeof options.timeZone === 'string' && typeof moment
                    .tz !== 'undefined') {
                    this.timeZone = moment.tz.zone(options.timeZone).parse(
                        new Date()) * -1; // Offset is positive if the timezone is behind UTC and negative if it is ahead.
                } else {
                    this.timeZone = options.timeZone;
                }
                this.startDate.utcOffset(this.timeZone);
                this.endDate.utcOffset(this.timeZone);
            } else {
                this.timeZone = moment(this.startDate).utcOffset();
            }

            if(typeof options.ranges === 'object') {
                for(range in options.ranges) {

                    if(typeof options.ranges[range][0] === 'string')
                        start = moment(options.ranges[range][0], this.format);
                    else
                        start = moment(options.ranges[range][0]);

                    if(typeof options.ranges[range][1] === 'string')
                        end = moment(options.ranges[range][1], this.format);
                    else
                        end = moment(options.ranges[range][1]);

                    // If we have a min/max date set, bound this range
                    // to it, but only if it would otherwise fall
                    // outside of the min/max.
                    if(this.minDate && start.isBefore(this.minDate))
                        start = moment(this.minDate);

                    if(this.maxDate && end.isAfter(this.maxDate))
                        end = moment(this.maxDate);

                    // If the end of the range is before the minimum (if min is set) OR
                    // the start of the range is after the max (also if set) don't display this
                    // range option.
                    if((this.minDate && end.isBefore(this.minDate)) || (
                            this.maxDate && start.isAfter(this.maxDate))) {
                        continue;
                    }

                    this.ranges[range] = [start, end];
                }

                var list = '<ul>';
                for(range in this.ranges) {
                    list += '<li>' + range + '</li>';
                }
                list += '</ul>';

                if(!this.multipleSelect){
                    this.container.find('.ranges ul').remove();
                    this.container.find('.ranges').prepend(list);
                }
            }

            if(typeof callback === 'function') {
                this.cb = callback;
            }

            if(!this.timePicker) {
                this.startDate = this.startDate.startOf('day');
                this.endDate = this.endDate.endOf('day');
            }

            if(this.singleDatePicker) {
                this.opens = 'left';
                this.container.addClass('single');
                this.container.find('.calendar.left').show();
                this.container.find('.ranges').show();
            }

            this.oldStartDate = this.startDate.clone();
            this.oldEndDate = this.endDate.clone();
            this.oldChosenLabel = this.chosenLabel;

            this.leftCalendar = {
                month: moment([this.startDate.year(), this.startDate
                    .month(), 1, this.startDate.hour(), this
                    .startDate.minute(), this.startDate.second()
                ]),
                calendar: []
            };

            if(this.opens == 'right' || this.opens == 'center') {
                //swap calendar positions
                var first = this.container.find('.calendar.first');
                var second = this.container.find('.calendar.second');

                if(second.hasClass('single')) {
                    second.removeClass('single');
                    first.addClass('single');
                }

                first.removeClass('left').addClass('right');
                second.removeClass('right').addClass('left');

                if(this.singleDatePicker) {
                    first.show();
                    second.hide();
                }
            }

            if(typeof options.ranges === 'undefined' && !this.singleDatePicker) {
                this.container.addClass('show-calendar');
            }

            this.container.removeClass('opensleft opensright').addClass(
                'opens' + this.opens);

            this.updateView();

            if(this.multipleSelect)
                this.updateMultipleSelectCalendars();
            else
                this.updateCalendars();

            //apply CSS classes and labels to buttons
            var c = this.container;
            $.each(this.buttonClasses, function (idx, val) {
                c.find('button').addClass(val);
            });
        },

        setStartDate: function (startDate) {
            if(typeof startDate === 'string')
                this.startDate = moment(startDate, this.format).utcOffset(
                    this.timeZone);

            if(typeof startDate === 'object')
                this.startDate = moment(startDate);

            if(!this.timePicker)
                this.startDate = this.startDate.startOf('day');

            this.oldStartDate = this.startDate.clone();

            this.updateView();
            this.updateCalendars();
            this.updateInputText();
        },

        setEndDate: function (endDate) {
            if(typeof endDate === 'string')
                this.endDate = moment(endDate, this.format).utcOffset(
                    this.timeZone);

            if(typeof endDate === 'object')
                this.endDate = moment(endDate);

            if(!this.timePicker)
                this.endDate = this.endDate.endOf('day');

            this.oldEndDate = this.endDate.clone();

            this.updateView();
            this.updateCalendars();
            this.updateInputText();
        },

        updateView: function () {
            this.leftCalendar.month.month(this.startDate.month()).year(
                this.startDate.year()).hour(this.startDate.hour()).minute(
                this.startDate.minute());
        },

        notify: function () {
            this.updateView();
            this.cb(this.startDate, this.endDate, this.chosenLabel);
        },

        show: function (e) {
            if(this.isShowing) return;

            this.container.show();
            this.isShowing = true;
        },

        showCalendars: function () {
            this.container.addClass('show-calendar');
        },

        pad: function (n, width, z) {
            z = z || '0';
            n = n + '';
            return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
        },

        getDate(){
            if (this.multipleSelect){
                console.error("Calendar is not in single selection mode!");
                return;
            }

            var year  = this.startDate.year() + 543,
                month = this.startDate.month() + 1,
                day   = this.startDate.date();

            return this.pad(day, 2) + "/" + this.pad(month, 2) + "/" + year;
        },

        getDates(){
            if (!this.multipleSelect){
                console.error("Calendar is not in multiple selection mode!");
                return;
            }

            var dates = this.dateSelectedArr.map(function(date){
                var year = date.year() + 543,
                    month = date.month() + 1,
                    day = date.date();

                return this.pad(day, 2) + "/" + this.pad(month, 2) + "/" + year;
            }, this);

            return dates;
        },
        
        setDate(thaiDate){
            if(!thaiDate || typeof thaiDate !== "string"){
                console.error("Parameter is not an string type");
                return;
            }

            if (this.multipleSelect){
                console.error("Calendar is not in single selection mode!");
                return;
            }

            var isValid = true;
            var date = thaiDate.split('/');
            var day = parseInt(date[0]);
            var month = parseInt(date[1]);
            var year = parseInt(date[2]);

            //validate input
            if (Number.isInteger(day) && Number.isInteger(month)
                && Number.isInteger(year)) {
                if (("" + day).length > 2) isValid = false;
                if (("" + month).length > 2) isValid = false;
                if (("" + year).length > 4) isValid = false;
                if (year < 2483 || year < 543) isValid = false;
            }
            else {
                isValid = false;
            }

            year = Math.max(year - 543, 0);
            date = day + "/" + month + "/" + year;
            date = moment(date, "DD/MM/YYYY");

            if (!date.isValid())
                isValid = false;

            if (!isValid) {
                console.error("Date is not valid!");
                return;
            }

            this.bySystem = true;
            this.setStartDate(date);
            this.setEndDate(date);
            this.bySystem = false;
        },

        setDates(thaiDates){
            if (!thaiDates || !(thaiDates instanceof Array) ){
                console.error("Parameter is not an array type");
                return;
            }

            if (!this.multipleSelect){
                console.error("Calendar is not in multiple selection mode!");
                return;
            }

            this.dateSelectedArr = [];
            thaiDates.forEach( function(th){
                var isValid = true;
                var date = th.split('/');
                var day = parseInt(date[0]);
                var month = parseInt(date[1]);
                var year = parseInt(date[2]);

                //validate input
                if (Number.isInteger(day) && Number.isInteger(month) 
                    && Number.isInteger(year)) {
                    if (("" + day).length > 2) isValid = false;
                    if (("" + month).length > 2) isValid = false;
                    if (("" + year).length > 4) isValid = false;
                    if (year < 2483 || year < 543) isValid = false;
                }
                else {
                    isValid = false;
                }

                year = Math.max(year - 543, 0);
                date = day + "/" + month + "/" + year;
                date = moment(date, "DD/MM/YYYY");

                if (!date.isValid())
                    isValid = false;

                if (!isValid) {
                    console.error("Date is not valid!");
                    return;
                }

                this.dateSelectedArr.push(date);
            }, this);

            this.updateMultipleSelectCalendars();
        },

        updateInputText: function () {
            if (this.bySystem) return;
            this.element.trigger('selectDate', this.getDate());
        },

        updateInputTextMultipleSelect: function () {
            this.element.trigger('selectDates', [this.getDates()]);
        },

        clickRange: function (e) {
            var label = e.target.innerHTML;
            this.chosenLabel = label;
            var dates = this.ranges[label];

            this.startDate = dates[0];
            this.endDate = dates[1];

            if(!this.timePicker) {
                this.startDate.startOf('day');
                this.endDate.endOf('day');
            }

            this.leftCalendar.month.month(this.startDate.month()).year(
                    this.startDate.year()).hour(this.startDate.hour())
                .minute(this.startDate.minute());
            this.updateCalendars();
            this.updateInputText();

        },

        clickPrev: function (e) {
            var cal = $(e.target).parents('.calendar');
            this.leftCalendar.month.subtract(1, 'month');
            if(this.multipleSelect)
                this.updateMultipleSelectCalendars();
            else
                this.updateCalendars();
        },

        clickNext: function (e) {
            var cal = $(e.target).parents('.calendar');
            this.leftCalendar.month.add(1, 'month');
            if(this.multipleSelect)
                this.updateMultipleSelectCalendars();
            else
                this.updateCalendars();
        },

        setCustomDates: function (startDate, endDate) {
            this.chosenLabel = this.locale.customRangeLabel;
            if(startDate.isAfter(endDate)) {
                var difference = this.endDate.diff(this.startDate);
                endDate = moment(startDate).add(difference, 'ms');
                if(this.maxDate && endDate.isAfter(this.maxDate)) {
                    endDate = this.maxDate.clone();
                }
            }
            this.startDate = startDate;
            this.endDate = endDate;

            this.updateView();
            this.updateCalendars();
        },

        setCustomMultipleDates: function (startDate) {
            this.chosenLabel = this.locale.customRangeLabel;
            this.startDate = startDate;
            this.endDate = startDate;

            this.updateView();
            this.updateMultipleSelectCalendars();
        },

        clickDate: function (e) {
            if(this.multipleSelect){
                var title = $(e.target).attr('data-title');
                var row = title.substr(1, 1);
                var col = title.substr(3, 1);
                var cal = $(e.target).parents('.calendar');
                var date = this.leftCalendar.calendar[row][col];
                var notDuplicated = true;
                //toggle active class
                $(e.target).toggleClass("active");

                this.dateSelectedArr = this.dateSelectedArr.filter((selectedDate)=>{
                    if (selectedDate.isSame(date))
                        return (notDuplicated = false);
                    else
                        return true;
                });

                if (notDuplicated){
                    this.dateSelectedArr.push(date);
                    this.setCustomMultipleDates(date);
                }

                this.updateMultipleSelectCalendars();
                this.updateInputTextMultipleSelect();
            }
            else{
                var title = $(e.target).attr('data-title');
                var row = title.substr(1, 1);
                var col = title.substr(3, 1);
                var cal = $(e.target).parents('.calendar');

                var startDate, endDate;
                startDate = this.leftCalendar.calendar[row][col];
                endDate = this.endDate;
                if(typeof this.dateLimit === 'object') {
                    var maxDate = moment(startDate).add(this.dateLimit).startOf(
                        'day');
                    if(endDate.isAfter(maxDate)) {
                        endDate = maxDate;
                    }
                }

                if(this.singleDatePicker && cal.hasClass('left')) {
                    endDate = startDate.clone();
                }

                cal.find('td').removeClass('active');

                $(e.target).addClass('active');

                this.setCustomDates(startDate, endDate);

                if(!this.timePicker)
                    endDate.endOf('day');

                if(this.singleDatePicker && !this.timePicker)
                    this.updateInputText();
            }
        },

        updateMonthYear: function (e) {
            var isLeft = $(e.target).closest('.calendar').hasClass(
                    'left'),
                leftOrRight = isLeft ? 'left' : 'right',
                cal = this.container.find('.calendar.' + leftOrRight);

            // Month must be Number for new moment versions
            var month = parseInt(cal.find('.monthselect').val(), 10);
            var year = cal.find('.yearselect').val();

            if(!isLeft && !this.singleDatePicker) {
                if(year < this.startDate.year() || (year == this.startDate
                        .year() && month < this.startDate.month())) {
                    month = this.startDate.month();
                    year = this.startDate.year();
                }
            }

            if(this.minDate) {
                if(year < this.minDate.year() || (year == this.minDate.year() &&
                        month < this.minDate.month())) {
                    month = this.minDate.month();
                    year = this.minDate.year();
                }
            }

            if(this.maxDate) {
                if(year > this.maxDate.year() || (year == this.maxDate.year() &&
                        month > this.maxDate.month())) {
                    month = this.maxDate.month();
                    year = this.maxDate.year();
                }
            }

            this[leftOrRight + 'Calendar'].month.month(month).year(year);
            this.updateCalendars();
        },

        updateCalendars: function () {
            this.leftCalendar.calendar = this.buildCalendar(this.leftCalendar
                .month.month(), this.leftCalendar.month.year(), this
                .leftCalendar.month.hour(), this.leftCalendar.month.minute(),
                this.leftCalendar.month.second(), 'left');

            this.container.find('.calendar.left').empty().html(this.renderCalendar(
                this.leftCalendar.calendar, this.startDate, this
                .minDate, this.maxDate, 'left'));

            this.container.find('.ranges li').removeClass('active');
            var i = 0;
            for(var range in this.ranges) {
                //ignore times when comparing dates if time picker is not enabled
                if(this.startDate.format('YYYY-MM-DD') == this.ranges[
                        range][0].format('YYYY-MM-DD') && this.endDate
                    .format('YYYY-MM-DD') == this.ranges[range][1].format(
                        'YYYY-MM-DD')) {
                    customRange = false;
                    this.chosenLabel = this.container.find(
                            '.ranges li:eq(' + i + ')')
                        .addClass('active').html();
                }
                i++;
            }
            this.element.trigger('monthChange', [this.leftCalendar.calendar]);
        },

        updateMultipleSelectCalendars: function () {
            this.leftCalendar.calendar = this.buildCalendar(this.leftCalendar
                .month.month(), this.leftCalendar.month.year(), this
                .leftCalendar.month.hour(), this.leftCalendar.month.minute(),
                this.leftCalendar.month.second(), 'left');

            this.container.find('.calendar.left').empty().html(this.renderMultipleSelectCalendar(
                this.leftCalendar.calendar, this.dateSelectedArr, this
                .minDate, this.maxDate, 'left'));

            this.container.find('.ranges li').removeClass('active');
            var i = 0;
            for(var range in this.ranges) {
                //ignore times when comparing dates if time picker is not enabled
                if(this.startDate.format('YYYY-MM-DD') == this.ranges[
                        range][0].format('YYYY-MM-DD') && this.endDate
                    .format('YYYY-MM-DD') == this.ranges[range][1].format(
                        'YYYY-MM-DD')) {
                    customRange = false;
                    this.chosenLabel = this.container.find(
                            '.ranges li:eq(' + i + ')')
                        .addClass('active').html();
                }
                i++;
            }
        },

        buildCalendar: function (month, year, hour, minute, second, side) {
            var daysInMonth = moment([year, month]).daysInMonth();
            var firstDay = moment([year, month, 1]);
            var lastDay = moment([year, month, daysInMonth]);
            var lastMonth = moment(firstDay).subtract(1, 'month').month();
            var lastYear = moment(firstDay).subtract(1, 'month').year();

            var daysInLastMonth = moment([lastYear, lastMonth]).daysInMonth();

            var dayOfWeek = firstDay.day();

            var i;

            //initialize a 6 rows x 7 columns array for the calendar
            var calendar = [];
            calendar.firstDay = firstDay;
            calendar.lastDay = lastDay;

            for(i = 0; i < 6; i++) {
                calendar[i] = [];
            }

            //populate the calendar with date objects
            var startDay = daysInLastMonth - dayOfWeek + this.locale.firstDay +
                1;
            if(startDay > daysInLastMonth)
                startDay -= 7;

            if(dayOfWeek == this.locale.firstDay)
                startDay = daysInLastMonth - 6;

            var curDate = moment([lastYear, lastMonth, startDay, 12,
                minute, second
            ]).utcOffset(this.timeZone);

            var col, row;
            for(i = 0, col = 0, row = 0; i < 42; i++, col++, curDate =
                moment(curDate).add(24, 'hour')) {
                if(i > 0 && col % 7 === 0) {
                    col = 0;
                    row++;
                }
                calendar[row][col] = curDate.clone().hour(hour);
                curDate.hour(12);

                if(this.minDate && calendar[row][col].format(
                        'YYYY-MM-DD') == this.minDate.format(
                        'YYYY-MM-DD') && calendar[row][col].isBefore(
                        this.minDate) && side == 'left') {
                    calendar[row][col] = this.minDate.clone();
                }

                if(this.maxDate && calendar[row][col].format(
                        'YYYY-MM-DD') == this.maxDate.format(
                        'YYYY-MM-DD') && calendar[row][col].isAfter(this
                        .maxDate) && side == 'right') {
                    calendar[row][col] = this.maxDate.clone();
                }

            }

            return calendar;
        },

        renderDropdowns: function (selected, minDate, maxDate) {
            var currentMonth = selected.month();
            var currentYear = selected.year();
            var maxYear = (maxDate && maxDate.year()) || (currentYear +
                5);
            var minYear = (minDate && minDate.year()) || (currentYear -
                50);

            var monthHtml = '<select class="ui compact selection dropdown monthselect">';
            var inMinYear = currentYear == minYear;
            var inMaxYear = currentYear == maxYear;

            for(var m = 0; m < 12; m++) {
                if((!inMinYear || m >= minDate.month()) && (!inMaxYear ||
                        m <= maxDate.month())) {
                    monthHtml += "<option value='" + m + "'" +
                        (m === currentMonth ? " selected='selected'" :
                            "") +
                        ">" + this.locale.monthNames[m] + "</option>";
                }
            }
            monthHtml += "</select>";

            var yearHtml = '<select class="ui compact selection dropdown yearselect">';

            for(var y = minYear; y <= maxYear; y++) {
                yearHtml += '<option value="' + y + '"' +
                    (y === currentYear ? ' selected="selected"' : '');
                yearHtml += '>' + (y + 543) + '</option>';
            }

            yearHtml += '</select>';

            return monthHtml + yearHtml;
        },

        renderCalendar: function (calendar, selected, minDate, maxDate, side) {
            var html = '<div class="calendar-date">';
            html += '<table class="table-condensed">';
            html += '<thead>';
            html += '<tr>';

            // add empty cell for week number
            if(this.showWeekNumbers)
                html += '<th></th>';

            if(!minDate || minDate.isBefore(calendar.firstDay)) {
                html +=
                    '<th class="prev available"><i class="left arrow icon"></i></th>';
            } else {
                html += '<th></th>';
            }

            var dateHtml = this.locale.monthNames[calendar[1][1].month()] +
                calendar[1][1].format(" YYYY");

            if(this.showDropdowns) {
                dateHtml = this.renderDropdowns(calendar[1][1], minDate,
                    maxDate);
            }

            html += '<th colspan="5" class="month">' + dateHtml +
                '</th>';
            if(!maxDate || maxDate.isAfter(calendar.lastDay)) {
                html +=
                    '<th class="next available"><i class="right arrow icon"></i></th>';
            } else {
                html += '<th></th>';
            }

            html += '</tr>';
            html += '<tr>';

            // add week number label
            if(this.showWeekNumbers)
                html += '<th class="week">' + this.locale.weekLabel +
                '</th>';

            $.each(this.locale.daysOfWeek, function (index, dayOfWeek) {
                html += '<th>' + dayOfWeek + '</th>';
            });

            html += '</tr>';
            html += '</thead>';
            html += '<tbody>';

            for(var row = 0; row < 6; row++) {
                html += '<tr>';

                // add week number
                if(this.showWeekNumbers)
                    html += '<td class="week">' + calendar[row][0].week() +
                    '</td>';

                for(var col = 0; col < 7; col++) {
                    var cname = 'available ';
                    cname += (calendar[row][col].month() == calendar[1][
                        1
                    ].month()) ? '' : 'off';

                    if((minDate && calendar[row][col].isBefore(minDate,
                            'day')) || (maxDate && calendar[row][col].isAfter(
                            maxDate, 'day'))) {
                        cname = ' off disabled ';
                    } else if(calendar[row][col].format('YYYY-MM-DD') ==
                        selected.format('YYYY-MM-DD')) {
                        cname += ' active ';
                        if(calendar[row][col].format('YYYY-MM-DD') ==
                            this.startDate.format('YYYY-MM-DD')) {
                            cname += ' start-date ';
                        }
                        if(calendar[row][col].format('YYYY-MM-DD') ==
                            this.endDate.format('YYYY-MM-DD')) {
                            cname += ' end-date ';
                        }
                    } else if(calendar[row][col] >= this.startDate &&
                        calendar[row][col] <= this.endDate) {
                        cname += ' in-range ';
                        if(calendar[row][col].isSame(this.startDate)) {
                            cname += ' start-date ';
                        }
                        if(calendar[row][col].isSame(this.endDate)) {
                            cname += ' end-date ';
                        }
                    }

                    var title = 'r' + row + 'c' + col;
                    html += '<td class="' + cname.replace(/\s+/g, ' ').replace(
                            /^\s?(.*?)\s?$/, '$1') + '" data-title="' +
                        title + '">' + calendar[row][col].date() +
                        '</td>';
                }
                html += '</tr>';
            }

            html += '</tbody>';
            html += '</table>';
            html += '</div>';

            return html;

        },

        renderMultipleSelectCalendar: function (calendar, selectedArr, minDate, maxDate, side) {

            var html = '<div class="calendar-date">';
            html += '<table class="table-condensed">';
            html += '<thead>';
            html += '<tr>';

            // add empty cell for week number
            if(this.showWeekNumbers)
                html += '<th></th>';

            if(!minDate || minDate.isBefore(calendar.firstDay)) {
                html +=
                    '<th class="prev available"><i class="left arrow icon"></i></th>';
            } else {
                html += '<th></th>';
            }

            var dateHtml = this.locale.monthNames[calendar[1][1].month()] +
                calendar[1][1].format(" YYYY");

            if(this.showDropdowns) {
                dateHtml = this.renderDropdowns(calendar[1][1], minDate,
                    maxDate);
            }

            html += '<th colspan="5" class="month">' + dateHtml +
                '</th>';
            if(!maxDate || maxDate.isAfter(calendar.lastDay)) {
                html +=
                    '<th class="next available"><i class="right arrow icon"></i></th>';
            } else {
                html += '<th></th>';
            }

            html += '</tr>';
            html += '<tr>';

            // add week number label
            if(this.showWeekNumbers)
                html += '<th class="week">' + this.locale.weekLabel +
                '</th>';

            $.each(this.locale.daysOfWeek, function (index, dayOfWeek) {
                html += '<th>' + dayOfWeek + '</th>';
            });

            html += '</tr>';
            html += '</thead>';
            html += '<tbody>';
            
            for(var row = 0; row < 6; row++) {
                html += '<tr>';

                // add week number
                if(this.showWeekNumbers)
                    html += '<td class="week">' + calendar[row][0].week() +
                    '</td>';

                for(var col = 0; col < 7; col++) {
                    var cname = 'available ';
                    cname += (calendar[row][col].month() == calendar[1][
                        1
                    ].month()) ? '' : 'off';

                    if((minDate && calendar[row][col].isBefore(minDate,
                            'day')) || (maxDate && calendar[row][col].isAfter(
                            maxDate, 'day'))) {
                        cname = ' off disabled ';
                    }

                    var secondCondition = false;
                    //active selected date
                    for (let selectedDate of selectedArr){
                        if (calendar[row][col].format('YYYY-MM-DD') ==
                            selectedDate.format('YYYY-MM-DD')) {
                            cname += ' active ';
                            if (calendar[row][col].format('YYYY-MM-DD') ==
                                selectedDate.format('YYYY-MM-DD')) {
                                cname += ' start-date ';
                            }
                            if (calendar[row][col].format('YYYY-MM-DD') ==
                                selectedDate.format('YYYY-MM-DD')) {
                                cname += ' end-date ';
                            }
                            secondCondition = true;
                        } 
                    }

                    //hilight today
                    if (calendar[row][col].isSame(moment(), "day") && !secondCondition) {
                        cname += ' in-range ';
                        // if(calendar[row][col].isSame(this.startDate)) {
                        //     cname += ' start-date ';
                        // }
                        // if(calendar[row][col].isSame(this.endDate)) {
                        //     cname += ' end-date ';
                        // }
                    }

                    var title = 'r' + row + 'c' + col;
                    html += '<td class="' + cname.replace(/\s+/g, ' ').replace(
                            /^\s?(.*?)\s?$/, '$1') + '" data-title="' +
                        title + '">' + calendar[row][col].date() +
                        '</td>';
                }
                html += '</tr>';
            }

            html += '</tbody>';
            html += '</table>';
            html += '</div>';

            return html;

        },

        remove: function () {
            this.container.remove();
        }

    };

    $.fn.calendar = function (options, cb) {
        this.each(function () {
            var el = $(this);
            if(el.data('vccalendar'))
                el.data('vccalendar').remove();
            el.data('vccalendar', new Calendar(el,
                options, cb));
        });
        return this;
    };

    $.fn.setCalendarDates = function(dateArr){
        this.each(function () {
            var el = $(this);
            el.data('vccalendar').setDates(dateArr);
        });
        return this;
    };

    $.fn.setCalendarDate = function(date){
        this.each(function () {
            var el = $(this);
            el.data('vccalendar').setDate(date);
        });
        return this;
    };

    $.fn.getCalendarDate = function(){
        var date;
        this.each(function () {
            var el = $(this);
            date = el.data('vccalendar').getDate();
        });
        return date;
    };

    $.fn.getCalendarDates = function(){
        var dates;
        this.each(function () {
            var el = $(this);
            dates = el.data('vccalendar').getDates();
        });
        return dates;
    };

}));

/*!
 * FullCalendar v0.0.0
 * Docs & License: http://fullcalendar.io/
 * (c) 2016 Adam Shaw
 */

(function(factory) {
	if (typeof define === 'function' && define.amd) {
		define([ 'jquery', 'moment' ], factory);
	}
	else if (typeof exports === 'object') { // Node/CommonJS
		module.exports = factory(require('jquery'), require('moment'));
	}
	else {
		factory(jQuery, moment);
	}
})(function($, moment) {

;;

var FC = $.fullCalendar = {
	version: "0.0.0",
	internalApiVersion: 7
};
var fcViews = FC.views = {};


$.fn.fullCalendar = function(options) {
	var args = Array.prototype.slice.call(arguments, 1); // for a possible method call
	var res = this; // what this function will return (this jQuery object by default)

	this.each(function(i, _element) { // loop each DOM element involved
		var element = $(_element);
		var calendar = element.data('fullCalendar'); // get the existing calendar object (if any)
		var singleRes; // the returned value of this single method call

		// a method call
		if (typeof options === 'string') {
			if (calendar && $.isFunction(calendar[options])) {
				singleRes = calendar[options].apply(calendar, args);
				if (!i) {
					res = singleRes; // record the first method call result
				}
				if (options === 'destroy') { // for the destroy method, must remove Calendar object data
					element.removeData('fullCalendar');
				}
			}
		}
		// a new calendar initialization
		else if (!calendar) { // don't initialize twice
			calendar = new Calendar(element, options);
			element.data('fullCalendar', calendar);
			calendar.render();
		}
	});

	return res;
};


var complexOptions = [ // names of options that are objects whose properties should be combined
	'header',
	'footer',
	'buttonText',
	'buttonIcons',
	'themeButtonIcons'
];


// Merges an array of option objects into a single object
function mergeOptions(optionObjs) {
	return mergeProps(optionObjs, complexOptions);
}

;;

// exports
FC.intersectRanges = intersectRanges;
FC.applyAll = applyAll;
FC.debounce = debounce;
FC.isInt = isInt;
FC.htmlEscape = htmlEscape;
FC.cssToStr = cssToStr;
FC.proxy = proxy;
FC.capitaliseFirstLetter = capitaliseFirstLetter;


/* FullCalendar-specific DOM Utilities
----------------------------------------------------------------------------------------------------------------------*/


// Given the scrollbar widths of some other container, create borders/margins on rowEls in order to match the left
// and right space that was offset by the scrollbars. A 1-pixel border first, then margin beyond that.
function compensateScroll(rowEls, scrollbarWidths) {
	if (scrollbarWidths.left) {
		rowEls.css({
			'border-left-width': 1,
			'margin-left': scrollbarWidths.left - 1
		});
	}
	if (scrollbarWidths.right) {
		rowEls.css({
			'border-right-width': 1,
			'margin-right': scrollbarWidths.right - 1
		});
	}
}


// Undoes compensateScroll and restores all borders/margins
function uncompensateScroll(rowEls) {
	rowEls.css({
		'margin-left': '',
		'margin-right': '',
		'border-left-width': '',
		'border-right-width': ''
	});
}


// Make the mouse cursor express that an event is not allowed in the current area
function disableCursor() {
	$('body').addClass('fc-not-allowed');
}


// Returns the mouse cursor to its original look
function enableCursor() {
	$('body').removeClass('fc-not-allowed');
}


// Given a total available height to fill, have `els` (essentially child rows) expand to accomodate.
// By default, all elements that are shorter than the recommended height are expanded uniformly, not considering
// any other els that are already too tall. if `shouldRedistribute` is on, it considers these tall rows and 
// reduces the available height.
function distributeHeight(els, availableHeight, shouldRedistribute) {

	// *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,
	// and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.

	var minOffset1 = Math.floor(availableHeight / els.length); // for non-last element
	var minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1)); // for last element *FLOORING NOTE*
	var flexEls = []; // elements that are allowed to expand. array of DOM nodes
	var flexOffsets = []; // amount of vertical space it takes up
	var flexHeights = []; // actual css height
	var usedHeight = 0;

	undistributeHeight(els); // give all elements their natural height

	// find elements that are below the recommended height (expandable).
	// important to query for heights in a single first pass (to avoid reflow oscillation).
	els.each(function(i, el) {
		var minOffset = i === els.length - 1 ? minOffset2 : minOffset1;
		var naturalOffset = $(el).outerHeight(true);

		if (naturalOffset < minOffset) {
			flexEls.push(el);
			flexOffsets.push(naturalOffset);
			flexHeights.push($(el).height());
		}
		else {
			// this element stretches past recommended height (non-expandable). mark the space as occupied.
			usedHeight += naturalOffset;
		}
	});

	// readjust the recommended height to only consider the height available to non-maxed-out rows.
	if (shouldRedistribute) {
		availableHeight -= usedHeight;
		minOffset1 = Math.floor(availableHeight / flexEls.length);
		minOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1)); // *FLOORING NOTE*
	}

	// assign heights to all expandable elements
	$(flexEls).each(function(i, el) {
		var minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;
		var naturalOffset = flexOffsets[i];
		var naturalHeight = flexHeights[i];
		var newHeight = minOffset - (naturalOffset - naturalHeight); // subtract the margin/padding

		if (naturalOffset < minOffset) { // we check this again because redistribution might have changed things
			$(el).height(newHeight);
		}
	});
}


// Undoes distrubuteHeight, restoring all els to their natural height
function undistributeHeight(els) {
	els.height('');
}


// Given `els`, a jQuery set of <td> cells, find the cell with the largest natural width and set the widths of all the
// cells to be that width.
// PREREQUISITE: if you want a cell to take up width, it needs to have a single inner element w/ display:inline
function matchCellWidths(els) {
	var maxInnerWidth = 0;

	els.find('> *').each(function(i, innerEl) {
		var innerWidth = $(innerEl).outerWidth();
		if (innerWidth > maxInnerWidth) {
			maxInnerWidth = innerWidth;
		}
	});

	maxInnerWidth++; // sometimes not accurate of width the text needs to stay on one line. insurance

	els.width(maxInnerWidth);

	return maxInnerWidth;
}


// Given one element that resides inside another,
// Subtracts the height of the inner element from the outer element.
function subtractInnerElHeight(outerEl, innerEl) {
	var both = outerEl.add(innerEl);
	var diff;

	// effin' IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked
	both.css({
		position: 'relative', // cause a reflow, which will force fresh dimension recalculation
		left: -1 // ensure reflow in case the el was already relative. negative is less likely to cause new scroll
	});
	diff = outerEl.outerHeight() - innerEl.outerHeight(); // grab the dimensions
	both.css({ position: '', left: '' }); // undo hack

	return diff;
}


/* Element Geom Utilities
----------------------------------------------------------------------------------------------------------------------*/

FC.getOuterRect = getOuterRect;
FC.getClientRect = getClientRect;
FC.getContentRect = getContentRect;
FC.getScrollbarWidths = getScrollbarWidths;


// borrowed from https://github.com/jquery/jquery-ui/blob/1.11.0/ui/core.js#L51
function getScrollParent(el) {
	var position = el.css('position'),
		scrollParent = el.parents().filter(function() {
			var parent = $(this);
			return (/(auto|scroll)/).test(
				parent.css('overflow') + parent.css('overflow-y') + parent.css('overflow-x')
			);
		}).eq(0);

	return position === 'fixed' || !scrollParent.length ? $(el[0].ownerDocument || document) : scrollParent;
}


// Queries the outer bounding area of a jQuery element.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
function getOuterRect(el, origin) {
	var offset = el.offset();
	var left = offset.left - (origin ? origin.left : 0);
	var top = offset.top - (origin ? origin.top : 0);

	return {
		left: left,
		right: left + el.outerWidth(),
		top: top,
		bottom: top + el.outerHeight()
	};
}


// Queries the area within the margin/border/scrollbars of a jQuery element. Does not go within the padding.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.
function getClientRect(el, origin) {
	var offset = el.offset();
	var scrollbarWidths = getScrollbarWidths(el);
	var left = offset.left + getCssFloat(el, 'border-left-width') + scrollbarWidths.left - (origin ? origin.left : 0);
	var top = offset.top + getCssFloat(el, 'border-top-width') + scrollbarWidths.top - (origin ? origin.top : 0);

	return {
		left: left,
		right: left + el[0].clientWidth, // clientWidth includes padding but NOT scrollbars
		top: top,
		bottom: top + el[0].clientHeight // clientHeight includes padding but NOT scrollbars
	};
}


// Queries the area within the margin/border/padding of a jQuery element. Assumed not to have scrollbars.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
function getContentRect(el, origin) {
	var offset = el.offset(); // just outside of border, margin not included
	var left = offset.left + getCssFloat(el, 'border-left-width') + getCssFloat(el, 'padding-left') -
		(origin ? origin.left : 0);
	var top = offset.top + getCssFloat(el, 'border-top-width') + getCssFloat(el, 'padding-top') -
		(origin ? origin.top : 0);

	return {
		left: left,
		right: left + el.width(),
		top: top,
		bottom: top + el.height()
	};
}


// Returns the computed left/right/top/bottom scrollbar widths for the given jQuery element.
// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.
function getScrollbarWidths(el) {
	var leftRightWidth = el.innerWidth() - el[0].clientWidth; // the paddings cancel out, leaving the scrollbars
	var widths = {
		left: 0,
		right: 0,
		top: 0,
		bottom: el.innerHeight() - el[0].clientHeight // the paddings cancel out, leaving the bottom scrollbar
	};

	if (getIsLeftRtlScrollbars() && el.css('direction') == 'rtl') { // is the scrollbar on the left side?
		widths.left = leftRightWidth;
	}
	else {
		widths.right = leftRightWidth;
	}

	return widths;
}


// Logic for determining if, when the element is right-to-left, the scrollbar appears on the left side

var _isLeftRtlScrollbars = null;

function getIsLeftRtlScrollbars() { // responsible for caching the computation
	if (_isLeftRtlScrollbars === null) {
		_isLeftRtlScrollbars = computeIsLeftRtlScrollbars();
	}
	return _isLeftRtlScrollbars;
}

function computeIsLeftRtlScrollbars() { // creates an offscreen test element, then removes it
	var el = $('<div><div/></div>')
		.css({
			position: 'absolute',
			top: -1000,
			left: 0,
			border: 0,
			padding: 0,
			overflow: 'scroll',
			direction: 'rtl'
		})
		.appendTo('body');
	var innerEl = el.children();
	var res = innerEl.offset().left > el.offset().left; // is the inner div shifted to accommodate a left scrollbar?
	el.remove();
	return res;
}


// Retrieves a jQuery element's computed CSS value as a floating-point number.
// If the queried value is non-numeric (ex: IE can return "medium" for border width), will just return zero.
function getCssFloat(el, prop) {
	return parseFloat(el.css(prop)) || 0;
}


/* Mouse / Touch Utilities
----------------------------------------------------------------------------------------------------------------------*/

FC.preventDefault = preventDefault;


// Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)
function isPrimaryMouseButton(ev) {
	return ev.which == 1 && !ev.ctrlKey;
}


function getEvX(ev) {
	if (ev.pageX !== undefined) {
		return ev.pageX;
	}
	var touches = ev.originalEvent.touches;
	if (touches) {
		return touches[0].pageX;
	}
}


function getEvY(ev) {
	if (ev.pageY !== undefined) {
		return ev.pageY;
	}
	var touches = ev.originalEvent.touches;
	if (touches) {
		return touches[0].pageY;
	}
}


function getEvIsTouch(ev) {
	return /^touch/.test(ev.type);
}


function preventSelection(el) {
	el.addClass('fc-unselectable')
		.on('selectstart', preventDefault);
}


// Stops a mouse/touch event from doing it's native browser action
function preventDefault(ev) {
	ev.preventDefault();
}


// attach a handler to get called when ANY scroll action happens on the page.
// this was impossible to do with normal on/off because 'scroll' doesn't bubble.
// http://stackoverflow.com/a/32954565/96342
// returns `true` on success.
function bindAnyScroll(handler) {
	if (window.addEventListener) {
		window.addEventListener('scroll', handler, true); // useCapture=true
		return true;
	}
	return false;
}


// undoes bindAnyScroll. must pass in the original function.
// returns `true` on success.
function unbindAnyScroll(handler) {
	if (window.removeEventListener) {
		window.removeEventListener('scroll', handler, true); // useCapture=true
		return true;
	}
	return false;
}


/* General Geometry Utils
----------------------------------------------------------------------------------------------------------------------*/

FC.intersectRects = intersectRects;

// Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false
function intersectRects(rect1, rect2) {
	var res = {
		left: Math.max(rect1.left, rect2.left),
		right: Math.min(rect1.right, rect2.right),
		top: Math.max(rect1.top, rect2.top),
		bottom: Math.min(rect1.bottom, rect2.bottom)
	};

	if (res.left < res.right && res.top < res.bottom) {
		return res;
	}
	return false;
}


// Returns a new point that will have been moved to reside within the given rectangle
function constrainPoint(point, rect) {
	return {
		left: Math.min(Math.max(point.left, rect.left), rect.right),
		top: Math.min(Math.max(point.top, rect.top), rect.bottom)
	};
}


// Returns a point that is the center of the given rectangle
function getRectCenter(rect) {
	return {
		left: (rect.left + rect.right) / 2,
		top: (rect.top + rect.bottom) / 2
	};
}


// Subtracts point2's coordinates from point1's coordinates, returning a delta
function diffPoints(point1, point2) {
	return {
		left: point1.left - point2.left,
		top: point1.top - point2.top
	};
}


/* Object Ordering by Field
----------------------------------------------------------------------------------------------------------------------*/

FC.parseFieldSpecs = parseFieldSpecs;
FC.compareByFieldSpecs = compareByFieldSpecs;
FC.compareByFieldSpec = compareByFieldSpec;
FC.flexibleCompare = flexibleCompare;


function parseFieldSpecs(input) {
	var specs = [];
	var tokens = [];
	var i, token;

	if (typeof input === 'string') {
		tokens = input.split(/\s*,\s*/);
	}
	else if (typeof input === 'function') {
		tokens = [ input ];
	}
	else if ($.isArray(input)) {
		tokens = input;
	}

	for (i = 0; i < tokens.length; i++) {
		token = tokens[i];

		if (typeof token === 'string') {
			specs.push(
				token.charAt(0) == '-' ?
					{ field: token.substring(1), order: -1 } :
					{ field: token, order: 1 }
			);
		}
		else if (typeof token === 'function') {
			specs.push({ func: token });
		}
	}

	return specs;
}


function compareByFieldSpecs(obj1, obj2, fieldSpecs) {
	var i;
	var cmp;

	for (i = 0; i < fieldSpecs.length; i++) {
		cmp = compareByFieldSpec(obj1, obj2, fieldSpecs[i]);
		if (cmp) {
			return cmp;
		}
	}

	return 0;
}


function compareByFieldSpec(obj1, obj2, fieldSpec) {
	if (fieldSpec.func) {
		return fieldSpec.func(obj1, obj2);
	}
	return flexibleCompare(obj1[fieldSpec.field], obj2[fieldSpec.field]) *
		(fieldSpec.order || 1);
}


function flexibleCompare(a, b) {
	if (!a && !b) {
		return 0;
	}
	if (b == null) {
		return -1;
	}
	if (a == null) {
		return 1;
	}
	if ($.type(a) === 'string' || $.type(b) === 'string') {
		return String(a).localeCompare(String(b));
	}
	return a - b;
}


/* FullCalendar-specific Misc Utilities
----------------------------------------------------------------------------------------------------------------------*/


// Computes the intersection of the two ranges. Will return fresh date clones in a range.
// Returns undefined if no intersection.
// Expects all dates to be normalized to the same timezone beforehand.
// TODO: move to date section?
function intersectRanges(subjectRange, constraintRange) {
	var subjectStart = subjectRange.start;
	var subjectEnd = subjectRange.end;
	var constraintStart = constraintRange.start;
	var constraintEnd = constraintRange.end;
	var segStart, segEnd;
	var isStart, isEnd;

	if (subjectEnd > constraintStart && subjectStart < constraintEnd) { // in bounds at all?

		if (subjectStart >= constraintStart) {
			segStart = subjectStart.clone();
			isStart = true;
		}
		else {
			segStart = constraintStart.clone();
			isStart =  false;
		}

		if (subjectEnd <= constraintEnd) {
			segEnd = subjectEnd.clone();
			isEnd = true;
		}
		else {
			segEnd = constraintEnd.clone();
			isEnd = false;
		}

		return {
			start: segStart,
			end: segEnd,
			isStart: isStart,
			isEnd: isEnd
		};
	}
}


/* Date Utilities
----------------------------------------------------------------------------------------------------------------------*/

FC.computeIntervalUnit = computeIntervalUnit;
FC.divideRangeByDuration = divideRangeByDuration;
FC.divideDurationByDuration = divideDurationByDuration;
FC.multiplyDuration = multiplyDuration;
FC.durationHasTime = durationHasTime;

var dayIDs = [ 'sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat' ];
var intervalUnits = [ 'year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond' ];


// Diffs the two moments into a Duration where full-days are recorded first, then the remaining time.
// Moments will have their timezones normalized.
function diffDayTime(a, b) {
	return moment.duration({
		days: a.clone().stripTime().diff(b.clone().stripTime(), 'days'),
		ms: a.time() - b.time() // time-of-day from day start. disregards timezone
	});
}


// Diffs the two moments via their start-of-day (regardless of timezone). Produces whole-day durations.
function diffDay(a, b) {
	return moment.duration({
		days: a.clone().stripTime().diff(b.clone().stripTime(), 'days')
	});
}


// Diffs two moments, producing a duration, made of a whole-unit-increment of the given unit. Uses rounding.
function diffByUnit(a, b, unit) {
	return moment.duration(
		Math.round(a.diff(b, unit, true)), // returnFloat=true
		unit
	);
}


// Computes the unit name of the largest whole-unit period of time.
// For example, 48 hours will be "days" whereas 49 hours will be "hours".
// Accepts start/end, a range object, or an original duration object.
function computeIntervalUnit(start, end) {
	var i, unit;
	var val;

	for (i = 0; i < intervalUnits.length; i++) {
		unit = intervalUnits[i];
		val = computeRangeAs(unit, start, end);

		if (val >= 1 && isInt(val)) {
			break;
		}
	}

	return unit; // will be "milliseconds" if nothing else matches
}


// Computes the number of units (like "hours") in the given range.
// Range can be a {start,end} object, separate start/end args, or a Duration.
// Results are based on Moment's .as() and .diff() methods, so results can depend on internal handling
// of month-diffing logic (which tends to vary from version to version).
function computeRangeAs(unit, start, end) {

	if (end != null) { // given start, end
		return end.diff(start, unit, true);
	}
	else if (moment.isDuration(start)) { // given duration
		return start.as(unit);
	}
	else { // given { start, end } range object
		return start.end.diff(start.start, unit, true);
	}
}


// Intelligently divides a range (specified by a start/end params) by a duration
function divideRangeByDuration(start, end, dur) {
	var months;

	if (durationHasTime(dur)) {
		return (end - start) / dur;
	}
	months = dur.asMonths();
	if (Math.abs(months) >= 1 && isInt(months)) {
		return end.diff(start, 'months', true) / months;
	}
	return end.diff(start, 'days', true) / dur.asDays();
}


// Intelligently divides one duration by another
function divideDurationByDuration(dur1, dur2) {
	var months1, months2;

	if (durationHasTime(dur1) || durationHasTime(dur2)) {
		return dur1 / dur2;
	}
	months1 = dur1.asMonths();
	months2 = dur2.asMonths();
	if (
		Math.abs(months1) >= 1 && isInt(months1) &&
		Math.abs(months2) >= 1 && isInt(months2)
	) {
		return months1 / months2;
	}
	return dur1.asDays() / dur2.asDays();
}


// Intelligently multiplies a duration by a number
function multiplyDuration(dur, n) {
	var months;

	if (durationHasTime(dur)) {
		return moment.duration(dur * n);
	}
	months = dur.asMonths();
	if (Math.abs(months) >= 1 && isInt(months)) {
		return moment.duration({ months: months * n });
	}
	return moment.duration({ days: dur.asDays() * n });
}


// Returns a boolean about whether the given duration has any time parts (hours/minutes/seconds/ms)
function durationHasTime(dur) {
	return Boolean(dur.hours() || dur.minutes() || dur.seconds() || dur.milliseconds());
}


function isNativeDate(input) {
	return  Object.prototype.toString.call(input) === '[object Date]' || input instanceof Date;
}


// Returns a boolean about whether the given input is a time string, like "06:40:00" or "06:00"
function isTimeString(str) {
	return /^\d+\:\d+(?:\:\d+\.?(?:\d{3})?)?$/.test(str);
}


/* Logging and Debug
----------------------------------------------------------------------------------------------------------------------*/

FC.log = function() {
	var console = window.console;

	if (console && console.log) {
		return console.log.apply(console, arguments);
	}
};

FC.warn = function() {
	var console = window.console;

	if (console && console.warn) {
		return console.warn.apply(console, arguments);
	}
	else {
		return FC.log.apply(FC, arguments);
	}
};


/* General Utilities
----------------------------------------------------------------------------------------------------------------------*/

var hasOwnPropMethod = {}.hasOwnProperty;


// Merges an array of objects into a single object.
// The second argument allows for an array of property names who's object values will be merged together.
function mergeProps(propObjs, complexProps) {
	var dest = {};
	var i, name;
	var complexObjs;
	var j, val;
	var props;

	if (complexProps) {
		for (i = 0; i < complexProps.length; i++) {
			name = complexProps[i];
			complexObjs = [];

			// collect the trailing object values, stopping when a non-object is discovered
			for (j = propObjs.length - 1; j >= 0; j--) {
				val = propObjs[j][name];

				if (typeof val === 'object') {
					complexObjs.unshift(val);
				}
				else if (val !== undefined) {
					dest[name] = val; // if there were no objects, this value will be used
					break;
				}
			}

			// if the trailing values were objects, use the merged value
			if (complexObjs.length) {
				dest[name] = mergeProps(complexObjs);
			}
		}
	}

	// copy values into the destination, going from last to first
	for (i = propObjs.length - 1; i >= 0; i--) {
		props = propObjs[i];

		for (name in props) {
			if (!(name in dest)) { // if already assigned by previous props or complex props, don't reassign
				dest[name] = props[name];
			}
		}
	}

	return dest;
}


// Create an object that has the given prototype. Just like Object.create
function createObject(proto) {
	var f = function() {};
	f.prototype = proto;
	return new f();
}
FC.createObject = createObject;


function copyOwnProps(src, dest) {
	for (var name in src) {
		if (hasOwnProp(src, name)) {
			dest[name] = src[name];
		}
	}
}


function hasOwnProp(obj, name) {
	return hasOwnPropMethod.call(obj, name);
}


// Is the given value a non-object non-function value?
function isAtomic(val) {
	return /undefined|null|boolean|number|string/.test($.type(val));
}


function applyAll(functions, thisObj, args) {
	if ($.isFunction(functions)) {
		functions = [ functions ];
	}
	if (functions) {
		var i;
		var ret;
		for (i=0; i<functions.length; i++) {
			ret = functions[i].apply(thisObj, args) || ret;
		}
		return ret;
	}
}


function firstDefined() {
	for (var i=0; i<arguments.length; i++) {
		if (arguments[i] !== undefined) {
			return arguments[i];
		}
	}
}


function htmlEscape(s) {
	return (s + '').replace(/&/g, '&amp;')
		.replace(/</g, '&lt;')
		.replace(/>/g, '&gt;')
		.replace(/'/g, '&#039;')
		.replace(/"/g, '&quot;')
		.replace(/\n/g, '<br />');
}


function stripHtmlEntities(text) {
	return text.replace(/&.*?;/g, '');
}


// Given a hash of CSS properties, returns a string of CSS.
// Uses property names as-is (no camel-case conversion). Will not make statements for null/undefined values.
function cssToStr(cssProps) {
	var statements = [];

	$.each(cssProps, function(name, val) {
		if (val != null) {
			statements.push(name + ':' + val);
		}
	});

	return statements.join(';');
}


// Given an object hash of HTML attribute names to values,
// generates a string that can be injected between < > in HTML
function attrsToStr(attrs) {
	var parts = [];

	$.each(attrs, function(name, val) {
		if (val != null) {
			parts.push(name + '="' + htmlEscape(val) + '"');
		}
	});

	return parts.join(' ');
}


function capitaliseFirstLetter(str) {
	return str.charAt(0).toUpperCase() + str.slice(1);
}


function compareNumbers(a, b) { // for .sort()
	return a - b;
}


function isInt(n) {
	return n % 1 === 0;
}


// Returns a method bound to the given object context.
// Just like one of the jQuery.proxy signatures, but without the undesired behavior of treating the same method with
// different contexts as identical when binding/unbinding events.
function proxy(obj, methodName) {
	var method = obj[methodName];

	return function() {
		return method.apply(obj, arguments);
	};
}


// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.
// https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714
function debounce(func, wait, immediate) {
	var timeout, args, context, timestamp, result;

	var later = function() {
		var last = +new Date() - timestamp;
		if (last < wait) {
			timeout = setTimeout(later, wait - last);
		}
		else {
			timeout = null;
			if (!immediate) {
				result = func.apply(context, args);
				context = args = null;
			}
		}
	};

	return function() {
		context = this;
		args = arguments;
		timestamp = +new Date();
		var callNow = immediate && !timeout;
		if (!timeout) {
			timeout = setTimeout(later, wait);
		}
		if (callNow) {
			result = func.apply(context, args);
			context = args = null;
		}
		return result;
	};
}

;;

/*
GENERAL NOTE on moments throughout the *entire rest* of the codebase:
All moments are assumed to be ambiguously-zoned unless otherwise noted,
with the NOTABLE EXCEOPTION of start/end dates that live on *Event Objects*.
Ambiguously-TIMED moments are assumed to be ambiguously-zoned by nature.
*/

var ambigDateOfMonthRegex = /^\s*\d{4}-\d\d$/;
var ambigTimeOrZoneRegex =
	/^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?)?$/;
var newMomentProto = moment.fn; // where we will attach our new methods
var oldMomentProto = $.extend({}, newMomentProto); // copy of original moment methods

// tell momentjs to transfer these properties upon clone
var momentProperties = moment.momentProperties;
momentProperties.push('_fullCalendar');
momentProperties.push('_ambigTime');
momentProperties.push('_ambigZone');


// Creating
// -------------------------------------------------------------------------------------------------

// Creates a new moment, similar to the vanilla moment(...) constructor, but with
// extra features (ambiguous time, enhanced formatting). When given an existing moment,
// it will function as a clone (and retain the zone of the moment). Anything else will
// result in a moment in the local zone.
FC.moment = function() {
	return makeMoment(arguments);
};

// Sames as FC.moment, but forces the resulting moment to be in the UTC timezone.
FC.moment.utc = function() {
	var mom = makeMoment(arguments, true);

	// Force it into UTC because makeMoment doesn't guarantee it
	// (if given a pre-existing moment for example)
	if (mom.hasTime()) { // don't give ambiguously-timed moments a UTC zone
		mom.utc();
	}

	return mom;
};

// Same as FC.moment, but when given an ISO8601 string, the timezone offset is preserved.
// ISO8601 strings with no timezone offset will become ambiguously zoned.
FC.moment.parseZone = function() {
	return makeMoment(arguments, true, true);
};

// Builds an enhanced moment from args. When given an existing moment, it clones. When given a
// native Date, or called with no arguments (the current time), the resulting moment will be local.
// Anything else needs to be "parsed" (a string or an array), and will be affected by:
//    parseAsUTC - if there is no zone information, should we parse the input in UTC?
//    parseZone - if there is zone information, should we force the zone of the moment?
function makeMoment(args, parseAsUTC, parseZone) {
	var input = args[0];
	var isSingleString = args.length == 1 && typeof input === 'string';
	var isAmbigTime;
	var isAmbigZone;
	var ambigMatch;
	var mom;

	if (moment.isMoment(input) || isNativeDate(input) || input === undefined) {
		mom = moment.apply(null, args);
	}
	else { // "parsing" is required
		isAmbigTime = false;
		isAmbigZone = false;

		if (isSingleString) {
			if (ambigDateOfMonthRegex.test(input)) {
				// accept strings like '2014-05', but convert to the first of the month
				input += '-01';
				args = [ input ]; // for when we pass it on to moment's constructor
				isAmbigTime = true;
				isAmbigZone = true;
			}
			else if ((ambigMatch = ambigTimeOrZoneRegex.exec(input))) {
				isAmbigTime = !ambigMatch[5]; // no time part?
				isAmbigZone = true;
			}
		}
		else if ($.isArray(input)) {
			// arrays have no timezone information, so assume ambiguous zone
			isAmbigZone = true;
		}
		// otherwise, probably a string with a format

		if (parseAsUTC || isAmbigTime) {
			mom = moment.utc.apply(moment, args);
		}
		else {
			mom = moment.apply(null, args);
		}

		if (isAmbigTime) {
			mom._ambigTime = true;
			mom._ambigZone = true; // ambiguous time always means ambiguous zone
		}
		else if (parseZone) { // let's record the inputted zone somehow
			if (isAmbigZone) {
				mom._ambigZone = true;
			}
			else if (isSingleString) {
				mom.utcOffset(input); // if not a valid zone, will assign UTC
			}
		}
	}

	mom._fullCalendar = true; // flag for extended functionality

	return mom;
}


// Week Number
// -------------------------------------------------------------------------------------------------


// Returns the week number, considering the locale's custom week number calcuation
// `weeks` is an alias for `week`
newMomentProto.week = newMomentProto.weeks = function(input) {
	var weekCalc = this._locale._fullCalendar_weekCalc;

	if (input == null && typeof weekCalc === 'function') { // custom function only works for getter
		return weekCalc(this);
	}
	else if (weekCalc === 'ISO') {
		return oldMomentProto.isoWeek.apply(this, arguments); // ISO getter/setter
	}

	return oldMomentProto.week.apply(this, arguments); // local getter/setter
};


// Time-of-day
// -------------------------------------------------------------------------------------------------

// GETTER
// Returns a Duration with the hours/minutes/seconds/ms values of the moment.
// If the moment has an ambiguous time, a duration of 00:00 will be returned.
//
// SETTER
// You can supply a Duration, a Moment, or a Duration-like argument.
// When setting the time, and the moment has an ambiguous time, it then becomes unambiguous.
newMomentProto.time = function(time) {

	// Fallback to the original method (if there is one) if this moment wasn't created via FullCalendar.
	// `time` is a generic enough method name where this precaution is necessary to avoid collisions w/ other plugins.
	if (!this._fullCalendar) {
		return oldMomentProto.time.apply(this, arguments);
	}

	if (time == null) { // getter
		return moment.duration({
			hours: this.hours(),
			minutes: this.minutes(),
			seconds: this.seconds(),
			milliseconds: this.milliseconds()
		});
	}
	else { // setter

		this._ambigTime = false; // mark that the moment now has a time

		if (!moment.isDuration(time) && !moment.isMoment(time)) {
			time = moment.duration(time);
		}

		// The day value should cause overflow (so 24 hours becomes 00:00:00 of next day).
		// Only for Duration times, not Moment times.
		var dayHours = 0;
		if (moment.isDuration(time)) {
			dayHours = Math.floor(time.asDays()) * 24;
		}

		// We need to set the individual fields.
		// Can't use startOf('day') then add duration. In case of DST at start of day.
		return this.hours(dayHours + time.hours())
			.minutes(time.minutes())
			.seconds(time.seconds())
			.milliseconds(time.milliseconds());
	}
};

// Converts the moment to UTC, stripping out its time-of-day and timezone offset,
// but preserving its YMD. A moment with a stripped time will display no time
// nor timezone offset when .format() is called.
newMomentProto.stripTime = function() {

	if (!this._ambigTime) {

		this.utc(true); // keepLocalTime=true (for keeping *date* value)

		// set time to zero
		this.set({
			hours: 0,
			minutes: 0,
			seconds: 0,
			ms: 0
		});

		// Mark the time as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
		// which clears all ambig flags.
		this._ambigTime = true;
		this._ambigZone = true; // if ambiguous time, also ambiguous timezone offset
	}

	return this; // for chaining
};

// Returns if the moment has a non-ambiguous time (boolean)
newMomentProto.hasTime = function() {
	return !this._ambigTime;
};


// Timezone
// -------------------------------------------------------------------------------------------------

// Converts the moment to UTC, stripping out its timezone offset, but preserving its
// YMD and time-of-day. A moment with a stripped timezone offset will display no
// timezone offset when .format() is called.
newMomentProto.stripZone = function() {
	var wasAmbigTime;

	if (!this._ambigZone) {

		wasAmbigTime = this._ambigTime;

		this.utc(true); // keepLocalTime=true (for keeping date and time values)

		// the above call to .utc()/.utcOffset() unfortunately might clear the ambig flags, so restore
		this._ambigTime = wasAmbigTime || false;

		// Mark the zone as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
		// which clears the ambig flags.
		this._ambigZone = true;
	}

	return this; // for chaining
};

// Returns of the moment has a non-ambiguous timezone offset (boolean)
newMomentProto.hasZone = function() {
	return !this._ambigZone;
};


// implicitly marks a zone
newMomentProto.local = function(keepLocalTime) {

	// for when converting from ambiguously-zoned to local,
	// keep the time values when converting from UTC -> local
	oldMomentProto.local.call(this, this._ambigZone || keepLocalTime);

	// ensure non-ambiguous
	// this probably already happened via local() -> utcOffset(), but don't rely on Moment's internals
	this._ambigTime = false;
	this._ambigZone = false;

	return this; // for chaining
};


// implicitly marks a zone
newMomentProto.utc = function(keepLocalTime) {

	oldMomentProto.utc.call(this, keepLocalTime);

	// ensure non-ambiguous
	// this probably already happened via utc() -> utcOffset(), but don't rely on Moment's internals
	this._ambigTime = false;
	this._ambigZone = false;

	return this;
};


// implicitly marks a zone (will probably get called upon .utc() and .local())
newMomentProto.utcOffset = function(tzo) {

	if (tzo != null) { // setter
		// these assignments needs to happen before the original zone method is called.
		// I forget why, something to do with a browser crash.
		this._ambigTime = false;
		this._ambigZone = false;
	}

	return oldMomentProto.utcOffset.apply(this, arguments);
};


// Formatting
// -------------------------------------------------------------------------------------------------

newMomentProto.format = function() {
	if (this._fullCalendar && arguments[0]) { // an enhanced moment? and a format string provided?
		return formatDate(this, arguments[0]); // our extended formatting
	}
	if (this._ambigTime) {
		return oldMomentFormat(this, 'YYYY-MM-DD');
	}
	if (this._ambigZone) {
		return oldMomentFormat(this, 'YYYY-MM-DD[T]HH:mm:ss');
	}
	return oldMomentProto.format.apply(this, arguments);
};

newMomentProto.toISOString = function() {
	if (this._ambigTime) {
		return oldMomentFormat(this, 'YYYY-MM-DD');
	}
	if (this._ambigZone) {
		return oldMomentFormat(this, 'YYYY-MM-DD[T]HH:mm:ss');
	}
	return oldMomentProto.toISOString.apply(this, arguments);
};

;;
(function () {

	// exports
	FC.formatDate = formatDate;
	FC.formatRange = formatRange;
	FC.oldMomentFormat = oldMomentFormat;
	FC.queryMostGranularFormatUnit = queryMostGranularFormatUnit;


	// Config
	// ---------------------------------------------------------------------------------------------------------------------

	/*
	Inserted between chunks in the fake ("intermediate") formatting string.
	Important that it passes as whitespace (\s) because moment often identifies non-standalone months
	via a regexp with an \s.
	*/
	var PART_SEPARATOR = '\u000b'; // vertical tab

	/*
	Inserted as the first character of a literal-text chunk to indicate that the literal text is not actually literal text,
	but rather, a "special" token that has custom rendering (see specialTokens map).
	*/
	var SPECIAL_TOKEN_MARKER = '\u001f'; // information separator 1

	/*
	Inserted at the beginning and end of a span of text that must have non-zero numeric characters.
	Handling of these markers is done in a post-processing step at the very end of text rendering.
	*/
	var MAYBE_MARKER = '\u001e'; // information separator 2
	var MAYBE_REGEXP = new RegExp(MAYBE_MARKER + '([^' + MAYBE_MARKER + ']*)' + MAYBE_MARKER, 'g'); // must be global

	/*
	Addition formatting tokens we want recognized
	*/
	var specialTokens = {
		t: function (date) { // "a" or "p"
			return oldMomentFormat(date, 'a').charAt(0);
		},
		T: function (date) { // "A" or "P"
			return oldMomentFormat(date, 'A').charAt(0);
		},
		B: function (date) {
			return date.year() + 543;
		},
	};

	/*
	The first characters of formatting tokens for units that are 1 day or larger.
	`value` is for ranking relative size (lower means bigger).
	`unit` is a normalized unit, used for comparing moments.
	*/
	var largeTokenMap = {
		B: { value: 1, unit: 'year' },
		Y: { value: 1, unit: 'year' },
		M: { value: 2, unit: 'month' },
		W: { value: 3, unit: 'week' }, // ISO week
		w: { value: 3, unit: 'week' }, // local week
		D: { value: 4, unit: 'day' }, // day of month
		d: { value: 4, unit: 'day' } // day of week
	};


	// Single Date Formatting
	// ---------------------------------------------------------------------------------------------------------------------

	/*
	Formats `date` with a Moment formatting string, but allow our non-zero areas and special token
	*/
	function formatDate(date, formatStr) {
		return renderFakeFormatString(
			getParsedFormatString(formatStr).fakeFormatString,
			date
		);
	}

	/*
	Call this if you want Moment's original format method to be used
	*/
	function oldMomentFormat(mom, formatStr) {
		return oldMomentProto.format.call(mom, formatStr); // oldMomentProto defined in moment-ext.js
	}


	// Date Range Formatting
	// -------------------------------------------------------------------------------------------------
	// TODO: make it work with timezone offset

	/*
	Using a formatting string meant for a single date, generate a range string, like
	"Sep 2 - 9 2013", that intelligently inserts a separator where the dates differ.
	If the dates are the same as far as the format string is concerned, just return a single
	rendering of one date, without any separator.
	*/
	function formatRange(date1, date2, formatStr, separator, isRTL) {
		var localeData;

		date1 = FC.moment.parseZone(date1);
		date2 = FC.moment.parseZone(date2);

		localeData = date1.localeData();

		// Expand localized format strings, like "LL" -> "MMMM D YYYY".
		// BTW, this is not important for `formatDate` because it is impossible to put custom tokens
		// or non-zero areas in Moment's localized format strings.
		formatStr = localeData.longDateFormat(formatStr) || formatStr;

		return renderParsedFormat(
			getParsedFormatString(formatStr),
			date1,
			date2,
			separator || ' - ',
			isRTL
		);
	}

	/*
	Renders a range with an already-parsed format string.
	*/
	function renderParsedFormat(parsedFormat, date1, date2, separator, isRTL) {
		var sameUnits = parsedFormat.sameUnits;
		var unzonedDate1 = date1.clone().stripZone(); // for same-unit comparisons
		var unzonedDate2 = date2.clone().stripZone(); // "

		var renderedParts1 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date1);
		var renderedParts2 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date2);

		var leftI;
		var leftStr = '';
		var rightI;
		var rightStr = '';
		var middleI;
		var middleStr1 = '';
		var middleStr2 = '';
		var middleStr = '';

		// Start at the leftmost side of the formatting string and continue until you hit a token
		// that is not the same between dates.
		for (
			leftI = 0;
			leftI < sameUnits.length && (!sameUnits[leftI] || unzonedDate1.isSame(unzonedDate2, sameUnits[leftI]));
			leftI++
		) {
			leftStr += renderedParts1[leftI];
		}

		// Similarly, start at the rightmost side of the formatting string and move left
		for (
			rightI = sameUnits.length - 1;
			rightI > leftI && (!sameUnits[rightI] || unzonedDate1.isSame(unzonedDate2, sameUnits[rightI]));
			rightI--
		) {
			// If current chunk is on the boundary of unique date-content, and is a special-case
			// date-formatting postfix character, then don't consume it. Consider it unique date-content.
			// TODO: make configurable
			if (rightI - 1 === leftI && renderedParts1[rightI] === '.') {
				break;
			}

			rightStr = renderedParts1[rightI] + rightStr;
		}

		// The area in the middle is different for both of the dates.
		// Collect them distinctly so we can jam them together later.
		for (middleI = leftI; middleI <= rightI; middleI++) {
			middleStr1 += renderedParts1[middleI];
			middleStr2 += renderedParts2[middleI];
		}

		if (middleStr1 || middleStr2) {
			if (isRTL) {
				middleStr = middleStr2 + separator + middleStr1;
			}
			else {
				middleStr = middleStr1 + separator + middleStr2;
			}
		}

		return processMaybeMarkers(
			leftStr + middleStr + rightStr
		);
	}


	// Format String Parsing
	// ---------------------------------------------------------------------------------------------------------------------

	var parsedFormatStrCache = {};

	/*
	Returns a parsed format string, leveraging a cache.
	*/
	function getParsedFormatString(formatStr) {
		return parsedFormatStrCache[formatStr] ||
			(parsedFormatStrCache[formatStr] = parseFormatString(formatStr));
	}

	/*
	Parses a format string into the following:
	- fakeFormatString: a momentJS formatting string, littered with special control characters that get post-processed.
	- sameUnits: for every part in fakeFormatString, if the part is a token, the value will be a unit string (like "day"),
	  that indicates how similar a range's start & end must be in order to share the same formatted text.
	  If not a token, then the value is null.
	  Always a flat array (not nested liked "chunks").
	*/
	function parseFormatString(formatStr) {
		var chunks = chunkFormatString(formatStr);

		return {
			fakeFormatString: buildFakeFormatString(chunks),
			sameUnits: buildSameUnits(chunks)
		};
	}

	/*
	Break the formatting string into an array of chunks.
	A 'maybe' chunk will have nested chunks.
	*/
	function chunkFormatString(formatStr) {
		var chunks = [];
		var match;

		// TODO: more descrimination
		// \4 is a backreference to the first character of a multi-character set.
		var chunker = /\[([^\]]*)\]|\(([^\)]*)\)|(LTS|LT|(\w)\4*o?)|([^\w\[\(]+)/g;

		while ((match = chunker.exec(formatStr))) {
			if (match[1]) { // a literal string inside [ ... ]
				chunks.push.apply(chunks, // append
					splitStringLiteral(match[1])
				);
			}
			else if (match[2]) { // non-zero formatting inside ( ... )
				chunks.push({ maybe: chunkFormatString(match[2]) });
			}
			else if (match[3]) { // a formatting token
				chunks.push({ token: match[3] });
			}
			else if (match[5]) { // an unenclosed literal string
				chunks.push.apply(chunks, // append
					splitStringLiteral(match[5])
				);
			}
		}

		return chunks;
	}

	/*
	Potentially splits a literal-text string into multiple parts. For special cases.
	*/
	function splitStringLiteral(s) {
		if (s === '. ') {
			return ['.', ' ']; // for locales with periods bound to the end of each year/month/date
		}
		else {
			return [s];
		}
	}

	/*
	Given chunks parsed from a real format string, generate a fake (aka "intermediate") format string with special control
	characters that will eventually be given to moment for formatting, and then post-processed.
	*/
	function buildFakeFormatString(chunks) {
		var parts = [];
		var i, chunk;

		for (i = 0; i < chunks.length; i++) {
			chunk = chunks[i];

			if (typeof chunk === 'string') {
				parts.push('[' + chunk + ']');
			}
			else if (chunk.token) {
				if (chunk.token in specialTokens) {
					parts.push(
						SPECIAL_TOKEN_MARKER + // useful during post-processing
						'[' + chunk.token + ']' // preserve as literal text
					);
				}
				else {
					parts.push(chunk.token); // unprotected text implies a format string
				}
			}
			else if (chunk.maybe) {
				parts.push(
					MAYBE_MARKER + // useful during post-processing
					buildFakeFormatString(chunk.maybe) +
					MAYBE_MARKER
				);
			}
		}

		return parts.join(PART_SEPARATOR);
	}

	/*
	Given parsed chunks from a real formatting string, generates an array of unit strings (like "day") that indicate
	in which regard two dates must be similar in order to share range formatting text.
	The `chunks` can be nested (because of "maybe" chunks), however, the returned array will be flat.
	*/
	function buildSameUnits(chunks) {
		var units = [];
		var i, chunk;
		var tokenInfo;

		for (i = 0; i < chunks.length; i++) {
			chunk = chunks[i];

			if (chunk.token) {
				tokenInfo = largeTokenMap[chunk.token.charAt(0)];
				units.push(tokenInfo ? tokenInfo.unit : 'second'); // default to a very strict same-second
			}
			else if (chunk.maybe) {
				units.push.apply(units, // append
					buildSameUnits(chunk.maybe)
				);
			}
			else {
				units.push(null);
			}
		}

		return units;
	}


	// Rendering to text
	// ---------------------------------------------------------------------------------------------------------------------

	/*
	Formats a date with a fake format string, post-processes the control characters, then returns.
	*/
	function renderFakeFormatString(fakeFormatString, date) {
		return processMaybeMarkers(
			renderFakeFormatStringParts(fakeFormatString, date).join('')
		);
	}

	/*
	Formats a date into parts that will have been post-processed, EXCEPT for the "maybe" markers.
	*/
	function renderFakeFormatStringParts(fakeFormatString, date) {
		var parts = [];
		var fakeRender = oldMomentFormat(date, fakeFormatString);
		var fakeParts = fakeRender.split(PART_SEPARATOR);
		var i, fakePart;

		for (i = 0; i < fakeParts.length; i++) {
			fakePart = fakeParts[i];

			if (fakePart.charAt(0) === SPECIAL_TOKEN_MARKER) {
				parts.push(
					// the literal string IS the token's name.
					// call special token's registered function.
					specialTokens[fakePart.substring(1)](date)
				);
			}
			else {
				parts.push(fakePart);
			}
		}

		return parts;
	}

	/*
	Accepts an almost-finally-formatted string and processes the "maybe" control characters, returning a new string.
	*/
	function processMaybeMarkers(s) {
		return s.replace(MAYBE_REGEXP, function (m0, m1) { // regex assumed to have 'g' flag
			if (m1.match(/[1-9]/)) { // any non-zero numeric characters?
				return m1;
			}
			else {
				return '';
			}
		});
	}


	// Misc Utils
	// -------------------------------------------------------------------------------------------------

	/*
	Returns a unit string, either 'year', 'month', 'day', or null for the most granular formatting token in the string.
	*/
	function queryMostGranularFormatUnit(formatStr) {
		var chunks = chunkFormatString(formatStr);
		var i, chunk;
		var candidate;
		var best;

		for (i = 0; i < chunks.length; i++) {
			chunk = chunks[i];

			if (chunk.token) {
				candidate = largeTokenMap[chunk.token.charAt(0)];
				if (candidate) {
					if (!best || candidate.value > best.value) {
						best = candidate;
					}
				}
			}
		}

		if (best) {
			return best.unit;
		}

		return null;
	};

})();

// quick local references
var formatDate = FC.formatDate;
var formatRange = FC.formatRange;
var oldMomentFormat = FC.oldMomentFormat;

;;

FC.Class = Class; // export

// Class that all other classes will inherit from
function Class() { }


// Called on a class to create a subclass.
// Last argument contains instance methods. Any argument before the last are considered mixins.
Class.extend = function() {
	var len = arguments.length;
	var i;
	var members;

	for (i = 0; i < len; i++) {
		members = arguments[i];
		if (i < len - 1) { // not the last argument?
			mixIntoClass(this, members);
		}
	}

	return extendClass(this, members || {}); // members will be undefined if no arguments
};


// Adds new member variables/methods to the class's prototype.
// Can be called with another class, or a plain object hash containing new members.
Class.mixin = function(members) {
	mixIntoClass(this, members);
};


function extendClass(superClass, members) {
	var subClass;

	// ensure a constructor for the subclass, forwarding all arguments to the super-constructor if it doesn't exist
	if (hasOwnProp(members, 'constructor')) {
		subClass = members.constructor;
	}
	if (typeof subClass !== 'function') {
		subClass = members.constructor = function() {
			superClass.apply(this, arguments);
		};
	}

	// build the base prototype for the subclass, which is an new object chained to the superclass's prototype
	subClass.prototype = createObject(superClass.prototype);

	// copy each member variable/method onto the the subclass's prototype
	copyOwnProps(members, subClass.prototype);

	// copy over all class variables/methods to the subclass, such as `extend` and `mixin`
	copyOwnProps(superClass, subClass);

	return subClass;
}


function mixIntoClass(theClass, members) {
	copyOwnProps(members, theClass.prototype);
}
;;

/*
Wrap jQuery's Deferred Promise object to be slightly more Promise/A+ compliant.
With the added non-standard feature of synchronously executing handlers on resolved promises,
which doesn't always happen otherwise (esp with nested .then handlers!?),
so, this makes things a lot easier, esp because jQuery 3 changed the synchronicity for Deferred objects.

TODO: write tests and more comments
*/

function Promise(executor) {
	var deferred = $.Deferred();
	var promise = deferred.promise();

	if (typeof executor === 'function') {
		executor(
			function(value) { // resolve
				if (Promise.immediate) {
					promise._value = value;
				}
				deferred.resolve(value);
			},
			function() { // reject
				deferred.reject();
			}
		);
	}
	
	if (Promise.immediate) {
		var origThen = promise.then;

		promise.then = function(onFulfilled, onRejected) {
			var state = promise.state();
			
			if (state === 'resolved') {
				if (typeof onFulfilled === 'function') {
					return Promise.resolve(onFulfilled(promise._value));
				}
			}
			else if (state === 'rejected') {
				if (typeof onRejected === 'function') {
					onRejected();
					return promise; // already rejected
				}
			}

			return origThen.call(promise, onFulfilled, onRejected);
		};
	}

	return promise; // instanceof Promise will break :( TODO: make Promise a real class
}

FC.Promise = Promise;

Promise.immediate = true;


Promise.resolve = function(value) {
	if (value && typeof value.resolve === 'function') {
		return value.promise();
	}
	if (value && typeof value.then === 'function') {
		return value;
	}
	else {
		var deferred = $.Deferred().resolve(value);
		var promise = deferred.promise();

		if (Promise.immediate) {
			var origThen = promise.then;

			promise._value = value;

			promise.then = function(onFulfilled, onRejected) {
				if (typeof onFulfilled === 'function') {
					return Promise.resolve(onFulfilled(value));
				}
				return origThen.call(promise, onFulfilled, onRejected);
			};
		}

		return promise;
	}
};


Promise.reject = function() {
	return $.Deferred().reject().promise();
};


Promise.all = function(inputs) {
	var hasAllValues = false;
	var values;
	var i, input;

	if (Promise.immediate) {
		hasAllValues = true;
		values = [];

		for (i = 0; i < inputs.length; i++) {
			input = inputs[i];

			if (input && typeof input.state === 'function' && input.state() === 'resolved' && ('_value' in input)) {
				values.push(input._value);
			}
			else if (input && typeof input.then === 'function') {
				hasAllValues = false;
				break;
			}
			else {
				values.push(input);
			}
		}
	}

	if (hasAllValues) {
		return Promise.resolve(values);
	}
	else {
		return $.when.apply($.when, inputs).then(function() {
			return $.when($.makeArray(arguments));
		});
	}
};

;;

// TODO: write tests and clean up code

function TaskQueue(debounceWait) {
	var q = []; // array of runFuncs

	function addTask(taskFunc) {
		return new Promise(function(resolve) {

			// should run this function when it's taskFunc's turn to run.
			// responsible for popping itself off the queue.
			var runFunc = function() {
				Promise.resolve(taskFunc()) // result might be async, coerce to promise
					.then(resolve) // resolve TaskQueue::push's promise, for the caller. will receive result of taskFunc.
					.then(function() {
						q.shift(); // pop itself off

						// run the next task, if any
						if (q.length) {
							q[0]();
						}
					});
			};

			// always put the task at the end of the queue, BEFORE running the task
			q.push(runFunc);

			// if it's the only task in the queue, run immediately
			if (q.length === 1) {
				runFunc();
			}
		});
	}

	this.add = // potentially debounce, for the public method
		typeof debounceWait === 'number' ?
			debounce(addTask, debounceWait) :
			addTask; // if not a number (null/undefined/false), no debounce at all

	this.addQuickly = addTask; // guaranteed no debounce
}

FC.TaskQueue = TaskQueue;

/*
q = new TaskQueue();

function work(i) {
	return q.push(function() {
		trigger();
		console.log('work' + i);
	});
}

var cnt = 0;

function trigger() {
	if (cnt < 5) {
		cnt++;
		work(cnt);
	}
}

work(9);
*/

;;

var EmitterMixin = FC.EmitterMixin = {

	// jQuery-ification via $(this) allows a non-DOM object to have
	// the same event handling capabilities (including namespaces).


	on: function(types, handler) {
		$(this).on(types, this._prepareIntercept(handler));
		return this; // for chaining
	},


	one: function(types, handler) {
		$(this).one(types, this._prepareIntercept(handler));
		return this; // for chaining
	},


	_prepareIntercept: function(handler) {
		// handlers are always called with an "event" object as their first param.
		// sneak the `this` context and arguments into the extra parameter object
		// and forward them on to the original handler.
		var intercept = function(ev, extra) {
			return handler.apply(
				extra.context || this,
				extra.args || []
			);
		};

		// mimick jQuery's internal "proxy" system (risky, I know)
		// causing all functions with the same .guid to appear to be the same.
		// https://github.com/jquery/jquery/blob/2.2.4/src/core.js#L448
		// this is needed for calling .off with the original non-intercept handler.
		if (!handler.guid) {
			handler.guid = $.guid++;
		}
		intercept.guid = handler.guid;

		return intercept;
	},


	off: function(types, handler) {
		$(this).off(types, handler);

		return this; // for chaining
	},


	trigger: function(types) {
		var args = Array.prototype.slice.call(arguments, 1); // arguments after the first

		// pass in "extra" info to the intercept
		$(this).triggerHandler(types, { args: args });

		return this; // for chaining
	},


	triggerWith: function(types, context, args) {

		// `triggerHandler` is less reliant on the DOM compared to `trigger`.
		// pass in "extra" info to the intercept.
		$(this).triggerHandler(types, { context: context, args: args });

		return this; // for chaining
	}

};

;;

/*
Utility methods for easily listening to events on another object,
and more importantly, easily unlistening from them.
*/
var ListenerMixin = FC.ListenerMixin = (function() {
	var guid = 0;
	var ListenerMixin = {

		listenerId: null,

		/*
		Given an `other` object that has on/off methods, bind the given `callback` to an event by the given name.
		The `callback` will be called with the `this` context of the object that .listenTo is being called on.
		Can be called:
			.listenTo(other, eventName, callback)
		OR
			.listenTo(other, {
				eventName1: callback1,
				eventName2: callback2
			})
		*/
		listenTo: function(other, arg, callback) {
			if (typeof arg === 'object') { // given dictionary of callbacks
				for (var eventName in arg) {
					if (arg.hasOwnProperty(eventName)) {
						this.listenTo(other, eventName, arg[eventName]);
					}
				}
			}
			else if (typeof arg === 'string') {
				other.on(
					arg + '.' + this.getListenerNamespace(), // use event namespacing to identify this object
					$.proxy(callback, this) // always use `this` context
						// the usually-undesired jQuery guid behavior doesn't matter,
						// because we always unbind via namespace
				);
			}
		},

		/*
		Causes the current object to stop listening to events on the `other` object.
		`eventName` is optional. If omitted, will stop listening to ALL events on `other`.
		*/
		stopListeningTo: function(other, eventName) {
			other.off((eventName || '') + '.' + this.getListenerNamespace());
		},

		/*
		Returns a string, unique to this object, to be used for event namespacing
		*/
		getListenerNamespace: function() {
			if (this.listenerId == null) {
				this.listenerId = guid++;
			}
			return '_listener' + this.listenerId;
		}

	};
	return ListenerMixin;
})();
;;

// simple class for toggle a `isIgnoringMouse` flag on delay
// initMouseIgnoring must first be called, with a millisecond delay setting.
var MouseIgnorerMixin = {

	isIgnoringMouse: false, // bool
	delayUnignoreMouse: null, // method


	initMouseIgnoring: function(delay) {
		this.delayUnignoreMouse = debounce(proxy(this, 'unignoreMouse'), delay || 1000);
	},


	// temporarily ignore mouse actions on segments
	tempIgnoreMouse: function() {
		this.isIgnoringMouse = true;
		this.delayUnignoreMouse();
	},


	// delayUnignoreMouse eventually calls this
	unignoreMouse: function() {
		this.isIgnoringMouse = false;
	}

};

;;

/* A rectangular panel that is absolutely positioned over other content
------------------------------------------------------------------------------------------------------------------------
Options:
	- className (string)
	- content (HTML string or jQuery element set)
	- parentEl
	- top
	- left
	- right (the x coord of where the right edge should be. not a "CSS" right)
	- autoHide (boolean)
	- show (callback)
	- hide (callback)
*/

var Popover = Class.extend(ListenerMixin, {

	isHidden: true,
	options: null,
	el: null, // the container element for the popover. generated by this object
	margin: 10, // the space required between the popover and the edges of the scroll container


	constructor: function(options) {
		this.options = options || {};
	},


	// Shows the popover on the specified position. Renders it if not already
	show: function() {
		if (this.isHidden) {
			if (!this.el) {
				this.render();
			}
			this.el.show();
			this.position();
			this.isHidden = false;
			this.trigger('show');
		}
	},


	// Hides the popover, through CSS, but does not remove it from the DOM
	hide: function() {
		if (!this.isHidden) {
			this.el.hide();
			this.isHidden = true;
			this.trigger('hide');
		}
	},


	// Creates `this.el` and renders content inside of it
	render: function() {
		var _this = this;
		var options = this.options;

		this.el = $('<div class="fc-popover"/>')
			.addClass(options.className || '')
			.css({
				// position initially to the top left to avoid creating scrollbars
				top: 0,
				left: 0
			})
			.append(options.content)
			.appendTo(options.parentEl);

		// when a click happens on anything inside with a 'fc-close' className, hide the popover
		this.el.on('click', '.fc-close', function() {
			_this.hide();
		});

		if (options.autoHide) {
			this.listenTo($(document), 'mousedown', this.documentMousedown);
		}
	},


	// Triggered when the user clicks *anywhere* in the document, for the autoHide feature
	documentMousedown: function(ev) {
		// only hide the popover if the click happened outside the popover
		if (this.el && !$(ev.target).closest(this.el).length) {
			this.hide();
		}
	},


	// Hides and unregisters any handlers
	removeElement: function() {
		this.hide();

		if (this.el) {
			this.el.remove();
			this.el = null;
		}

		this.stopListeningTo($(document), 'mousedown');
	},


	// Positions the popover optimally, using the top/left/right options
	position: function() {
		var options = this.options;
		var origin = this.el.offsetParent().offset();
		var width = this.el.outerWidth();
		var height = this.el.outerHeight();
		var windowEl = $(window);
		var viewportEl = getScrollParent(this.el);
		var viewportTop;
		var viewportLeft;
		var viewportOffset;
		var top; // the "position" (not "offset") values for the popover
		var left; //

		// compute top and left
		top = options.top || 0;
		if (options.left !== undefined) {
			left = options.left;
		}
		else if (options.right !== undefined) {
			left = options.right - width; // derive the left value from the right value
		}
		else {
			left = 0;
		}

		if (viewportEl.is(window) || viewportEl.is(document)) { // normalize getScrollParent's result
			viewportEl = windowEl;
			viewportTop = 0; // the window is always at the top left
			viewportLeft = 0; // (and .offset() won't work if called here)
		}
		else {
			viewportOffset = viewportEl.offset();
			viewportTop = viewportOffset.top;
			viewportLeft = viewportOffset.left;
		}

		// if the window is scrolled, it causes the visible area to be further down
		viewportTop += windowEl.scrollTop();
		viewportLeft += windowEl.scrollLeft();

		// constrain to the view port. if constrained by two edges, give precedence to top/left
		if (options.viewportConstrain !== false) {
			top = Math.min(top, viewportTop + viewportEl.outerHeight() - height - this.margin);
			top = Math.max(top, viewportTop + this.margin);
			left = Math.min(left, viewportLeft + viewportEl.outerWidth() - width - this.margin);
			left = Math.max(left, viewportLeft + this.margin);
		}

		this.el.css({
			top: top - origin.top,
			left: left - origin.left
		});
	},


	// Triggers a callback. Calls a function in the option hash of the same name.
	// Arguments beyond the first `name` are forwarded on.
	// TODO: better code reuse for this. Repeat code
	trigger: function(name) {
		if (this.options[name]) {
			this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
		}
	}

});

;;

/*
A cache for the left/right/top/bottom/width/height values for one or more elements.
Works with both offset (from topleft document) and position (from offsetParent).

options:
- els
- isHorizontal
- isVertical
*/
var CoordCache = FC.CoordCache = Class.extend({

	els: null, // jQuery set (assumed to be siblings)
	forcedOffsetParentEl: null, // options can override the natural offsetParent
	origin: null, // {left,top} position of offsetParent of els
	boundingRect: null, // constrain cordinates to this rectangle. {left,right,top,bottom} or null
	isHorizontal: false, // whether to query for left/right/width
	isVertical: false, // whether to query for top/bottom/height

	// arrays of coordinates (offsets from topleft of document)
	lefts: null,
	rights: null,
	tops: null,
	bottoms: null,


	constructor: function(options) {
		this.els = $(options.els);
		this.isHorizontal = options.isHorizontal;
		this.isVertical = options.isVertical;
		this.forcedOffsetParentEl = options.offsetParent ? $(options.offsetParent) : null;
	},


	// Queries the els for coordinates and stores them.
	// Call this method before using and of the get* methods below.
	build: function() {
		var offsetParentEl = this.forcedOffsetParentEl;
		if (!offsetParentEl && this.els.length > 0) {
			offsetParentEl = this.els.eq(0).offsetParent();
		}

		this.origin = offsetParentEl ?
			offsetParentEl.offset() :
			null;

		this.boundingRect = this.queryBoundingRect();

		if (this.isHorizontal) {
			this.buildElHorizontals();
		}
		if (this.isVertical) {
			this.buildElVerticals();
		}
	},


	// Destroys all internal data about coordinates, freeing memory
	clear: function() {
		this.origin = null;
		this.boundingRect = null;
		this.lefts = null;
		this.rights = null;
		this.tops = null;
		this.bottoms = null;
	},


	// When called, if coord caches aren't built, builds them
	ensureBuilt: function() {
		if (!this.origin) {
			this.build();
		}
	},


	// Populates the left/right internal coordinate arrays
	buildElHorizontals: function() {
		var lefts = [];
		var rights = [];

		this.els.each(function(i, node) {
			var el = $(node);
			var left = el.offset().left;
			var width = el.outerWidth();

			lefts.push(left);
			rights.push(left + width);
		});

		this.lefts = lefts;
		this.rights = rights;
	},


	// Populates the top/bottom internal coordinate arrays
	buildElVerticals: function() {
		var tops = [];
		var bottoms = [];

		this.els.each(function(i, node) {
			var el = $(node);
			var top = el.offset().top;
			var height = el.outerHeight();

			tops.push(top);
			bottoms.push(top + height);
		});

		this.tops = tops;
		this.bottoms = bottoms;
	},


	// Given a left offset (from document left), returns the index of the el that it horizontally intersects.
	// If no intersection is made, returns undefined.
	getHorizontalIndex: function(leftOffset) {
		this.ensureBuilt();

		var lefts = this.lefts;
		var rights = this.rights;
		var len = lefts.length;
		var i;

		for (i = 0; i < len; i++) {
			if (leftOffset >= lefts[i] && leftOffset < rights[i]) {
				return i;
			}
		}
	},


	// Given a top offset (from document top), returns the index of the el that it vertically intersects.
	// If no intersection is made, returns undefined.
	getVerticalIndex: function(topOffset) {
		this.ensureBuilt();

		var tops = this.tops;
		var bottoms = this.bottoms;
		var len = tops.length;
		var i;

		for (i = 0; i < len; i++) {
			if (topOffset >= tops[i] && topOffset < bottoms[i]) {
				return i;
			}
		}
	},


	// Gets the left offset (from document left) of the element at the given index
	getLeftOffset: function(leftIndex) {
		this.ensureBuilt();
		return this.lefts[leftIndex];
	},


	// Gets the left position (from offsetParent left) of the element at the given index
	getLeftPosition: function(leftIndex) {
		this.ensureBuilt();
		return this.lefts[leftIndex] - this.origin.left;
	},


	// Gets the right offset (from document left) of the element at the given index.
	// This value is NOT relative to the document's right edge, like the CSS concept of "right" would be.
	getRightOffset: function(leftIndex) {
		this.ensureBuilt();
		return this.rights[leftIndex];
	},


	// Gets the right position (from offsetParent left) of the element at the given index.
	// This value is NOT relative to the offsetParent's right edge, like the CSS concept of "right" would be.
	getRightPosition: function(leftIndex) {
		this.ensureBuilt();
		return this.rights[leftIndex] - this.origin.left;
	},


	// Gets the width of the element at the given index
	getWidth: function(leftIndex) {
		this.ensureBuilt();
		return this.rights[leftIndex] - this.lefts[leftIndex];
	},


	// Gets the top offset (from document top) of the element at the given index
	getTopOffset: function(topIndex) {
		this.ensureBuilt();
		return this.tops[topIndex];
	},


	// Gets the top position (from offsetParent top) of the element at the given position
	getTopPosition: function(topIndex) {
		this.ensureBuilt();
		return this.tops[topIndex] - this.origin.top;
	},

	// Gets the bottom offset (from the document top) of the element at the given index.
	// This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of "bottom" would be.
	getBottomOffset: function(topIndex) {
		this.ensureBuilt();
		return this.bottoms[topIndex];
	},


	// Gets the bottom position (from the offsetParent top) of the element at the given index.
	// This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of "bottom" would be.
	getBottomPosition: function(topIndex) {
		this.ensureBuilt();
		return this.bottoms[topIndex] - this.origin.top;
	},


	// Gets the height of the element at the given index
	getHeight: function(topIndex) {
		this.ensureBuilt();
		return this.bottoms[topIndex] - this.tops[topIndex];
	},


	// Bounding Rect
	// TODO: decouple this from CoordCache

	// Compute and return what the elements' bounding rectangle is, from the user's perspective.
	// Right now, only returns a rectangle if constrained by an overflow:scroll element.
	// Returns null if there are no elements
	queryBoundingRect: function() {
		var scrollParentEl;

		if (this.els.length > 0) {
			scrollParentEl = getScrollParent(this.els.eq(0));

			if (!scrollParentEl.is(document)) {
				return getClientRect(scrollParentEl);
			}
		}

		return null;
	},

	isPointInBounds: function(leftOffset, topOffset) {
		return this.isLeftInBounds(leftOffset) && this.isTopInBounds(topOffset);
	},

	isLeftInBounds: function(leftOffset) {
		return !this.boundingRect || (leftOffset >= this.boundingRect.left && leftOffset < this.boundingRect.right);
	},

	isTopInBounds: function(topOffset) {
		return !this.boundingRect || (topOffset >= this.boundingRect.top && topOffset < this.boundingRect.bottom);
	}

});

;;

/* Tracks a drag's mouse movement, firing various handlers
----------------------------------------------------------------------------------------------------------------------*/
// TODO: use Emitter

var DragListener = FC.DragListener = Class.extend(ListenerMixin, MouseIgnorerMixin, {

	options: null,
	subjectEl: null,

	// coordinates of the initial mousedown
	originX: null,
	originY: null,

	// the wrapping element that scrolls, or MIGHT scroll if there's overflow.
	// TODO: do this for wrappers that have overflow:hidden as well.
	scrollEl: null,

	isInteracting: false,
	isDistanceSurpassed: false,
	isDelayEnded: false,
	isDragging: false,
	isTouch: false,

	delay: null,
	delayTimeoutId: null,
	minDistance: null,

	handleTouchScrollProxy: null, // calls handleTouchScroll, always bound to `this`


	constructor: function(options) {
		this.options = options || {};
		this.handleTouchScrollProxy = proxy(this, 'handleTouchScroll');
		this.initMouseIgnoring(500);
	},


	// Interaction (high-level)
	// -----------------------------------------------------------------------------------------------------------------


	startInteraction: function(ev, extraOptions) {
		var isTouch = getEvIsTouch(ev);

		if (ev.type === 'mousedown') {
			if (this.isIgnoringMouse) {
				return;
			}
			else if (!isPrimaryMouseButton(ev)) {
				return;
			}
			else {
				ev.preventDefault(); // prevents native selection in most browsers
			}
		}

		if (!this.isInteracting) {

			// process options
			extraOptions = extraOptions || {};
			this.delay = firstDefined(extraOptions.delay, this.options.delay, 0);
			this.minDistance = firstDefined(extraOptions.distance, this.options.distance, 0);
			this.subjectEl = this.options.subjectEl;

			this.isInteracting = true;
			this.isTouch = isTouch;
			this.isDelayEnded = false;
			this.isDistanceSurpassed = false;

			this.originX = getEvX(ev);
			this.originY = getEvY(ev);
			this.scrollEl = getScrollParent($(ev.target));

			this.bindHandlers();
			this.initAutoScroll();
			this.handleInteractionStart(ev);
			this.startDelay(ev);

			if (!this.minDistance) {
				this.handleDistanceSurpassed(ev);
			}
		}
	},


	handleInteractionStart: function(ev) {
		this.trigger('interactionStart', ev);
	},


	endInteraction: function(ev, isCancelled) {
		if (this.isInteracting) {
			this.endDrag(ev);

			if (this.delayTimeoutId) {
				clearTimeout(this.delayTimeoutId);
				this.delayTimeoutId = null;
			}

			this.destroyAutoScroll();
			this.unbindHandlers();

			this.isInteracting = false;
			this.handleInteractionEnd(ev, isCancelled);

			// a touchstart+touchend on the same element will result in the following addition simulated events:
			// mouseover + mouseout + click
			// let's ignore these bogus events
			if (this.isTouch) {
				this.tempIgnoreMouse();
			}
		}
	},


	handleInteractionEnd: function(ev, isCancelled) {
		this.trigger('interactionEnd', ev, isCancelled || false);
	},


	// Binding To DOM
	// -----------------------------------------------------------------------------------------------------------------


	bindHandlers: function() {
		var _this = this;
		var touchStartIgnores = 1;

		if (this.isTouch) {
			this.listenTo($(document), {
				touchmove: this.handleTouchMove,
				touchend: this.endInteraction,
				touchcancel: this.endInteraction,

				// Sometimes touchend doesn't fire
				// (can't figure out why. touchcancel doesn't fire either. has to do with scrolling?)
				// If another touchstart happens, we know it's bogus, so cancel the drag.
				// touchend will continue to be broken until user does a shorttap/scroll, but this is best we can do.
				touchstart: function(ev) {
					if (touchStartIgnores) { // bindHandlers is called from within a touchstart,
						touchStartIgnores--; // and we don't want this to fire immediately, so ignore.
					}
					else {
						_this.endInteraction(ev, true); // isCancelled=true
					}
				}
			});

			// listen to ALL scroll actions on the page
			if (
				!bindAnyScroll(this.handleTouchScrollProxy) && // hopefully this works and short-circuits the rest
				this.scrollEl // otherwise, attach a single handler to this
			) {
				this.listenTo(this.scrollEl, 'scroll', this.handleTouchScroll);
			}
		}
		else {
			this.listenTo($(document), {
				mousemove: this.handleMouseMove,
				mouseup: this.endInteraction
			});
		}

		this.listenTo($(document), {
			selectstart: preventDefault, // don't allow selection while dragging
			contextmenu: preventDefault // long taps would open menu on Chrome dev tools
		});
	},


	unbindHandlers: function() {
		this.stopListeningTo($(document));

		// unbind scroll listening
		unbindAnyScroll(this.handleTouchScrollProxy);
		if (this.scrollEl) {
			this.stopListeningTo(this.scrollEl, 'scroll');
		}
	},


	// Drag (high-level)
	// -----------------------------------------------------------------------------------------------------------------


	// extraOptions ignored if drag already started
	startDrag: function(ev, extraOptions) {
		this.startInteraction(ev, extraOptions); // ensure interaction began

		if (!this.isDragging) {
			this.isDragging = true;
			this.handleDragStart(ev);
		}
	},


	handleDragStart: function(ev) {
		this.trigger('dragStart', ev);
	},


	handleMove: function(ev) {
		var dx = getEvX(ev) - this.originX;
		var dy = getEvY(ev) - this.originY;
		var minDistance = this.minDistance;
		var distanceSq; // current distance from the origin, squared

		if (!this.isDistanceSurpassed) {
			distanceSq = dx * dx + dy * dy;
			if (distanceSq >= minDistance * minDistance) { // use pythagorean theorem
				this.handleDistanceSurpassed(ev);
			}
		}

		if (this.isDragging) {
			this.handleDrag(dx, dy, ev);
		}
	},


	// Called while the mouse is being moved and when we know a legitimate drag is taking place
	handleDrag: function(dx, dy, ev) {
		this.trigger('drag', dx, dy, ev);
		this.updateAutoScroll(ev); // will possibly cause scrolling
	},


	endDrag: function(ev) {
		if (this.isDragging) {
			this.isDragging = false;
			this.handleDragEnd(ev);
		}
	},


	handleDragEnd: function(ev) {
		this.trigger('dragEnd', ev);
	},


	// Delay
	// -----------------------------------------------------------------------------------------------------------------


	startDelay: function(initialEv) {
		var _this = this;

		if (this.delay) {
			this.delayTimeoutId = setTimeout(function() {
				_this.handleDelayEnd(initialEv);
			}, this.delay);
		}
		else {
			this.handleDelayEnd(initialEv);
		}
	},


	handleDelayEnd: function(initialEv) {
		this.isDelayEnded = true;

		if (this.isDistanceSurpassed) {
			this.startDrag(initialEv);
		}
	},


	// Distance
	// -----------------------------------------------------------------------------------------------------------------


	handleDistanceSurpassed: function(ev) {
		this.isDistanceSurpassed = true;

		if (this.isDelayEnded) {
			this.startDrag(ev);
		}
	},


	// Mouse / Touch
	// -----------------------------------------------------------------------------------------------------------------


	handleTouchMove: function(ev) {
		// prevent inertia and touchmove-scrolling while dragging
		if (this.isDragging) {
			ev.preventDefault();
		}

		this.handleMove(ev);
	},


	handleMouseMove: function(ev) {
		this.handleMove(ev);
	},


	// Scrolling (unrelated to auto-scroll)
	// -----------------------------------------------------------------------------------------------------------------


	handleTouchScroll: function(ev) {
		// if the drag is being initiated by touch, but a scroll happens before
		// the drag-initiating delay is over, cancel the drag
		if (!this.isDragging) {
			this.endInteraction(ev, true); // isCancelled=true
		}
	},


	// Utils
	// -----------------------------------------------------------------------------------------------------------------


	// Triggers a callback. Calls a function in the option hash of the same name.
	// Arguments beyond the first `name` are forwarded on.
	trigger: function(name) {
		if (this.options[name]) {
			this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
		}
		// makes _methods callable by event name. TODO: kill this
		if (this['_' + name]) {
			this['_' + name].apply(this, Array.prototype.slice.call(arguments, 1));
		}
	}


});

;;
/*
this.scrollEl is set in DragListener
*/
DragListener.mixin({

	isAutoScroll: false,

	scrollBounds: null, // { top, bottom, left, right }
	scrollTopVel: null, // pixels per second
	scrollLeftVel: null, // pixels per second
	scrollIntervalId: null, // ID of setTimeout for scrolling animation loop

	// defaults
	scrollSensitivity: 30, // pixels from edge for scrolling to start
	scrollSpeed: 200, // pixels per second, at maximum speed
	scrollIntervalMs: 50, // millisecond wait between scroll increment


	initAutoScroll: function() {
		var scrollEl = this.scrollEl;

		this.isAutoScroll =
			this.options.scroll &&
			scrollEl &&
			!scrollEl.is(window) &&
			!scrollEl.is(document);

		if (this.isAutoScroll) {
			// debounce makes sure rapid calls don't happen
			this.listenTo(scrollEl, 'scroll', debounce(this.handleDebouncedScroll, 100));
		}
	},


	destroyAutoScroll: function() {
		this.endAutoScroll(); // kill any animation loop

		// remove the scroll handler if there is a scrollEl
		if (this.isAutoScroll) {
			this.stopListeningTo(this.scrollEl, 'scroll'); // will probably get removed by unbindHandlers too :(
		}
	},


	// Computes and stores the bounding rectangle of scrollEl
	computeScrollBounds: function() {
		if (this.isAutoScroll) {
			this.scrollBounds = getOuterRect(this.scrollEl);
			// TODO: use getClientRect in future. but prevents auto scrolling when on top of scrollbars
		}
	},


	// Called when the dragging is in progress and scrolling should be updated
	updateAutoScroll: function(ev) {
		var sensitivity = this.scrollSensitivity;
		var bounds = this.scrollBounds;
		var topCloseness, bottomCloseness;
		var leftCloseness, rightCloseness;
		var topVel = 0;
		var leftVel = 0;

		if (bounds) { // only scroll if scrollEl exists

			// compute closeness to edges. valid range is from 0.0 - 1.0
			topCloseness = (sensitivity - (getEvY(ev) - bounds.top)) / sensitivity;
			bottomCloseness = (sensitivity - (bounds.bottom - getEvY(ev))) / sensitivity;
			leftCloseness = (sensitivity - (getEvX(ev) - bounds.left)) / sensitivity;
			rightCloseness = (sensitivity - (bounds.right - getEvX(ev))) / sensitivity;

			// translate vertical closeness into velocity.
			// mouse must be completely in bounds for velocity to happen.
			if (topCloseness >= 0 && topCloseness <= 1) {
				topVel = topCloseness * this.scrollSpeed * -1; // negative. for scrolling up
			}
			else if (bottomCloseness >= 0 && bottomCloseness <= 1) {
				topVel = bottomCloseness * this.scrollSpeed;
			}

			// translate horizontal closeness into velocity
			if (leftCloseness >= 0 && leftCloseness <= 1) {
				leftVel = leftCloseness * this.scrollSpeed * -1; // negative. for scrolling left
			}
			else if (rightCloseness >= 0 && rightCloseness <= 1) {
				leftVel = rightCloseness * this.scrollSpeed;
			}
		}

		this.setScrollVel(topVel, leftVel);
	},


	// Sets the speed-of-scrolling for the scrollEl
	setScrollVel: function(topVel, leftVel) {

		this.scrollTopVel = topVel;
		this.scrollLeftVel = leftVel;

		this.constrainScrollVel(); // massages into realistic values

		// if there is non-zero velocity, and an animation loop hasn't already started, then START
		if ((this.scrollTopVel || this.scrollLeftVel) && !this.scrollIntervalId) {
			this.scrollIntervalId = setInterval(
				proxy(this, 'scrollIntervalFunc'), // scope to `this`
				this.scrollIntervalMs
			);
		}
	},


	// Forces scrollTopVel and scrollLeftVel to be zero if scrolling has already gone all the way
	constrainScrollVel: function() {
		var el = this.scrollEl;

		if (this.scrollTopVel < 0) { // scrolling up?
			if (el.scrollTop() <= 0) { // already scrolled all the way up?
				this.scrollTopVel = 0;
			}
		}
		else if (this.scrollTopVel > 0) { // scrolling down?
			if (el.scrollTop() + el[0].clientHeight >= el[0].scrollHeight) { // already scrolled all the way down?
				this.scrollTopVel = 0;
			}
		}

		if (this.scrollLeftVel < 0) { // scrolling left?
			if (el.scrollLeft() <= 0) { // already scrolled all the left?
				this.scrollLeftVel = 0;
			}
		}
		else if (this.scrollLeftVel > 0) { // scrolling right?
			if (el.scrollLeft() + el[0].clientWidth >= el[0].scrollWidth) { // already scrolled all the way right?
				this.scrollLeftVel = 0;
			}
		}
	},


	// This function gets called during every iteration of the scrolling animation loop
	scrollIntervalFunc: function() {
		var el = this.scrollEl;
		var frac = this.scrollIntervalMs / 1000; // considering animation frequency, what the vel should be mult'd by

		// change the value of scrollEl's scroll
		if (this.scrollTopVel) {
			el.scrollTop(el.scrollTop() + this.scrollTopVel * frac);
		}
		if (this.scrollLeftVel) {
			el.scrollLeft(el.scrollLeft() + this.scrollLeftVel * frac);
		}

		this.constrainScrollVel(); // since the scroll values changed, recompute the velocities

		// if scrolled all the way, which causes the vels to be zero, stop the animation loop
		if (!this.scrollTopVel && !this.scrollLeftVel) {
			this.endAutoScroll();
		}
	},


	// Kills any existing scrolling animation loop
	endAutoScroll: function() {
		if (this.scrollIntervalId) {
			clearInterval(this.scrollIntervalId);
			this.scrollIntervalId = null;

			this.handleScrollEnd();
		}
	},


	// Get called when the scrollEl is scrolled (NOTE: this is delayed via debounce)
	handleDebouncedScroll: function() {
		// recompute all coordinates, but *only* if this is *not* part of our scrolling animation
		if (!this.scrollIntervalId) {
			this.handleScrollEnd();
		}
	},


	// Called when scrolling has stopped, whether through auto scroll, or the user scrolling
	handleScrollEnd: function() {
	}

});
;;

/* Tracks mouse movements over a component and raises events about which hit the mouse is over.
------------------------------------------------------------------------------------------------------------------------
options:
- subjectEl
- subjectCenter
*/

var HitDragListener = DragListener.extend({

	component: null, // converts coordinates to hits
		// methods: prepareHits, releaseHits, queryHit

	origHit: null, // the hit the mouse was over when listening started
	hit: null, // the hit the mouse is over
	coordAdjust: null, // delta that will be added to the mouse coordinates when computing collisions


	constructor: function(component, options) {
		DragListener.call(this, options); // call the super-constructor

		this.component = component;
	},


	// Called when drag listening starts (but a real drag has not necessarily began).
	// ev might be undefined if dragging was started manually.
	handleInteractionStart: function(ev) {
		var subjectEl = this.subjectEl;
		var subjectRect;
		var origPoint;
		var point;

		this.computeCoords();

		if (ev) {
			origPoint = { left: getEvX(ev), top: getEvY(ev) };
			point = origPoint;

			// constrain the point to bounds of the element being dragged
			if (subjectEl) {
				subjectRect = getOuterRect(subjectEl); // used for centering as well
				point = constrainPoint(point, subjectRect);
			}

			this.origHit = this.queryHit(point.left, point.top);

			// treat the center of the subject as the collision point?
			if (subjectEl && this.options.subjectCenter) {

				// only consider the area the subject overlaps the hit. best for large subjects.
				// TODO: skip this if hit didn't supply left/right/top/bottom
				if (this.origHit) {
					subjectRect = intersectRects(this.origHit, subjectRect) ||
						subjectRect; // in case there is no intersection
				}

				point = getRectCenter(subjectRect);
			}

			this.coordAdjust = diffPoints(point, origPoint); // point - origPoint
		}
		else {
			this.origHit = null;
			this.coordAdjust = null;
		}

		// call the super-method. do it after origHit has been computed
		DragListener.prototype.handleInteractionStart.apply(this, arguments);
	},


	// Recomputes the drag-critical positions of elements
	computeCoords: function() {
		this.component.prepareHits();
		this.computeScrollBounds(); // why is this here??????
	},


	// Called when the actual drag has started
	handleDragStart: function(ev) {
		var hit;

		DragListener.prototype.handleDragStart.apply(this, arguments); // call the super-method

		// might be different from this.origHit if the min-distance is large
		hit = this.queryHit(getEvX(ev), getEvY(ev));

		// report the initial hit the mouse is over
		// especially important if no min-distance and drag starts immediately
		if (hit) {
			this.handleHitOver(hit);
		}
	},


	// Called when the drag moves
	handleDrag: function(dx, dy, ev) {
		var hit;

		DragListener.prototype.handleDrag.apply(this, arguments); // call the super-method

		hit = this.queryHit(getEvX(ev), getEvY(ev));

		if (!isHitsEqual(hit, this.hit)) { // a different hit than before?
			if (this.hit) {
				this.handleHitOut();
			}
			if (hit) {
				this.handleHitOver(hit);
			}
		}
	},


	// Called when dragging has been stopped
	handleDragEnd: function() {
		this.handleHitDone();
		DragListener.prototype.handleDragEnd.apply(this, arguments); // call the super-method
	},


	// Called when a the mouse has just moved over a new hit
	handleHitOver: function(hit) {
		var isOrig = isHitsEqual(hit, this.origHit);

		this.hit = hit;

		this.trigger('hitOver', this.hit, isOrig, this.origHit);
	},


	// Called when the mouse has just moved out of a hit
	handleHitOut: function() {
		if (this.hit) {
			this.trigger('hitOut', this.hit);
			this.handleHitDone();
			this.hit = null;
		}
	},


	// Called after a hitOut. Also called before a dragStop
	handleHitDone: function() {
		if (this.hit) {
			this.trigger('hitDone', this.hit);
		}
	},


	// Called when the interaction ends, whether there was a real drag or not
	handleInteractionEnd: function() {
		DragListener.prototype.handleInteractionEnd.apply(this, arguments); // call the super-method

		this.origHit = null;
		this.hit = null;

		this.component.releaseHits();
	},


	// Called when scrolling has stopped, whether through auto scroll, or the user scrolling
	handleScrollEnd: function() {
		DragListener.prototype.handleScrollEnd.apply(this, arguments); // call the super-method

		this.computeCoords(); // hits' absolute positions will be in new places. recompute
	},


	// Gets the hit underneath the coordinates for the given mouse event
	queryHit: function(left, top) {

		if (this.coordAdjust) {
			left += this.coordAdjust.left;
			top += this.coordAdjust.top;
		}

		return this.component.queryHit(left, top);
	}

});


// Returns `true` if the hits are identically equal. `false` otherwise. Must be from the same component.
// Two null values will be considered equal, as two "out of the component" states are the same.
function isHitsEqual(hit0, hit1) {

	if (!hit0 && !hit1) {
		return true;
	}

	if (hit0 && hit1) {
		return hit0.component === hit1.component &&
			isHitPropsWithin(hit0, hit1) &&
			isHitPropsWithin(hit1, hit0); // ensures all props are identical
	}

	return false;
}


// Returns true if all of subHit's non-standard properties are within superHit
function isHitPropsWithin(subHit, superHit) {
	for (var propName in subHit) {
		if (!/^(component|left|right|top|bottom)$/.test(propName)) {
			if (subHit[propName] !== superHit[propName]) {
				return false;
			}
		}
	}
	return true;
}

;;

/* Creates a clone of an element and lets it track the mouse as it moves
----------------------------------------------------------------------------------------------------------------------*/

var MouseFollower = Class.extend(ListenerMixin, {

	options: null,

	sourceEl: null, // the element that will be cloned and made to look like it is dragging
	el: null, // the clone of `sourceEl` that will track the mouse
	parentEl: null, // the element that `el` (the clone) will be attached to

	// the initial position of el, relative to the offset parent. made to match the initial offset of sourceEl
	top0: null,
	left0: null,

	// the absolute coordinates of the initiating touch/mouse action
	y0: null,
	x0: null,

	// the number of pixels the mouse has moved from its initial position
	topDelta: null,
	leftDelta: null,

	isFollowing: false,
	isHidden: false,
	isAnimating: false, // doing the revert animation?

	constructor: function(sourceEl, options) {
		this.options = options = options || {};
		this.sourceEl = sourceEl;
		this.parentEl = options.parentEl ? $(options.parentEl) : sourceEl.parent(); // default to sourceEl's parent
	},


	// Causes the element to start following the mouse
	start: function(ev) {
		if (!this.isFollowing) {
			this.isFollowing = true;

			this.y0 = getEvY(ev);
			this.x0 = getEvX(ev);
			this.topDelta = 0;
			this.leftDelta = 0;

			if (!this.isHidden) {
				this.updatePosition();
			}

			if (getEvIsTouch(ev)) {
				this.listenTo($(document), 'touchmove', this.handleMove);
			}
			else {
				this.listenTo($(document), 'mousemove', this.handleMove);
			}
		}
	},


	// Causes the element to stop following the mouse. If shouldRevert is true, will animate back to original position.
	// `callback` gets invoked when the animation is complete. If no animation, it is invoked immediately.
	stop: function(shouldRevert, callback) {
		var _this = this;
		var revertDuration = this.options.revertDuration;

		function complete() { // might be called by .animate(), which might change `this` context
			_this.isAnimating = false;
			_this.removeElement();

			_this.top0 = _this.left0 = null; // reset state for future updatePosition calls

			if (callback) {
				callback();
			}
		}

		if (this.isFollowing && !this.isAnimating) { // disallow more than one stop animation at a time
			this.isFollowing = false;

			this.stopListeningTo($(document));

			if (shouldRevert && revertDuration && !this.isHidden) { // do a revert animation?
				this.isAnimating = true;
				this.el.animate({
					top: this.top0,
					left: this.left0
				}, {
					duration: revertDuration,
					complete: complete
				});
			}
			else {
				complete();
			}
		}
	},


	// Gets the tracking element. Create it if necessary
	getEl: function() {
		var el = this.el;

		if (!el) {
			el = this.el = this.sourceEl.clone()
				.addClass(this.options.additionalClass || '')
				.css({
					position: 'absolute',
					visibility: '', // in case original element was hidden (commonly through hideEvents())
					display: this.isHidden ? 'none' : '', // for when initially hidden
					margin: 0,
					right: 'auto', // erase and set width instead
					bottom: 'auto', // erase and set height instead
					width: this.sourceEl.width(), // explicit height in case there was a 'right' value
					height: this.sourceEl.height(), // explicit width in case there was a 'bottom' value
					opacity: this.options.opacity || '',
					zIndex: this.options.zIndex
				});

			// we don't want long taps or any mouse interaction causing selection/menus.
			// would use preventSelection(), but that prevents selectstart, causing problems.
			el.addClass('fc-unselectable');

			el.appendTo(this.parentEl);
		}

		return el;
	},


	// Removes the tracking element if it has already been created
	removeElement: function() {
		if (this.el) {
			this.el.remove();
			this.el = null;
		}
	},


	// Update the CSS position of the tracking element
	updatePosition: function() {
		var sourceOffset;
		var origin;

		this.getEl(); // ensure this.el

		// make sure origin info was computed
		if (this.top0 === null) {
			sourceOffset = this.sourceEl.offset();
			origin = this.el.offsetParent().offset();
			this.top0 = sourceOffset.top - origin.top;
			this.left0 = sourceOffset.left - origin.left;
		}

		this.el.css({
			top: this.top0 + this.topDelta,
			left: this.left0 + this.leftDelta
		});
	},


	// Gets called when the user moves the mouse
	handleMove: function(ev) {
		this.topDelta = getEvY(ev) - this.y0;
		this.leftDelta = getEvX(ev) - this.x0;

		if (!this.isHidden) {
			this.updatePosition();
		}
	},


	// Temporarily makes the tracking element invisible. Can be called before following starts
	hide: function() {
		if (!this.isHidden) {
			this.isHidden = true;
			if (this.el) {
				this.el.hide();
			}
		}
	},


	// Show the tracking element after it has been temporarily hidden
	show: function() {
		if (this.isHidden) {
			this.isHidden = false;
			this.updatePosition();
			this.getEl().show();
		}
	}

});

;;

/* An abstract class comprised of a "grid" of areas that each represent a specific datetime
----------------------------------------------------------------------------------------------------------------------*/

var Grid = FC.Grid = Class.extend(ListenerMixin, MouseIgnorerMixin, {

	// self-config, overridable by subclasses
	hasDayInteractions: true, // can user click/select ranges of time?

	view: null, // a View object
	isRTL: null, // shortcut to the view's isRTL option

	start: null,
	end: null,

	el: null, // the containing element
	elsByFill: null, // a hash of jQuery element sets used for rendering each fill. Keyed by fill name.

	// derived from options
	eventTimeFormat: null,
	displayEventTime: null,
	displayEventEnd: null,

	minResizeDuration: null, // TODO: hack. set by subclasses. minumum event resize duration

	// if defined, holds the unit identified (ex: "year" or "month") that determines the level of granularity
	// of the date areas. if not defined, assumes to be day and time granularity.
	// TODO: port isTimeScale into same system?
	largeUnit: null,

	dayDragListener: null,
	segDragListener: null,
	segResizeListener: null,
	externalDragListener: null,


	constructor: function(view) {
		this.view = view;
		this.isRTL = view.opt('isRTL');
		this.elsByFill = {};

		this.dayDragListener = this.buildDayDragListener();
		this.initMouseIgnoring();
	},


	/* Options
	------------------------------------------------------------------------------------------------------------------*/


	// Generates the format string used for event time text, if not explicitly defined by 'timeFormat'
	computeEventTimeFormat: function() {
		return this.view.opt('smallTimeFormat');
	},


	// Determines whether events should have their end times displayed, if not explicitly defined by 'displayEventTime'.
	// Only applies to non-all-day events.
	computeDisplayEventTime: function() {
		return true;
	},


	// Determines whether events should have their end times displayed, if not explicitly defined by 'displayEventEnd'
	computeDisplayEventEnd: function() {
		return true;
	},


	/* Dates
	------------------------------------------------------------------------------------------------------------------*/


	// Tells the grid about what period of time to display.
	// Any date-related internal data should be generated.
	setRange: function(range) {
		this.start = range.start.clone();
		this.end = range.end.clone();

		this.rangeUpdated();
		this.processRangeOptions();
	},


	// Called when internal variables that rely on the range should be updated
	rangeUpdated: function() {
	},


	// Updates values that rely on options and also relate to range
	processRangeOptions: function() {
		var view = this.view;
		var displayEventTime;
		var displayEventEnd;

		this.eventTimeFormat =
			view.opt('eventTimeFormat') ||
			view.opt('timeFormat') || // deprecated
			this.computeEventTimeFormat();

		displayEventTime = view.opt('displayEventTime');
		if (displayEventTime == null) {
			displayEventTime = this.computeDisplayEventTime(); // might be based off of range
		}

		displayEventEnd = view.opt('displayEventEnd');
		if (displayEventEnd == null) {
			displayEventEnd = this.computeDisplayEventEnd(); // might be based off of range
		}

		this.displayEventTime = displayEventTime;
		this.displayEventEnd = displayEventEnd;
	},


	// Converts a span (has unzoned start/end and any other grid-specific location information)
	// into an array of segments (pieces of events whose format is decided by the grid).
	spanToSegs: function(span) {
		// subclasses must implement
	},


	// Diffs the two dates, returning a duration, based on granularity of the grid
	// TODO: port isTimeScale into this system?
	diffDates: function(a, b) {
		if (this.largeUnit) {
			return diffByUnit(a, b, this.largeUnit);
		}
		else {
			return diffDayTime(a, b);
		}
	},


	/* Hit Area
	------------------------------------------------------------------------------------------------------------------*/


	// Called before one or more queryHit calls might happen. Should prepare any cached coordinates for queryHit
	prepareHits: function() {
	},


	// Called when queryHit calls have subsided. Good place to clear any coordinate caches.
	releaseHits: function() {
	},


	// Given coordinates from the topleft of the document, return data about the date-related area underneath.
	// Can return an object with arbitrary properties (although top/right/left/bottom are encouraged).
	// Must have a `grid` property, a reference to this current grid. TODO: avoid this
	// The returned object will be processed by getHitSpan and getHitEl.
	queryHit: function(leftOffset, topOffset) {
	},


	// Given position-level information about a date-related area within the grid,
	// should return an object with at least a start/end date. Can provide other information as well.
	getHitSpan: function(hit) {
	},


	// Given position-level information about a date-related area within the grid,
	// should return a jQuery element that best represents it. passed to dayClick callback.
	getHitEl: function(hit) {
	},


	/* Rendering
	------------------------------------------------------------------------------------------------------------------*/


	// Sets the container element that the grid should render inside of.
	// Does other DOM-related initializations.
	setElement: function(el) {
		this.el = el;

		if (this.hasDayInteractions) {
			preventSelection(el);

			this.bindDayHandler('touchstart', this.dayTouchStart);
			this.bindDayHandler('mousedown', this.dayMousedown);
		}

		// attach event-element-related handlers. in Grid.events
		// same garbage collection note as above.
		this.bindSegHandlers();

		this.bindGlobalHandlers();
	},


	bindDayHandler: function(name, handler) {
		var _this = this;

		// attach a handler to the grid's root element.
		// jQuery will take care of unregistering them when removeElement gets called.
		this.el.on(name, function(ev) {
			if (
				!$(ev.target).is(
					_this.segSelector + ',' + // directly on an event element
					_this.segSelector + ' *,' + // within an event element
					'.fc-more,' + // a "more.." link
					'a[data-goto]' // a clickable nav link
				)
			) {
				return handler.call(_this, ev);
			}
		});
	},


	// Removes the grid's container element from the DOM. Undoes any other DOM-related attachments.
	// DOES NOT remove any content beforehand (doesn't clear events or call unrenderDates), unlike View
	removeElement: function() {
		this.unbindGlobalHandlers();
		this.clearDragListeners();

		this.el.remove();

		// NOTE: we don't null-out this.el for the same reasons we don't do it within View::removeElement
	},


	// Renders the basic structure of grid view before any content is rendered
	renderSkeleton: function() {
		// subclasses should implement
	},


	// Renders the grid's date-related content (like areas that represent days/times).
	// Assumes setRange has already been called and the skeleton has already been rendered.
	renderDates: function() {
		// subclasses should implement
	},


	// Unrenders the grid's date-related content
	unrenderDates: function() {
		// subclasses should implement
	},


	/* Handlers
	------------------------------------------------------------------------------------------------------------------*/


	// Binds DOM handlers to elements that reside outside the grid, such as the document
	bindGlobalHandlers: function() {
		this.listenTo($(document), {
			dragstart: this.externalDragStart, // jqui
			sortstart: this.externalDragStart // jqui
		});
	},


	// Unbinds DOM handlers from elements that reside outside the grid
	unbindGlobalHandlers: function() {
		this.stopListeningTo($(document));
	},


	// Process a mousedown on an element that represents a day. For day clicking and selecting.
	dayMousedown: function(ev) {
		if (!this.isIgnoringMouse) {
			this.dayDragListener.startInteraction(ev, {
				//distance: 5, // needs more work if we want dayClick to fire correctly
			});
		}
	},


	dayTouchStart: function(ev) {
		var view = this.view;
		var selectLongPressDelay = view.opt('selectLongPressDelay');

		// HACK to prevent a user's clickaway for unselecting a range or an event
		// from causing a dayClick.
		if (view.isSelected || view.selectedEvent) {
			this.tempIgnoreMouse();
		}

		if (selectLongPressDelay == null) {
			selectLongPressDelay = view.opt('longPressDelay'); // fallback
		}

		this.dayDragListener.startInteraction(ev, {
			delay: selectLongPressDelay
		});
	},


	// Creates a listener that tracks the user's drag across day elements.
	// For day clicking and selecting.
	buildDayDragListener: function() {
		var _this = this;
		var view = this.view;
		var isSelectable = view.opt('selectable');
		var dayClickHit; // null if invalid dayClick
		var selectionSpan; // null if invalid selection

		// this listener tracks a mousedown on a day element, and a subsequent drag.
		// if the drag ends on the same day, it is a 'dayClick'.
		// if 'selectable' is enabled, this listener also detects selections.
		var dragListener = new HitDragListener(this, {
			scroll: view.opt('dragScroll'),
			interactionStart: function() {
				dayClickHit = dragListener.origHit; // for dayClick, where no dragging happens
				selectionSpan = null;
			},
			dragStart: function() {
				view.unselect(); // since we could be rendering a new selection, we want to clear any old one
			},
			hitOver: function(hit, isOrig, origHit) {
				if (origHit) { // click needs to have started on a hit

					// if user dragged to another cell at any point, it can no longer be a dayClick
					if (!isOrig) {
						dayClickHit = null;
					}

					if (isSelectable) {
						selectionSpan = _this.computeSelection(
							_this.getHitSpan(origHit),
							_this.getHitSpan(hit)
						);
						if (selectionSpan) {
							_this.renderSelection(selectionSpan);
						}
						else if (selectionSpan === false) {
							disableCursor();
						}
					}
				}
			},
			hitOut: function() { // called before mouse moves to a different hit OR moved out of all hits
				dayClickHit = null;
				selectionSpan = null;
				_this.unrenderSelection();
			},
			hitDone: function() { // called after a hitOut OR before a dragEnd
				enableCursor();
			},
			interactionEnd: function(ev, isCancelled) {
				if (!isCancelled) {
					if (
						dayClickHit &&
						!_this.isIgnoringMouse // see hack in dayTouchStart
					) {
						view.triggerDayClick(
							_this.getHitSpan(dayClickHit),
							_this.getHitEl(dayClickHit),
							ev
						);
					}
					if (selectionSpan) {
						// the selection will already have been rendered. just report it
						view.reportSelection(selectionSpan, ev);
					}
				}
			}
		});

		return dragListener;
	},


	// Kills all in-progress dragging.
	// Useful for when public API methods that result in re-rendering are invoked during a drag.
	// Also useful for when touch devices misbehave and don't fire their touchend.
	clearDragListeners: function() {
		this.dayDragListener.endInteraction();

		if (this.segDragListener) {
			this.segDragListener.endInteraction(); // will clear this.segDragListener
		}
		if (this.segResizeListener) {
			this.segResizeListener.endInteraction(); // will clear this.segResizeListener
		}
		if (this.externalDragListener) {
			this.externalDragListener.endInteraction(); // will clear this.externalDragListener
		}
	},


	/* Event Helper
	------------------------------------------------------------------------------------------------------------------*/
	// TODO: should probably move this to Grid.events, like we did event dragging / resizing


	// Renders a mock event at the given event location, which contains zoned start/end properties.
	// Returns all mock event elements.
	renderEventLocationHelper: function(eventLocation, sourceSeg) {
		var fakeEvent = this.fabricateHelperEvent(eventLocation, sourceSeg);

		return this.renderHelper(fakeEvent, sourceSeg); // do the actual rendering
	},


	// Builds a fake event given zoned event date properties and a segment is should be inspired from.
	// The range's end can be null, in which case the mock event that is rendered will have a null end time.
	// `sourceSeg` is the internal segment object involved in the drag. If null, something external is dragging.
	fabricateHelperEvent: function(eventLocation, sourceSeg) {
		var fakeEvent = sourceSeg ? createObject(sourceSeg.event) : {}; // mask the original event object if possible

		fakeEvent.start = eventLocation.start.clone();
		fakeEvent.end = eventLocation.end ? eventLocation.end.clone() : null;
		fakeEvent.allDay = null; // force it to be freshly computed by normalizeEventDates
		this.view.calendar.normalizeEventDates(fakeEvent);

		// this extra className will be useful for differentiating real events from mock events in CSS
		fakeEvent.className = (fakeEvent.className || []).concat('fc-helper');

		// if something external is being dragged in, don't render a resizer
		if (!sourceSeg) {
			fakeEvent.editable = false;
		}

		return fakeEvent;
	},


	// Renders a mock event. Given zoned event date properties.
	// Must return all mock event elements.
	renderHelper: function(eventLocation, sourceSeg) {
		// subclasses must implement
	},


	// Unrenders a mock event
	unrenderHelper: function() {
		// subclasses must implement
	},


	/* Selection
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of a selection. Will highlight by default but can be overridden by subclasses.
	// Given a span (unzoned start/end and other misc data)
	renderSelection: function(span) {
		this.renderHighlight(span);
	},


	// Unrenders any visual indications of a selection. Will unrender a highlight by default.
	unrenderSelection: function() {
		this.unrenderHighlight();
	},


	// Given the first and last date-spans of a selection, returns another date-span object.
	// Subclasses can override and provide additional data in the span object. Will be passed to renderSelection().
	// Will return false if the selection is invalid and this should be indicated to the user.
	// Will return null/undefined if a selection invalid but no error should be reported.
	computeSelection: function(span0, span1) {
		var span = this.computeSelectionSpan(span0, span1);

		if (span && !this.view.calendar.isSelectionSpanAllowed(span)) {
			return false;
		}

		return span;
	},


	// Given two spans, must return the combination of the two.
	// TODO: do this separation of concerns (combining VS validation) for event dnd/resize too.
	computeSelectionSpan: function(span0, span1) {
		var dates = [ span0.start, span0.end, span1.start, span1.end ];

		dates.sort(compareNumbers); // sorts chronologically. works with Moments

		return { start: dates[0].clone(), end: dates[3].clone() };
	},


	/* Highlight
	------------------------------------------------------------------------------------------------------------------*/


	// Renders an emphasis on the given date range. Given a span (unzoned start/end and other misc data)
	renderHighlight: function(span) {
		this.renderFill('highlight', this.spanToSegs(span));
	},


	// Unrenders the emphasis on a date range
	unrenderHighlight: function() {
		this.unrenderFill('highlight');
	},


	// Generates an array of classNames for rendering the highlight. Used by the fill system.
	highlightSegClasses: function() {
		return [ 'fc-highlight' ];
	},


	/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/


	renderBusinessHours: function() {
	},


	unrenderBusinessHours: function() {
	},


	/* Now Indicator
	------------------------------------------------------------------------------------------------------------------*/


	getNowIndicatorUnit: function() {
	},


	renderNowIndicator: function(date) {
	},


	unrenderNowIndicator: function() {
	},


	/* Fill System (highlight, background events, business hours)
	--------------------------------------------------------------------------------------------------------------------
	TODO: remove this system. like we did in TimeGrid
	*/


	// Renders a set of rectangles over the given segments of time.
	// MUST RETURN a subset of segs, the segs that were actually rendered.
	// Responsible for populating this.elsByFill. TODO: better API for expressing this requirement
	renderFill: function(type, segs) {
		// subclasses must implement
	},


	// Unrenders a specific type of fill that is currently rendered on the grid
	unrenderFill: function(type) {
		var el = this.elsByFill[type];

		if (el) {
			el.remove();
			delete this.elsByFill[type];
		}
	},


	// Renders and assigns an `el` property for each fill segment. Generic enough to work with different types.
	// Only returns segments that successfully rendered.
	// To be harnessed by renderFill (implemented by subclasses).
	// Analagous to renderFgSegEls.
	renderFillSegEls: function(type, segs) {
		var _this = this;
		var segElMethod = this[type + 'SegEl'];
		var html = '';
		var renderedSegs = [];
		var i;

		if (segs.length) {

			// build a large concatenation of segment HTML
			for (i = 0; i < segs.length; i++) {
				html += this.fillSegHtml(type, segs[i]);
			}

			// Grab individual elements from the combined HTML string. Use each as the default rendering.
			// Then, compute the 'el' for each segment.
			$(html).each(function(i, node) {
				var seg = segs[i];
				var el = $(node);

				// allow custom filter methods per-type
				if (segElMethod) {
					el = segElMethod.call(_this, seg, el);
				}

				if (el) { // custom filters did not cancel the render
					el = $(el); // allow custom filter to return raw DOM node

					// correct element type? (would be bad if a non-TD were inserted into a table for example)
					if (el.is(_this.fillSegTag)) {
						seg.el = el;
						renderedSegs.push(seg);
					}
				}
			});
		}

		return renderedSegs;
	},


	fillSegTag: 'div', // subclasses can override


	// Builds the HTML needed for one fill segment. Generic enough to work with different types.
	fillSegHtml: function(type, seg) {

		// custom hooks per-type
		var classesMethod = this[type + 'SegClasses'];
		var cssMethod = this[type + 'SegCss'];

		var classes = classesMethod ? classesMethod.call(this, seg) : [];
		var css = cssToStr(cssMethod ? cssMethod.call(this, seg) : {});

		return '<' + this.fillSegTag +
			(classes.length ? ' class="' + classes.join(' ') + '"' : '') +
			(css ? ' style="' + css + '"' : '') +
			' />';
	},



	/* Generic rendering utilities for subclasses
	------------------------------------------------------------------------------------------------------------------*/


	// Computes HTML classNames for a single-day element
	getDayClasses: function(date, noThemeHighlight) {
		var view = this.view;
		var today = view.calendar.getNow();
		var classes = [ 'fc-' + dayIDs[date.day()] ];

		if (
			view.intervalDuration.as('months') == 1 &&
			date.month() != view.intervalStart.month()
		) {
			classes.push('fc-other-month');
		}

		if (date.isSame(today, 'day')) {
			classes.push('fc-today');

			if (noThemeHighlight !== true) {
				classes.push(view.highlightStateClass);
			}
		}
		else if (date < today) {
			classes.push('fc-past');
		}
		else {
			classes.push('fc-future');
		}

		return classes;
	}

});

;;

/* Event-rendering and event-interaction methods for the abstract Grid class
----------------------------------------------------------------------------------------------------------------------*/

Grid.mixin({

	// self-config, overridable by subclasses
	segSelector: '.fc-event-container > *', // what constitutes an event element?

	mousedOverSeg: null, // the segment object the user's mouse is over. null if over nothing
	isDraggingSeg: false, // is a segment being dragged? boolean
	isResizingSeg: false, // is a segment being resized? boolean
	isDraggingExternal: false, // jqui-dragging an external element? boolean
	segs: null, // the *event* segments currently rendered in the grid. TODO: rename to `eventSegs`


	// Renders the given events onto the grid
	renderEvents: function(events) {
		var bgEvents = [];
		var fgEvents = [];
		var i;

		for (i = 0; i < events.length; i++) {
			(isBgEvent(events[i]) ? bgEvents : fgEvents).push(events[i]);
		}

		this.segs = [].concat( // record all segs
			this.renderBgEvents(bgEvents),
			this.renderFgEvents(fgEvents)
		);
	},


	renderBgEvents: function(events) {
		var segs = this.eventsToSegs(events);

		// renderBgSegs might return a subset of segs, segs that were actually rendered
		return this.renderBgSegs(segs) || segs;
	},


	renderFgEvents: function(events) {
		var segs = this.eventsToSegs(events);

		// renderFgSegs might return a subset of segs, segs that were actually rendered
		return this.renderFgSegs(segs) || segs;
	},


	// Unrenders all events currently rendered on the grid
	unrenderEvents: function() {
		this.handleSegMouseout(); // trigger an eventMouseout if user's mouse is over an event
		this.clearDragListeners();

		this.unrenderFgSegs();
		this.unrenderBgSegs();

		this.segs = null;
	},


	// Retrieves all rendered segment objects currently rendered on the grid
	getEventSegs: function() {
		return this.segs || [];
	},


	/* Foreground Segment Rendering
	------------------------------------------------------------------------------------------------------------------*/


	// Renders foreground event segments onto the grid. May return a subset of segs that were rendered.
	renderFgSegs: function(segs) {
		// subclasses must implement
	},


	// Unrenders all currently rendered foreground segments
	unrenderFgSegs: function() {
		// subclasses must implement
	},


	// Renders and assigns an `el` property for each foreground event segment.
	// Only returns segments that successfully rendered.
	// A utility that subclasses may use.
	renderFgSegEls: function(segs, disableResizing) {
		var view = this.view;
		var html = '';
		var renderedSegs = [];
		var i;

		if (segs.length) { // don't build an empty html string

			// build a large concatenation of event segment HTML
			for (i = 0; i < segs.length; i++) {
				html += this.fgSegHtml(segs[i], disableResizing);
			}

			// Grab individual elements from the combined HTML string. Use each as the default rendering.
			// Then, compute the 'el' for each segment. An el might be null if the eventRender callback returned false.
			$(html).each(function(i, node) {
				var seg = segs[i];
				var el = view.resolveEventEl(seg.event, $(node));

				if (el) {
					el.data('fc-seg', seg); // used by handlers
					seg.el = el;
					renderedSegs.push(seg);
				}
			});
		}

		return renderedSegs;
	},


	// Generates the HTML for the default rendering of a foreground event segment. Used by renderFgSegEls()
	fgSegHtml: function(seg, disableResizing) {
		// subclasses should implement
	},


	/* Background Segment Rendering
	------------------------------------------------------------------------------------------------------------------*/


	// Renders the given background event segments onto the grid.
	// Returns a subset of the segs that were actually rendered.
	renderBgSegs: function(segs) {
		return this.renderFill('bgEvent', segs);
	},


	// Unrenders all the currently rendered background event segments
	unrenderBgSegs: function() {
		this.unrenderFill('bgEvent');
	},


	// Renders a background event element, given the default rendering. Called by the fill system.
	bgEventSegEl: function(seg, el) {
		return this.view.resolveEventEl(seg.event, el); // will filter through eventRender
	},


	// Generates an array of classNames to be used for the default rendering of a background event.
	// Called by fillSegHtml.
	bgEventSegClasses: function(seg) {
		var event = seg.event;
		var source = event.source || {};

		return [ 'fc-bgevent' ].concat(
			event.className,
			source.className || []
		);
	},


	// Generates a semicolon-separated CSS string to be used for the default rendering of a background event.
	// Called by fillSegHtml.
	bgEventSegCss: function(seg) {
		return {
			'background-color': this.getSegSkinCss(seg)['background-color']
		};
	},


	// Generates an array of classNames to be used for the rendering business hours overlay. Called by the fill system.
	// Called by fillSegHtml.
	businessHoursSegClasses: function(seg) {
		return [ 'fc-nonbusiness', 'fc-bgevent' ];
	},


	/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/


	// Compute business hour segs for the grid's current date range.
	// Caller must ask if whole-day business hours are needed.
	// If no `businessHours` configuration value is specified, assumes the calendar default.
	buildBusinessHourSegs: function(wholeDay, businessHours) {
		return this.eventsToSegs(
			this.buildBusinessHourEvents(wholeDay, businessHours)
		);
	},


	// Compute business hour *events* for the grid's current date range.
	// Caller must ask if whole-day business hours are needed.
	// If no `businessHours` configuration value is specified, assumes the calendar default.
	buildBusinessHourEvents: function(wholeDay, businessHours) {
		var calendar = this.view.calendar;
		var events;

		if (businessHours == null) {
			// fallback
			// access from calendawr. don't access from view. doesn't update with dynamic options.
			businessHours = calendar.options.businessHours;
		}

		events = calendar.computeBusinessHourEvents(wholeDay, businessHours);

		// HACK. Eventually refactor business hours "events" system.
		// If no events are given, but businessHours is activated, this means the entire visible range should be
		// marked as *not* business-hours, via inverse-background rendering.
		if (!events.length && businessHours) {
			events = [
				$.extend({}, BUSINESS_HOUR_EVENT_DEFAULTS, {
					start: this.view.end, // guaranteed out-of-range
					end: this.view.end,   // "
					dow: null
				})
			];
		}

		return events;
	},


	/* Handlers
	------------------------------------------------------------------------------------------------------------------*/


	// Attaches event-element-related handlers for *all* rendered event segments of the view.
	bindSegHandlers: function() {
		this.bindSegHandlersToEl(this.el);
	},


	// Attaches event-element-related handlers to an arbitrary container element. leverages bubbling.
	bindSegHandlersToEl: function(el) {
		this.bindSegHandlerToEl(el, 'touchstart', this.handleSegTouchStart);
		this.bindSegHandlerToEl(el, 'touchend', this.handleSegTouchEnd);
		this.bindSegHandlerToEl(el, 'mouseenter', this.handleSegMouseover);
		this.bindSegHandlerToEl(el, 'mouseleave', this.handleSegMouseout);
		this.bindSegHandlerToEl(el, 'mousedown', this.handleSegMousedown);
		this.bindSegHandlerToEl(el, 'click', this.handleSegClick);
	},


	// Executes a handler for any a user-interaction on a segment.
	// Handler gets called with (seg, ev), and with the `this` context of the Grid
	bindSegHandlerToEl: function(el, name, handler) {
		var _this = this;

		el.on(name, this.segSelector, function(ev) {
			var seg = $(this).data('fc-seg'); // grab segment data. put there by View::renderEvents

			// only call the handlers if there is not a drag/resize in progress
			if (seg && !_this.isDraggingSeg && !_this.isResizingSeg) {
				return handler.call(_this, seg, ev); // context will be the Grid
			}
		});
	},


	handleSegClick: function(seg, ev) {
		var res = this.view.publiclyTrigger('eventClick', seg.el[0], seg.event, ev); // can return `false` to cancel
		if (res === false) {
			ev.preventDefault();
		}
	},


	// Updates internal state and triggers handlers for when an event element is moused over
	handleSegMouseover: function(seg, ev) {
		if (
			!this.isIgnoringMouse &&
			!this.mousedOverSeg
		) {
			this.mousedOverSeg = seg;
			if (this.view.isEventResizable(seg.event)) {
				seg.el.addClass('fc-allow-mouse-resize');
			}
			this.view.publiclyTrigger('eventMouseover', seg.el[0], seg.event, ev);
		}
	},


	// Updates internal state and triggers handlers for when an event element is moused out.
	// Can be given no arguments, in which case it will mouseout the segment that was previously moused over.
	handleSegMouseout: function(seg, ev) {
		ev = ev || {}; // if given no args, make a mock mouse event

		if (this.mousedOverSeg) {
			seg = seg || this.mousedOverSeg; // if given no args, use the currently moused-over segment
			this.mousedOverSeg = null;
			if (this.view.isEventResizable(seg.event)) {
				seg.el.removeClass('fc-allow-mouse-resize');
			}
			this.view.publiclyTrigger('eventMouseout', seg.el[0], seg.event, ev);
		}
	},


	handleSegMousedown: function(seg, ev) {
		var isResizing = this.startSegResize(seg, ev, { distance: 5 });

		if (!isResizing && this.view.isEventDraggable(seg.event)) {
			this.buildSegDragListener(seg)
				.startInteraction(ev, {
					distance: 5
				});
		}
	},


	handleSegTouchStart: function(seg, ev) {
		var view = this.view;
		var event = seg.event;
		var isSelected = view.isEventSelected(event);
		var isDraggable = view.isEventDraggable(event);
		var isResizable = view.isEventResizable(event);
		var isResizing = false;
		var dragListener;
		var eventLongPressDelay;

		if (isSelected && isResizable) {
			// only allow resizing of the event is selected
			isResizing = this.startSegResize(seg, ev);
		}

		if (!isResizing && (isDraggable || isResizable)) { // allowed to be selected?

			eventLongPressDelay = view.opt('eventLongPressDelay');
			if (eventLongPressDelay == null) {
				eventLongPressDelay = view.opt('longPressDelay'); // fallback
			}

			dragListener = isDraggable ?
				this.buildSegDragListener(seg) :
				this.buildSegSelectListener(seg); // seg isn't draggable, but still needs to be selected

			dragListener.startInteraction(ev, { // won't start if already started
				delay: isSelected ? 0 : eventLongPressDelay // do delay if not already selected
			});
		}

		// a long tap simulates a mouseover. ignore this bogus mouseover.
		this.tempIgnoreMouse();
	},


	handleSegTouchEnd: function(seg, ev) {
		// touchstart+touchend = click, which simulates a mouseover.
		// ignore this bogus mouseover.
		this.tempIgnoreMouse();
	},


	// returns boolean whether resizing actually started or not.
	// assumes the seg allows resizing.
	// `dragOptions` are optional.
	startSegResize: function(seg, ev, dragOptions) {
		if ($(ev.target).is('.fc-resizer')) {
			this.buildSegResizeListener(seg, $(ev.target).is('.fc-start-resizer'))
				.startInteraction(ev, dragOptions);
			return true;
		}
		return false;
	},



	/* Event Dragging
	------------------------------------------------------------------------------------------------------------------*/


	// Builds a listener that will track user-dragging on an event segment.
	// Generic enough to work with any type of Grid.
	// Has side effect of setting/unsetting `segDragListener`
	buildSegDragListener: function(seg) {
		var _this = this;
		var view = this.view;
		var calendar = view.calendar;
		var el = seg.el;
		var event = seg.event;
		var isDragging;
		var mouseFollower; // A clone of the original element that will move with the mouse
		var dropLocation; // zoned event date properties

		if (this.segDragListener) {
			return this.segDragListener;
		}

		// Tracks mouse movement over the *view's* coordinate map. Allows dragging and dropping between subcomponents
		// of the view.
		var dragListener = this.segDragListener = new HitDragListener(view, {
			scroll: view.opt('dragScroll'),
			subjectEl: el,
			subjectCenter: true,
			interactionStart: function(ev) {
				seg.component = _this; // for renderDrag
				isDragging = false;
				mouseFollower = new MouseFollower(seg.el, {
					additionalClass: 'fc-dragging',
					parentEl: view.el,
					opacity: dragListener.isTouch ? null : view.opt('dragOpacity'),
					revertDuration: view.opt('dragRevertDuration'),
					zIndex: 2 // one above the .fc-view
				});
				mouseFollower.hide(); // don't show until we know this is a real drag
				mouseFollower.start(ev);
			},
			dragStart: function(ev) {
				if (dragListener.isTouch && !view.isEventSelected(event)) {
					// if not previously selected, will fire after a delay. then, select the event
					view.selectEvent(event);
				}
				isDragging = true;
				_this.handleSegMouseout(seg, ev); // ensure a mouseout on the manipulated event has been reported
				_this.segDragStart(seg, ev);
				view.hideEvent(event); // hide all event segments. our mouseFollower will take over
			},
			hitOver: function(hit, isOrig, origHit) {
				var dragHelperEls;

				// starting hit could be forced (DayGrid.limit)
				if (seg.hit) {
					origHit = seg.hit;
				}

				// since we are querying the parent view, might not belong to this grid
				dropLocation = _this.computeEventDrop(
					origHit.component.getHitSpan(origHit),
					hit.component.getHitSpan(hit),
					event
				);

				if (dropLocation && !calendar.isEventSpanAllowed(_this.eventToSpan(dropLocation), event)) {
					disableCursor();
					dropLocation = null;
				}

				// if a valid drop location, have the subclass render a visual indication
				if (dropLocation && (dragHelperEls = view.renderDrag(dropLocation, seg))) {

					dragHelperEls.addClass('fc-dragging');
					if (!dragListener.isTouch) {
						_this.applyDragOpacity(dragHelperEls);
					}

					mouseFollower.hide(); // if the subclass is already using a mock event "helper", hide our own
				}
				else {
					mouseFollower.show(); // otherwise, have the helper follow the mouse (no snapping)
				}

				if (isOrig) {
					dropLocation = null; // needs to have moved hits to be a valid drop
				}
			},
			hitOut: function() { // called before mouse moves to a different hit OR moved out of all hits
				view.unrenderDrag(); // unrender whatever was done in renderDrag
				mouseFollower.show(); // show in case we are moving out of all hits
				dropLocation = null;
			},
			hitDone: function() { // Called after a hitOut OR before a dragEnd
				enableCursor();
			},
			interactionEnd: function(ev) {
				delete seg.component; // prevent side effects

				// do revert animation if hasn't changed. calls a callback when finished (whether animation or not)
				mouseFollower.stop(!dropLocation, function() {
					if (isDragging) {
						view.unrenderDrag();
						_this.segDragStop(seg, ev);
					}

					if (dropLocation) {
						// no need to re-show original, will rerender all anyways. esp important if eventRenderWait
						view.reportEventDrop(event, dropLocation, _this.largeUnit, el, ev);
					}
					else {
						view.showEvent(event);
					}
				});
				_this.segDragListener = null;
			}
		});

		return dragListener;
	},


	// seg isn't draggable, but let's use a generic DragListener
	// simply for the delay, so it can be selected.
	// Has side effect of setting/unsetting `segDragListener`
	buildSegSelectListener: function(seg) {
		var _this = this;
		var view = this.view;
		var event = seg.event;

		if (this.segDragListener) {
			return this.segDragListener;
		}

		var dragListener = this.segDragListener = new DragListener({
			dragStart: function(ev) {
				if (dragListener.isTouch && !view.isEventSelected(event)) {
					// if not previously selected, will fire after a delay. then, select the event
					view.selectEvent(event);
				}
			},
			interactionEnd: function(ev) {
				_this.segDragListener = null;
			}
		});

		return dragListener;
	},


	// Called before event segment dragging starts
	segDragStart: function(seg, ev) {
		this.isDraggingSeg = true;
		this.view.publiclyTrigger('eventDragStart', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
	},


	// Called after event segment dragging stops
	segDragStop: function(seg, ev) {
		this.isDraggingSeg = false;
		this.view.publiclyTrigger('eventDragStop', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
	},


	// Given the spans an event drag began, and the span event was dropped, calculates the new zoned start/end/allDay
	// values for the event. Subclasses may override and set additional properties to be used by renderDrag.
	// A falsy returned value indicates an invalid drop.
	// DOES NOT consider overlap/constraint.
	computeEventDrop: function(startSpan, endSpan, event) {
		var calendar = this.view.calendar;
		var dragStart = startSpan.start;
		var dragEnd = endSpan.start;
		var delta;
		var dropLocation; // zoned event date properties

		if (dragStart.hasTime() === dragEnd.hasTime()) {
			delta = this.diffDates(dragEnd, dragStart);

			// if an all-day event was in a timed area and it was dragged to a different time,
			// guarantee an end and adjust start/end to have times
			if (event.allDay && durationHasTime(delta)) {
				dropLocation = {
					start: event.start.clone(),
					end: calendar.getEventEnd(event), // will be an ambig day
					allDay: false // for normalizeEventTimes
				};
				calendar.normalizeEventTimes(dropLocation);
			}
			// othewise, work off existing values
			else {
				dropLocation = pluckEventDateProps(event);
			}

			dropLocation.start.add(delta);
			if (dropLocation.end) {
				dropLocation.end.add(delta);
			}
		}
		else {
			// if switching from day <-> timed, start should be reset to the dropped date, and the end cleared
			dropLocation = {
				start: dragEnd.clone(),
				end: null, // end should be cleared
				allDay: !dragEnd.hasTime()
			};
		}

		return dropLocation;
	},


	// Utility for apply dragOpacity to a jQuery set
	applyDragOpacity: function(els) {
		var opacity = this.view.opt('dragOpacity');

		if (opacity != null) {
			els.css('opacity', opacity);
		}
	},


	/* External Element Dragging
	------------------------------------------------------------------------------------------------------------------*/


	// Called when a jQuery UI drag is initiated anywhere in the DOM
	externalDragStart: function(ev, ui) {
		var view = this.view;
		var el;
		var accept;

		if (view.opt('droppable')) { // only listen if this setting is on
			el = $((ui ? ui.item : null) || ev.target);

			// Test that the dragged element passes the dropAccept selector or filter function.
			// FYI, the default is "*" (matches all)
			accept = view.opt('dropAccept');
			if ($.isFunction(accept) ? accept.call(el[0], el) : el.is(accept)) {
				if (!this.isDraggingExternal) { // prevent double-listening if fired twice
					this.listenToExternalDrag(el, ev, ui);
				}
			}
		}
	},


	// Called when a jQuery UI drag starts and it needs to be monitored for dropping
	listenToExternalDrag: function(el, ev, ui) {
		var _this = this;
		var calendar = this.view.calendar;
		var meta = getDraggedElMeta(el); // extra data about event drop, including possible event to create
		var dropLocation; // a null value signals an unsuccessful drag

		// listener that tracks mouse movement over date-associated pixel regions
		var dragListener = _this.externalDragListener = new HitDragListener(this, {
			interactionStart: function() {
				_this.isDraggingExternal = true;
			},
			hitOver: function(hit) {
				dropLocation = _this.computeExternalDrop(
					hit.component.getHitSpan(hit), // since we are querying the parent view, might not belong to this grid
					meta
				);

				if ( // invalid hit?
					dropLocation &&
					!calendar.isExternalSpanAllowed(_this.eventToSpan(dropLocation), dropLocation, meta.eventProps)
				) {
					disableCursor();
					dropLocation = null;
				}

				if (dropLocation) {
					_this.renderDrag(dropLocation); // called without a seg parameter
				}
			},
			hitOut: function() {
				dropLocation = null; // signal unsuccessful
			},
			hitDone: function() { // Called after a hitOut OR before a dragEnd
				enableCursor();
				_this.unrenderDrag();
			},
			interactionEnd: function(ev) {
				if (dropLocation) { // element was dropped on a valid hit
					_this.view.reportExternalDrop(meta, dropLocation, el, ev, ui);
				}
				_this.isDraggingExternal = false;
				_this.externalDragListener = null;
			}
		});

		dragListener.startDrag(ev); // start listening immediately
	},


	// Given a hit to be dropped upon, and misc data associated with the jqui drag (guaranteed to be a plain object),
	// returns the zoned start/end dates for the event that would result from the hypothetical drop. end might be null.
	// Returning a null value signals an invalid drop hit.
	// DOES NOT consider overlap/constraint.
	computeExternalDrop: function(span, meta) {
		var calendar = this.view.calendar;
		var dropLocation = {
			start: calendar.applyTimezone(span.start), // simulate a zoned event start date
			end: null
		};

		// if dropped on an all-day span, and element's metadata specified a time, set it
		if (meta.startTime && !dropLocation.start.hasTime()) {
			dropLocation.start.time(meta.startTime);
		}

		if (meta.duration) {
			dropLocation.end = dropLocation.start.clone().add(meta.duration);
		}

		return dropLocation;
	},



	/* Drag Rendering (for both events and an external elements)
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of an event or external element being dragged.
	// `dropLocation` contains hypothetical start/end/allDay values the event would have if dropped. end can be null.
	// `seg` is the internal segment object that is being dragged. If dragging an external element, `seg` is null.
	// A truthy returned value indicates this method has rendered a helper element.
	// Must return elements used for any mock events.
	renderDrag: function(dropLocation, seg) {
		// subclasses must implement
	},


	// Unrenders a visual indication of an event or external element being dragged
	unrenderDrag: function() {
		// subclasses must implement
	},


	/* Resizing
	------------------------------------------------------------------------------------------------------------------*/


	// Creates a listener that tracks the user as they resize an event segment.
	// Generic enough to work with any type of Grid.
	buildSegResizeListener: function(seg, isStart) {
		var _this = this;
		var view = this.view;
		var calendar = view.calendar;
		var el = seg.el;
		var event = seg.event;
		var eventEnd = calendar.getEventEnd(event);
		var isDragging;
		var resizeLocation; // zoned event date properties. falsy if invalid resize

		// Tracks mouse movement over the *grid's* coordinate map
		var dragListener = this.segResizeListener = new HitDragListener(this, {
			scroll: view.opt('dragScroll'),
			subjectEl: el,
			interactionStart: function() {
				isDragging = false;
			},
			dragStart: function(ev) {
				isDragging = true;
				_this.handleSegMouseout(seg, ev); // ensure a mouseout on the manipulated event has been reported
				_this.segResizeStart(seg, ev);
			},
			hitOver: function(hit, isOrig, origHit) {
				var origHitSpan = _this.getHitSpan(origHit);
				var hitSpan = _this.getHitSpan(hit);

				resizeLocation = isStart ?
					_this.computeEventStartResize(origHitSpan, hitSpan, event) :
					_this.computeEventEndResize(origHitSpan, hitSpan, event);

				if (resizeLocation) {
					if (!calendar.isEventSpanAllowed(_this.eventToSpan(resizeLocation), event)) {
						disableCursor();
						resizeLocation = null;
					}
					// no change? (FYI, event dates might have zones)
					else if (
						resizeLocation.start.isSame(event.start.clone().stripZone()) &&
						resizeLocation.end.isSame(eventEnd.clone().stripZone())
					) {
						resizeLocation = null;
					}
				}

				if (resizeLocation) {
					view.hideEvent(event);
					_this.renderEventResize(resizeLocation, seg);
				}
			},
			hitOut: function() { // called before mouse moves to a different hit OR moved out of all hits
				resizeLocation = null;
				view.showEvent(event); // for when out-of-bounds. show original
			},
			hitDone: function() { // resets the rendering to show the original event
				_this.unrenderEventResize();
				enableCursor();
			},
			interactionEnd: function(ev) {
				if (isDragging) {
					_this.segResizeStop(seg, ev);
				}

				if (resizeLocation) { // valid date to resize to?
					// no need to re-show original, will rerender all anyways. esp important if eventRenderWait
					view.reportEventResize(event, resizeLocation, _this.largeUnit, el, ev);
				}
				else {
					view.showEvent(event);
				}
				_this.segResizeListener = null;
			}
		});

		return dragListener;
	},


	// Called before event segment resizing starts
	segResizeStart: function(seg, ev) {
		this.isResizingSeg = true;
		this.view.publiclyTrigger('eventResizeStart', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
	},


	// Called after event segment resizing stops
	segResizeStop: function(seg, ev) {
		this.isResizingSeg = false;
		this.view.publiclyTrigger('eventResizeStop', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
	},


	// Returns new date-information for an event segment being resized from its start
	computeEventStartResize: function(startSpan, endSpan, event) {
		return this.computeEventResize('start', startSpan, endSpan, event);
	},


	// Returns new date-information for an event segment being resized from its end
	computeEventEndResize: function(startSpan, endSpan, event) {
		return this.computeEventResize('end', startSpan, endSpan, event);
	},


	// Returns new zoned date information for an event segment being resized from its start OR end
	// `type` is either 'start' or 'end'.
	// DOES NOT consider overlap/constraint.
	computeEventResize: function(type, startSpan, endSpan, event) {
		var calendar = this.view.calendar;
		var delta = this.diffDates(endSpan[type], startSpan[type]);
		var resizeLocation; // zoned event date properties
		var defaultDuration;

		// build original values to work from, guaranteeing a start and end
		resizeLocation = {
			start: event.start.clone(),
			end: calendar.getEventEnd(event),
			allDay: event.allDay
		};

		// if an all-day event was in a timed area and was resized to a time, adjust start/end to have times
		if (resizeLocation.allDay && durationHasTime(delta)) {
			resizeLocation.allDay = false;
			calendar.normalizeEventTimes(resizeLocation);
		}

		resizeLocation[type].add(delta); // apply delta to start or end

		// if the event was compressed too small, find a new reasonable duration for it
		if (!resizeLocation.start.isBefore(resizeLocation.end)) {

			defaultDuration =
				this.minResizeDuration || // TODO: hack
				(event.allDay ?
					calendar.defaultAllDayEventDuration :
					calendar.defaultTimedEventDuration);

			if (type == 'start') { // resizing the start?
				resizeLocation.start = resizeLocation.end.clone().subtract(defaultDuration);
			}
			else { // resizing the end?
				resizeLocation.end = resizeLocation.start.clone().add(defaultDuration);
			}
		}

		return resizeLocation;
	},


	// Renders a visual indication of an event being resized.
	// `range` has the updated dates of the event. `seg` is the original segment object involved in the drag.
	// Must return elements used for any mock events.
	renderEventResize: function(range, seg) {
		// subclasses must implement
	},


	// Unrenders a visual indication of an event being resized.
	unrenderEventResize: function() {
		// subclasses must implement
	},


	/* Rendering Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Compute the text that should be displayed on an event's element.
	// `range` can be the Event object itself, or something range-like, with at least a `start`.
	// If event times are disabled, or the event has no time, will return a blank string.
	// If not specified, formatStr will default to the eventTimeFormat setting,
	// and displayEnd will default to the displayEventEnd setting.
	getEventTimeText: function(range, formatStr, displayEnd) {

		if (formatStr == null) {
			formatStr = this.eventTimeFormat;
		}

		if (displayEnd == null) {
			displayEnd = this.displayEventEnd;
		}

		if (this.displayEventTime && range.start.hasTime()) {
			if (displayEnd && range.end) {
				return this.view.formatRange(range, formatStr);
			}
			else {
				return range.start.format(formatStr);
			}
		}

		return '';
	},


	// Generic utility for generating the HTML classNames for an event segment's element
	getSegClasses: function(seg, isDraggable, isResizable) {
		var view = this.view;
		var classes = [
			'fc-event',
			seg.isStart ? 'fc-start' : 'fc-not-start',
			seg.isEnd ? 'fc-end' : 'fc-not-end'
		].concat(this.getSegCustomClasses(seg));

		if (isDraggable) {
			classes.push('fc-draggable');
		}
		if (isResizable) {
			classes.push('fc-resizable');
		}

		// event is currently selected? attach a className.
		if (view.isEventSelected(seg.event)) {
			classes.push('fc-selected');
		}

		return classes;
	},


	// List of classes that were defined by the caller of the API in some way
	getSegCustomClasses: function(seg) {
		var event = seg.event;

		return [].concat(
			event.className, // guaranteed to be an array
			event.source ? event.source.className : []
		);
	},


	// Utility for generating event skin-related CSS properties
	getSegSkinCss: function(seg) {
		return {
			'background-color': this.getSegBackgroundColor(seg),
			'border-color': this.getSegBorderColor(seg),
			color: this.getSegTextColor(seg)
		};
	},


	// Queries for caller-specified color, then falls back to default
	getSegBackgroundColor: function(seg) {
		return seg.event.backgroundColor ||
			seg.event.color ||
			this.getSegDefaultBackgroundColor(seg);
	},


	getSegDefaultBackgroundColor: function(seg) {
		var source = seg.event.source || {};

		return source.backgroundColor ||
			source.color ||
			this.view.opt('eventBackgroundColor') ||
			this.view.opt('eventColor');
	},


	// Queries for caller-specified color, then falls back to default
	getSegBorderColor: function(seg) {
		return seg.event.borderColor ||
			seg.event.color ||
			this.getSegDefaultBorderColor(seg);
	},


	getSegDefaultBorderColor: function(seg) {
		var source = seg.event.source || {};

		return source.borderColor ||
			source.color ||
			this.view.opt('eventBorderColor') ||
			this.view.opt('eventColor');
	},


	// Queries for caller-specified color, then falls back to default
	getSegTextColor: function(seg) {
		return seg.event.textColor ||
			this.getSegDefaultTextColor(seg);
	},


	getSegDefaultTextColor: function(seg) {
		var source = seg.event.source || {};

		return source.textColor ||
			this.view.opt('eventTextColor');
	},


	/* Converting events -> eventRange -> eventSpan -> eventSegs
	------------------------------------------------------------------------------------------------------------------*/


	// Generates an array of segments for the given single event
	// Can accept an event "location" as well (which only has start/end and no allDay)
	eventToSegs: function(event) {
		return this.eventsToSegs([ event ]);
	},


	eventToSpan: function(event) {
		return this.eventToSpans(event)[0];
	},


	// Generates spans (always unzoned) for the given event.
	// Does not do any inverting for inverse-background events.
	// Can accept an event "location" as well (which only has start/end and no allDay)
	eventToSpans: function(event) {
		var range = this.eventToRange(event);
		return this.eventRangeToSpans(range, event);
	},



	// Converts an array of event objects into an array of event segment objects.
	// A custom `segSliceFunc` may be given for arbitrarily slicing up events.
	// Doesn't guarantee an order for the resulting array.
	eventsToSegs: function(allEvents, segSliceFunc) {
		var _this = this;
		var eventsById = groupEventsById(allEvents);
		var segs = [];

		$.each(eventsById, function(id, events) {
			var ranges = [];
			var i;

			for (i = 0; i < events.length; i++) {
				ranges.push(_this.eventToRange(events[i]));
			}

			// inverse-background events (utilize only the first event in calculations)
			if (isInverseBgEvent(events[0])) {
				ranges = _this.invertRanges(ranges);

				for (i = 0; i < ranges.length; i++) {
					segs.push.apply(segs, // append to
						_this.eventRangeToSegs(ranges[i], events[0], segSliceFunc));
				}
			}
			// normal event ranges
			else {
				for (i = 0; i < ranges.length; i++) {
					segs.push.apply(segs, // append to
						_this.eventRangeToSegs(ranges[i], events[i], segSliceFunc));
				}
			}
		});

		return segs;
	},


	// Generates the unzoned start/end dates an event appears to occupy
	// Can accept an event "location" as well (which only has start/end and no allDay)
	eventToRange: function(event) {
		var calendar = this.view.calendar;
		var start = event.start.clone().stripZone();
		var end = (
				event.end ?
					event.end.clone() :
					// derive the end from the start and allDay. compute allDay if necessary
					calendar.getDefaultEventEnd(
						event.allDay != null ?
							event.allDay :
							!event.start.hasTime(),
						event.start
					)
			).stripZone();

		// hack: dynamic locale change forgets to upate stored event localed
		calendar.localizeMoment(start);
		calendar.localizeMoment(end);

		return { start: start, end: end };
	},


	// Given an event's range (unzoned start/end), and the event itself,
	// slice into segments (using the segSliceFunc function if specified)
	eventRangeToSegs: function(range, event, segSliceFunc) {
		var spans = this.eventRangeToSpans(range, event);
		var segs = [];
		var i;

		for (i = 0; i < spans.length; i++) {
			segs.push.apply(segs, // append to
				this.eventSpanToSegs(spans[i], event, segSliceFunc));
		}

		return segs;
	},


	// Given an event's unzoned date range, return an array of "span" objects.
	// Subclasses can override.
	eventRangeToSpans: function(range, event) {
		return [ $.extend({}, range) ]; // copy into a single-item array
	},


	// Given an event's span (unzoned start/end and other misc data), and the event itself,
	// slices into segments and attaches event-derived properties to them.
	eventSpanToSegs: function(span, event, segSliceFunc) {
		var segs = segSliceFunc ? segSliceFunc(span) : this.spanToSegs(span);
		var i, seg;

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			seg.event = event;
			seg.eventStartMS = +span.start; // TODO: not the best name after making spans unzoned
			seg.eventDurationMS = span.end - span.start;
		}

		return segs;
	},


	// Produces a new array of range objects that will cover all the time NOT covered by the given ranges.
	// SIDE EFFECT: will mutate the given array and will use its date references.
	invertRanges: function(ranges) {
		var view = this.view;
		var viewStart = view.start.clone(); // need a copy
		var viewEnd = view.end.clone(); // need a copy
		var inverseRanges = [];
		var start = viewStart; // the end of the previous range. the start of the new range
		var i, range;

		// ranges need to be in order. required for our date-walking algorithm
		ranges.sort(compareRanges);

		for (i = 0; i < ranges.length; i++) {
			range = ranges[i];

			// add the span of time before the event (if there is any)
			if (range.start > start) { // compare millisecond time (skip any ambig logic)
				inverseRanges.push({
					start: start,
					end: range.start
				});
			}

			start = range.end;
		}

		// add the span of time after the last event (if there is any)
		if (start < viewEnd) { // compare millisecond time (skip any ambig logic)
			inverseRanges.push({
				start: start,
				end: viewEnd
			});
		}

		return inverseRanges;
	},


	sortEventSegs: function(segs) {
		segs.sort(proxy(this, 'compareEventSegs'));
	},


	// A cmp function for determining which segments should take visual priority
	compareEventSegs: function(seg1, seg2) {
		return seg1.eventStartMS - seg2.eventStartMS || // earlier events go first
			seg2.eventDurationMS - seg1.eventDurationMS || // tie? longer events go first
			seg2.event.allDay - seg1.event.allDay || // tie? put all-day events first (booleans cast to 0/1)
			compareByFieldSpecs(seg1.event, seg2.event, this.view.eventOrderSpecs);
	}

});


/* Utilities
----------------------------------------------------------------------------------------------------------------------*/


function pluckEventDateProps(event) {
	return {
		start: event.start.clone(),
		end: event.end ? event.end.clone() : null,
		allDay: event.allDay // keep it the same
	};
}
FC.pluckEventDateProps = pluckEventDateProps;


function isBgEvent(event) { // returns true if background OR inverse-background
	var rendering = getEventRendering(event);
	return rendering === 'background' || rendering === 'inverse-background';
}
FC.isBgEvent = isBgEvent; // export


function isInverseBgEvent(event) {
	return getEventRendering(event) === 'inverse-background';
}


function getEventRendering(event) {
	return firstDefined((event.source || {}).rendering, event.rendering);
}


function groupEventsById(events) {
	var eventsById = {};
	var i, event;

	for (i = 0; i < events.length; i++) {
		event = events[i];
		(eventsById[event._id] || (eventsById[event._id] = [])).push(event);
	}

	return eventsById;
}


// A cmp function for determining which non-inverted "ranges" (see above) happen earlier
function compareRanges(range1, range2) {
	return range1.start - range2.start; // earlier ranges go first
}


/* External-Dragging-Element Data
----------------------------------------------------------------------------------------------------------------------*/

// Require all HTML5 data-* attributes used by FullCalendar to have this prefix.
// A value of '' will query attributes like data-event. A value of 'fc' will query attributes like data-fc-event.
FC.dataAttrPrefix = '';

// Given a jQuery element that might represent a dragged FullCalendar event, returns an intermediate data structure
// to be used for Event Object creation.
// A defined `.eventProps`, even when empty, indicates that an event should be created.
function getDraggedElMeta(el) {
	var prefix = FC.dataAttrPrefix;
	var eventProps; // properties for creating the event, not related to date/time
	var startTime; // a Duration
	var duration;
	var stick;

	if (prefix) { prefix += '-'; }
	eventProps = el.data(prefix + 'event') || null;

	if (eventProps) {
		if (typeof eventProps === 'object') {
			eventProps = $.extend({}, eventProps); // make a copy
		}
		else { // something like 1 or true. still signal event creation
			eventProps = {};
		}

		// pluck special-cased date/time properties
		startTime = eventProps.start;
		if (startTime == null) { startTime = eventProps.time; } // accept 'time' as well
		duration = eventProps.duration;
		stick = eventProps.stick;
		delete eventProps.start;
		delete eventProps.time;
		delete eventProps.duration;
		delete eventProps.stick;
	}

	// fallback to standalone attribute values for each of the date/time properties
	if (startTime == null) { startTime = el.data(prefix + 'start'); }
	if (startTime == null) { startTime = el.data(prefix + 'time'); } // accept 'time' as well
	if (duration == null) { duration = el.data(prefix + 'duration'); }
	if (stick == null) { stick = el.data(prefix + 'stick'); }

	// massage into correct data types
	startTime = startTime != null ? moment.duration(startTime) : null;
	duration = duration != null ? moment.duration(duration) : null;
	stick = Boolean(stick);

	return { eventProps: eventProps, startTime: startTime, duration: duration, stick: stick };
}


;;

/*
A set of rendering and date-related methods for a visual component comprised of one or more rows of day columns.
Prerequisite: the object being mixed into needs to be a *Grid*
*/
var DayTableMixin = FC.DayTableMixin = {

	breakOnWeeks: false, // should create a new row for each week?
	dayDates: null, // whole-day dates for each column. left to right
	dayIndices: null, // for each day from start, the offset
	daysPerRow: null,
	rowCnt: null,
	colCnt: null,
	colHeadFormat: null,


	// Populates internal variables used for date calculation and rendering
	updateDayTable: function() {
		var view = this.view;
		var date = this.start.clone();
		var dayIndex = -1;
		var dayIndices = [];
		var dayDates = [];
		var daysPerRow;
		var firstDay;
		var rowCnt;

		while (date.isBefore(this.end)) { // loop each day from start to end
			if (view.isHiddenDay(date)) {
				dayIndices.push(dayIndex + 0.5); // mark that it's between indices
			}
			else {
				dayIndex++;
				dayIndices.push(dayIndex);
				dayDates.push(date.clone());
			}
			date.add(1, 'days');
		}

		if (this.breakOnWeeks) {
			// count columns until the day-of-week repeats
			firstDay = dayDates[0].day();
			for (daysPerRow = 1; daysPerRow < dayDates.length; daysPerRow++) {
				if (dayDates[daysPerRow].day() == firstDay) {
					break;
				}
			}
			rowCnt = Math.ceil(dayDates.length / daysPerRow);
		}
		else {
			rowCnt = 1;
			daysPerRow = dayDates.length;
		}

		this.dayDates = dayDates;
		this.dayIndices = dayIndices;
		this.daysPerRow = daysPerRow;
		this.rowCnt = rowCnt;

		this.updateDayTableCols();
	},


	// Computes and assigned the colCnt property and updates any options that may be computed from it
	updateDayTableCols: function() {
		this.colCnt = this.computeColCnt();
		this.colHeadFormat = this.view.opt('columnFormat') || this.computeColHeadFormat();
	},


	// Determines how many columns there should be in the table
	computeColCnt: function() {
		return this.daysPerRow;
	},


	// Computes the ambiguously-timed moment for the given cell
	getCellDate: function(row, col) {
		return this.dayDates[
				this.getCellDayIndex(row, col)
			].clone();
	},


	// Computes the ambiguously-timed date range for the given cell
	getCellRange: function(row, col) {
		var start = this.getCellDate(row, col);
		var end = start.clone().add(1, 'days');

		return { start: start, end: end };
	},


	// Returns the number of day cells, chronologically, from the first of the grid (0-based)
	getCellDayIndex: function(row, col) {
		return row * this.daysPerRow + this.getColDayIndex(col);
	},


	// Returns the numner of day cells, chronologically, from the first cell in *any given row*
	getColDayIndex: function(col) {
		if (this.isRTL) {
			return this.colCnt - 1 - col;
		}
		else {
			return col;
		}
	},


	// Given a date, returns its chronolocial cell-index from the first cell of the grid.
	// If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
	// If before the first offset, returns a negative number.
	// If after the last offset, returns an offset past the last cell offset.
	// Only works for *start* dates of cells. Will not work for exclusive end dates for cells.
	getDateDayIndex: function(date) {
		var dayIndices = this.dayIndices;
		var dayOffset = date.diff(this.start, 'days');

		if (dayOffset < 0) {
			return dayIndices[0] - 1;
		}
		else if (dayOffset >= dayIndices.length) {
			return dayIndices[dayIndices.length - 1] + 1;
		}
		else {
			return dayIndices[dayOffset];
		}
	},


	/* Options
	------------------------------------------------------------------------------------------------------------------*/


	// Computes a default column header formatting string if `colFormat` is not explicitly defined
	computeColHeadFormat: function() {
		// if more than one week row, or if there are a lot of columns with not much space,
		// put just the day numbers will be in each cell
		if (this.rowCnt > 1 || this.colCnt > 10) {
			return 'ddd'; // "Sat"
		}
		// multiple days, so full single date string WON'T be in title text
		else if (this.colCnt > 1) {
			return this.view.opt('dayOfMonthFormat'); // "Sat 12/10"
		}
		// single day, so full single date string will probably be in title text
		else {
			return 'dddd'; // "Saturday"
		}
	},


	/* Slicing
	------------------------------------------------------------------------------------------------------------------*/


	// Slices up a date range into a segment for every week-row it intersects with
	sliceRangeByRow: function(range) {
		var daysPerRow = this.daysPerRow;
		var normalRange = this.view.computeDayRange(range); // make whole-day range, considering nextDayThreshold
		var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index
		var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index
		var segs = [];
		var row;
		var rowFirst, rowLast; // inclusive day-index range for current row
		var segFirst, segLast; // inclusive day-index range for segment

		for (row = 0; row < this.rowCnt; row++) {
			rowFirst = row * daysPerRow;
			rowLast = rowFirst + daysPerRow - 1;

			// intersect segment's offset range with the row's
			segFirst = Math.max(rangeFirst, rowFirst);
			segLast = Math.min(rangeLast, rowLast);

			// deal with in-between indices
			segFirst = Math.ceil(segFirst); // in-between starts round to next cell
			segLast = Math.floor(segLast); // in-between ends round to prev cell

			if (segFirst <= segLast) { // was there any intersection with the current row?
				segs.push({
					row: row,

					// normalize to start of row
					firstRowDayIndex: segFirst - rowFirst,
					lastRowDayIndex: segLast - rowFirst,

					// must be matching integers to be the segment's start/end
					isStart: segFirst === rangeFirst,
					isEnd: segLast === rangeLast
				});
			}
		}

		return segs;
	},


	// Slices up a date range into a segment for every day-cell it intersects with.
	// TODO: make more DRY with sliceRangeByRow somehow.
	sliceRangeByDay: function(range) {
		var daysPerRow = this.daysPerRow;
		var normalRange = this.view.computeDayRange(range); // make whole-day range, considering nextDayThreshold
		var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index
		var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index
		var segs = [];
		var row;
		var rowFirst, rowLast; // inclusive day-index range for current row
		var i;
		var segFirst, segLast; // inclusive day-index range for segment

		for (row = 0; row < this.rowCnt; row++) {
			rowFirst = row * daysPerRow;
			rowLast = rowFirst + daysPerRow - 1;

			for (i = rowFirst; i <= rowLast; i++) {

				// intersect segment's offset range with the row's
				segFirst = Math.max(rangeFirst, i);
				segLast = Math.min(rangeLast, i);

				// deal with in-between indices
				segFirst = Math.ceil(segFirst); // in-between starts round to next cell
				segLast = Math.floor(segLast); // in-between ends round to prev cell

				if (segFirst <= segLast) { // was there any intersection with the current row?
					segs.push({
						row: row,

						// normalize to start of row
						firstRowDayIndex: segFirst - rowFirst,
						lastRowDayIndex: segLast - rowFirst,

						// must be matching integers to be the segment's start/end
						isStart: segFirst === rangeFirst,
						isEnd: segLast === rangeLast
					});
				}
			}
		}

		return segs;
	},


	/* Header Rendering
	------------------------------------------------------------------------------------------------------------------*/


	renderHeadHtml: function() {
		var view = this.view;

		return '' +
			'<div class="fc-row ' + view.widgetHeaderClass + '">' +
				'<table>' +
					'<thead>' +
						this.renderHeadTrHtml() +
					'</thead>' +
				'</table>' +
			'</div>';
	},


	renderHeadIntroHtml: function() {
		return this.renderIntroHtml(); // fall back to generic
	},


	renderHeadTrHtml: function() {
		return '' +
			'<tr>' +
				(this.isRTL ? '' : this.renderHeadIntroHtml()) +
				this.renderHeadDateCellsHtml() +
				(this.isRTL ? this.renderHeadIntroHtml() : '') +
			'</tr>';
	},


	renderHeadDateCellsHtml: function() {
		var htmls = [];
		var col, date;

		for (col = 0; col < this.colCnt; col++) {
			date = this.getCellDate(0, col);
			htmls.push(this.renderHeadDateCellHtml(date));
		}

		return htmls.join('');
	},


	// TODO: when internalApiVersion, accept an object for HTML attributes
	// (colspan should be no different)
	renderHeadDateCellHtml: function(date, colspan, otherAttrs) {
		var view = this.view;
		var classNames = [
			'fc-day-header',
			view.widgetHeaderClass
		];

		// if only one row of days, the classNames on the header can represent the specific days beneath
		if (this.rowCnt === 1) {
			classNames = classNames.concat(
				// includes the day-of-week class
				// noThemeHighlight=true (don't highlight the header)
				this.getDayClasses(date, true)
			);
		}
		else {
			classNames.push('fc-' + dayIDs[date.day()]); // only add the day-of-week class
		}

		return '' +
            '<th class="' + classNames.join(' ') + '"' +
				(this.rowCnt === 1 ?
					' data-date="' + date.format('YYYY-MM-DD') + '"' :
					'') +
				(colspan > 1 ?
					' colspan="' + colspan + '"' :
					'') +
				(otherAttrs ?
					' ' + otherAttrs :
					'') +
				'>' +
				// don't make a link if the heading could represent multiple days, or if there's only one day (forceOff)
				view.buildGotoAnchorHtml(
					{ date: date, forceOff: this.rowCnt > 1 || this.colCnt === 1 },
					htmlEscape(date.format(this.colHeadFormat)) // inner HTML
				) +
			'</th>';
	},


	/* Background Rendering
	------------------------------------------------------------------------------------------------------------------*/


	renderBgTrHtml: function(row) {
		return '' +
			'<tr>' +
				(this.isRTL ? '' : this.renderBgIntroHtml(row)) +
				this.renderBgCellsHtml(row) +
				(this.isRTL ? this.renderBgIntroHtml(row) : '') +
			'</tr>';
	},


	renderBgIntroHtml: function(row) {
		return this.renderIntroHtml(); // fall back to generic
	},


	renderBgCellsHtml: function(row) {
		var htmls = [];
		var col, date;

		for (col = 0; col < this.colCnt; col++) {
			date = this.getCellDate(row, col);
			htmls.push(this.renderBgCellHtml(date));
		}

		return htmls.join('');
	},


	renderBgCellHtml: function(date, otherAttrs) {
		var view = this.view;
		var classes = this.getDayClasses(date);

		classes.unshift('fc-day', view.widgetContentClass);

		return '<td class="' + classes.join(' ') + '"' +
			' data-date="' + date.format('YYYY-MM-DD') + '"' + // if date has a time, won't format it
			(otherAttrs ?
				' ' + otherAttrs :
				'') +
			'></td>';
	},


	/* Generic
	------------------------------------------------------------------------------------------------------------------*/


	// Generates the default HTML intro for any row. User classes should override
	renderIntroHtml: function() {
	},


	// TODO: a generic method for dealing with <tr>, RTL, intro
	// when increment internalApiVersion
	// wrapTr (scheduler)


	/* Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Applies the generic "intro" and "outro" HTML to the given cells.
	// Intro means the leftmost cell when the calendar is LTR and the rightmost cell when RTL. Vice-versa for outro.
	bookendCells: function(trEl) {
		var introHtml = this.renderIntroHtml();

		if (introHtml) {
			if (this.isRTL) {
				trEl.append(introHtml);
			}
			else {
				trEl.prepend(introHtml);
			}
		}
	}

};

;;

/* A component that renders a grid of whole-days that runs horizontally. There can be multiple rows, one per week.
----------------------------------------------------------------------------------------------------------------------*/

var DayGrid = FC.DayGrid = Grid.extend(DayTableMixin, {

	numbersVisible: false, // should render a row for day/week numbers? set by outside view. TODO: make internal
	bottomCoordPadding: 0, // hack for extending the hit area for the last row of the coordinate grid

	rowEls: null, // set of fake row elements
	cellEls: null, // set of whole-day elements comprising the row's background
	helperEls: null, // set of cell skeleton elements for rendering the mock event "helper"

	rowCoordCache: null,
	colCoordCache: null,


	// Renders the rows and columns into the component's `this.el`, which should already be assigned.
	// isRigid determins whether the individual rows should ignore the contents and be a constant height.
	// Relies on the view's colCnt and rowCnt. In the future, this component should probably be self-sufficient.
	renderDates: function(isRigid) {
		var view = this.view;
		var rowCnt = this.rowCnt;
		var colCnt = this.colCnt;
		var html = '';
		var row;
		var col;

		for (row = 0; row < rowCnt; row++) {
			html += this.renderDayRowHtml(row, isRigid);
		}
		this.el.html(html);

		this.rowEls = this.el.find('.fc-row');
		this.cellEls = this.el.find('.fc-day');

		this.rowCoordCache = new CoordCache({
			els: this.rowEls,
			isVertical: true
		});
		this.colCoordCache = new CoordCache({
			els: this.cellEls.slice(0, this.colCnt), // only the first row
			isHorizontal: true
		});

		// trigger dayRender with each cell's element
		for (row = 0; row < rowCnt; row++) {
			for (col = 0; col < colCnt; col++) {
				view.publiclyTrigger(
					'dayRender',
					null,
					this.getCellDate(row, col),
					this.getCellEl(row, col)
				);
			}
		}
	},


	unrenderDates: function() {
		this.removeSegPopover();
	},


	renderBusinessHours: function() {
		var segs = this.buildBusinessHourSegs(true); // wholeDay=true
		this.renderFill('businessHours', segs, 'bgevent');
	},


	unrenderBusinessHours: function() {
		this.unrenderFill('businessHours');
	},


	// Generates the HTML for a single row, which is a div that wraps a table.
	// `row` is the row number.
	renderDayRowHtml: function(row, isRigid) {
		var view = this.view;
		var classes = [ 'fc-row', 'fc-week', view.widgetContentClass ];

		if (isRigid) {
			classes.push('fc-rigid');
		}

		return '' +
			'<div class="' + classes.join(' ') + '">' +
				'<div class="fc-bg">' +
					'<table>' +
						this.renderBgTrHtml(row) +
					'</table>' +
				'</div>' +
				'<div class="fc-content-skeleton">' +
					'<table>' +
						(this.numbersVisible ?
							'<thead>' +
								this.renderNumberTrHtml(row) +
							'</thead>' :
							''
							) +
					'</table>' +
				'</div>' +
			'</div>';
	},


	/* Grid Number Rendering
	------------------------------------------------------------------------------------------------------------------*/


	renderNumberTrHtml: function(row) {
		return '' +
			'<tr>' +
				(this.isRTL ? '' : this.renderNumberIntroHtml(row)) +
				this.renderNumberCellsHtml(row) +
				(this.isRTL ? this.renderNumberIntroHtml(row) : '') +
			'</tr>';
	},


	renderNumberIntroHtml: function(row) {
		return this.renderIntroHtml();
	},


	renderNumberCellsHtml: function(row) {
		var htmls = [];
		var col, date;

		for (col = 0; col < this.colCnt; col++) {
			date = this.getCellDate(row, col);
			htmls.push(this.renderNumberCellHtml(date));
		}

		return htmls.join('');
	},


	// Generates the HTML for the <td>s of the "number" row in the DayGrid's content skeleton.
	// The number row will only exist if either day numbers or week numbers are turned on.
	renderNumberCellHtml: function(date) {
		var html = '';
		var classes;
		var weekCalcFirstDoW;

		if (!this.view.dayNumbersVisible && !this.view.cellWeekNumbersVisible) {
			// no numbers in day cell (week number must be along the side)
			return '<td/>'; //  will create an empty space above events :(
		}

		classes = this.getDayClasses(date);
		classes.unshift('fc-day-top');

		if (this.view.cellWeekNumbersVisible) {
			// To determine the day of week number change under ISO, we cannot
			// rely on moment.js methods such as firstDayOfWeek() or weekday(),
			// because they rely on the locale's dow (possibly overridden by
			// our firstDay option), which may not be Monday. We cannot change
			// dow, because that would affect the calendar start day as well.
			if (date._locale._fullCalendar_weekCalc === 'ISO') {
				weekCalcFirstDoW = 1;  // Monday by ISO 8601 definition
			}
			else {
				weekCalcFirstDoW = date._locale.firstDayOfWeek();
			}
		}

		html += '<td class="' + classes.join(' ') + '" data-date="' + date.format() + '">';

		if (this.view.cellWeekNumbersVisible && (date.day() == weekCalcFirstDoW)) {
			html += this.view.buildGotoAnchorHtml(
				{ date: date, type: 'week' },
				{ 'class': 'fc-week-number' },
				date.format('w') // inner HTML
			);
		}

		if (this.view.dayNumbersVisible) {
			html += this.view.buildGotoAnchorHtml(
				date,
				{ 'class': 'fc-day-number' },
				date.date() // inner HTML
			);
		}

		html += '</td>';

		return html;
	},


	/* Options
	------------------------------------------------------------------------------------------------------------------*/


	// Computes a default event time formatting string if `timeFormat` is not explicitly defined
	computeEventTimeFormat: function() {
		return this.view.opt('extraSmallTimeFormat'); // like "6p" or "6:30p"
	},


	// Computes a default `displayEventEnd` value if one is not expliclty defined
	computeDisplayEventEnd: function() {
		return this.colCnt == 1; // we'll likely have space if there's only one day
	},


	/* Dates
	------------------------------------------------------------------------------------------------------------------*/


	rangeUpdated: function() {
		this.updateDayTable();
	},


	// Slices up the given span (unzoned start/end with other misc data) into an array of segments
	spanToSegs: function(span) {
		var segs = this.sliceRangeByRow(span);
		var i, seg;

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			if (this.isRTL) {
				seg.leftCol = this.daysPerRow - 1 - seg.lastRowDayIndex;
				seg.rightCol = this.daysPerRow - 1 - seg.firstRowDayIndex;
			}
			else {
				seg.leftCol = seg.firstRowDayIndex;
				seg.rightCol = seg.lastRowDayIndex;
			}
		}

		return segs;
	},


	/* Hit System
	------------------------------------------------------------------------------------------------------------------*/


	prepareHits: function() {
		this.colCoordCache.build();
		this.rowCoordCache.build();
		this.rowCoordCache.bottoms[this.rowCnt - 1] += this.bottomCoordPadding; // hack
	},


	releaseHits: function() {
		this.colCoordCache.clear();
		this.rowCoordCache.clear();
	},


	queryHit: function(leftOffset, topOffset) {
		if (this.colCoordCache.isLeftInBounds(leftOffset) && this.rowCoordCache.isTopInBounds(topOffset)) {
			var col = this.colCoordCache.getHorizontalIndex(leftOffset);
			var row = this.rowCoordCache.getVerticalIndex(topOffset);

			if (row != null && col != null) {
				return this.getCellHit(row, col);
			}
		}
	},


	getHitSpan: function(hit) {
		return this.getCellRange(hit.row, hit.col);
	},


	getHitEl: function(hit) {
		return this.getCellEl(hit.row, hit.col);
	},


	/* Cell System
	------------------------------------------------------------------------------------------------------------------*/
	// FYI: the first column is the leftmost column, regardless of date


	getCellHit: function(row, col) {
		return {
			row: row,
			col: col,
			component: this, // needed unfortunately :(
			left: this.colCoordCache.getLeftOffset(col),
			right: this.colCoordCache.getRightOffset(col),
			top: this.rowCoordCache.getTopOffset(row),
			bottom: this.rowCoordCache.getBottomOffset(row)
		};
	},


	getCellEl: function(row, col) {
		return this.cellEls.eq(row * this.colCnt + col);
	},


	/* Event Drag Visualization
	------------------------------------------------------------------------------------------------------------------*/
	// TODO: move to DayGrid.event, similar to what we did with Grid's drag methods


	// Renders a visual indication of an event or external element being dragged.
	// `eventLocation` has zoned start and end (optional)
	renderDrag: function(eventLocation, seg) {

		// always render a highlight underneath
		this.renderHighlight(this.eventToSpan(eventLocation));

		// if a segment from the same calendar but another component is being dragged, render a helper event
		if (seg && seg.component !== this) {
			return this.renderEventLocationHelper(eventLocation, seg); // returns mock event elements
		}
	},


	// Unrenders any visual indication of a hovering event
	unrenderDrag: function() {
		this.unrenderHighlight();
		this.unrenderHelper();
	},


	/* Event Resize Visualization
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of an event being resized
	renderEventResize: function(eventLocation, seg) {
		this.renderHighlight(this.eventToSpan(eventLocation));
		return this.renderEventLocationHelper(eventLocation, seg); // returns mock event elements
	},


	// Unrenders a visual indication of an event being resized
	unrenderEventResize: function() {
		this.unrenderHighlight();
		this.unrenderHelper();
	},


	/* Event Helper
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a mock "helper" event. `sourceSeg` is the associated internal segment object. It can be null.
	renderHelper: function(event, sourceSeg) {
		var helperNodes = [];
		var segs = this.eventToSegs(event);
		var rowStructs;

		segs = this.renderFgSegEls(segs); // assigns each seg's el and returns a subset of segs that were rendered
		rowStructs = this.renderSegRows(segs);

		// inject each new event skeleton into each associated row
		this.rowEls.each(function(row, rowNode) {
			var rowEl = $(rowNode); // the .fc-row
			var skeletonEl = $('<div class="fc-helper-skeleton"><table/></div>'); // will be absolutely positioned
			var skeletonTop;

			// If there is an original segment, match the top position. Otherwise, put it at the row's top level
			if (sourceSeg && sourceSeg.row === row) {
				skeletonTop = sourceSeg.el.position().top;
			}
			else {
				skeletonTop = rowEl.find('.fc-content-skeleton tbody').position().top;
			}

			skeletonEl.css('top', skeletonTop)
				.find('table')
					.append(rowStructs[row].tbodyEl);

			rowEl.append(skeletonEl);
			helperNodes.push(skeletonEl[0]);
		});

		return ( // must return the elements rendered
			this.helperEls = $(helperNodes) // array -> jQuery set
		);
	},


	// Unrenders any visual indication of a mock helper event
	unrenderHelper: function() {
		if (this.helperEls) {
			this.helperEls.remove();
			this.helperEls = null;
		}
	},


	/* Fill System (highlight, background events, business hours)
	------------------------------------------------------------------------------------------------------------------*/


	fillSegTag: 'td', // override the default tag name


	// Renders a set of rectangles over the given segments of days.
	// Only returns segments that successfully rendered.
	renderFill: function(type, segs, className) {
		var nodes = [];
		var i, seg;
		var skeletonEl;

		segs = this.renderFillSegEls(type, segs); // assignes `.el` to each seg. returns successfully rendered segs

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			skeletonEl = this.renderFillRow(type, seg, className);
			this.rowEls.eq(seg.row).append(skeletonEl);
			nodes.push(skeletonEl[0]);
		}

		this.elsByFill[type] = $(nodes);

		return segs;
	},


	// Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.
	renderFillRow: function(type, seg, className) {
		var colCnt = this.colCnt;
		var startCol = seg.leftCol;
		var endCol = seg.rightCol + 1;
		var skeletonEl;
		var trEl;

		className = className || type.toLowerCase();

		skeletonEl = $(
			'<div class="fc-' + className + '-skeleton">' +
				'<table><tr/></table>' +
			'</div>'
		);
		trEl = skeletonEl.find('tr');

		if (startCol > 0) {
			trEl.append('<td colspan="' + startCol + '"/>');
		}

		trEl.append(
			seg.el.attr('colspan', endCol - startCol)
		);

		if (endCol < colCnt) {
			trEl.append('<td colspan="' + (colCnt - endCol) + '"/>');
		}

		this.bookendCells(trEl);

		return skeletonEl;
	}

});

;;

/* Event-rendering methods for the DayGrid class
----------------------------------------------------------------------------------------------------------------------*/

DayGrid.mixin({

	rowStructs: null, // an array of objects, each holding information about a row's foreground event-rendering


	// Unrenders all events currently rendered on the grid
	unrenderEvents: function() {
		this.removeSegPopover(); // removes the "more.." events popover
		Grid.prototype.unrenderEvents.apply(this, arguments); // calls the super-method
	},


	// Retrieves all rendered segment objects currently rendered on the grid
	getEventSegs: function() {
		return Grid.prototype.getEventSegs.call(this) // get the segments from the super-method
			.concat(this.popoverSegs || []); // append the segments from the "more..." popover
	},


	// Renders the given background event segments onto the grid
	renderBgSegs: function(segs) {

		// don't render timed background events
		var allDaySegs = $.grep(segs, function(seg) {
			return seg.event.allDay;
		});

		return Grid.prototype.renderBgSegs.call(this, allDaySegs); // call the super-method
	},


	// Renders the given foreground event segments onto the grid
	renderFgSegs: function(segs) {
		var rowStructs;

		// render an `.el` on each seg
		// returns a subset of the segs. segs that were actually rendered
		segs = this.renderFgSegEls(segs);

		rowStructs = this.rowStructs = this.renderSegRows(segs);

		// append to each row's content skeleton
		this.rowEls.each(function(i, rowNode) {
			$(rowNode).find('.fc-content-skeleton > table').append(
				rowStructs[i].tbodyEl
			);
		});

		return segs; // return only the segs that were actually rendered
	},


	// Unrenders all currently rendered foreground event segments
	unrenderFgSegs: function() {
		var rowStructs = this.rowStructs || [];
		var rowStruct;

		while ((rowStruct = rowStructs.pop())) {
			rowStruct.tbodyEl.remove();
		}

		this.rowStructs = null;
	},


	// Uses the given events array to generate <tbody> elements that should be appended to each row's content skeleton.
	// Returns an array of rowStruct objects (see the bottom of `renderSegRow`).
	// PRECONDITION: each segment shoud already have a rendered and assigned `.el`
	renderSegRows: function(segs) {
		var rowStructs = [];
		var segRows;
		var row;

		segRows = this.groupSegRows(segs); // group into nested arrays

		// iterate each row of segment groupings
		for (row = 0; row < segRows.length; row++) {
			rowStructs.push(
				this.renderSegRow(row, segRows[row])
			);
		}

		return rowStructs;
	},


	// Builds the HTML to be used for the default element for an individual segment
	fgSegHtml: function(seg, disableResizing) {
		var view = this.view;
		var event = seg.event;
		var isDraggable = view.isEventDraggable(event);
		var isResizableFromStart = !disableResizing && event.allDay &&
			seg.isStart && view.isEventResizableFromStart(event);
		var isResizableFromEnd = !disableResizing && event.allDay &&
			seg.isEnd && view.isEventResizableFromEnd(event);
		var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
		var skinCss = cssToStr(this.getSegSkinCss(seg));
		var timeHtml = '';
		var timeText;
		var titleHtml;

		classes.unshift('fc-day-grid-event', 'fc-h-event');

		// Only display a timed events time if it is the starting segment
		if (seg.isStart) {
			timeText = this.getEventTimeText(event);
			if (timeText) {
				timeHtml = '<span class="fc-time">' + htmlEscape(timeText) + '</span>';
			}
		}

		titleHtml =
			'<span class="fc-title">' +
				(htmlEscape(event.title || '') || '&nbsp;') + // we always want one line of height
			'</span>';
		
		return '<a class="' + classes.join(' ') + '"' +
				(event.url ?
					' href="' + htmlEscape(event.url) + '"' :
					''
					) +
				(skinCss ?
					' style="' + skinCss + '"' :
					''
					) +
			'>' +
				'<div class="fc-content">' +
					(this.isRTL ?
						titleHtml + ' ' + timeHtml : // put a natural space in between
						timeHtml + ' ' + titleHtml   //
						) +
				'</div>' +
				(isResizableFromStart ?
					'<div class="fc-resizer fc-start-resizer" />' :
					''
					) +
				(isResizableFromEnd ?
					'<div class="fc-resizer fc-end-resizer" />' :
					''
					) +
			'</a>';
	},


	// Given a row # and an array of segments all in the same row, render a <tbody> element, a skeleton that contains
	// the segments. Returns object with a bunch of internal data about how the render was calculated.
	// NOTE: modifies rowSegs
	renderSegRow: function(row, rowSegs) {
		var colCnt = this.colCnt;
		var segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels
		var levelCnt = Math.max(1, segLevels.length); // ensure at least one level
		var tbody = $('<tbody/>');
		var segMatrix = []; // lookup for which segments are rendered into which level+col cells
		var cellMatrix = []; // lookup for all <td> elements of the level+col matrix
		var loneCellMatrix = []; // lookup for <td> elements that only take up a single column
		var i, levelSegs;
		var col;
		var tr;
		var j, seg;
		var td;

		// populates empty cells from the current column (`col`) to `endCol`
		function emptyCellsUntil(endCol) {
			while (col < endCol) {
				// try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell
				td = (loneCellMatrix[i - 1] || [])[col];
				if (td) {
					td.attr(
						'rowspan',
						parseInt(td.attr('rowspan') || 1, 10) + 1
					);
				}
				else {
					td = $('<td/>');
					tr.append(td);
				}
				cellMatrix[i][col] = td;
				loneCellMatrix[i][col] = td;
				col++;
			}
		}

		for (i = 0; i < levelCnt; i++) { // iterate through all levels
			levelSegs = segLevels[i];
			col = 0;
			tr = $('<tr/>');

			segMatrix.push([]);
			cellMatrix.push([]);
			loneCellMatrix.push([]);

			// levelCnt might be 1 even though there are no actual levels. protect against this.
			// this single empty row is useful for styling.
			if (levelSegs) {
				for (j = 0; j < levelSegs.length; j++) { // iterate through segments in level
					seg = levelSegs[j];

					emptyCellsUntil(seg.leftCol);

					// create a container that occupies or more columns. append the event element.
					td = $('<td class="fc-event-container"/>').append(seg.el);
					if (seg.leftCol != seg.rightCol) {
						td.attr('colspan', seg.rightCol - seg.leftCol + 1);
					}
					else { // a single-column segment
						loneCellMatrix[i][col] = td;
					}

					while (col <= seg.rightCol) {
						cellMatrix[i][col] = td;
						segMatrix[i][col] = seg;
						col++;
					}

					tr.append(td);
				}
			}

			emptyCellsUntil(colCnt); // finish off the row
			this.bookendCells(tr);
			tbody.append(tr);
		}

		return { // a "rowStruct"
			row: row, // the row number
			tbodyEl: tbody,
			cellMatrix: cellMatrix,
			segMatrix: segMatrix,
			segLevels: segLevels,
			segs: rowSegs
		};
	},


	// Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.
	// NOTE: modifies segs
	buildSegLevels: function(segs) {
		var levels = [];
		var i, seg;
		var j;

		// Give preference to elements with certain criteria, so they have
		// a chance to be closer to the top.
		this.sortEventSegs(segs);
		
		for (i = 0; i < segs.length; i++) {
			seg = segs[i];

			// loop through levels, starting with the topmost, until the segment doesn't collide with other segments
			for (j = 0; j < levels.length; j++) {
				if (!isDaySegCollision(seg, levels[j])) {
					break;
				}
			}
			// `j` now holds the desired subrow index
			seg.level = j;

			// create new level array if needed and append segment
			(levels[j] || (levels[j] = [])).push(seg);
		}

		// order segments left-to-right. very important if calendar is RTL
		for (j = 0; j < levels.length; j++) {
			levels[j].sort(compareDaySegCols);
		}

		return levels;
	},


	// Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row
	groupSegRows: function(segs) {
		var segRows = [];
		var i;

		for (i = 0; i < this.rowCnt; i++) {
			segRows.push([]);
		}

		for (i = 0; i < segs.length; i++) {
			segRows[segs[i].row].push(segs[i]);
		}

		return segRows;
	}

});


// Computes whether two segments' columns collide. They are assumed to be in the same row.
function isDaySegCollision(seg, otherSegs) {
	var i, otherSeg;

	for (i = 0; i < otherSegs.length; i++) {
		otherSeg = otherSegs[i];

		if (
			otherSeg.leftCol <= seg.rightCol &&
			otherSeg.rightCol >= seg.leftCol
		) {
			return true;
		}
	}

	return false;
}


// A cmp function for determining the leftmost event
function compareDaySegCols(a, b) {
	return a.leftCol - b.leftCol;
}

;;

/* Methods relate to limiting the number events for a given day on a DayGrid
----------------------------------------------------------------------------------------------------------------------*/
// NOTE: all the segs being passed around in here are foreground segs

DayGrid.mixin({

	segPopover: null, // the Popover that holds events that can't fit in a cell. null when not visible
	popoverSegs: null, // an array of segment objects that the segPopover holds. null when not visible


	removeSegPopover: function() {
		if (this.segPopover) {
			this.segPopover.hide(); // in handler, will call segPopover's removeElement
		}
	},


	// Limits the number of "levels" (vertically stacking layers of events) for each row of the grid.
	// `levelLimit` can be false (don't limit), a number, or true (should be computed).
	limitRows: function(levelLimit) {
		var rowStructs = this.rowStructs || [];
		var row; // row #
		var rowLevelLimit;

		for (row = 0; row < rowStructs.length; row++) {
			this.unlimitRow(row);

			if (!levelLimit) {
				rowLevelLimit = false;
			}
			else if (typeof levelLimit === 'number') {
				rowLevelLimit = levelLimit;
			}
			else {
				rowLevelLimit = this.computeRowLevelLimit(row);
			}

			if (rowLevelLimit !== false) {
				this.limitRow(row, rowLevelLimit);
			}
		}
	},


	// Computes the number of levels a row will accomodate without going outside its bounds.
	// Assumes the row is "rigid" (maintains a constant height regardless of what is inside).
	// `row` is the row number.
	computeRowLevelLimit: function(row) {
		var rowEl = this.rowEls.eq(row); // the containing "fake" row div
		var rowHeight = rowEl.height(); // TODO: cache somehow?
		var trEls = this.rowStructs[row].tbodyEl.children();
		var i, trEl;
		var trHeight;

		function iterInnerHeights(i, childNode) {
			trHeight = Math.max(trHeight, $(childNode).outerHeight());
		}

		// Reveal one level <tr> at a time and stop when we find one out of bounds
		for (i = 0; i < trEls.length; i++) {
			trEl = trEls.eq(i).removeClass('fc-limited'); // reset to original state (reveal)

			// with rowspans>1 and IE8, trEl.outerHeight() would return the height of the largest cell,
			// so instead, find the tallest inner content element.
			trHeight = 0;
			trEl.find('> td > :first-child').each(iterInnerHeights);

			if (trEl.position().top + trHeight > rowHeight) {
				return i;
			}
		}

		return false; // should not limit at all
	},


	// Limits the given grid row to the maximum number of levels and injects "more" links if necessary.
	// `row` is the row number.
	// `levelLimit` is a number for the maximum (inclusive) number of levels allowed.
	limitRow: function(row, levelLimit) {
		var _this = this;
		var rowStruct = this.rowStructs[row];
		var moreNodes = []; // array of "more" <a> links and <td> DOM nodes
		var col = 0; // col #, left-to-right (not chronologically)
		var levelSegs; // array of segment objects in the last allowable level, ordered left-to-right
		var cellMatrix; // a matrix (by level, then column) of all <td> jQuery elements in the row
		var limitedNodes; // array of temporarily hidden level <tr> and segment <td> DOM nodes
		var i, seg;
		var segsBelow; // array of segment objects below `seg` in the current `col`
		var totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies
		var colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs's first column)
		var td, rowspan;
		var segMoreNodes; // array of "more" <td> cells that will stand-in for the current seg's cell
		var j;
		var moreTd, moreWrap, moreLink;

		// Iterates through empty level cells and places "more" links inside if need be
		function emptyCellsUntil(endCol) { // goes from current `col` to `endCol`
			while (col < endCol) {
				segsBelow = _this.getCellSegs(row, col, levelLimit);
				if (segsBelow.length) {
					td = cellMatrix[levelLimit - 1][col];
					moreLink = _this.renderMoreLink(row, col, segsBelow);
					moreWrap = $('<div/>').append(moreLink);
					td.append(moreWrap);
					moreNodes.push(moreWrap[0]);
				}
				col++;
			}
		}

		if (levelLimit && levelLimit < rowStruct.segLevels.length) { // is it actually over the limit?
			levelSegs = rowStruct.segLevels[levelLimit - 1];
			cellMatrix = rowStruct.cellMatrix;

			limitedNodes = rowStruct.tbodyEl.children().slice(levelLimit) // get level <tr> elements past the limit
				.addClass('fc-limited').get(); // hide elements and get a simple DOM-nodes array

			// iterate though segments in the last allowable level
			for (i = 0; i < levelSegs.length; i++) {
				seg = levelSegs[i];
				emptyCellsUntil(seg.leftCol); // process empty cells before the segment

				// determine *all* segments below `seg` that occupy the same columns
				colSegsBelow = [];
				totalSegsBelow = 0;
				while (col <= seg.rightCol) {
					segsBelow = this.getCellSegs(row, col, levelLimit);
					colSegsBelow.push(segsBelow);
					totalSegsBelow += segsBelow.length;
					col++;
				}

				if (totalSegsBelow) { // do we need to replace this segment with one or many "more" links?
					td = cellMatrix[levelLimit - 1][seg.leftCol]; // the segment's parent cell
					rowspan = td.attr('rowspan') || 1;
					segMoreNodes = [];

					// make a replacement <td> for each column the segment occupies. will be one for each colspan
					for (j = 0; j < colSegsBelow.length; j++) {
						moreTd = $('<td class="fc-more-cell"/>').attr('rowspan', rowspan);
						segsBelow = colSegsBelow[j];
						moreLink = this.renderMoreLink(
							row,
							seg.leftCol + j,
							[ seg ].concat(segsBelow) // count seg as hidden too
						);
						moreWrap = $('<div/>').append(moreLink);
						moreTd.append(moreWrap);
						segMoreNodes.push(moreTd[0]);
						moreNodes.push(moreTd[0]);
					}

					td.addClass('fc-limited').after($(segMoreNodes)); // hide original <td> and inject replacements
					limitedNodes.push(td[0]);
				}
			}

			emptyCellsUntil(this.colCnt); // finish off the level
			rowStruct.moreEls = $(moreNodes); // for easy undoing later
			rowStruct.limitedEls = $(limitedNodes); // for easy undoing later
		}
	},


	// Reveals all levels and removes all "more"-related elements for a grid's row.
	// `row` is a row number.
	unlimitRow: function(row) {
		var rowStruct = this.rowStructs[row];

		if (rowStruct.moreEls) {
			rowStruct.moreEls.remove();
			rowStruct.moreEls = null;
		}

		if (rowStruct.limitedEls) {
			rowStruct.limitedEls.removeClass('fc-limited');
			rowStruct.limitedEls = null;
		}
	},


	// Renders an <a> element that represents hidden event element for a cell.
	// Responsible for attaching click handler as well.
	renderMoreLink: function(row, col, hiddenSegs) {
		var _this = this;
		var view = this.view;

		return $('<a class="fc-more"/>')
			.text(
				this.getMoreLinkText(hiddenSegs.length)
			)
			.on('click', function(ev) {
				var clickOption = view.opt('eventLimitClick');
				var date = _this.getCellDate(row, col);
				var moreEl = $(this);
				var dayEl = _this.getCellEl(row, col);
				var allSegs = _this.getCellSegs(row, col);

				// rescope the segments to be within the cell's date
				var reslicedAllSegs = _this.resliceDaySegs(allSegs, date);
				var reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);

				if (typeof clickOption === 'function') {
					// the returned value can be an atomic option
					clickOption = view.publiclyTrigger('eventLimitClick', null, {
						date: date,
						dayEl: dayEl,
						moreEl: moreEl,
						segs: reslicedAllSegs,
						hiddenSegs: reslicedHiddenSegs
					}, ev);
				}

				if (clickOption === 'popover') {
					_this.showSegPopover(row, col, moreEl, reslicedAllSegs);
				}
				else if (typeof clickOption === 'string') { // a view name
					view.calendar.zoomTo(date, clickOption);
				}
			});
	},


	// Reveals the popover that displays all events within a cell
	showSegPopover: function(row, col, moreLink, segs) {
		var _this = this;
		var view = this.view;
		var moreWrap = moreLink.parent(); // the <div> wrapper around the <a>
		var topEl; // the element we want to match the top coordinate of
		var options;

		if (this.rowCnt == 1) {
			topEl = view.el; // will cause the popover to cover any sort of header
		}
		else {
			topEl = this.rowEls.eq(row); // will align with top of row
		}

		options = {
			className: 'fc-more-popover',
			content: this.renderSegPopoverContent(row, col, segs),
			parentEl: this.view.el, // attach to root of view. guarantees outside of scrollbars.
			top: topEl.offset().top,
			autoHide: true, // when the user clicks elsewhere, hide the popover
			viewportConstrain: view.opt('popoverViewportConstrain'),
			hide: function() {
				// kill everything when the popover is hidden
				// notify events to be removed
				if (_this.popoverSegs) {
					var seg;
					for (var i = 0; i < _this.popoverSegs.length; ++i) {
						seg = _this.popoverSegs[i];
						view.publiclyTrigger('eventDestroy', seg.event, seg.event, seg.el);
					}
				}
				_this.segPopover.removeElement();
				_this.segPopover = null;
				_this.popoverSegs = null;
			}
		};

		// Determine horizontal coordinate.
		// We use the moreWrap instead of the <td> to avoid border confusion.
		if (this.isRTL) {
			options.right = moreWrap.offset().left + moreWrap.outerWidth() + 1; // +1 to be over cell border
		}
		else {
			options.left = moreWrap.offset().left - 1; // -1 to be over cell border
		}

		this.segPopover = new Popover(options);
		this.segPopover.show();

		// the popover doesn't live within the grid's container element, and thus won't get the event
		// delegated-handlers for free. attach event-related handlers to the popover.
		this.bindSegHandlersToEl(this.segPopover.el);
	},


	// Builds the inner DOM contents of the segment popover
	renderSegPopoverContent: function(row, col, segs) {
		var view = this.view;
		var isTheme = view.opt('theme');
		var title = this.getCellDate(row, col).format(view.opt('dayPopoverFormat'));
		var content = $(
			'<div class="fc-header ' + view.widgetHeaderClass + '">' +
				'<span class="fc-close ' +
					(isTheme ? 'ui-icon ui-icon-closethick' : 'fc-icon fc-icon-x') +
				'"></span>' +
				'<span class="fc-title">' +
					htmlEscape(title) +
				'</span>' +
				'<div class="fc-clear"/>' +
			'</div>' +
			'<div class="fc-body ' + view.widgetContentClass + '">' +
				'<div class="fc-event-container"></div>' +
			'</div>'
		);
		var segContainer = content.find('.fc-event-container');
		var i;

		// render each seg's `el` and only return the visible segs
		segs = this.renderFgSegEls(segs, true); // disableResizing=true
		this.popoverSegs = segs;

		for (i = 0; i < segs.length; i++) {

			// because segments in the popover are not part of a grid coordinate system, provide a hint to any
			// grids that want to do drag-n-drop about which cell it came from
			this.prepareHits();
			segs[i].hit = this.getCellHit(row, col);
			this.releaseHits();

			segContainer.append(segs[i].el);
		}

		return content;
	},


	// Given the events within an array of segment objects, reslice them to be in a single day
	resliceDaySegs: function(segs, dayDate) {

		// build an array of the original events
		var events = $.map(segs, function(seg) {
			return seg.event;
		});

		var dayStart = dayDate.clone();
		var dayEnd = dayStart.clone().add(1, 'days');
		var dayRange = { start: dayStart, end: dayEnd };

		// slice the events with a custom slicing function
		segs = this.eventsToSegs(
			events,
			function(range) {
				var seg = intersectRanges(range, dayRange); // undefind if no intersection
				return seg ? [ seg ] : []; // must return an array of segments
			}
		);

		// force an order because eventsToSegs doesn't guarantee one
		this.sortEventSegs(segs);

		return segs;
	},


	// Generates the text that should be inside a "more" link, given the number of events it represents
	getMoreLinkText: function(num) {
		var opt = this.view.opt('eventLimitText');

		if (typeof opt === 'function') {
			return opt(num);
		}
		else {
			return '+' + num + ' ' + opt;
		}
	},


	// Returns segments within a given cell.
	// If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.
	getCellSegs: function(row, col, startLevel) {
		var segMatrix = this.rowStructs[row].segMatrix;
		var level = startLevel || 0;
		var segs = [];
		var seg;

		while (level < segMatrix.length) {
			seg = segMatrix[level][col];
			if (seg) {
				segs.push(seg);
			}
			level++;
		}

		return segs;
	}

});

;;

/* A component that renders one or more columns of vertical time slots
----------------------------------------------------------------------------------------------------------------------*/
// We mixin DayTable, even though there is only a single row of days

var TimeGrid = FC.TimeGrid = Grid.extend(DayTableMixin, {

	slotDuration: null, // duration of a "slot", a distinct time segment on given day, visualized by lines
	snapDuration: null, // granularity of time for dragging and selecting
	snapsPerSlot: null,
	minTime: null, // Duration object that denotes the first visible time of any given day
	maxTime: null, // Duration object that denotes the exclusive visible end time of any given day
	labelFormat: null, // formatting string for times running along vertical axis
	labelInterval: null, // duration of how often a label should be displayed for a slot

	colEls: null, // cells elements in the day-row background
	slatContainerEl: null, // div that wraps all the slat rows
	slatEls: null, // elements running horizontally across all columns
	nowIndicatorEls: null,

	colCoordCache: null,
	slatCoordCache: null,


	constructor: function() {
		Grid.apply(this, arguments); // call the super-constructor

		this.processOptions();
	},


	// Renders the time grid into `this.el`, which should already be assigned.
	// Relies on the view's colCnt. In the future, this component should probably be self-sufficient.
	renderDates: function() {
		this.el.html(this.renderHtml());
		this.colEls = this.el.find('.fc-day');
		this.slatContainerEl = this.el.find('.fc-slats');
		this.slatEls = this.slatContainerEl.find('tr');

		this.colCoordCache = new CoordCache({
			els: this.colEls,
			isHorizontal: true
		});
		this.slatCoordCache = new CoordCache({
			els: this.slatEls,
			isVertical: true
		});

		this.renderContentSkeleton();
	},


	// Renders the basic HTML skeleton for the grid
	renderHtml: function() {
		return '' +
			'<div class="fc-bg">' +
				'<table>' +
					this.renderBgTrHtml(0) + // row=0
				'</table>' +
			'</div>' +
			'<div class="fc-slats">' +
				'<table>' +
					this.renderSlatRowHtml() +
				'</table>' +
			'</div>';
	},


	// Generates the HTML for the horizontal "slats" that run width-wise. Has a time axis on a side. Depends on RTL.
	renderSlatRowHtml: function() {
		var view = this.view;
		var isRTL = this.isRTL;
		var html = '';
		var slotTime = moment.duration(+this.minTime); // wish there was .clone() for durations
		var slotDate; // will be on the view's first day, but we only care about its time
		var isLabeled;
		var axisHtml;

		// Calculate the time for each slot
		while (slotTime < this.maxTime) {
			slotDate = this.start.clone().time(slotTime);
			isLabeled = isInt(divideDurationByDuration(slotTime, this.labelInterval));

			axisHtml =
				'<td class="fc-axis fc-time ' + view.widgetContentClass + '" ' + view.axisStyleAttr() + '>' +
					(isLabeled ?
						'<span>' + // for matchCellWidths
							htmlEscape(slotDate.format(this.labelFormat)) +
						'</span>' :
						''
						) +
				'</td>';

			html +=
				'<tr data-time="' + slotDate.format('HH:mm:ss') + '"' +
					(isLabeled ? '' : ' class="fc-minor"') +
					'>' +
					(!isRTL ? axisHtml : '') +
					'<td class="' + view.widgetContentClass + '"/>' +
					(isRTL ? axisHtml : '') +
				"</tr>";

			slotTime.add(this.slotDuration);
		}

		return html;
	},


	/* Options
	------------------------------------------------------------------------------------------------------------------*/


	// Parses various options into properties of this object
	processOptions: function() {
		var view = this.view;
		var slotDuration = view.opt('slotDuration');
		var snapDuration = view.opt('snapDuration');
		var input;

		slotDuration = moment.duration(slotDuration);
		snapDuration = snapDuration ? moment.duration(snapDuration) : slotDuration;

		this.slotDuration = slotDuration;
		this.snapDuration = snapDuration;
		this.snapsPerSlot = slotDuration / snapDuration; // TODO: ensure an integer multiple?

		this.minResizeDuration = snapDuration; // hack

		this.minTime = moment.duration(view.opt('minTime'));
		this.maxTime = moment.duration(view.opt('maxTime'));

		// might be an array value (for TimelineView).
		// if so, getting the most granular entry (the last one probably).
		input = view.opt('slotLabelFormat');
		if ($.isArray(input)) {
			input = input[input.length - 1];
		}

		this.labelFormat =
			input ||
			view.opt('smallTimeFormat'); // the computed default

		input = view.opt('slotLabelInterval');
		this.labelInterval = input ?
			moment.duration(input) :
			this.computeLabelInterval(slotDuration);
	},


	// Computes an automatic value for slotLabelInterval
	computeLabelInterval: function(slotDuration) {
		var i;
		var labelInterval;
		var slotsPerLabel;

		// find the smallest stock label interval that results in more than one slots-per-label
		for (i = AGENDA_STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {
			labelInterval = moment.duration(AGENDA_STOCK_SUB_DURATIONS[i]);
			slotsPerLabel = divideDurationByDuration(labelInterval, slotDuration);
			if (isInt(slotsPerLabel) && slotsPerLabel > 1) {
				return labelInterval;
			}
		}

		return moment.duration(slotDuration); // fall back. clone
	},


	// Computes a default event time formatting string if `timeFormat` is not explicitly defined
	computeEventTimeFormat: function() {
		return this.view.opt('noMeridiemTimeFormat'); // like "6:30" (no AM/PM)
	},


	// Computes a default `displayEventEnd` value if one is not expliclty defined
	computeDisplayEventEnd: function() {
		return true;
	},


	/* Hit System
	------------------------------------------------------------------------------------------------------------------*/


	prepareHits: function() {
		this.colCoordCache.build();
		this.slatCoordCache.build();
	},


	releaseHits: function() {
		this.colCoordCache.clear();
		// NOTE: don't clear slatCoordCache because we rely on it for computeTimeTop
	},


	queryHit: function(leftOffset, topOffset) {
		var snapsPerSlot = this.snapsPerSlot;
		var colCoordCache = this.colCoordCache;
		var slatCoordCache = this.slatCoordCache;

		if (colCoordCache.isLeftInBounds(leftOffset) && slatCoordCache.isTopInBounds(topOffset)) {
			var colIndex = colCoordCache.getHorizontalIndex(leftOffset);
			var slatIndex = slatCoordCache.getVerticalIndex(topOffset);

			if (colIndex != null && slatIndex != null) {
				var slatTop = slatCoordCache.getTopOffset(slatIndex);
				var slatHeight = slatCoordCache.getHeight(slatIndex);
				var partial = (topOffset - slatTop) / slatHeight; // floating point number between 0 and 1
				var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat
				var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;
				var snapTop = slatTop + (localSnapIndex / snapsPerSlot) * slatHeight;
				var snapBottom = slatTop + ((localSnapIndex + 1) / snapsPerSlot) * slatHeight;

				return {
					col: colIndex,
					snap: snapIndex,
					component: this, // needed unfortunately :(
					left: colCoordCache.getLeftOffset(colIndex),
					right: colCoordCache.getRightOffset(colIndex),
					top: snapTop,
					bottom: snapBottom
				};
			}
		}
	},


	getHitSpan: function(hit) {
		var start = this.getCellDate(0, hit.col); // row=0
		var time = this.computeSnapTime(hit.snap); // pass in the snap-index
		var end;

		start.time(time);
		end = start.clone().add(this.snapDuration);

		return { start: start, end: end };
	},


	getHitEl: function(hit) {
		return this.colEls.eq(hit.col);
	},


	/* Dates
	------------------------------------------------------------------------------------------------------------------*/


	rangeUpdated: function() {
		this.updateDayTable();
	},


	// Given a row number of the grid, representing a "snap", returns a time (Duration) from its start-of-day
	computeSnapTime: function(snapIndex) {
		return moment.duration(this.minTime + this.snapDuration * snapIndex);
	},


	// Slices up the given span (unzoned start/end with other misc data) into an array of segments
	spanToSegs: function(span) {
		var segs = this.sliceRangeByTimes(span);
		var i;

		for (i = 0; i < segs.length; i++) {
			if (this.isRTL) {
				segs[i].col = this.daysPerRow - 1 - segs[i].dayIndex;
			}
			else {
				segs[i].col = segs[i].dayIndex;
			}
		}

		return segs;
	},


	sliceRangeByTimes: function(range) {
		var segs = [];
		var seg;
		var dayIndex;
		var dayDate;
		var dayRange;

		for (dayIndex = 0; dayIndex < this.daysPerRow; dayIndex++) {
			dayDate = this.dayDates[dayIndex].clone(); // TODO: better API for this?
			dayRange = {
				start: dayDate.clone().time(this.minTime),
				end: dayDate.clone().time(this.maxTime)
			};
			seg = intersectRanges(range, dayRange); // both will be ambig timezone
			if (seg) {
				seg.dayIndex = dayIndex;
				segs.push(seg);
			}
		}

		return segs;
	},


	/* Coordinates
	------------------------------------------------------------------------------------------------------------------*/


	updateSize: function(isResize) { // NOT a standard Grid method
		this.slatCoordCache.build();

		if (isResize) {
			this.updateSegVerticals(
				[].concat(this.fgSegs || [], this.bgSegs || [], this.businessSegs || [])
			);
		}
	},


	getTotalSlatHeight: function() {
		return this.slatContainerEl.outerHeight();
	},


	// Computes the top coordinate, relative to the bounds of the grid, of the given date.
	// A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.
	computeDateTop: function(date, startOfDayDate) {
		return this.computeTimeTop(
			moment.duration(
				date - startOfDayDate.clone().stripTime()
			)
		);
	},


	// Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).
	computeTimeTop: function(time) {
		var len = this.slatEls.length;
		var slatCoverage = (time - this.minTime) / this.slotDuration; // floating-point value of # of slots covered
		var slatIndex;
		var slatRemainder;

		// compute a floating-point number for how many slats should be progressed through.
		// from 0 to number of slats (inclusive)
		// constrained because minTime/maxTime might be customized.
		slatCoverage = Math.max(0, slatCoverage);
		slatCoverage = Math.min(len, slatCoverage);

		// an integer index of the furthest whole slat
		// from 0 to number slats (*exclusive*, so len-1)
		slatIndex = Math.floor(slatCoverage);
		slatIndex = Math.min(slatIndex, len - 1);

		// how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.
		// could be 1.0 if slatCoverage is covering *all* the slots
		slatRemainder = slatCoverage - slatIndex;

		return this.slatCoordCache.getTopPosition(slatIndex) +
			this.slatCoordCache.getHeight(slatIndex) * slatRemainder;
	},



	/* Event Drag Visualization
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of an event being dragged over the specified date(s).
	// A returned value of `true` signals that a mock "helper" event has been rendered.
	renderDrag: function(eventLocation, seg) {

		if (seg) { // if there is event information for this drag, render a helper event

			// returns mock event elements
			// signal that a helper has been rendered
			return this.renderEventLocationHelper(eventLocation, seg);
		}
		else {
			// otherwise, just render a highlight
			this.renderHighlight(this.eventToSpan(eventLocation));
		}
	},


	// Unrenders any visual indication of an event being dragged
	unrenderDrag: function() {
		this.unrenderHelper();
		this.unrenderHighlight();
	},


	/* Event Resize Visualization
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of an event being resized
	renderEventResize: function(eventLocation, seg) {
		return this.renderEventLocationHelper(eventLocation, seg); // returns mock event elements
	},


	// Unrenders any visual indication of an event being resized
	unrenderEventResize: function() {
		this.unrenderHelper();
	},


	/* Event Helper
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a mock "helper" event. `sourceSeg` is the original segment object and might be null (an external drag)
	renderHelper: function(event, sourceSeg) {
		return this.renderHelperSegs(this.eventToSegs(event), sourceSeg); // returns mock event elements
	},


	// Unrenders any mock helper event
	unrenderHelper: function() {
		this.unrenderHelperSegs();
	},


	/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/


	renderBusinessHours: function() {
		this.renderBusinessSegs(
			this.buildBusinessHourSegs()
		);
	},


	unrenderBusinessHours: function() {
		this.unrenderBusinessSegs();
	},


	/* Now Indicator
	------------------------------------------------------------------------------------------------------------------*/


	getNowIndicatorUnit: function() {
		return 'minute'; // will refresh on the minute
	},


	renderNowIndicator: function(date) {
		// seg system might be overkill, but it handles scenario where line needs to be rendered
		//  more than once because of columns with the same date (resources columns for example)
		var segs = this.spanToSegs({ start: date, end: date });
		var top = this.computeDateTop(date, date);
		var nodes = [];
		var i;

		// render lines within the columns
		for (i = 0; i < segs.length; i++) {
			nodes.push($('<div class="fc-now-indicator fc-now-indicator-line"></div>')
				.css('top', top)
				.appendTo(this.colContainerEls.eq(segs[i].col))[0]);
		}

		// render an arrow over the axis
		if (segs.length > 0) { // is the current time in view?
			nodes.push($('<div class="fc-now-indicator fc-now-indicator-arrow"></div>')
				.css('top', top)
				.appendTo(this.el.find('.fc-content-skeleton'))[0]);
		}

		this.nowIndicatorEls = $(nodes);
	},


	unrenderNowIndicator: function() {
		if (this.nowIndicatorEls) {
			this.nowIndicatorEls.remove();
			this.nowIndicatorEls = null;
		}
	},


	/* Selection
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.
	renderSelection: function(span) {
		if (this.view.opt('selectHelper')) { // this setting signals that a mock helper event should be rendered

			// normally acceps an eventLocation, span has a start/end, which is good enough
			this.renderEventLocationHelper(span);
		}
		else {
			this.renderHighlight(span);
		}
	},


	// Unrenders any visual indication of a selection
	unrenderSelection: function() {
		this.unrenderHelper();
		this.unrenderHighlight();
	},


	/* Highlight
	------------------------------------------------------------------------------------------------------------------*/


	renderHighlight: function(span) {
		this.renderHighlightSegs(this.spanToSegs(span));
	},


	unrenderHighlight: function() {
		this.unrenderHighlightSegs();
	}

});

;;

/* Methods for rendering SEGMENTS, pieces of content that live on the view
 ( this file is no longer just for events )
----------------------------------------------------------------------------------------------------------------------*/

TimeGrid.mixin({

	colContainerEls: null, // containers for each column

	// inner-containers for each column where different types of segs live
	fgContainerEls: null,
	bgContainerEls: null,
	helperContainerEls: null,
	highlightContainerEls: null,
	businessContainerEls: null,

	// arrays of different types of displayed segments
	fgSegs: null,
	bgSegs: null,
	helperSegs: null,
	highlightSegs: null,
	businessSegs: null,


	// Renders the DOM that the view's content will live in
	renderContentSkeleton: function() {
		var cellHtml = '';
		var i;
		var skeletonEl;

		for (i = 0; i < this.colCnt; i++) {
			cellHtml +=
				'<td>' +
					'<div class="fc-content-col">' +
						'<div class="fc-event-container fc-helper-container"></div>' +
						'<div class="fc-event-container"></div>' +
						'<div class="fc-highlight-container"></div>' +
						'<div class="fc-bgevent-container"></div>' +
						'<div class="fc-business-container"></div>' +
					'</div>' +
				'</td>';
		}

		skeletonEl = $(
			'<div class="fc-content-skeleton">' +
				'<table>' +
					'<tr>' + cellHtml + '</tr>' +
				'</table>' +
			'</div>'
		);

		this.colContainerEls = skeletonEl.find('.fc-content-col');
		this.helperContainerEls = skeletonEl.find('.fc-helper-container');
		this.fgContainerEls = skeletonEl.find('.fc-event-container:not(.fc-helper-container)');
		this.bgContainerEls = skeletonEl.find('.fc-bgevent-container');
		this.highlightContainerEls = skeletonEl.find('.fc-highlight-container');
		this.businessContainerEls = skeletonEl.find('.fc-business-container');

		this.bookendCells(skeletonEl.find('tr')); // TODO: do this on string level
		this.el.append(skeletonEl);
	},


	/* Foreground Events
	------------------------------------------------------------------------------------------------------------------*/


	renderFgSegs: function(segs) {
		segs = this.renderFgSegsIntoContainers(segs, this.fgContainerEls);
		this.fgSegs = segs;
		return segs; // needed for Grid::renderEvents
	},


	unrenderFgSegs: function() {
		this.unrenderNamedSegs('fgSegs');
	},


	/* Foreground Helper Events
	------------------------------------------------------------------------------------------------------------------*/


	renderHelperSegs: function(segs, sourceSeg) {
		var helperEls = [];
		var i, seg;
		var sourceEl;

		segs = this.renderFgSegsIntoContainers(segs, this.helperContainerEls);

		// Try to make the segment that is in the same row as sourceSeg look the same
		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			if (sourceSeg && sourceSeg.col === seg.col) {
				sourceEl = sourceSeg.el;
				seg.el.css({
					left: sourceEl.css('left'),
					right: sourceEl.css('right'),
					'margin-left': sourceEl.css('margin-left'),
					'margin-right': sourceEl.css('margin-right')
				});
			}
			helperEls.push(seg.el[0]);
		}

		this.helperSegs = segs;

		return $(helperEls); // must return rendered helpers
	},


	unrenderHelperSegs: function() {
		this.unrenderNamedSegs('helperSegs');
	},


	/* Background Events
	------------------------------------------------------------------------------------------------------------------*/


	renderBgSegs: function(segs) {
		segs = this.renderFillSegEls('bgEvent', segs); // TODO: old fill system
		this.updateSegVerticals(segs);
		this.attachSegsByCol(this.groupSegsByCol(segs), this.bgContainerEls);
		this.bgSegs = segs;
		return segs; // needed for Grid::renderEvents
	},


	unrenderBgSegs: function() {
		this.unrenderNamedSegs('bgSegs');
	},


	/* Highlight
	------------------------------------------------------------------------------------------------------------------*/


	renderHighlightSegs: function(segs) {
		segs = this.renderFillSegEls('highlight', segs); // TODO: old fill system
		this.updateSegVerticals(segs);
		this.attachSegsByCol(this.groupSegsByCol(segs), this.highlightContainerEls);
		this.highlightSegs = segs;
	},


	unrenderHighlightSegs: function() {
		this.unrenderNamedSegs('highlightSegs');
	},


	/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/


	renderBusinessSegs: function(segs) {
		segs = this.renderFillSegEls('businessHours', segs); // TODO: old fill system
		this.updateSegVerticals(segs);
		this.attachSegsByCol(this.groupSegsByCol(segs), this.businessContainerEls);
		this.businessSegs = segs;
	},


	unrenderBusinessSegs: function() {
		this.unrenderNamedSegs('businessSegs');
	},


	/* Seg Rendering Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col
	groupSegsByCol: function(segs) {
		var segsByCol = [];
		var i;

		for (i = 0; i < this.colCnt; i++) {
			segsByCol.push([]);
		}

		for (i = 0; i < segs.length; i++) {
			segsByCol[segs[i].col].push(segs[i]);
		}

		return segsByCol;
	},


	// Given segments grouped by column, insert the segments' elements into a parallel array of container
	// elements, each living within a column.
	attachSegsByCol: function(segsByCol, containerEls) {
		var col;
		var segs;
		var i;

		for (col = 0; col < this.colCnt; col++) { // iterate each column grouping
			segs = segsByCol[col];

			for (i = 0; i < segs.length; i++) {
				containerEls.eq(col).append(segs[i].el);
			}
		}
	},


	// Given the name of a property of `this` object, assumed to be an array of segments,
	// loops through each segment and removes from DOM. Will null-out the property afterwards.
	unrenderNamedSegs: function(propName) {
		var segs = this[propName];
		var i;

		if (segs) {
			for (i = 0; i < segs.length; i++) {
				segs[i].el.remove();
			}
			this[propName] = null;
		}
	},



	/* Foreground Event Rendering Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Given an array of foreground segments, render a DOM element for each, computes position,
	// and attaches to the column inner-container elements.
	renderFgSegsIntoContainers: function(segs, containerEls) {
		var segsByCol;
		var col;

		segs = this.renderFgSegEls(segs); // will call fgSegHtml
		segsByCol = this.groupSegsByCol(segs);

		for (col = 0; col < this.colCnt; col++) {
			this.updateFgSegCoords(segsByCol[col]);
		}

		this.attachSegsByCol(segsByCol, containerEls);

		return segs;
	},


	// Renders the HTML for a single event segment's default rendering
	fgSegHtml: function(seg, disableResizing) {
		var view = this.view;
		var event = seg.event;
		var isDraggable = view.isEventDraggable(event);
		var isResizableFromStart = !disableResizing && seg.isStart && view.isEventResizableFromStart(event);
		var isResizableFromEnd = !disableResizing && seg.isEnd && view.isEventResizableFromEnd(event);
		var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
		var skinCss = cssToStr(this.getSegSkinCss(seg));
		var timeText;
		var fullTimeText; // more verbose time text. for the print stylesheet
		var startTimeText; // just the start time text

		classes.unshift('fc-time-grid-event', 'fc-v-event');

		if (view.isMultiDayEvent(event)) { // if the event appears to span more than one day...
			// Don't display time text on segments that run entirely through a day.
			// That would appear as midnight-midnight and would look dumb.
			// Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)
			if (seg.isStart || seg.isEnd) {
				timeText = this.getEventTimeText(seg);
				fullTimeText = this.getEventTimeText(seg, 'LT');
				startTimeText = this.getEventTimeText(seg, null, false); // displayEnd=false
			}
		} else {
			// Display the normal time text for the *event's* times
			timeText = this.getEventTimeText(event);
			fullTimeText = this.getEventTimeText(event, 'LT');
			startTimeText = this.getEventTimeText(event, null, false); // displayEnd=false
		}

		return '<a class="' + classes.join(' ') + '"' +
			(event.url ?
				' href="' + htmlEscape(event.url) + '"' :
				''
				) +
			(skinCss ?
				' style="' + skinCss + '"' :
				''
				) +
			'>' +
				'<div class="fc-content">' +
					(timeText ?
						'<div class="fc-time"' +
						' data-start="' + htmlEscape(startTimeText) + '"' +
						' data-full="' + htmlEscape(fullTimeText) + '"' +
						'>' +
							'<span>' + htmlEscape(timeText) + '</span>' +
						'</div>' :
						''
						) +
					(event.title ?
						'<div class="fc-title">' +
							htmlEscape(event.title) +
						'</div>' :
						''
						) +
				'</div>' +
				'<div class="fc-bg"/>' +
				/* TODO: write CSS for this
				(isResizableFromStart ?
					'<div class="fc-resizer fc-start-resizer" />' :
					''
					) +
				*/
				(isResizableFromEnd ?
					'<div class="fc-resizer fc-end-resizer" />' :
					''
					) +
			'</a>';
	},


	/* Seg Position Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Refreshes the CSS top/bottom coordinates for each segment element.
	// Works when called after initial render, after a window resize/zoom for example.
	updateSegVerticals: function(segs) {
		this.computeSegVerticals(segs);
		this.assignSegVerticals(segs);
	},


	// For each segment in an array, computes and assigns its top and bottom properties
	computeSegVerticals: function(segs) {
		var i, seg;

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			seg.top = this.computeDateTop(seg.start, seg.start);
			seg.bottom = this.computeDateTop(seg.end, seg.start);
		}
	},


	// Given segments that already have their top/bottom properties computed, applies those values to
	// the segments' elements.
	assignSegVerticals: function(segs) {
		var i, seg;

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			seg.el.css(this.generateSegVerticalCss(seg));
		}
	},


	// Generates an object with CSS properties for the top/bottom coordinates of a segment element
	generateSegVerticalCss: function(seg) {
		return {
			top: seg.top,
			bottom: -seg.bottom // flipped because needs to be space beyond bottom edge of event container
		};
	},


	/* Foreground Event Positioning Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Given segments that are assumed to all live in the *same column*,
	// compute their verical/horizontal coordinates and assign to their elements.
	updateFgSegCoords: function(segs) {
		this.computeSegVerticals(segs); // horizontals relies on this
		this.computeFgSegHorizontals(segs); // compute horizontal coordinates, z-index's, and reorder the array
		this.assignSegVerticals(segs);
		this.assignFgSegHorizontals(segs);
	},


	// Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.
	// NOTE: Also reorders the given array by date!
	computeFgSegHorizontals: function(segs) {
		var levels;
		var level0;
		var i;

		this.sortEventSegs(segs); // order by certain criteria
		levels = buildSlotSegLevels(segs);
		computeForwardSlotSegs(levels);

		if ((level0 = levels[0])) {

			for (i = 0; i < level0.length; i++) {
				computeSlotSegPressures(level0[i]);
			}

			for (i = 0; i < level0.length; i++) {
				this.computeFgSegForwardBack(level0[i], 0, 0);
			}
		}
	},


	// Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range
	// from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to "left" and
	// seg.forwardCoord maps to "right" (via percentage). Vice-versa if the calendar is right-to-left.
	//
	// The segment might be part of a "series", which means consecutive segments with the same pressure
	// who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of
	// segments behind this one in the current series, and `seriesBackwardCoord` is the starting
	// coordinate of the first segment in the series.
	computeFgSegForwardBack: function(seg, seriesBackwardPressure, seriesBackwardCoord) {
		var forwardSegs = seg.forwardSegs;
		var i;

		if (seg.forwardCoord === undefined) { // not already computed

			if (!forwardSegs.length) {

				// if there are no forward segments, this segment should butt up against the edge
				seg.forwardCoord = 1;
			}
			else {

				// sort highest pressure first
				this.sortForwardSegs(forwardSegs);

				// this segment's forwardCoord will be calculated from the backwardCoord of the
				// highest-pressure forward segment.
				this.computeFgSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);
				seg.forwardCoord = forwardSegs[0].backwardCoord;
			}

			// calculate the backwardCoord from the forwardCoord. consider the series
			seg.backwardCoord = seg.forwardCoord -
				(seg.forwardCoord - seriesBackwardCoord) / // available width for series
				(seriesBackwardPressure + 1); // # of segments in the series

			// use this segment's coordinates to computed the coordinates of the less-pressurized
			// forward segments
			for (i=0; i<forwardSegs.length; i++) {
				this.computeFgSegForwardBack(forwardSegs[i], 0, seg.forwardCoord);
			}
		}
	},


	sortForwardSegs: function(forwardSegs) {
		forwardSegs.sort(proxy(this, 'compareForwardSegs'));
	},


	// A cmp function for determining which forward segment to rely on more when computing coordinates.
	compareForwardSegs: function(seg1, seg2) {
		// put higher-pressure first
		return seg2.forwardPressure - seg1.forwardPressure ||
			// put segments that are closer to initial edge first (and favor ones with no coords yet)
			(seg1.backwardCoord || 0) - (seg2.backwardCoord || 0) ||
			// do normal sorting...
			this.compareEventSegs(seg1, seg2);
	},


	// Given foreground event segments that have already had their position coordinates computed,
	// assigns position-related CSS values to their elements.
	assignFgSegHorizontals: function(segs) {
		var i, seg;

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			seg.el.css(this.generateFgSegHorizontalCss(seg));

			// if the height is short, add a className for alternate styling
			if (seg.bottom - seg.top < 30) {
				seg.el.addClass('fc-short');
			}
		}
	},


	// Generates an object with CSS properties/values that should be applied to an event segment element.
	// Contains important positioning-related properties that should be applied to any event element, customized or not.
	generateFgSegHorizontalCss: function(seg) {
		var shouldOverlap = this.view.opt('slotEventOverlap');
		var backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point
		var forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point
		var props = this.generateSegVerticalCss(seg); // get top/bottom first
		var left; // amount of space from left edge, a fraction of the total width
		var right; // amount of space from right edge, a fraction of the total width

		if (shouldOverlap) {
			// double the width, but don't go beyond the maximum forward coordinate (1.0)
			forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);
		}

		if (this.isRTL) {
			left = 1 - forwardCoord;
			right = backwardCoord;
		}
		else {
			left = backwardCoord;
			right = 1 - forwardCoord;
		}

		props.zIndex = seg.level + 1; // convert from 0-base to 1-based
		props.left = left * 100 + '%';
		props.right = right * 100 + '%';

		if (shouldOverlap && seg.forwardPressure) {
			// add padding to the edge so that forward stacked events don't cover the resizer's icon
			props[this.isRTL ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width
		}

		return props;
	}

});


// Builds an array of segments "levels". The first level will be the leftmost tier of segments if the calendar is
// left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.
function buildSlotSegLevels(segs) {
	var levels = [];
	var i, seg;
	var j;

	for (i=0; i<segs.length; i++) {
		seg = segs[i];

		// go through all the levels and stop on the first level where there are no collisions
		for (j=0; j<levels.length; j++) {
			if (!computeSlotSegCollisions(seg, levels[j]).length) {
				break;
			}
		}

		seg.level = j;

		(levels[j] || (levels[j] = [])).push(seg);
	}

	return levels;
}


// For every segment, figure out the other segments that are in subsequent
// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs
function computeForwardSlotSegs(levels) {
	var i, level;
	var j, seg;
	var k;

	for (i=0; i<levels.length; i++) {
		level = levels[i];

		for (j=0; j<level.length; j++) {
			seg = level[j];

			seg.forwardSegs = [];
			for (k=i+1; k<levels.length; k++) {
				computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);
			}
		}
	}
}


// Figure out which path forward (via seg.forwardSegs) results in the longest path until
// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure
function computeSlotSegPressures(seg) {
	var forwardSegs = seg.forwardSegs;
	var forwardPressure = 0;
	var i, forwardSeg;

	if (seg.forwardPressure === undefined) { // not already computed

		for (i=0; i<forwardSegs.length; i++) {
			forwardSeg = forwardSegs[i];

			// figure out the child's maximum forward path
			computeSlotSegPressures(forwardSeg);

			// either use the existing maximum, or use the child's forward pressure
			// plus one (for the forwardSeg itself)
			forwardPressure = Math.max(
				forwardPressure,
				1 + forwardSeg.forwardPressure
			);
		}

		seg.forwardPressure = forwardPressure;
	}
}


// Find all the segments in `otherSegs` that vertically collide with `seg`.
// Append into an optionally-supplied `results` array and return.
function computeSlotSegCollisions(seg, otherSegs, results) {
	results = results || [];

	for (var i=0; i<otherSegs.length; i++) {
		if (isSlotSegCollision(seg, otherSegs[i])) {
			results.push(otherSegs[i]);
		}
	}

	return results;
}


// Do these segments occupy the same vertical space?
function isSlotSegCollision(seg1, seg2) {
	return seg1.bottom > seg2.top && seg1.top < seg2.bottom;
}

;;

/* An abstract class from which other views inherit from
----------------------------------------------------------------------------------------------------------------------*/

var View = FC.View = Class.extend(EmitterMixin, ListenerMixin, {

	type: null, // subclass' view name (string)
	name: null, // deprecated. use `type` instead
	title: null, // the text that will be displayed in the header's title

	calendar: null, // owner Calendar object
	options: null, // hash containing all options. already merged with view-specific-options
	el: null, // the view's containing element. set by Calendar

	isDateSet: false,
	isDateRendered: false,
	dateRenderQueue: null,

	isEventsBound: false,
	isEventsSet: false,
	isEventsRendered: false,
	eventRenderQueue: null,

	// range the view is actually displaying (moments)
	start: null,
	end: null, // exclusive

	// range the view is formally responsible for (moments)
	// may be different from start/end. for example, a month view might have 1st-31st, excluding padded dates
	intervalStart: null,
	intervalEnd: null, // exclusive
	intervalDuration: null,
	intervalUnit: null, // name of largest unit being displayed, like "month" or "week"

	isRTL: false,
	isSelected: false, // boolean whether a range of time is user-selected or not
	selectedEvent: null,

	eventOrderSpecs: null, // criteria for ordering events when they have same date/time

	// classNames styled by jqui themes
	widgetHeaderClass: null,
	widgetContentClass: null,
	highlightStateClass: null,

	// for date utils, computed from options
	nextDayThreshold: null,
	isHiddenDayHash: null,

	// now indicator
	isNowIndicatorRendered: null,
	initialNowDate: null, // result first getNow call
	initialNowQueriedMs: null, // ms time the getNow was called
	nowIndicatorTimeoutID: null, // for refresh timing of now indicator
	nowIndicatorIntervalID: null, // "


	constructor: function(calendar, type, options, intervalDuration) {

		this.calendar = calendar;
		this.type = this.name = type; // .name is deprecated
		this.options = options;
		this.intervalDuration = intervalDuration || moment.duration(1, 'day');

		this.nextDayThreshold = moment.duration(this.opt('nextDayThreshold'));
		this.initThemingProps();
		this.initHiddenDays();
		this.isRTL = this.opt('isRTL');

		this.eventOrderSpecs = parseFieldSpecs(this.opt('eventOrder'));

		this.dateRenderQueue = new TaskQueue();
		this.eventRenderQueue = new TaskQueue(this.opt('eventRenderWait'));

		this.initialize();
	},


	// A good place for subclasses to initialize member variables
	initialize: function() {
		// subclasses can implement
	},


	// Retrieves an option with the given name
	opt: function(name) {
		return this.options[name];
	},


	// Triggers handlers that are view-related. Modifies args before passing to calendar.
	publiclyTrigger: function(name, thisObj) { // arguments beyond thisObj are passed along
		var calendar = this.calendar;

		return calendar.publiclyTrigger.apply(
			calendar,
			[name, thisObj || this].concat(
				Array.prototype.slice.call(arguments, 2), // arguments beyond thisObj
				[ this ] // always make the last argument a reference to the view. TODO: deprecate
			)
		);
	},


	// Returns a proxy of the given promise that will be rejected if the given event fires
	// before the promise resolves.
	rejectOn: function(eventName, promise) {
		var _this = this;

		return new Promise(function(resolve, reject) {
			_this.one(eventName, reject);

			function cleanup() {
				_this.off(eventName, reject);
			}

			promise.then(function(res) { // success
				cleanup();
				resolve(res);
			}, function() { // failure
				cleanup();
				reject();
			});
		});
	},


	/* Date Computation
	------------------------------------------------------------------------------------------------------------------*/


	// Updates all internal dates for displaying the given unzoned range.
	setRange: function(range) {
		$.extend(this, range); // assigns every property to this object's member variables
		this.updateTitle();
	},


	// Given a single current unzoned date, produce information about what range to display.
	// Subclasses can override. Must return all properties.
	computeRange: function(date) {
		var intervalUnit = computeIntervalUnit(this.intervalDuration);
		var intervalStart = date.clone().startOf(intervalUnit);
		var intervalEnd = intervalStart.clone().add(this.intervalDuration);
		var start, end;

		// normalize the range's time-ambiguity
		if (/year|month|week|day/.test(intervalUnit)) { // whole-days?
			intervalStart.stripTime();
			intervalEnd.stripTime();
		}
		else { // needs to have a time?
			if (!intervalStart.hasTime()) {
				intervalStart = this.calendar.time(0); // give 00:00 time
			}
			if (!intervalEnd.hasTime()) {
				intervalEnd = this.calendar.time(0); // give 00:00 time
			}
		}

		start = intervalStart.clone();
		start = this.skipHiddenDays(start);
		end = intervalEnd.clone();
		end = this.skipHiddenDays(end, -1, true); // exclusively move backwards

		return {
			intervalUnit: intervalUnit,
			intervalStart: intervalStart,
			intervalEnd: intervalEnd,
			start: start,
			end: end
		};
	},


	// Computes the new date when the user hits the prev button, given the current date
	computePrevDate: function(date) {
		return this.massageCurrentDate(
			date.clone().startOf(this.intervalUnit).subtract(this.intervalDuration), -1
		);
	},


	// Computes the new date when the user hits the next button, given the current date
	computeNextDate: function(date) {
		return this.massageCurrentDate(
			date.clone().startOf(this.intervalUnit).add(this.intervalDuration)
		);
	},


	// Given an arbitrarily calculated current date of the calendar, returns a date that is ensured to be completely
	// visible. `direction` is optional and indicates which direction the current date was being
	// incremented or decremented (1 or -1).
	massageCurrentDate: function(date, direction) {
		if (this.intervalDuration.as('days') <= 1) { // if the view displays a single day or smaller
			if (this.isHiddenDay(date)) {
				date = this.skipHiddenDays(date, direction);
				date.startOf('day');
			}
		}

		return date;
	},


	/* Title and Date Formatting
	------------------------------------------------------------------------------------------------------------------*/


	// Sets the view's title property to the most updated computed value
	updateTitle: function() {
		this.title = this.computeTitle();
		this.calendar.setToolbarsTitle(this.title);
	},


	// Computes what the title at the top of the calendar should be for this view
	computeTitle: function() {
		return this.formatRange(
			{
				// in case intervalStart/End has a time, make sure timezone is correct
				start: this.calendar.applyTimezone(this.intervalStart),
				end: this.calendar.applyTimezone(this.intervalEnd)
			},
			this.opt('titleFormat') || this.computeTitleFormat(),
			this.opt('titleRangeSeparator')
		);
	},


	// Generates the format string that should be used to generate the title for the current date range.
	// Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.
	computeTitleFormat: function() {
		if (this.intervalUnit == 'year') {
			return 'YYYY';
		}
		else if (this.intervalUnit == 'month') {
			return this.opt('monthYearFormat'); // like "September 2014"
		}
		else if (this.intervalDuration.as('days') > 1) {
			return 'll'; // multi-day range. shorter, like "Sep 9 - 10 2014"
		}
		else {
			return 'LL'; // one day. longer, like "September 9 2014"
		}
	},


	// Utility for formatting a range. Accepts a range object, formatting string, and optional separator.
	// Displays all-day ranges naturally, with an inclusive end. Takes the current isRTL into account.
	// The timezones of the dates within `range` will be respected.
	formatRange: function(range, formatStr, separator) {
		var end = range.end;

		if (!end.hasTime()) { // all-day?
			end = end.clone().subtract(1); // convert to inclusive. last ms of previous day
		}

		return formatRange(range.start, end, formatStr, separator, this.opt('isRTL'));
	},


	getAllDayHtml: function() {
		return this.opt('allDayHtml') || htmlEscape(this.opt('allDayText'));
	},


	/* Navigation
	------------------------------------------------------------------------------------------------------------------*/


	// Generates HTML for an anchor to another view into the calendar.
	// Will either generate an <a> tag or a non-clickable <span> tag, depending on enabled settings.
	// `gotoOptions` can either be a moment input, or an object with the form:
	// { date, type, forceOff }
	// `type` is a view-type like "day" or "week". default value is "day".
	// `attrs` and `innerHtml` are use to generate the rest of the HTML tag.
	buildGotoAnchorHtml: function(gotoOptions, attrs, innerHtml) {
		var date, type, forceOff;
		var finalOptions;

		if ($.isPlainObject(gotoOptions)) {
			date = gotoOptions.date;
			type = gotoOptions.type;
			forceOff = gotoOptions.forceOff;
		}
		else {
			date = gotoOptions; // a single moment input
		}
		date = FC.moment(date); // if a string, parse it

		finalOptions = { // for serialization into the link
			date: date.format('YYYY-MM-DD'),
			type: type || 'day'
		};

		if (typeof attrs === 'string') {
			innerHtml = attrs;
			attrs = null;
		}

		attrs = attrs ? ' ' + attrsToStr(attrs) : ''; // will have a leading space
		innerHtml = innerHtml || '';

		if (!forceOff && this.opt('navLinks')) {
			return '<a' + attrs +
				' data-goto="' + htmlEscape(JSON.stringify(finalOptions)) + '">' +
				innerHtml +
				'</a>';
		}
		else {
			return '<span' + attrs + '>' +
				innerHtml +
				'</span>';
		}
	},


	// Rendering Non-date-related Content
	// -----------------------------------------------------------------------------------------------------------------


	// Sets the container element that the view should render inside of, does global DOM-related initializations,
	// and renders all the non-date-related content inside.
	setElement: function(el) {
		this.el = el;
		this.bindGlobalHandlers();
		this.renderSkeleton();
	},


	// Removes the view's container element from the DOM, clearing any content beforehand.
	// Undoes any other DOM-related attachments.
	removeElement: function() {
		this.unsetDate();
		this.unrenderSkeleton();

		this.unbindGlobalHandlers();

		this.el.remove();
		// NOTE: don't null-out this.el in case the View was destroyed within an API callback.
		// We don't null-out the View's other jQuery element references upon destroy,
		//  so we shouldn't kill this.el either.
	},


	// Renders the basic structure of the view before any content is rendered
	renderSkeleton: function() {
		// subclasses should implement
	},


	// Unrenders the basic structure of the view
	unrenderSkeleton: function() {
		// subclasses should implement
	},


	// Date Setting/Unsetting
	// -----------------------------------------------------------------------------------------------------------------


	setDate: function(date) {
		var isReset = this.isDateSet;

		this.isDateSet = true;
		this.handleDate(date, isReset);
		this.trigger(isReset ? 'dateReset' : 'dateSet', date);
	},


	unsetDate: function() {
		if (this.isDateSet) {
			this.isDateSet = false;
			this.handleDateUnset();
			this.trigger('dateUnset');
		}
	},


	// Date Handling
	// -----------------------------------------------------------------------------------------------------------------


	handleDate: function(date, isReset) {
		var _this = this;

		this.unbindEvents(); // will do nothing if not already bound
		this.requestDateRender(date).then(function() {
			// wish we could start earlier, but setRange/computeRange needs to execute first
			_this.bindEvents(); // will request events
		});
	},


	handleDateUnset: function() {
		this.unbindEvents();
		this.requestDateUnrender();
	},


	// Date Render Queuing
	// -----------------------------------------------------------------------------------------------------------------


	// if date not specified, uses current
	requestDateRender: function(date) {
		var _this = this;

		return this.dateRenderQueue.add(function() {
			return _this.executeDateRender(date);
		});
	},


	requestDateUnrender: function() {
		var _this = this;

		return this.dateRenderQueue.add(function() {
			return _this.executeDateUnrender();
		});
	},


	// Date High-level Rendering
	// -----------------------------------------------------------------------------------------------------------------


	// if date not specified, uses current
	executeDateRender: function(date) {
		var _this = this;

		// if rendering a new date, reset scroll to initial state (scrollTime)
		if (date) {
			this.captureInitialScroll();
		}
		else {
			this.captureScroll(); // a rerender of the current date
		}

		this.freezeHeight();

		return this.executeDateUnrender().then(function() {

			if (date) {
				_this.setRange(_this.computeRange(date));
			}

			if (_this.render) {
				_this.render(); // TODO: deprecate
			}

			_this.renderDates();
			_this.updateSize();
			_this.renderBusinessHours(); // might need coordinates, so should go after updateSize()
			_this.startNowIndicator();

			_this.thawHeight();
			_this.releaseScroll();

			_this.isDateRendered = true;
			_this.onDateRender();
			_this.trigger('dateRender');
		});
	},


	executeDateUnrender: function() {
		var _this = this;

		if (_this.isDateRendered) {
			return this.requestEventsUnrender().then(function() {

				_this.unselect();
				_this.stopNowIndicator();
				_this.triggerUnrender();
				_this.unrenderBusinessHours();
				_this.unrenderDates();

				if (_this.destroy) {
					_this.destroy(); // TODO: deprecate
				}

				_this.isDateRendered = false;
				_this.trigger('dateUnrender');
			});
		}
		else {
			return Promise.resolve();
		}
	},


	// Date Rendering Triggers
	// -----------------------------------------------------------------------------------------------------------------


	onDateRender: function() {
		this.triggerRender();
	},


	// Date Low-level Rendering
	// -----------------------------------------------------------------------------------------------------------------


	// date-cell content only
	renderDates: function() {
		// subclasses should implement
	},


	// date-cell content only
	unrenderDates: function() {
		// subclasses should override
	},


	// Misc view rendering utils
	// -------------------------


	// Signals that the view's content has been rendered
	triggerRender: function() {
		this.publiclyTrigger('viewRender', this, this, this.el);
	},


	// Signals that the view's content is about to be unrendered
	triggerUnrender: function() {
		this.publiclyTrigger('viewDestroy', this, this, this.el);
	},


	// Binds DOM handlers to elements that reside outside the view container, such as the document
	bindGlobalHandlers: function() {
		this.listenTo($(document), 'mousedown', this.handleDocumentMousedown);
		this.listenTo($(document), 'touchstart', this.processUnselect);
	},


	// Unbinds DOM handlers from elements that reside outside the view container
	unbindGlobalHandlers: function() {
		this.stopListeningTo($(document));
	},


	// Initializes internal variables related to theming
	initThemingProps: function() {
		var tm = this.opt('theme') ? 'ui' : 'fc';

		this.widgetHeaderClass = tm + '-widget-header';
		this.widgetContentClass = tm + '-widget-content';
		this.highlightStateClass = tm + '-state-highlight';
	},


	/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/


	// Renders business-hours onto the view. Assumes updateSize has already been called.
	renderBusinessHours: function() {
		// subclasses should implement
	},


	// Unrenders previously-rendered business-hours
	unrenderBusinessHours: function() {
		// subclasses should implement
	},


	/* Now Indicator
	------------------------------------------------------------------------------------------------------------------*/


	// Immediately render the current time indicator and begins re-rendering it at an interval,
	// which is defined by this.getNowIndicatorUnit().
	// TODO: somehow do this for the current whole day's background too
	startNowIndicator: function() {
		var _this = this;
		var unit;
		var update;
		var delay; // ms wait value

		if (this.opt('nowIndicator')) {
			unit = this.getNowIndicatorUnit();
			if (unit) {
				update = proxy(this, 'updateNowIndicator'); // bind to `this`

				this.initialNowDate = this.calendar.getNow();
				this.initialNowQueriedMs = +new Date();
				this.renderNowIndicator(this.initialNowDate);
				this.isNowIndicatorRendered = true;

				// wait until the beginning of the next interval
				delay = this.initialNowDate.clone().startOf(unit).add(1, unit) - this.initialNowDate;
				this.nowIndicatorTimeoutID = setTimeout(function() {
					_this.nowIndicatorTimeoutID = null;
					update();
					delay = +moment.duration(1, unit);
					delay = Math.max(100, delay); // prevent too frequent
					_this.nowIndicatorIntervalID = setInterval(update, delay); // update every interval
				}, delay);
			}
		}
	},


	// rerenders the now indicator, computing the new current time from the amount of time that has passed
	// since the initial getNow call.
	updateNowIndicator: function() {
		if (this.isNowIndicatorRendered) {
			this.unrenderNowIndicator();
			this.renderNowIndicator(
				this.initialNowDate.clone().add(new Date() - this.initialNowQueriedMs) // add ms
			);
		}
	},


	// Immediately unrenders the view's current time indicator and stops any re-rendering timers.
	// Won't cause side effects if indicator isn't rendered.
	stopNowIndicator: function() {
		if (this.isNowIndicatorRendered) {

			if (this.nowIndicatorTimeoutID) {
				clearTimeout(this.nowIndicatorTimeoutID);
				this.nowIndicatorTimeoutID = null;
			}
			if (this.nowIndicatorIntervalID) {
				clearTimeout(this.nowIndicatorIntervalID);
				this.nowIndicatorIntervalID = null;
			}

			this.unrenderNowIndicator();
			this.isNowIndicatorRendered = false;
		}
	},


	// Returns a string unit, like 'second' or 'minute' that defined how often the current time indicator
	// should be refreshed. If something falsy is returned, no time indicator is rendered at all.
	getNowIndicatorUnit: function() {
		// subclasses should implement
	},


	// Renders a current time indicator at the given datetime
	renderNowIndicator: function(date) {
		// subclasses should implement
	},


	// Undoes the rendering actions from renderNowIndicator
	unrenderNowIndicator: function() {
		// subclasses should implement
	},


	/* Dimensions
	------------------------------------------------------------------------------------------------------------------*/


	// Refreshes anything dependant upon sizing of the container element of the grid
	updateSize: function(isResize) {

		if (isResize) {
			this.captureScroll();
		}

		this.updateHeight(isResize);
		this.updateWidth(isResize);
		this.updateNowIndicator();

		if (isResize) {
			this.releaseScroll();
		}
	},


	// Refreshes the horizontal dimensions of the calendar
	updateWidth: function(isResize) {
		// subclasses should implement
	},


	// Refreshes the vertical dimensions of the calendar
	updateHeight: function(isResize) {
		var calendar = this.calendar; // we poll the calendar for height information

		this.setHeight(
			calendar.getSuggestedViewHeight(),
			calendar.isHeightAuto()
		);
	},


	// Updates the vertical dimensions of the calendar to the specified height.
	// if `isAuto` is set to true, height becomes merely a suggestion and the view should use its "natural" height.
	setHeight: function(height, isAuto) {
		// subclasses should implement
	},


	/* Scroller
	------------------------------------------------------------------------------------------------------------------*/


	capturedScroll: null,
	capturedScrollDepth: 0,


	captureScroll: function() {
		if (!(this.capturedScrollDepth++)) {
			this.capturedScroll = this.isDateRendered ? this.queryScroll() : {}; // require a render first
			return true; // root?
		}
		return false;
	},


	captureInitialScroll: function(forcedScroll) {
		if (this.captureScroll()) { // root?
			this.capturedScroll.isInitial = true;

			if (forcedScroll) {
				$.extend(this.capturedScroll, forcedScroll);
			}
			else {
				this.capturedScroll.isComputed = true;
			}
		}
	},


	releaseScroll: function() {
		var scroll = this.capturedScroll;
		var isRoot = this.discardScroll();

		if (scroll.isComputed) {
			if (isRoot) {
				// only compute initial scroll if it will actually be used (is the root capture)
				$.extend(scroll, this.computeInitialScroll());
			}
			else {
				scroll = null; // scroll couldn't be computed. don't apply it to the DOM
			}
		}

		if (scroll) {
			// we act immediately on a releaseScroll operation, as opposed to captureScroll.
			// if capture/release wraps a render operation that screws up the scroll,
			// we still want to restore it a good state after, regardless of depth.

			if (scroll.isInitial) {
				this.hardSetScroll(scroll); // outsmart how browsers set scroll on initial DOM
			}
			else {
				this.setScroll(scroll);
			}
		}
	},


	discardScroll: function() {
		if (!(--this.capturedScrollDepth)) {
			this.capturedScroll = null;
			return true; // root?
		}
		return false;
	},


	computeInitialScroll: function() {
		return {};
	},


	queryScroll: function() {
		return {};
	},


	hardSetScroll: function(scroll) {
		var _this = this;
		var exec = function() { _this.setScroll(scroll); };
		exec();
		setTimeout(exec, 0); // to surely clear the browser's initial scroll for the DOM
	},


	setScroll: function(scroll) {
	},


	/* Height Freezing
	------------------------------------------------------------------------------------------------------------------*/


	freezeHeight: function() {
		this.calendar.freezeContentHeight();
	},


	thawHeight: function() {
		this.calendar.thawContentHeight();
	},


	// Event Binding/Unbinding
	// -----------------------------------------------------------------------------------------------------------------


	bindEvents: function() {
		var _this = this;

		if (!this.isEventsBound) {
			this.isEventsBound = true;
			this.rejectOn('eventsUnbind', this.requestEvents()).then(function(events) { // TODO: test rejection
				_this.listenTo(_this.calendar, 'eventsReset', _this.setEvents);
				_this.setEvents(events);
			});
		}
	},


	unbindEvents: function() {
		if (this.isEventsBound) {
			this.isEventsBound = false;
			this.stopListeningTo(this.calendar, 'eventsReset');
			this.unsetEvents();
			this.trigger('eventsUnbind');
		}
	},


	// Event Setting/Unsetting
	// -----------------------------------------------------------------------------------------------------------------


	setEvents: function(events) {
		var isReset = this.isEventSet;

		this.isEventsSet = true;
		this.handleEvents(events, isReset);
		this.trigger(isReset ? 'eventsReset' : 'eventsSet', events);
	},


	unsetEvents: function() {
		if (this.isEventsSet) {
			this.isEventsSet = false;
			this.handleEventsUnset();
			this.trigger('eventsUnset');
		}
	},


	whenEventsSet: function() {
		var _this = this;

		if (this.isEventsSet) {
			return Promise.resolve(this.getCurrentEvents());
		}
		else {
			return new Promise(function(resolve) {
				_this.one('eventsSet', resolve);
			});
		}
	},


	// Event Handling
	// -----------------------------------------------------------------------------------------------------------------


	handleEvents: function(events, isReset) {
		this.requestEventsRender(events);
	},


	handleEventsUnset: function() {
		this.requestEventsUnrender();
	},


	// Event Render Queuing
	// -----------------------------------------------------------------------------------------------------------------


	// assumes any previous event renders have been cleared already
	requestEventsRender: function(events) {
		var _this = this;

		return this.eventRenderQueue.add(function() { // might not return a promise if debounced!? bad
			return _this.executeEventsRender(events);
		});
	},


	requestEventsUnrender: function() {
		var _this = this;

		if (this.isEventsRendered) {
			return this.eventRenderQueue.addQuickly(function() {
				return _this.executeEventsUnrender();
			});
		}
		else {
			return Promise.resolve();
		}
	},


	requestCurrentEventsRender: function() {
		if (this.isEventsSet) {
			this.requestEventsRender(this.getCurrentEvents());
		}
		else {
			return Promise.reject();
		}
	},


	// Event High-level Rendering
	// -----------------------------------------------------------------------------------------------------------------


	executeEventsRender: function(events) {
		var _this = this;

		this.captureScroll();
		this.freezeHeight();

		return this.executeEventsUnrender().then(function() {
			_this.renderEvents(events);

			_this.thawHeight();
			_this.releaseScroll();

			_this.isEventsRendered = true;
			_this.onEventsRender();
			_this.trigger('eventsRender');
		});
	},


	executeEventsUnrender: function() {
		if (this.isEventsRendered) {
			this.onBeforeEventsUnrender();

			this.captureScroll();
			this.freezeHeight();

			if (this.destroyEvents) {
				this.destroyEvents(); // TODO: deprecate
			}

			this.unrenderEvents();

			this.thawHeight();
			this.releaseScroll();

			this.isEventsRendered = false;
			this.trigger('eventsUnrender');
		}

		return Promise.resolve(); // always synchronous
	},


	// Event Rendering Triggers
	// -----------------------------------------------------------------------------------------------------------------


	// Signals that all events have been rendered
	onEventsRender: function() {
		this.renderedEventSegEach(function(seg) {
			this.publiclyTrigger('eventAfterRender', seg.event, seg.event, seg.el);
		});
		this.publiclyTrigger('eventAfterAllRender');
	},


	// Signals that all event elements are about to be removed
	onBeforeEventsUnrender: function() {
		this.renderedEventSegEach(function(seg) {
			this.publiclyTrigger('eventDestroy', seg.event, seg.event, seg.el);
		});
	},


	// Event Low-level Rendering
	// -----------------------------------------------------------------------------------------------------------------


	// Renders the events onto the view.
	renderEvents: function(events) {
		// subclasses should implement
	},


	// Removes event elements from the view.
	unrenderEvents: function() {
		// subclasses should implement
	},


	// Event Data Access
	// -----------------------------------------------------------------------------------------------------------------


	requestEvents: function() {
		return this.calendar.requestEvents(this.start, this.end);
	},


	getCurrentEvents: function() {
		return this.calendar.getPrunedEventCache();
	},


	// Event Rendering Utils
	// -----------------------------------------------------------------------------------------------------------------


	// Given an event and the default element used for rendering, returns the element that should actually be used.
	// Basically runs events and elements through the eventRender hook.
	resolveEventEl: function(event, el) {
		var custom = this.publiclyTrigger('eventRender', event, event, el);

		if (custom === false) { // means don't render at all
			el = null;
		}
		else if (custom && custom !== true) {
			el = $(custom);
		}

		return el;
	},


	// Hides all rendered event segments linked to the given event
	showEvent: function(event) {
		this.renderedEventSegEach(function(seg) {
			seg.el.css('visibility', '');
		}, event);
	},


	// Shows all rendered event segments linked to the given event
	hideEvent: function(event) {
		this.renderedEventSegEach(function(seg) {
			seg.el.css('visibility', 'hidden');
		}, event);
	},


	// Iterates through event segments that have been rendered (have an el). Goes through all by default.
	// If the optional `event` argument is specified, only iterates through segments linked to that event.
	// The `this` value of the callback function will be the view.
	renderedEventSegEach: function(func, event) {
		var segs = this.getEventSegs();
		var i;

		for (i = 0; i < segs.length; i++) {
			if (!event || segs[i].event._id === event._id) {
				if (segs[i].el) {
					func.call(this, segs[i]);
				}
			}
		}
	},


	// Retrieves all the rendered segment objects for the view
	getEventSegs: function() {
		// subclasses must implement
		return [];
	},


	/* Event Drag-n-Drop
	------------------------------------------------------------------------------------------------------------------*/


	// Computes if the given event is allowed to be dragged by the user
	isEventDraggable: function(event) {
		return this.isEventStartEditable(event);
	},


	isEventStartEditable: function(event) {
		return firstDefined(
			event.startEditable,
			(event.source || {}).startEditable,
			this.opt('eventStartEditable'),
			this.isEventGenerallyEditable(event)
		);
	},


	isEventGenerallyEditable: function(event) {
		return firstDefined(
			event.editable,
			(event.source || {}).editable,
			this.opt('editable')
		);
	},


	// Must be called when an event in the view is dropped onto new location.
	// `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.
	reportEventDrop: function(event, dropLocation, largeUnit, el, ev) {
		var calendar = this.calendar;
		var mutateResult = calendar.mutateEvent(event, dropLocation, largeUnit);
		var undoFunc = function() {
			mutateResult.undo();
			calendar.reportEventChange();
		};

		this.triggerEventDrop(event, mutateResult.dateDelta, undoFunc, el, ev);
		calendar.reportEventChange(); // will rerender events
	},


	// Triggers event-drop handlers that have subscribed via the API
	triggerEventDrop: function(event, dateDelta, undoFunc, el, ev) {
		this.publiclyTrigger('eventDrop', el[0], event, dateDelta, undoFunc, ev, {}); // {} = jqui dummy
	},


	/* External Element Drag-n-Drop
	------------------------------------------------------------------------------------------------------------------*/


	// Must be called when an external element, via jQuery UI, has been dropped onto the calendar.
	// `meta` is the parsed data that has been embedded into the dragging event.
	// `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.
	reportExternalDrop: function(meta, dropLocation, el, ev, ui) {
		var eventProps = meta.eventProps;
		var eventInput;
		var event;

		// Try to build an event object and render it. TODO: decouple the two
		if (eventProps) {
			eventInput = $.extend({}, eventProps, dropLocation);
			event = this.calendar.renderEvent(eventInput, meta.stick)[0]; // renderEvent returns an array
		}

		this.triggerExternalDrop(event, dropLocation, el, ev, ui);
	},


	// Triggers external-drop handlers that have subscribed via the API
	triggerExternalDrop: function(event, dropLocation, el, ev, ui) {

		// trigger 'drop' regardless of whether element represents an event
		this.publiclyTrigger('drop', el[0], dropLocation.start, ev, ui);

		if (event) {
			this.publiclyTrigger('eventReceive', null, event); // signal an external event landed
		}
	},


	/* Drag-n-Drop Rendering (for both events and external elements)
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of a event or external-element drag over the given drop zone.
	// If an external-element, seg will be `null`.
	// Must return elements used for any mock events.
	renderDrag: function(dropLocation, seg) {
		// subclasses must implement
	},


	// Unrenders a visual indication of an event or external-element being dragged.
	unrenderDrag: function() {
		// subclasses must implement
	},


	/* Event Resizing
	------------------------------------------------------------------------------------------------------------------*/


	// Computes if the given event is allowed to be resized from its starting edge
	isEventResizableFromStart: function(event) {
		return this.opt('eventResizableFromStart') && this.isEventResizable(event);
	},


	// Computes if the given event is allowed to be resized from its ending edge
	isEventResizableFromEnd: function(event) {
		return this.isEventResizable(event);
	},


	// Computes if the given event is allowed to be resized by the user at all
	isEventResizable: function(event) {
		var source = event.source || {};

		return firstDefined(
			event.durationEditable,
			source.durationEditable,
			this.opt('eventDurationEditable'),
			event.editable,
			source.editable,
			this.opt('editable')
		);
	},


	// Must be called when an event in the view has been resized to a new length
	reportEventResize: function(event, resizeLocation, largeUnit, el, ev) {
		var calendar = this.calendar;
		var mutateResult = calendar.mutateEvent(event, resizeLocation, largeUnit);
		var undoFunc = function() {
			mutateResult.undo();
			calendar.reportEventChange();
		};

		this.triggerEventResize(event, mutateResult.durationDelta, undoFunc, el, ev);
		calendar.reportEventChange(); // will rerender events
	},


	// Triggers event-resize handlers that have subscribed via the API
	triggerEventResize: function(event, durationDelta, undoFunc, el, ev) {
		this.publiclyTrigger('eventResize', el[0], event, durationDelta, undoFunc, ev, {}); // {} = jqui dummy
	},


	/* Selection (time range)
	------------------------------------------------------------------------------------------------------------------*/


	// Selects a date span on the view. `start` and `end` are both Moments.
	// `ev` is the native mouse event that begin the interaction.
	select: function(span, ev) {
		this.unselect(ev);
		this.renderSelection(span);
		this.reportSelection(span, ev);
	},


	// Renders a visual indication of the selection
	renderSelection: function(span) {
		// subclasses should implement
	},


	// Called when a new selection is made. Updates internal state and triggers handlers.
	reportSelection: function(span, ev) {
		this.isSelected = true;
		this.triggerSelect(span, ev);
	},


	// Triggers handlers to 'select'
	triggerSelect: function(span, ev) {
		this.publiclyTrigger(
			'select',
			null,
			this.calendar.applyTimezone(span.start), // convert to calendar's tz for external API
			this.calendar.applyTimezone(span.end), // "
			ev
		);
	},


	// Undoes a selection. updates in the internal state and triggers handlers.
	// `ev` is the native mouse event that began the interaction.
	unselect: function(ev) {
		if (this.isSelected) {
			this.isSelected = false;
			if (this.destroySelection) {
				this.destroySelection(); // TODO: deprecate
			}
			this.unrenderSelection();
			this.publiclyTrigger('unselect', null, ev);
		}
	},


	// Unrenders a visual indication of selection
	unrenderSelection: function() {
		// subclasses should implement
	},


	/* Event Selection
	------------------------------------------------------------------------------------------------------------------*/


	selectEvent: function(event) {
		if (!this.selectedEvent || this.selectedEvent !== event) {
			this.unselectEvent();
			this.renderedEventSegEach(function(seg) {
				seg.el.addClass('fc-selected');
			}, event);
			this.selectedEvent = event;
		}
	},


	unselectEvent: function() {
		if (this.selectedEvent) {
			this.renderedEventSegEach(function(seg) {
				seg.el.removeClass('fc-selected');
			}, this.selectedEvent);
			this.selectedEvent = null;
		}
	},


	isEventSelected: function(event) {
		// event references might change on refetchEvents(), while selectedEvent doesn't,
		// so compare IDs
		return this.selectedEvent && this.selectedEvent._id === event._id;
	},


	/* Mouse / Touch Unselecting (time range & event unselection)
	------------------------------------------------------------------------------------------------------------------*/
	// TODO: move consistently to down/start or up/end?
	// TODO: don't kill previous selection if touch scrolling


	handleDocumentMousedown: function(ev) {
		if (isPrimaryMouseButton(ev)) {
			this.processUnselect(ev);
		}
	},


	processUnselect: function(ev) {
		this.processRangeUnselect(ev);
		this.processEventUnselect(ev);
	},


	processRangeUnselect: function(ev) {
		var ignore;

		// is there a time-range selection?
		if (this.isSelected && this.opt('unselectAuto')) {
			// only unselect if the clicked element is not identical to or inside of an 'unselectCancel' element
			ignore = this.opt('unselectCancel');
			if (!ignore || !$(ev.target).closest(ignore).length) {
				this.unselect(ev);
			}
		}
	},


	processEventUnselect: function(ev) {
		if (this.selectedEvent) {
			if (!$(ev.target).closest('.fc-selected').length) {
				this.unselectEvent();
			}
		}
	},


	/* Day Click
	------------------------------------------------------------------------------------------------------------------*/


	// Triggers handlers to 'dayClick'
	// Span has start/end of the clicked area. Only the start is useful.
	triggerDayClick: function(span, dayEl, ev) {
		this.publiclyTrigger(
			'dayClick',
			dayEl,
			this.calendar.applyTimezone(span.start), // convert to calendar's timezone for external API
			ev
		);
	},


	/* Date Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Initializes internal variables related to calculating hidden days-of-week
	initHiddenDays: function() {
		var hiddenDays = this.opt('hiddenDays') || []; // array of day-of-week indices that are hidden
		var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)
		var dayCnt = 0;
		var i;

		if (this.opt('weekends') === false) {
			hiddenDays.push(0, 6); // 0=sunday, 6=saturday
		}

		for (i = 0; i < 7; i++) {
			if (
				!(isHiddenDayHash[i] = $.inArray(i, hiddenDays) !== -1)
			) {
				dayCnt++;
			}
		}

		if (!dayCnt) {
			throw 'invalid hiddenDays'; // all days were hidden? bad.
		}

		this.isHiddenDayHash = isHiddenDayHash;
	},


	// Is the current day hidden?
	// `day` is a day-of-week index (0-6), or a Moment
	isHiddenDay: function(day) {
		if (moment.isMoment(day)) {
			day = day.day();
		}
		return this.isHiddenDayHash[day];
	},


	// Incrementing the current day until it is no longer a hidden day, returning a copy.
	// If the initial value of `date` is not a hidden day, don't do anything.
	// Pass `isExclusive` as `true` if you are dealing with an end date.
	// `inc` defaults to `1` (increment one day forward each time)
	skipHiddenDays: function(date, inc, isExclusive) {
		var out = date.clone();
		inc = inc || 1;
		while (
			this.isHiddenDayHash[(out.day() + (isExclusive ? inc : 0) + 7) % 7]
		) {
			out.add(inc, 'days');
		}
		return out;
	},


	// Returns the date range of the full days the given range visually appears to occupy.
	// Returns a new range object.
	computeDayRange: function(range) {
		var startDay = range.start.clone().stripTime(); // the beginning of the day the range starts
		var end = range.end;
		var endDay = null;
		var endTimeMS;

		if (end) {
			endDay = end.clone().stripTime(); // the beginning of the day the range exclusively ends
			endTimeMS = +end.time(); // # of milliseconds into `endDay`

			// If the end time is actually inclusively part of the next day and is equal to or
			// beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.
			// Otherwise, leaving it as inclusive will cause it to exclude `endDay`.
			if (endTimeMS && endTimeMS >= this.nextDayThreshold) {
				endDay.add(1, 'days');
			}
		}

		// If no end was specified, or if it is within `startDay` but not past nextDayThreshold,
		// assign the default duration of one day.
		if (!end || endDay <= startDay) {
			endDay = startDay.clone().add(1, 'days');
		}

		return { start: startDay, end: endDay };
	},


	// Does the given event visually appear to occupy more than one day?
	isMultiDayEvent: function(event) {
		var range = this.computeDayRange(event); // event is range-ish

		return range.end.diff(range.start, 'days') > 1;
	}

});

;;

/*
Embodies a div that has potential scrollbars
*/
var Scroller = FC.Scroller = Class.extend({

	el: null, // the guaranteed outer element
	scrollEl: null, // the element with the scrollbars
	overflowX: null,
	overflowY: null,


	constructor: function(options) {
		options = options || {};
		this.overflowX = options.overflowX || options.overflow || 'auto';
		this.overflowY = options.overflowY || options.overflow || 'auto';
	},


	render: function() {
		this.el = this.renderEl();
		this.applyOverflow();
	},


	renderEl: function() {
		return (this.scrollEl = $('<div class="fc-scroller"></div>'));
	},


	// sets to natural height, unlocks overflow
	clear: function() {
		this.setHeight('auto');
		this.applyOverflow();
	},


	destroy: function() {
		this.el.remove();
	},


	// Overflow
	// -----------------------------------------------------------------------------------------------------------------


	applyOverflow: function() {
		this.scrollEl.css({
			'overflow-x': this.overflowX,
			'overflow-y': this.overflowY
		});
	},


	// Causes any 'auto' overflow values to resolves to 'scroll' or 'hidden'.
	// Useful for preserving scrollbar widths regardless of future resizes.
	// Can pass in scrollbarWidths for optimization.
	lockOverflow: function(scrollbarWidths) {
		var overflowX = this.overflowX;
		var overflowY = this.overflowY;

		scrollbarWidths = scrollbarWidths || this.getScrollbarWidths();

		if (overflowX === 'auto') {
			overflowX = (
					scrollbarWidths.top || scrollbarWidths.bottom || // horizontal scrollbars?
					// OR scrolling pane with massless scrollbars?
					this.scrollEl[0].scrollWidth - 1 > this.scrollEl[0].clientWidth
						// subtract 1 because of IE off-by-one issue
				) ? 'scroll' : 'hidden';
		}

		if (overflowY === 'auto') {
			overflowY = (
					scrollbarWidths.left || scrollbarWidths.right || // vertical scrollbars?
					// OR scrolling pane with massless scrollbars?
					this.scrollEl[0].scrollHeight - 1 > this.scrollEl[0].clientHeight
						// subtract 1 because of IE off-by-one issue
				) ? 'scroll' : 'hidden';
		}

		this.scrollEl.css({ 'overflow-x': overflowX, 'overflow-y': overflowY });
	},


	// Getters / Setters
	// -----------------------------------------------------------------------------------------------------------------


	setHeight: function(height) {
		this.scrollEl.height(height);
	},


	getScrollTop: function() {
		return this.scrollEl.scrollTop();
	},


	setScrollTop: function(top) {
		this.scrollEl.scrollTop(top);
	},


	getClientWidth: function() {
		return this.scrollEl[0].clientWidth;
	},


	getClientHeight: function() {
		return this.scrollEl[0].clientHeight;
	},


	getScrollbarWidths: function() {
		return getScrollbarWidths(this.scrollEl);
	}

});

;;
function Iterator(items) {
    this.items = items || [];
}


/* Calls a method on every item passing the arguments through */
Iterator.prototype.proxyCall = function(methodName) {
    var args = Array.prototype.slice.call(arguments, 1);
    var results = [];

    this.items.forEach(function(item) {
        results.push(item[methodName].apply(item, args));
    });

    return results;
};

;;

/* Toolbar with buttons and title
----------------------------------------------------------------------------------------------------------------------*/

function Toolbar(calendar, toolbarOptions) {
	var t = this;

	// exports
	t.setToolbarOptions = setToolbarOptions;
	t.render = render;
	t.removeElement = removeElement;
	t.updateTitle = updateTitle;
	t.activateButton = activateButton;
	t.deactivateButton = deactivateButton;
	t.disableButton = disableButton;
	t.enableButton = enableButton;
	t.getViewsWithButtons = getViewsWithButtons;
	t.el = null; // mirrors local `el`

	// locals
	var el;
	var viewsWithButtons = [];
	var tm;

	// method to update toolbar-specific options, not calendar-wide options
	function setToolbarOptions(newToolbarOptions) {
		toolbarOptions = newToolbarOptions;
	}

	// can be called repeatedly and will rerender
	function render() {
		var sections = toolbarOptions.layout;

		tm = calendar.options.theme ? 'ui' : 'fc';

		if (sections) {
			if (!el) {
				el = this.el = $("<div class='fc-toolbar "+ toolbarOptions.extraClasses + "'/>");
			}
			else {
				el.empty();
			}
			el.append(renderSection('left'))
				.append(renderSection('right'))
				.append(renderSection('center'))
				.append('<div class="fc-clear"/>');
		}
		else {
			removeElement();
		}
	}


	function removeElement() {
		if (el) {
			el.remove();
			el = t.el = null;
		}
	}


	function renderSection(position) {
		var sectionEl = $('<div class="fc-' + position + '"/>');
		var buttonStr = toolbarOptions.layout[position];

		if (buttonStr) {
			$.each(buttonStr.split(' '), function(i) {
				var groupChildren = $();
				var isOnlyButtons = true;
				var groupEl;

				$.each(this.split(','), function(j, buttonName) {
					var customButtonProps;
					var viewSpec;
					var buttonClick;
					var overrideText; // text explicitly set by calendar's constructor options. overcomes icons
					var defaultText;
					var themeIcon;
					var normalIcon;
					var innerHtml;
					var classes;
					var button; // the element

					if (buttonName == 'title') {
						groupChildren = groupChildren.add($('<h2>&nbsp;</h2>')); // we always want it to take up height
						isOnlyButtons = false;
					}
					else {
						if ((customButtonProps = (calendar.options.customButtons || {})[buttonName])) {
							buttonClick = function(ev) {
								if (customButtonProps.click) {
									customButtonProps.click.call(button[0], ev);
								}
							};
							overrideText = ''; // icons will override text
							defaultText = customButtonProps.text;
						}
						else if ((viewSpec = calendar.getViewSpec(buttonName))) {
							buttonClick = function() {
								calendar.changeView(buttonName);
							};
							viewsWithButtons.push(buttonName);
							overrideText = viewSpec.buttonTextOverride;
							defaultText = viewSpec.buttonTextDefault;
						}
						else if (calendar[buttonName]) { // a calendar method
							buttonClick = function() {
								calendar[buttonName]();
							};
							overrideText = (calendar.overrides.buttonText || {})[buttonName];
							defaultText = calendar.options.buttonText[buttonName]; // everything else is considered default
						}

						if (buttonClick) {

							themeIcon =
								customButtonProps ?
									customButtonProps.themeIcon :
									calendar.options.themeButtonIcons[buttonName];

							normalIcon =
								customButtonProps ?
									customButtonProps.icon :
									calendar.options.buttonIcons[buttonName];

							if (overrideText) {
								innerHtml = htmlEscape(overrideText);
							}
							else if (themeIcon && calendar.options.theme) {
								innerHtml = "<span class='ui-icon ui-icon-" + themeIcon + "'></span>";
							}
							else if (normalIcon && !calendar.options.theme) {
								innerHtml = "<span class='fc-icon fc-icon-" + normalIcon + "'></span>";
							}
							else {
								innerHtml = htmlEscape(defaultText);
							}

							classes = [
								'fc-' + buttonName + '-button',
								tm + '-button',
								tm + '-state-default'
							];

							button = $( // type="button" so that it doesn't submit a form
								'<button type="button" class="' + classes.join(' ') + '">' +
									innerHtml +
								'</button>'
								)
								.click(function(ev) {
									// don't process clicks for disabled buttons
									if (!button.hasClass(tm + '-state-disabled')) {

										buttonClick(ev);

										// after the click action, if the button becomes the "active" tab, or disabled,
										// it should never have a hover class, so remove it now.
										if (
											button.hasClass(tm + '-state-active') ||
											button.hasClass(tm + '-state-disabled')
										) {
											button.removeClass(tm + '-state-hover');
										}
									}
								})
								.mousedown(function() {
									// the *down* effect (mouse pressed in).
									// only on buttons that are not the "active" tab, or disabled
									button
										.not('.' + tm + '-state-active')
										.not('.' + tm + '-state-disabled')
										.addClass(tm + '-state-down');
								})
								.mouseup(function() {
									// undo the *down* effect
									button.removeClass(tm + '-state-down');
								})
								.hover(
									function() {
										// the *hover* effect.
										// only on buttons that are not the "active" tab, or disabled
										button
											.not('.' + tm + '-state-active')
											.not('.' + tm + '-state-disabled')
											.addClass(tm + '-state-hover');
									},
									function() {
										// undo the *hover* effect
										button
											.removeClass(tm + '-state-hover')
											.removeClass(tm + '-state-down'); // if mouseleave happens before mouseup
									}
								);

							groupChildren = groupChildren.add(button);
						}
					}
				});

				if (isOnlyButtons) {
					groupChildren
						.first().addClass(tm + '-corner-left').end()
						.last().addClass(tm + '-corner-right').end();
				}

				if (groupChildren.length > 1) {
					groupEl = $('<div/>');
					if (isOnlyButtons) {
						groupEl.addClass('fc-button-group');
					}
					groupEl.append(groupChildren);
					sectionEl.append(groupEl);
				}
				else {
					sectionEl.append(groupChildren); // 1 or 0 children
				}
			});
		}

		return sectionEl;
	}


	function updateTitle(text) {
		if (el) {
			el.find('h2').text(text);
		}
	}


	function activateButton(buttonName) {
		if (el) {
			el.find('.fc-' + buttonName + '-button')
				.addClass(tm + '-state-active');
		}
	}


	function deactivateButton(buttonName) {
		if (el) {
			el.find('.fc-' + buttonName + '-button')
				.removeClass(tm + '-state-active');
		}
	}


	function disableButton(buttonName) {
		if (el) {
			el.find('.fc-' + buttonName + '-button')
				.prop('disabled', true)
				.addClass(tm + '-state-disabled');
		}
	}


	function enableButton(buttonName) {
		if (el) {
			el.find('.fc-' + buttonName + '-button')
				.prop('disabled', false)
				.removeClass(tm + '-state-disabled');
		}
	}


	function getViewsWithButtons() {
		return viewsWithButtons;
	}

}

;;

var Calendar = FC.Calendar = Class.extend({

	dirDefaults: null, // option defaults related to LTR or RTL
	localeDefaults: null, // option defaults related to current locale
	overrides: null, // option overrides given to the fullCalendar constructor
	dynamicOverrides: null, // options set with dynamic setter method. higher precedence than view overrides.
	options: null, // all defaults combined with overrides
	viewSpecCache: null, // cache of view definitions
	view: null, // current View object
	header: null,
	footer: null,
	loadingLevel: 0, // number of simultaneous loading tasks


	// a lot of this class' OOP logic is scoped within this constructor function,
	// but in the future, write individual methods on the prototype.
	constructor: Calendar_constructor,


	// Subclasses can override this for initialization logic after the constructor has been called
	initialize: function() {
	},


	// Computes the flattened options hash for the calendar and assigns to `this.options`.
	// Assumes this.overrides and this.dynamicOverrides have already been initialized.
	populateOptionsHash: function() {
		var locale, localeDefaults;
		var isRTL, dirDefaults;

		locale = firstDefined( // explicit locale option given?
			this.dynamicOverrides.locale,
			this.overrides.locale
		);
		localeDefaults = localeOptionHash[locale];
		if (!localeDefaults) { // explicit locale option not given or invalid?
			locale = Calendar.defaults.locale;
			localeDefaults = localeOptionHash[locale] || {};
		}

		isRTL = firstDefined( // based on options computed so far, is direction RTL?
			this.dynamicOverrides.isRTL,
			this.overrides.isRTL,
			localeDefaults.isRTL,
			Calendar.defaults.isRTL
		);
		dirDefaults = isRTL ? Calendar.rtlDefaults : {};

		this.dirDefaults = dirDefaults;
		this.localeDefaults = localeDefaults;
		this.options = mergeOptions([ // merge defaults and overrides. lowest to highest precedence
			Calendar.defaults, // global defaults
			dirDefaults,
			localeDefaults,
			this.overrides,
			this.dynamicOverrides
		]);
		populateInstanceComputableOptions(this.options); // fill in gaps with computed options
	},


	// Gets information about how to create a view. Will use a cache.
	getViewSpec: function(viewType) {
		var cache = this.viewSpecCache;

		return cache[viewType] || (cache[viewType] = this.buildViewSpec(viewType));
	},


	// Given a duration singular unit, like "week" or "day", finds a matching view spec.
	// Preference is given to views that have corresponding buttons.
	getUnitViewSpec: function(unit) {
		var viewTypes;
		var i;
		var spec;

		if ($.inArray(unit, intervalUnits) != -1) {

			// put views that have buttons first. there will be duplicates, but oh well
			viewTypes = this.header.getViewsWithButtons(); // TODO: include footer as well?
			$.each(FC.views, function(viewType) { // all views
				viewTypes.push(viewType);
			});

			for (i = 0; i < viewTypes.length; i++) {
				spec = this.getViewSpec(viewTypes[i]);
				if (spec) {
					if (spec.singleUnit == unit) {
						return spec;
					}
				}
			}
		}
	},


	// Builds an object with information on how to create a given view
	buildViewSpec: function(requestedViewType) {
		var viewOverrides = this.overrides.views || {};
		var specChain = []; // for the view. lowest to highest priority
		var defaultsChain = []; // for the view. lowest to highest priority
		var overridesChain = []; // for the view. lowest to highest priority
		var viewType = requestedViewType;
		var spec; // for the view
		var overrides; // for the view
		var duration;
		var unit;

		// iterate from the specific view definition to a more general one until we hit an actual View class
		while (viewType) {
			spec = fcViews[viewType];
			overrides = viewOverrides[viewType];
			viewType = null; // clear. might repopulate for another iteration

			if (typeof spec === 'function') { // TODO: deprecate
				spec = { 'class': spec };
			}

			if (spec) {
				specChain.unshift(spec);
				defaultsChain.unshift(spec.defaults || {});
				duration = duration || spec.duration;
				viewType = viewType || spec.type;
			}

			if (overrides) {
				overridesChain.unshift(overrides); // view-specific option hashes have options at zero-level
				duration = duration || overrides.duration;
				viewType = viewType || overrides.type;
			}
		}

		spec = mergeProps(specChain);
		spec.type = requestedViewType;
		if (!spec['class']) {
			return false;
		}

		if (duration) {
			duration = moment.duration(duration);
			if (duration.valueOf()) { // valid?
				spec.duration = duration;
				unit = computeIntervalUnit(duration);

				// view is a single-unit duration, like "week" or "day"
				// incorporate options for this. lowest priority
				if (duration.as(unit) === 1) {
					spec.singleUnit = unit;
					overridesChain.unshift(viewOverrides[unit] || {});
				}
			}
		}

		spec.defaults = mergeOptions(defaultsChain);
		spec.overrides = mergeOptions(overridesChain);

		this.buildViewSpecOptions(spec);
		this.buildViewSpecButtonText(spec, requestedViewType);

		return spec;
	},


	// Builds and assigns a view spec's options object from its already-assigned defaults and overrides
	buildViewSpecOptions: function(spec) {
		spec.options = mergeOptions([ // lowest to highest priority
			Calendar.defaults, // global defaults
			spec.defaults, // view's defaults (from ViewSubclass.defaults)
			this.dirDefaults,
			this.localeDefaults, // locale and dir take precedence over view's defaults!
			this.overrides, // calendar's overrides (options given to constructor)
			spec.overrides, // view's overrides (view-specific options)
			this.dynamicOverrides // dynamically set via setter. highest precedence
		]);
		populateInstanceComputableOptions(spec.options);
	},


	// Computes and assigns a view spec's buttonText-related options
	buildViewSpecButtonText: function(spec, requestedViewType) {

		// given an options object with a possible `buttonText` hash, lookup the buttonText for the
		// requested view, falling back to a generic unit entry like "week" or "day"
		function queryButtonText(options) {
			var buttonText = options.buttonText || {};
			return buttonText[requestedViewType] ||
				// view can decide to look up a certain key
				(spec.buttonTextKey ? buttonText[spec.buttonTextKey] : null) ||
				// a key like "month"
				(spec.singleUnit ? buttonText[spec.singleUnit] : null);
		}

		// highest to lowest priority
		spec.buttonTextOverride =
			queryButtonText(this.dynamicOverrides) ||
			queryButtonText(this.overrides) || // constructor-specified buttonText lookup hash takes precedence
			spec.overrides.buttonText; // `buttonText` for view-specific options is a string

		// highest to lowest priority. mirrors buildViewSpecOptions
		spec.buttonTextDefault =
			queryButtonText(this.localeDefaults) ||
			queryButtonText(this.dirDefaults) ||
			spec.defaults.buttonText || // a single string. from ViewSubclass.defaults
			queryButtonText(Calendar.defaults) ||
			(spec.duration ? this.humanizeDuration(spec.duration) : null) || // like "3 days"
			requestedViewType; // fall back to given view name
	},


	// Given a view name for a custom view or a standard view, creates a ready-to-go View object
	instantiateView: function(viewType) {
		var spec = this.getViewSpec(viewType);

		return new spec['class'](this, viewType, spec.options, spec.duration);
	},


	// Returns a boolean about whether the view is okay to instantiate at some point
	isValidViewType: function(viewType) {
		return Boolean(this.getViewSpec(viewType));
	},


	// Should be called when any type of async data fetching begins
	pushLoading: function() {
		if (!(this.loadingLevel++)) {
			this.publiclyTrigger('loading', null, true, this.view);
		}
	},


	// Should be called when any type of async data fetching completes
	popLoading: function() {
		if (!(--this.loadingLevel)) {
			this.publiclyTrigger('loading', null, false, this.view);
		}
	},


	// Given arguments to the select method in the API, returns a span (unzoned start/end and other info)
	buildSelectSpan: function(zonedStartInput, zonedEndInput) {
		var start = this.moment(zonedStartInput).stripZone();
		var end;

		if (zonedEndInput) {
			end = this.moment(zonedEndInput).stripZone();
		}
		else if (start.hasTime()) {
			end = start.clone().add(this.defaultTimedEventDuration);
		}
		else {
			end = start.clone().add(this.defaultAllDayEventDuration);
		}

		return { start: start, end: end };
	}

});


Calendar.mixin(EmitterMixin);


function Calendar_constructor(element, overrides) {
	var t = this;


	// Exports
	// -----------------------------------------------------------------------------------

	t.render = render;
	t.destroy = destroy;
	t.rerenderEvents = rerenderEvents;
	t.changeView = renderView; // `renderView` will switch to another view
	t.select = select;
	t.unselect = unselect;
	t.prev = prev;
	t.next = next;
	t.prevYear = prevYear;
	t.nextYear = nextYear;
	t.today = today;
	t.gotoDate = gotoDate;
	t.incrementDate = incrementDate;
	t.zoomTo = zoomTo;
	t.getDate = getDate;
	t.getCalendar = getCalendar;
	t.getView = getView;
	t.option = option; // getter/setter method
	t.publiclyTrigger = publiclyTrigger;


	// Options
	// -----------------------------------------------------------------------------------

	t.dynamicOverrides = {};
	t.viewSpecCache = {};
	t.optionHandlers = {}; // for Calendar.options.js
	t.overrides = $.extend({}, overrides); // make a copy

	t.populateOptionsHash(); // sets this.options



	// Locale-data Internals
	// -----------------------------------------------------------------------------------
	// Apply overrides to the current locale's data

	var localeData;

	// Called immediately, and when any of the options change.
	// Happens before any internal objects rebuild or rerender, because this is very core.
	t.bindOptions([
		'locale', 'monthNames', 'monthNamesShort', 'dayNames', 'dayNamesShort', 'firstDay', 'weekNumberCalculation'
	], function(locale, monthNames, monthNamesShort, dayNames, dayNamesShort, firstDay, weekNumberCalculation) {

		// normalize
		if (weekNumberCalculation === 'iso') {
			weekNumberCalculation = 'ISO'; // normalize
		}

		localeData = createObject( // make a cheap copy
			getMomentLocaleData(locale) // will fall back to en
		);

		if (monthNames) {
			localeData._months = monthNames;
		}
		if (monthNamesShort) {
			localeData._monthsShort = monthNamesShort;
		}
		if (dayNames) {
			localeData._weekdays = dayNames;
		}
		if (dayNamesShort) {
			localeData._weekdaysShort = dayNamesShort;
		}

		if (firstDay == null && weekNumberCalculation === 'ISO') {
			firstDay = 1;
		}
		if (firstDay != null) {
			var _week = createObject(localeData._week); // _week: { dow: # }
			_week.dow = firstDay;
			localeData._week = _week;
		}

		if ( // whitelist certain kinds of input
			weekNumberCalculation === 'ISO' ||
			weekNumberCalculation === 'local' ||
			typeof weekNumberCalculation === 'function'
		) {
			localeData._fullCalendar_weekCalc = weekNumberCalculation; // moment-ext will know what to do with it
		}

		// If the internal current date object already exists, move to new locale.
		// We do NOT need to do this technique for event dates, because this happens when converting to "segments".
		if (date) {
			localizeMoment(date); // sets to localeData
		}
	});


	// Calendar-specific Date Utilities
	// -----------------------------------------------------------------------------------


	t.defaultAllDayEventDuration = moment.duration(t.options.defaultAllDayEventDuration);
	t.defaultTimedEventDuration = moment.duration(t.options.defaultTimedEventDuration);


	// Builds a moment using the settings of the current calendar: timezone and locale.
	// Accepts anything the vanilla moment() constructor accepts.
	t.moment = function() {
		var mom;

		if (t.options.timezone === 'local') {
			mom = FC.moment.apply(null, arguments);

			// Force the moment to be local, because FC.moment doesn't guarantee it.
			if (mom.hasTime()) { // don't give ambiguously-timed moments a local zone
				mom.local();
			}
		}
		else if (t.options.timezone === 'UTC') {
			mom = FC.moment.utc.apply(null, arguments); // process as UTC
		}
		else {
			mom = FC.moment.parseZone.apply(null, arguments); // let the input decide the zone
		}

		localizeMoment(mom);

		return mom;
	};


	// Updates the given moment's locale settings to the current calendar locale settings.
	function localizeMoment(mom) {
		mom._locale = localeData;
	}
	t.localizeMoment = localizeMoment;


	// Returns a boolean about whether or not the calendar knows how to calculate
	// the timezone offset of arbitrary dates in the current timezone.
	t.getIsAmbigTimezone = function() {
		return t.options.timezone !== 'local' && t.options.timezone !== 'UTC';
	};


	// Returns a copy of the given date in the current timezone. Has no effect on dates without times.
	t.applyTimezone = function(date) {
		if (!date.hasTime()) {
			return date.clone();
		}

		var zonedDate = t.moment(date.toArray());
		var timeAdjust = date.time() - zonedDate.time();
		var adjustedZonedDate;

		// Safari sometimes has problems with this coersion when near DST. Adjust if necessary. (bug #2396)
		if (timeAdjust) { // is the time result different than expected?
			adjustedZonedDate = zonedDate.clone().add(timeAdjust); // add milliseconds
			if (date.time() - adjustedZonedDate.time() === 0) { // does it match perfectly now?
				zonedDate = adjustedZonedDate;
			}
		}

		return zonedDate;
	};


	// Returns a moment for the current date, as defined by the client's computer or from the `now` option.
	// Will return an moment with an ambiguous timezone.
	t.getNow = function() {
		var now = t.options.now;
		if (typeof now === 'function') {
			now = now();
		}
		return t.moment(now).stripZone();
	};


	// Get an event's normalized end date. If not present, calculate it from the defaults.
	t.getEventEnd = function(event) {
		if (event.end) {
			return event.end.clone();
		}
		else {
			return t.getDefaultEventEnd(event.allDay, event.start);
		}
	};


	// Given an event's allDay status and start date, return what its fallback end date should be.
	// TODO: rename to computeDefaultEventEnd
	t.getDefaultEventEnd = function(allDay, zonedStart) {
		var end = zonedStart.clone();

		if (allDay) {
			end.stripTime().add(t.defaultAllDayEventDuration);
		}
		else {
			end.add(t.defaultTimedEventDuration);
		}

		if (t.getIsAmbigTimezone()) {
			end.stripZone(); // we don't know what the tzo should be
		}

		return end;
	};


	// Produces a human-readable string for the given duration.
	// Side-effect: changes the locale of the given duration.
	t.humanizeDuration = function(duration) {
		return duration.locale(t.options.locale).humanize();
	};



	// Imports
	// -----------------------------------------------------------------------------------


	EventManager.call(t);



	// Locals
	// -----------------------------------------------------------------------------------


	var _element = element[0];
	var toolbarsManager;
	var header;
	var footer;
	var content;
	var tm; // for making theme classes
	var currentView; // NOTE: keep this in sync with this.view
	var viewsByType = {}; // holds all instantiated view instances, current or not
	var suggestedViewHeight;
	var windowResizeProxy; // wraps the windowResize function
	var ignoreWindowResize = 0;
	var date; // unzoned



	// Main Rendering
	// -----------------------------------------------------------------------------------


	// compute the initial ambig-timezone date
	if (t.options.defaultDate != null) {
		date = t.moment(t.options.defaultDate).stripZone();
	}
	else {
		date = t.getNow(); // getNow already returns unzoned
	}


	function render() {
		if (!content) {
			initialRender();
		}
		else if (elementVisible()) {
			// mainly for the public API
			calcSize();
			renderView();
		}
	}


	function initialRender() {
		element.addClass('fc');

		// event delegation for nav links
		element.on('click.fc', 'a[data-goto]', function(ev) {
			var anchorEl = $(this);
			var gotoOptions = anchorEl.data('goto'); // will automatically parse JSON
			var date = t.moment(gotoOptions.date);
			var viewType = gotoOptions.type;

			// property like "navLinkDayClick". might be a string or a function
			var customAction = currentView.opt('navLink' + capitaliseFirstLetter(viewType) + 'Click');

			if (typeof customAction === 'function') {
				customAction(date, ev);
			}
			else {
				if (typeof customAction === 'string') {
					viewType = customAction;
				}
				zoomTo(date, viewType);
			}
		});

		// called immediately, and upon option change
		t.bindOption('theme', function(theme) {
			tm = theme ? 'ui' : 'fc'; // affects a larger scope
			element.toggleClass('ui-widget', theme);
			element.toggleClass('fc-unthemed', !theme);
		});

		// called immediately, and upon option change.
		// HACK: locale often affects isRTL, so we explicitly listen to that too.
		t.bindOptions([ 'isRTL', 'locale' ], function(isRTL) {
			element.toggleClass('fc-ltr', !isRTL);
			element.toggleClass('fc-rtl', isRTL);
		});

		content = $("<div class='fc-view-container'/>").prependTo(element);

		var toolbars = buildToolbars();
		toolbarsManager = new Iterator(toolbars);

		header = t.header = toolbars[0];
		footer = t.footer = toolbars[1];

		renderHeader();
		renderFooter();
		renderView(t.options.defaultView);

		if (t.options.handleWindowResize) {
			windowResizeProxy = debounce(windowResize, t.options.windowResizeDelay); // prevents rapid calls
			$(window).resize(windowResizeProxy);
		}
	}


	function destroy() {

		if (currentView) {
			currentView.removeElement();

			// NOTE: don't null-out currentView/t.view in case API methods are called after destroy.
			// It is still the "current" view, just not rendered.
		}

		toolbarsManager.proxyCall('removeElement');
		content.remove();
		element.removeClass('fc fc-ltr fc-rtl fc-unthemed ui-widget');

		element.off('.fc'); // unbind nav link handlers

		if (windowResizeProxy) {
			$(window).unbind('resize', windowResizeProxy);
		}
	}


	function elementVisible() {
		return element.is(':visible');
	}



	// View Rendering
	// -----------------------------------------------------------------------------------


	// Renders a view because of a date change, view-type change, or for the first time.
	// If not given a viewType, keep the current view but render different dates.
	// Accepts an optional scroll state to restore to.
	function renderView(viewType, forcedScroll) {
		ignoreWindowResize++;

		var needsClearView = currentView && viewType && currentView.type !== viewType;

		// if viewType is changing, remove the old view's rendering
		if (needsClearView) {
			freezeContentHeight(); // prevent a scroll jump when view element is removed
			clearView();
		}

		// if viewType changed, or the view was never created, create a fresh view
		if (!currentView && viewType) {
			currentView = t.view =
				viewsByType[viewType] ||
				(viewsByType[viewType] = t.instantiateView(viewType));

			currentView.setElement(
				$("<div class='fc-view fc-" + viewType + "-view' />").appendTo(content)
			);
			toolbarsManager.proxyCall('activateButton', viewType);
		}

		if (currentView) {

			// in case the view should render a period of time that is completely hidden
			date = currentView.massageCurrentDate(date);

			// render or rerender the view
			if (
				!currentView.isDateSet ||
				!( // NOT within interval range signals an implicit date window change
					date >= currentView.intervalStart &&
					date < currentView.intervalEnd
				)
			) {
				if (elementVisible()) {

					if (forcedScroll) {
						currentView.captureInitialScroll(forcedScroll);
					}

					currentView.setDate(date, forcedScroll);

					if (forcedScroll) {
						currentView.releaseScroll();
					}

					// need to do this after View::render, so dates are calculated
					// NOTE: view updates title text proactively
					updateToolbarsTodayButton();
				}
			}
		}

		if (needsClearView) {
			thawContentHeight();
		}

		ignoreWindowResize--;
	}


	// Unrenders the current view and reflects this change in the Header.
	// Unregsiters the `currentView`, but does not remove from viewByType hash.
	function clearView() {
		toolbarsManager.proxyCall('deactivateButton', currentView.type);
		currentView.removeElement();
		currentView = t.view = null;
	}


	// Destroys the view, including the view object. Then, re-instantiates it and renders it.
	// Maintains the same scroll state.
	// TODO: maintain any other user-manipulated state.
	function reinitView() {
		ignoreWindowResize++;
		freezeContentHeight();

		var viewType = currentView.type;
		var scrollState = currentView.queryScroll();
		clearView();
		calcSize();
		renderView(viewType, scrollState);

		thawContentHeight();
		ignoreWindowResize--;
	}



	// Resizing
	// -----------------------------------------------------------------------------------


	t.getSuggestedViewHeight = function() {
		if (suggestedViewHeight === undefined) {
			calcSize();
		}
		return suggestedViewHeight;
	};


	t.isHeightAuto = function() {
		return t.options.contentHeight === 'auto' || t.options.height === 'auto';
	};


	function updateSize(shouldRecalc) {
		if (elementVisible()) {

			if (shouldRecalc) {
				_calcSize();
			}

			ignoreWindowResize++;
			currentView.updateSize(true); // isResize=true. will poll getSuggestedViewHeight() and isHeightAuto()
			ignoreWindowResize--;

			return true; // signal success
		}
	}


	function calcSize() {
		if (elementVisible()) {
			_calcSize();
		}
	}


	function _calcSize() { // assumes elementVisible
		var contentHeightInput = t.options.contentHeight;
		var heightInput = t.options.height;

		if (typeof contentHeightInput === 'number') { // exists and not 'auto'
			suggestedViewHeight = contentHeightInput;
		}
		else if (typeof contentHeightInput === 'function') { // exists and is a function
			suggestedViewHeight = contentHeightInput();
		}
		else if (typeof heightInput === 'number') { // exists and not 'auto'
			suggestedViewHeight = heightInput - queryToolbarsHeight();
		}
		else if (typeof heightInput === 'function') { // exists and is a function
			suggestedViewHeight = heightInput() - queryToolbarsHeight();
		}
		else if (heightInput === 'parent') { // set to height of parent element
			suggestedViewHeight = element.parent().height() - queryToolbarsHeight();
		}
		else {
			suggestedViewHeight = Math.round(content.width() / Math.max(t.options.aspectRatio, .5));
		}
	}


	function queryToolbarsHeight() {
		return toolbarsManager.items.reduce(function(accumulator, toolbar) {
			var toolbarHeight = toolbar.el ? toolbar.el.outerHeight(true) : 0; // includes margin
			return accumulator + toolbarHeight;
		}, 0);
	}


	function windowResize(ev) {
		if (
			!ignoreWindowResize &&
			ev.target === window && // so we don't process jqui "resize" events that have bubbled up
			currentView.start // view has already been rendered
		) {
			if (updateSize(true)) {
				currentView.publiclyTrigger('windowResize', _element);
			}
		}
	}



	/* Event Rendering
	-----------------------------------------------------------------------------*/


	function rerenderEvents() { // API method. destroys old events if previously rendered.
		if (elementVisible()) {
			t.reportEventChange(); // will re-trasmit events to the view, causing a rerender
		}
	}



	/* Toolbars
	-----------------------------------------------------------------------------*/


	function buildToolbars() {
		return [
			new Toolbar(t, computeHeaderOptions()),
			new Toolbar(t, computeFooterOptions())
		];
	}


	function computeHeaderOptions() {
		return {
			extraClasses: 'fc-header-toolbar',
			layout: t.options.header
		};
	}


	function computeFooterOptions() {
		return {
			extraClasses: 'fc-footer-toolbar',
			layout: t.options.footer
		};
	}


	// can be called repeatedly and Header will rerender
	function renderHeader() {
		header.setToolbarOptions(computeHeaderOptions());
		header.render();
		if (header.el) {
			element.prepend(header.el);
		}
	}


	// can be called repeatedly and Footer will rerender
	function renderFooter() {
		footer.setToolbarOptions(computeFooterOptions());
		footer.render();
		if (footer.el) {
			element.append(footer.el);
		}
	}


	t.setToolbarsTitle = function(title) {
		toolbarsManager.proxyCall('updateTitle', title);
	};


	function updateToolbarsTodayButton() {
		var now = t.getNow();
		if (now >= currentView.intervalStart && now < currentView.intervalEnd) {
			toolbarsManager.proxyCall('disableButton', 'today');
		}
		else {
			toolbarsManager.proxyCall('enableButton', 'today');
		}
	}



	/* Selection
	-----------------------------------------------------------------------------*/


	// this public method receives start/end dates in any format, with any timezone
	function select(zonedStartInput, zonedEndInput) {
		currentView.select(
			t.buildSelectSpan.apply(t, arguments)
		);
	}


	function unselect() { // safe to be called before renderView
		if (currentView) {
			currentView.unselect();
		}
	}



	/* Date
	-----------------------------------------------------------------------------*/


	function prev() {
		date = currentView.computePrevDate(date);
		renderView();
	}


	function next() {
		date = currentView.computeNextDate(date);
		renderView();
	}


	function prevYear() {
		date.add(-1, 'years');
		renderView();
	}


	function nextYear() {
		date.add(1, 'years');
		renderView();
	}


	function today() {
		date = t.getNow();
		renderView();
	}


	function gotoDate(zonedDateInput) {
		date = t.moment(zonedDateInput).stripZone();
		renderView();
	}


	function incrementDate(delta) {
		date.add(moment.duration(delta));
		renderView();
	}


	// Forces navigation to a view for the given date.
	// `viewType` can be a specific view name or a generic one like "week" or "day".
	function zoomTo(newDate, viewType) {
		var spec;

		viewType = viewType || 'day'; // day is default zoom
		spec = t.getViewSpec(viewType) || t.getUnitViewSpec(viewType);

		date = newDate.clone();
		renderView(spec ? spec.type : null);
	}


	// for external API
	function getDate() {
		return t.applyTimezone(date); // infuse the calendar's timezone
	}



	/* Height "Freezing"
	-----------------------------------------------------------------------------*/


	t.freezeContentHeight = freezeContentHeight;
	t.thawContentHeight = thawContentHeight;

	var freezeContentHeightDepth = 0;


	function freezeContentHeight() {
		if (!(freezeContentHeightDepth++)) {
			content.css({
				width: '100%',
				height: content.height(),
				overflow: 'hidden'
			});
		}
	}


	function thawContentHeight() {
		if (!(--freezeContentHeightDepth)) {
			content.css({
				width: '',
				height: '',
				overflow: ''
			});
		}
	}



	/* Misc
	-----------------------------------------------------------------------------*/


	function getCalendar() {
		return t;
	}


	function getView() {
		return currentView;
	}


	function option(name, value) {
		var newOptionHash;

		if (typeof name === 'string') {
			if (value === undefined) { // getter
				return t.options[name];
			}
			else { // setter for individual option
				newOptionHash = {};
				newOptionHash[name] = value;
				setOptions(newOptionHash);
			}
		}
		else if (typeof name === 'object') { // compound setter with object input
			setOptions(name);
		}
	}


	function setOptions(newOptionHash) {
		var optionCnt = 0;
		var optionName;

		for (optionName in newOptionHash) {
			t.dynamicOverrides[optionName] = newOptionHash[optionName];
		}

		t.viewSpecCache = {}; // the dynamic override invalidates the options in this cache, so just clear it
		t.populateOptionsHash(); // this.options needs to be recomputed after the dynamic override

		// trigger handlers after this.options has been updated
		for (optionName in newOptionHash) {
			t.triggerOptionHandlers(optionName); // recall bindOption/bindOptions
			optionCnt++;
		}

		// special-case handling of single option change.
		// if only one option change, `optionName` will be its name.
		if (optionCnt === 1) {
			if (optionName === 'height' || optionName === 'contentHeight' || optionName === 'aspectRatio') {
				updateSize(true); // true = allow recalculation of height
				return;
			}
			else if (optionName === 'defaultDate') {
				return; // can't change date this way. use gotoDate instead
			}
			else if (optionName === 'businessHours') {
				if (currentView) {
					currentView.unrenderBusinessHours();
					currentView.renderBusinessHours();
				}
				return;
			}
			else if (optionName === 'timezone') {
				t.rezoneArrayEventSources();
				t.refetchEvents();
				return;
			}
		}

		// catch-all. rerender the header and footer and rebuild/rerender the current view
		renderHeader();
		renderFooter();
		viewsByType = {}; // even non-current views will be affected by this option change. do before rerender
		reinitView();
	}


	function publiclyTrigger(name, thisObj) {
		var args = Array.prototype.slice.call(arguments, 2);

		thisObj = thisObj || _element;
		this.triggerWith(name, thisObj, args); // Emitter's method

		if (t.options[name]) {
			return t.options[name].apply(thisObj, args);
		}
	}

	t.initialize();
}

;;
/*
Options binding/triggering system.
*/
Calendar.mixin({

	// A map of option names to arrays of handler objects. Initialized to {} in Calendar.
	// Format for a handler object:
	// {
	//   func // callback function to be called upon change
	//   names // option names whose values should be given to func
	// }
	optionHandlers: null, 

	// Calls handlerFunc immediately, and when the given option has changed.
	// handlerFunc will be given the option value.
	bindOption: function(optionName, handlerFunc) {
		this.bindOptions([ optionName ], handlerFunc);
	},

	// Calls handlerFunc immediately, and when any of the given options change.
	// handlerFunc will be given each option value as ordered function arguments.
	bindOptions: function(optionNames, handlerFunc) {
		var handlerObj = { func: handlerFunc, names: optionNames };
		var i;

		for (i = 0; i < optionNames.length; i++) {
			this.registerOptionHandlerObj(optionNames[i], handlerObj);
		}

		this.triggerOptionHandlerObj(handlerObj);
	},

	// Puts the given handler object into the internal hash
	registerOptionHandlerObj: function(optionName, handlerObj) {
		(this.optionHandlers[optionName] || (this.optionHandlers[optionName] = []))
			.push(handlerObj);
	},

	// Reports that the given option has changed, and calls all appropriate handlers.
	triggerOptionHandlers: function(optionName) {
		var handlerObjs = this.optionHandlers[optionName] || [];
		var i;

		for (i = 0; i < handlerObjs.length; i++) {
			this.triggerOptionHandlerObj(handlerObjs[i]);
		}
	},

	// Calls the callback for a specific handler object, passing in the appropriate arguments.
	triggerOptionHandlerObj: function(handlerObj) {
		var optionNames = handlerObj.names;
		var optionValues = [];
		var i;

		for (i = 0; i < optionNames.length; i++) {
			optionValues.push(this.options[optionNames[i]]);
		}

		handlerObj.func.apply(this, optionValues); // maintain the Calendar's `this` context
	}

});

;;

Calendar.defaults = {

	titleRangeSeparator: ' \u2013 ', // en dash
	monthYearFormat: 'MMMM YYYY', // required for en. other locales rely on datepicker computable option

	defaultTimedEventDuration: '02:00:00',
	defaultAllDayEventDuration: { days: 1 },
	forceEventDuration: false,
	nextDayThreshold: '09:00:00', // 9am

	// display
	defaultView: 'month',
	aspectRatio: 1.35,
	header: {
		left: 'title',
		center: '',
		right: 'today prev,next'
	},
	weekends: true,
	weekNumbers: false,

	weekNumberTitle: 'W',
	weekNumberCalculation: 'local',
	
	//editable: false,

	//nowIndicator: false,

	scrollTime: '06:00:00',
	
	// event ajax
	lazyFetching: true,
	startParam: 'start',
	endParam: 'end',
	timezoneParam: 'timezone',

	timezone: false,

	//allDayDefault: undefined,

	// locale
	isRTL: false,
	buttonText: {
		prev: "prev",
		next: "next",
		prevYear: "prev year",
		nextYear: "next year",
		year: 'year', // TODO: locale files need to specify this
		today: 'today',
		month: 'month',
		week: 'week',
		day: 'day'
	},

	buttonIcons: {
		prev: 'left-single-arrow',
		next: 'right-single-arrow',
		prevYear: 'left-double-arrow',
		nextYear: 'right-double-arrow'
	},

	allDayText: 'all-day',
	
	// jquery-ui theming
	theme: false,
	themeButtonIcons: {
		prev: 'circle-triangle-w',
		next: 'circle-triangle-e',
		prevYear: 'seek-prev',
		nextYear: 'seek-next'
	},

	//eventResizableFromStart: false,
	dragOpacity: .75,
	dragRevertDuration: 500,
	dragScroll: true,
	
	//selectable: false,
	unselectAuto: true,
	
	dropAccept: '*',

	eventOrder: 'title',
	//eventRenderWait: null,

	eventLimit: false,
	eventLimitText: 'more',
	eventLimitClick: 'popover',
	dayPopoverFormat: 'LL',
	
	handleWindowResize: true,
	windowResizeDelay: 100, // milliseconds before an updateSize happens

	longPressDelay: 1000
	
};


Calendar.englishDefaults = { // used by locale.js
	dayPopoverFormat: 'dddd, MMMM D'
};


Calendar.rtlDefaults = { // right-to-left defaults
	header: { // TODO: smarter solution (first/center/last ?)
		left: 'next,prev today',
		center: '',
		right: 'title'
	},
	buttonIcons: {
		prev: 'right-single-arrow',
		next: 'left-single-arrow',
		prevYear: 'right-double-arrow',
		nextYear: 'left-double-arrow'
	},
	themeButtonIcons: {
		prev: 'circle-triangle-e',
		next: 'circle-triangle-w',
		nextYear: 'seek-prev',
		prevYear: 'seek-next'
	}
};

;;

var localeOptionHash = FC.locales = {}; // initialize and expose


// TODO: document the structure and ordering of a FullCalendar locale file


// Initialize jQuery UI datepicker translations while using some of the translations
// Will set this as the default locales for datepicker.
FC.datepickerLocale = function(localeCode, dpLocaleCode, dpOptions) {

	// get the FullCalendar internal option hash for this locale. create if necessary
	var fcOptions = localeOptionHash[localeCode] || (localeOptionHash[localeCode] = {});

	// transfer some simple options from datepicker to fc
	fcOptions.isRTL = dpOptions.isRTL;
	fcOptions.weekNumberTitle = dpOptions.weekHeader;

	// compute some more complex options from datepicker
	$.each(dpComputableOptions, function(name, func) {
		fcOptions[name] = func(dpOptions);
	});

	// is jQuery UI Datepicker is on the page?
	if ($.datepicker) {

		// Register the locale data.
		// FullCalendar and MomentJS use locale codes like "pt-br" but Datepicker
		// does it like "pt-BR" or if it doesn't have the locale, maybe just "pt".
		// Make an alias so the locale can be referenced either way.
		$.datepicker.regional[dpLocaleCode] =
			$.datepicker.regional[localeCode] = // alias
				dpOptions;

		// Alias 'en' to the default locale data. Do this every time.
		$.datepicker.regional.en = $.datepicker.regional[''];

		// Set as Datepicker's global defaults.
		$.datepicker.setDefaults(dpOptions);
	}
};


// Sets FullCalendar-specific translations. Will set the locales as the global default.
FC.locale = function(localeCode, newFcOptions) {
	var fcOptions;
	var momOptions;

	// get the FullCalendar internal option hash for this locale. create if necessary
	fcOptions = localeOptionHash[localeCode] || (localeOptionHash[localeCode] = {});

	// provided new options for this locales? merge them in
	if (newFcOptions) {
		fcOptions = localeOptionHash[localeCode] = mergeOptions([ fcOptions, newFcOptions ]);
	}

	// compute locale options that weren't defined.
	// always do this. newFcOptions can be undefined when initializing from i18n file,
	// so no way to tell if this is an initialization or a default-setting.
	momOptions = getMomentLocaleData(localeCode); // will fall back to en
	$.each(momComputableOptions, function(name, func) {
		if (fcOptions[name] == null) {
			fcOptions[name] = func(momOptions, fcOptions);
		}
	});

	// set it as the default locale for FullCalendar
	Calendar.defaults.locale = localeCode;
};


// NOTE: can't guarantee any of these computations will run because not every locale has datepicker
// configs, so make sure there are English fallbacks for these in the defaults file.
var dpComputableOptions = {

	buttonText: function(dpOptions) {
		return {
			// the translations sometimes wrongly contain HTML entities
			prev: stripHtmlEntities(dpOptions.prevText),
			next: stripHtmlEntities(dpOptions.nextText),
			today: stripHtmlEntities(dpOptions.currentText)
		};
	},

	// Produces format strings like "MMMM YYYY" -> "September 2014"
	monthYearFormat: function(dpOptions) {
		return dpOptions.showMonthAfterYear ?
			'YYYY[' + dpOptions.yearSuffix + '] MMMM' :
			'MMMM YYYY[' + dpOptions.yearSuffix + ']';
	}

};

var momComputableOptions = {

	// Produces format strings like "ddd M/D" -> "Fri 9/15"
	dayOfMonthFormat: function(momOptions, fcOptions) {
		var format = momOptions.longDateFormat('l'); // for the format like "M/D/YYYY"

		// strip the year off the edge, as well as other misc non-whitespace chars
		format = format.replace(/^Y+[^\w\s]*|[^\w\s]*Y+$/g, '');

		if (fcOptions.isRTL) {
			format += ' ddd'; // for RTL, add day-of-week to end
		}
		else {
			format = 'ddd ' + format; // for LTR, add day-of-week to beginning
		}
		return format;
	},

	// Produces format strings like "h:mma" -> "6:00pm"
	mediumTimeFormat: function(momOptions) { // can't be called `timeFormat` because collides with option
		return momOptions.longDateFormat('LT')
			.replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
	},

	// Produces format strings like "h(:mm)a" -> "6pm" / "6:30pm"
	smallTimeFormat: function(momOptions) {
		return momOptions.longDateFormat('LT')
			.replace(':mm', '(:mm)')
			.replace(/(\Wmm)$/, '($1)') // like above, but for foreign locales
			.replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
	},

	// Produces format strings like "h(:mm)t" -> "6p" / "6:30p"
	extraSmallTimeFormat: function(momOptions) {
		return momOptions.longDateFormat('LT')
			.replace(':mm', '(:mm)')
			.replace(/(\Wmm)$/, '($1)') // like above, but for foreign locales
			.replace(/\s*a$/i, 't'); // convert to AM/PM/am/pm to lowercase one-letter. remove any spaces beforehand
	},

	// Produces format strings like "ha" / "H" -> "6pm" / "18"
	hourFormat: function(momOptions) {
		return momOptions.longDateFormat('LT')
			.replace(':mm', '')
			.replace(/(\Wmm)$/, '') // like above, but for foreign locales
			.replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
	},

	// Produces format strings like "h:mm" -> "6:30" (with no AM/PM)
	noMeridiemTimeFormat: function(momOptions) {
		return momOptions.longDateFormat('LT')
			.replace(/\s*a$/i, ''); // remove trailing AM/PM
	}

};


// options that should be computed off live calendar options (considers override options)
// TODO: best place for this? related to locale?
// TODO: flipping text based on isRTL is a bad idea because the CSS `direction` might want to handle it
var instanceComputableOptions = {

	// Produces format strings for results like "Mo 16"
	smallDayDateFormat: function(options) {
		return options.isRTL ?
			'D dd' :
			'dd D';
	},

	// Produces format strings for results like "Wk 5"
	weekFormat: function(options) {
		return options.isRTL ?
			'w[ ' + options.weekNumberTitle + ']' :
			'[' + options.weekNumberTitle + ' ]w';
	},

	// Produces format strings for results like "Wk5"
	smallWeekFormat: function(options) {
		return options.isRTL ?
			'w[' + options.weekNumberTitle + ']' :
			'[' + options.weekNumberTitle + ']w';
	}

};

function populateInstanceComputableOptions(options) {
	$.each(instanceComputableOptions, function(name, func) {
		if (options[name] == null) {
			options[name] = func(options);
		}
	});
}


// Returns moment's internal locale data. If doesn't exist, returns English.
function getMomentLocaleData(localeCode) {
	return moment.localeData(localeCode) || moment.localeData('en');
}


// Initialize English by forcing computation of moment-derived options.
// Also, sets it as the default.
FC.locale('en', Calendar.englishDefaults);

;;

FC.sourceNormalizers = [];
FC.sourceFetchers = [];

var ajaxDefaults = {
	dataType: 'json',
	cache: false
};

var eventGUID = 1;


function EventManager() { // assumed to be a calendar
	var t = this;


	// exports
	t.requestEvents = requestEvents;
	t.reportEventChange = reportEventChange;
	t.isFetchNeeded = isFetchNeeded;
	t.fetchEvents = fetchEvents;
	t.fetchEventSources = fetchEventSources;
	t.refetchEvents = refetchEvents;
	t.refetchEventSources = refetchEventSources;
	t.getEventSources = getEventSources;
	t.getEventSourceById = getEventSourceById;
	t.addEventSource = addEventSource;
	t.removeEventSource = removeEventSource;
	t.removeEventSources = removeEventSources;
	t.updateEvent = updateEvent;
	t.updateEvents = updateEvents;
	t.renderEvent = renderEvent;
	t.renderEvents = renderEvents;
	t.removeEvents = removeEvents;
	t.clientEvents = clientEvents;
	t.mutateEvent = mutateEvent;
	t.normalizeEventDates = normalizeEventDates;
	t.normalizeEventTimes = normalizeEventTimes;


	// locals
	var stickySource = { events: [] };
	var sources = [ stickySource ];
	var rangeStart, rangeEnd;
	var pendingSourceCnt = 0; // outstanding fetch requests, max one per source
	var cache = []; // holds events that have already been expanded
	var prunedCache; // like cache, but only events that intersect with rangeStart/rangeEnd


	$.each(
		(t.options.events ? [ t.options.events ] : []).concat(t.options.eventSources || []),
		function(i, sourceInput) {
			var source = buildEventSource(sourceInput);
			if (source) {
				sources.push(source);
			}
		}
	);



	function requestEvents(start, end) {
		if (!t.options.lazyFetching || isFetchNeeded(start, end)) {
			return fetchEvents(start, end);
		}
		else {
			return Promise.resolve(prunedCache);
		}
	}


	function reportEventChange() {
		prunedCache = filterEventsWithinRange(cache);
		t.trigger('eventsReset', prunedCache);
	}


	function filterEventsWithinRange(events) {
		var filteredEvents = [];
		var i, event;

		for (i = 0; i < events.length; i++) {
			event = events[i];

			if (
				event.start.clone().stripZone() < rangeEnd &&
				t.getEventEnd(event).stripZone() > rangeStart
			) {
				filteredEvents.push(event);
			}
		}

		return filteredEvents;
	}


	t.getEventCache = function() {
		return cache;
	};


	t.getPrunedEventCache = function() {
		return prunedCache;
	};



	/* Fetching
	-----------------------------------------------------------------------------*/


	// start and end are assumed to be unzoned
	function isFetchNeeded(start, end) {
		return !rangeStart || // nothing has been fetched yet?
			start < rangeStart || end > rangeEnd; // is part of the new range outside of the old range?
	}


	function fetchEvents(start, end) {
		rangeStart = start;
		rangeEnd = end;
		return refetchEvents();
	}


	// poorly named. fetches all sources with current `rangeStart` and `rangeEnd`.
	function refetchEvents() {
		return fetchEventSources(sources, 'reset');
	}


	// poorly named. fetches a subset of event sources.
	function refetchEventSources(matchInputs) {
		return fetchEventSources(getEventSourcesByMatchArray(matchInputs));
	}


	// expects an array of event source objects (the originals, not copies)
	// `specialFetchType` is an optimization parameter that affects purging of the event cache.
	function fetchEventSources(specificSources, specialFetchType) {
		var i, source;

		if (specialFetchType === 'reset') {
			cache = [];
		}
		else if (specialFetchType !== 'add') {
			cache = excludeEventsBySources(cache, specificSources);
		}

		for (i = 0; i < specificSources.length; i++) {
			source = specificSources[i];

			// already-pending sources have already been accounted for in pendingSourceCnt
			if (source._status !== 'pending') {
				pendingSourceCnt++;
			}

			source._fetchId = (source._fetchId || 0) + 1;
			source._status = 'pending';
		}

		for (i = 0; i < specificSources.length; i++) {
			source = specificSources[i];
			tryFetchEventSource(source, source._fetchId);
		}

		if (pendingSourceCnt) {
			return new Promise(function(resolve) {
				t.one('eventsReceived', resolve); // will send prunedCache
			});
		}
		else { // executed all synchronously, or no sources at all
			return Promise.resolve(prunedCache);
		}
	}


	// fetches an event source and processes its result ONLY if it is still the current fetch.
	// caller is responsible for incrementing pendingSourceCnt first.
	function tryFetchEventSource(source, fetchId) {
		_fetchEventSource(source, function(eventInputs) {
			var isArraySource = $.isArray(source.events);
			var i, eventInput;
			var abstractEvent;

			if (
				// is this the source's most recent fetch?
				// if not, rely on an upcoming fetch of this source to decrement pendingSourceCnt
				fetchId === source._fetchId &&
				// event source no longer valid?
				source._status !== 'rejected'
			) {
				source._status = 'resolved';

				if (eventInputs) {
					for (i = 0; i < eventInputs.length; i++) {
						eventInput = eventInputs[i];

						if (isArraySource) { // array sources have already been convert to Event Objects
							abstractEvent = eventInput;
						}
						else {
							abstractEvent = buildEventFromInput(eventInput, source);
						}

						if (abstractEvent) { // not false (an invalid event)
							cache.push.apply( // append
								cache,
								expandEvent(abstractEvent) // add individual expanded events to the cache
							);
						}
					}
				}

				decrementPendingSourceCnt();
			}
		});
	}


	function rejectEventSource(source) {
		var wasPending = source._status === 'pending';

		source._status = 'rejected';

		if (wasPending) {
			decrementPendingSourceCnt();
		}
	}


	function decrementPendingSourceCnt() {
		pendingSourceCnt--;
		if (!pendingSourceCnt) {
			reportEventChange(cache); // updates prunedCache
			t.trigger('eventsReceived', prunedCache);
		}
	}


	function _fetchEventSource(source, callback) {
		var i;
		var fetchers = FC.sourceFetchers;
		var res;

		for (i=0; i<fetchers.length; i++) {
			res = fetchers[i].call(
				t, // this, the Calendar object
				source,
				rangeStart.clone(),
				rangeEnd.clone(),
				t.options.timezone,
				callback
			);

			if (res === true) {
				// the fetcher is in charge. made its own async request
				return;
			}
			else if (typeof res == 'object') {
				// the fetcher returned a new source. process it
				_fetchEventSource(res, callback);
				return;
			}
		}

		var events = source.events;
		if (events) {
			if ($.isFunction(events)) {
				t.pushLoading();
				events.call(
					t, // this, the Calendar object
					rangeStart.clone(),
					rangeEnd.clone(),
					t.options.timezone,
					function(events) {
						callback(events);
						t.popLoading();
					}
				);
			}
			else if ($.isArray(events)) {
				callback(events);
			}
			else {
				callback();
			}
		}else{
			var url = source.url;
			if (url) {
				var success = source.success;
				var error = source.error;
				var complete = source.complete;

				// retrieve any outbound GET/POST $.ajax data from the options
				var customData;
				if ($.isFunction(source.data)) {
					// supplied as a function that returns a key/value object
					customData = source.data();
				}
				else {
					// supplied as a straight key/value object
					customData = source.data;
				}

				// use a copy of the custom data so we can modify the parameters
				// and not affect the passed-in object.
				var data = $.extend({}, customData || {});

				var startParam = firstDefined(source.startParam, t.options.startParam);
				var endParam = firstDefined(source.endParam, t.options.endParam);
				var timezoneParam = firstDefined(source.timezoneParam, t.options.timezoneParam);

				if (startParam) {
					data[startParam] = rangeStart.format();
				}
				if (endParam) {
					data[endParam] = rangeEnd.format();
				}
				if (t.options.timezone && t.options.timezone != 'local') {
					data[timezoneParam] = t.options.timezone;
				}

				t.pushLoading();
				$.ajax($.extend({}, ajaxDefaults, source, {
					data: data,
					success: function(events) {
						events = events || [];
						var res = applyAll(success, this, arguments);
						if ($.isArray(res)) {
							events = res;
						}
						callback(events);
					},
					error: function() {
						applyAll(error, this, arguments);
						callback();
					},
					complete: function() {
						applyAll(complete, this, arguments);
						t.popLoading();
					}
				}));
			}else{
				callback();
			}
		}
	}



	/* Sources
	-----------------------------------------------------------------------------*/


	function addEventSource(sourceInput) {
		var source = buildEventSource(sourceInput);
		if (source) {
			sources.push(source);
			fetchEventSources([ source ], 'add'); // will eventually call reportEventChange
		}
	}


	function buildEventSource(sourceInput) { // will return undefined if invalid source
		var normalizers = FC.sourceNormalizers;
		var source;
		var i;

		if ($.isFunction(sourceInput) || $.isArray(sourceInput)) {
			source = { events: sourceInput };
		}
		else if (typeof sourceInput === 'string') {
			source = { url: sourceInput };
		}
		else if (typeof sourceInput === 'object') {
			source = $.extend({}, sourceInput); // shallow copy
		}

		if (source) {

			// TODO: repeat code, same code for event classNames
			if (source.className) {
				if (typeof source.className === 'string') {
					source.className = source.className.split(/\s+/);
				}
				// otherwise, assumed to be an array
			}
			else {
				source.className = [];
			}

			// for array sources, we convert to standard Event Objects up front
			if ($.isArray(source.events)) {
				source.origArray = source.events; // for removeEventSource
				source.events = $.map(source.events, function(eventInput) {
					return buildEventFromInput(eventInput, source);
				});
			}

			for (i=0; i<normalizers.length; i++) {
				normalizers[i].call(t, source);
			}

			return source;
		}
	}


	function removeEventSource(matchInput) {
		removeSpecificEventSources(
			getEventSourcesByMatch(matchInput)
		);
	}


	// if called with no arguments, removes all.
	function removeEventSources(matchInputs) {
		if (matchInputs == null) {
			removeSpecificEventSources(sources, true); // isAll=true
		}
		else {
			removeSpecificEventSources(
				getEventSourcesByMatchArray(matchInputs)
			);
		}
	}


	function removeSpecificEventSources(targetSources, isAll) {
		var i;

		// cancel pending requests
		for (i = 0; i < targetSources.length; i++) {
			rejectEventSource(targetSources[i]);
		}

		if (isAll) { // an optimization
			sources = [];
			cache = [];
		}
		else {
			// remove from persisted source list
			sources = $.grep(sources, function(source) {
				for (i = 0; i < targetSources.length; i++) {
					if (source === targetSources[i]) {
						return false; // exclude
					}
				}
				return true; // include
			});

			cache = excludeEventsBySources(cache, targetSources);
		}

		reportEventChange();
	}


	function getEventSources() {
		return sources.slice(1); // returns a shallow copy of sources with stickySource removed
	}


	function getEventSourceById(id) {
		return $.grep(sources, function(source) {
			return source.id && source.id === id;
		})[0];
	}


	// like getEventSourcesByMatch, but accepts multple match criteria (like multiple IDs)
	function getEventSourcesByMatchArray(matchInputs) {

		// coerce into an array
		if (!matchInputs) {
			matchInputs = [];
		}
		else if (!$.isArray(matchInputs)) {
			matchInputs = [ matchInputs ];
		}

		var matchingSources = [];
		var i;

		// resolve raw inputs to real event source objects
		for (i = 0; i < matchInputs.length; i++) {
			matchingSources.push.apply( // append
				matchingSources,
				getEventSourcesByMatch(matchInputs[i])
			);
		}

		return matchingSources;
	}


	// matchInput can either by a real event source object, an ID, or the function/URL for the source.
	// returns an array of matching source objects.
	function getEventSourcesByMatch(matchInput) {
		var i, source;

		// given an proper event source object
		for (i = 0; i < sources.length; i++) {
			source = sources[i];
			if (source === matchInput) {
				return [ source ];
			}
		}

		// an ID match
		source = getEventSourceById(matchInput);
		if (source) {
			return [ source ];
		}

		return $.grep(sources, function(source) {
			return isSourcesEquivalent(matchInput, source);
		});
	}


	function isSourcesEquivalent(source1, source2) {
		return source1 && source2 && getSourcePrimitive(source1) == getSourcePrimitive(source2);
	}


	function getSourcePrimitive(source) {
		return (
			(typeof source === 'object') ? // a normalized event source?
				(source.origArray || source.googleCalendarId || source.url || source.events) : // get the primitive
				null
		) ||
		source; // the given argument *is* the primitive
	}


	// util
	// returns a filtered array without events that are part of any of the given sources
	function excludeEventsBySources(specificEvents, specificSources) {
		return $.grep(specificEvents, function(event) {
			for (var i = 0; i < specificSources.length; i++) {
				if (event.source === specificSources[i]) {
					return false; // exclude
				}
			}
			return true; // keep
		});
	}



	/* Manipulation
	-----------------------------------------------------------------------------*/


	// Only ever called from the externally-facing API
	function updateEvent(event) {
		updateEvents([ event ]);
	}


	// Only ever called from the externally-facing API
	function updateEvents(events) {
		var i, event;

		for (i = 0; i < events.length; i++) {
			event = events[i];

			// massage start/end values, even if date string values
			event.start = t.moment(event.start);
			if (event.end) {
				event.end = t.moment(event.end);
			}
			else {
				event.end = null;
			}

			mutateEvent(event, getMiscEventProps(event)); // will handle start/end/allDay normalization
		}

		reportEventChange(); // reports event modifications (so we can redraw)
	}


	// Returns a hash of misc event properties that should be copied over to related events.
	function getMiscEventProps(event) {
		var props = {};

		$.each(event, function(name, val) {
			if (isMiscEventPropName(name)) {
				if (val !== undefined && isAtomic(val)) { // a defined non-object
					props[name] = val;
				}
			}
		});

		return props;
	}

	// non-date-related, non-id-related, non-secret
	function isMiscEventPropName(name) {
		return !/^_|^(id|allDay|start|end)$/.test(name);
	}


	// returns the expanded events that were created
	function renderEvent(eventInput, stick) {
		return renderEvents([ eventInput ], stick);
	}


	// returns the expanded events that were created
	function renderEvents(eventInputs, stick) {
		var renderedEvents = [];
		var renderableEvents;
		var abstractEvent;
		var i, j, event;

		for (i = 0; i < eventInputs.length; i++) {
			abstractEvent = buildEventFromInput(eventInputs[i]);

			if (abstractEvent) { // not false (a valid input)
				renderableEvents = expandEvent(abstractEvent);

				for (j = 0; j < renderableEvents.length; j++) {
					event = renderableEvents[j];

					if (!event.source) {
						if (stick) {
							stickySource.events.push(event);
							event.source = stickySource;
						}
						cache.push(event);
					}
				}

				renderedEvents = renderedEvents.concat(renderableEvents);
			}
		}

		if (renderedEvents.length) { // any new events rendered?
			reportEventChange();
		}

		return renderedEvents;
	}


	function removeEvents(filter) {
		var eventID;
		var i;

		if (filter == null) { // null or undefined. remove all events
			filter = function() { return true; }; // will always match
		}
		else if (!$.isFunction(filter)) { // an event ID
			eventID = filter + '';
			filter = function(event) {
				return event._id == eventID;
			};
		}

		// Purge event(s) from our local cache
		cache = $.grep(cache, filter, true); // inverse=true

		// Remove events from array sources.
		// This works because they have been converted to official Event Objects up front.
		// (and as a result, event._id has been calculated).
		for (i=0; i<sources.length; i++) {
			if ($.isArray(sources[i].events)) {
				sources[i].events = $.grep(sources[i].events, filter, true);
			}
		}

		reportEventChange();
	}


	function clientEvents(filter) {
		if ($.isFunction(filter)) {
			return $.grep(cache, filter);
		}
		else if (filter != null) { // not null, not undefined. an event ID
			filter += '';
			return $.grep(cache, function(e) {
				return e._id == filter;
			});
		}
		return cache; // else, return all
	}


	// Makes sure all array event sources have their internal event objects
	// converted over to the Calendar's current timezone.
	t.rezoneArrayEventSources = function() {
		var i;
		var events;
		var j;

		for (i = 0; i < sources.length; i++) {
			events = sources[i].events;
			if ($.isArray(events)) {

				for (j = 0; j < events.length; j++) {
					rezoneEventDates(events[j]);
				}
			}
		}
	};

	function rezoneEventDates(event) {
		event.start = t.moment(event.start);
		if (event.end) {
			event.end = t.moment(event.end);
		}
		backupEventDates(event);
	}


	/* Event Normalization
	-----------------------------------------------------------------------------*/


	// Given a raw object with key/value properties, returns an "abstract" Event object.
	// An "abstract" event is an event that, if recurring, will not have been expanded yet.
	// Will return `false` when input is invalid.
	// `source` is optional
	function buildEventFromInput(input, source) {
		var out = {};
		var start, end;
		var allDay;

		if (t.options.eventDataTransform) {
			input = t.options.eventDataTransform(input);
		}
		if (source && source.eventDataTransform) {
			input = source.eventDataTransform(input);
		}

		// Copy all properties over to the resulting object.
		// The special-case properties will be copied over afterwards.
		$.extend(out, input);

		if (source) {
			out.source = source;
		}

		out._id = input._id || (input.id === undefined ? '_fc' + eventGUID++ : input.id + '');

		if (input.className) {
			if (typeof input.className == 'string') {
				out.className = input.className.split(/\s+/);
			}
			else { // assumed to be an array
				out.className = input.className;
			}
		}
		else {
			out.className = [];
		}

		start = input.start || input.date; // "date" is an alias for "start"
		end = input.end;

		// parse as a time (Duration) if applicable
		if (isTimeString(start)) {
			start = moment.duration(start);
		}
		if (isTimeString(end)) {
			end = moment.duration(end);
		}

		if (input.dow || moment.isDuration(start) || moment.isDuration(end)) {

			// the event is "abstract" (recurring) so don't calculate exact start/end dates just yet
			out.start = start ? moment.duration(start) : null; // will be a Duration or null
			out.end = end ? moment.duration(end) : null; // will be a Duration or null
			out._recurring = true; // our internal marker
		}
		else {

			if (start) {
				start = t.moment(start);
				if (!start.isValid()) {
					return false;
				}
			}

			if (end) {
				end = t.moment(end);
				if (!end.isValid()) {
					end = null; // let defaults take over
				}
			}

			allDay = input.allDay;
			if (allDay === undefined) { // still undefined? fallback to default
				allDay = firstDefined(
					source ? source.allDayDefault : undefined,
					t.options.allDayDefault
				);
				// still undefined? normalizeEventDates will calculate it
			}

			assignDatesToEvent(start, end, allDay, out);
		}

		t.normalizeEvent(out); // hook for external use. a prototype method

		return out;
	}
	t.buildEventFromInput = buildEventFromInput;


	// Normalizes and assigns the given dates to the given partially-formed event object.
	// NOTE: mutates the given start/end moments. does not make a copy.
	function assignDatesToEvent(start, end, allDay, event) {
		event.start = start;
		event.end = end;
		event.allDay = allDay;
		normalizeEventDates(event);
		backupEventDates(event);
	}


	// Ensures proper values for allDay/start/end. Accepts an Event object, or a plain object with event-ish properties.
	// NOTE: Will modify the given object.
	function normalizeEventDates(eventProps) {

		normalizeEventTimes(eventProps);

		if (eventProps.end && !eventProps.end.isAfter(eventProps.start)) {
			eventProps.end = null;
		}

		if (!eventProps.end) {
			if (t.options.forceEventDuration) {
				eventProps.end = t.getDefaultEventEnd(eventProps.allDay, eventProps.start);
			}
			else {
				eventProps.end = null;
			}
		}
	}


	// Ensures the allDay property exists and the timeliness of the start/end dates are consistent
	function normalizeEventTimes(eventProps) {
		if (eventProps.allDay == null) {
			eventProps.allDay = !(eventProps.start.hasTime() || (eventProps.end && eventProps.end.hasTime()));
		}

		if (eventProps.allDay) {
			eventProps.start.stripTime();
			if (eventProps.end) {
				// TODO: consider nextDayThreshold here? If so, will require a lot of testing and adjustment
				eventProps.end.stripTime();
			}
		}
		else {
			if (!eventProps.start.hasTime()) {
				eventProps.start = t.applyTimezone(eventProps.start.time(0)); // will assign a 00:00 time
			}
			if (eventProps.end && !eventProps.end.hasTime()) {
				eventProps.end = t.applyTimezone(eventProps.end.time(0)); // will assign a 00:00 time
			}
		}
	}


	// If the given event is a recurring event, break it down into an array of individual instances.
	// If not a recurring event, return an array with the single original event.
	// If given a falsy input (probably because of a failed buildEventFromInput call), returns an empty array.
	// HACK: can override the recurring window by providing custom rangeStart/rangeEnd (for businessHours).
	function expandEvent(abstractEvent, _rangeStart, _rangeEnd) {
		var events = [];
		var dowHash;
		var dow;
		var i;
		var date;
		var startTime, endTime;
		var start, end;
		var event;

		_rangeStart = _rangeStart || rangeStart;
		_rangeEnd = _rangeEnd || rangeEnd;

		if (abstractEvent) {
			if (abstractEvent._recurring) {

				// make a boolean hash as to whether the event occurs on each day-of-week
				if ((dow = abstractEvent.dow)) {
					dowHash = {};
					for (i = 0; i < dow.length; i++) {
						dowHash[dow[i]] = true;
					}
				}

				// iterate through every day in the current range
				date = _rangeStart.clone().stripTime(); // holds the date of the current day
				while (date.isBefore(_rangeEnd)) {

					if (!dowHash || dowHash[date.day()]) { // if everyday, or this particular day-of-week

						startTime = abstractEvent.start; // the stored start and end properties are times (Durations)
						endTime = abstractEvent.end; // "
						start = date.clone();
						end = null;

						if (startTime) {
							start = start.time(startTime);
						}
						if (endTime) {
							end = date.clone().time(endTime);
						}

						event = $.extend({}, abstractEvent); // make a copy of the original
						assignDatesToEvent(
							start, end,
							!startTime && !endTime, // allDay?
							event
						);
						events.push(event);
					}

					date.add(1, 'days');
				}
			}
			else {
				events.push(abstractEvent); // return the original event. will be a one-item array
			}
		}

		return events;
	}
	t.expandEvent = expandEvent;



	/* Event Modification Math
	-----------------------------------------------------------------------------------------*/


	// Modifies an event and all related events by applying the given properties.
	// Special date-diffing logic is used for manipulation of dates.
	// If `props` does not contain start/end dates, the updated values are assumed to be the event's current start/end.
	// All date comparisons are done against the event's pristine _start and _end dates.
	// Returns an object with delta information and a function to undo all operations.
	// For making computations in a granularity greater than day/time, specify largeUnit.
	// NOTE: The given `newProps` might be mutated for normalization purposes.
	function mutateEvent(event, newProps, largeUnit) {
		var miscProps = {};
		var oldProps;
		var clearEnd;
		var startDelta;
		var endDelta;
		var durationDelta;
		var undoFunc;

		// diffs the dates in the appropriate way, returning a duration
		function diffDates(date1, date0) { // date1 - date0
			if (largeUnit) {
				return diffByUnit(date1, date0, largeUnit);
			}
			else if (newProps.allDay) {
				return diffDay(date1, date0);
			}
			else {
				return diffDayTime(date1, date0);
			}
		}

		newProps = newProps || {};

		// normalize new date-related properties
		if (!newProps.start) {
			newProps.start = event.start.clone();
		}
		if (newProps.end === undefined) {
			newProps.end = event.end ? event.end.clone() : null;
		}
		if (newProps.allDay == null) { // is null or undefined?
			newProps.allDay = event.allDay;
		}
		normalizeEventDates(newProps);

		// create normalized versions of the original props to compare against
		// need a real end value, for diffing
		oldProps = {
			start: event._start.clone(),
			end: event._end ? event._end.clone() : t.getDefaultEventEnd(event._allDay, event._start),
			allDay: newProps.allDay // normalize the dates in the same regard as the new properties
		};
		normalizeEventDates(oldProps);

		// need to clear the end date if explicitly changed to null
		clearEnd = event._end !== null && newProps.end === null;

		// compute the delta for moving the start date
		startDelta = diffDates(newProps.start, oldProps.start);

		// compute the delta for moving the end date
		if (newProps.end) {
			endDelta = diffDates(newProps.end, oldProps.end);
			durationDelta = endDelta.subtract(startDelta);
		}
		else {
			durationDelta = null;
		}

		// gather all non-date-related properties
		$.each(newProps, function(name, val) {
			if (isMiscEventPropName(name)) {
				if (val !== undefined) {
					miscProps[name] = val;
				}
			}
		});

		// apply the operations to the event and all related events
		undoFunc = mutateEvents(
			clientEvents(event._id), // get events with this ID
			clearEnd,
			newProps.allDay,
			startDelta,
			durationDelta,
			miscProps
		);

		return {
			dateDelta: startDelta,
			durationDelta: durationDelta,
			undo: undoFunc
		};
	}


	// Modifies an array of events in the following ways (operations are in order):
	// - clear the event's `end`
	// - convert the event to allDay
	// - add `dateDelta` to the start and end
	// - add `durationDelta` to the event's duration
	// - assign `miscProps` to the event
	//
	// Returns a function that can be called to undo all the operations.
	//
	// TODO: don't use so many closures. possible memory issues when lots of events with same ID.
	//
	function mutateEvents(events, clearEnd, allDay, dateDelta, durationDelta, miscProps) {
		var isAmbigTimezone = t.getIsAmbigTimezone();
		var undoFunctions = [];

		// normalize zero-length deltas to be null
		if (dateDelta && !dateDelta.valueOf()) { dateDelta = null; }
		if (durationDelta && !durationDelta.valueOf()) { durationDelta = null; }

		$.each(events, function(i, event) {
			var oldProps;
			var newProps;

			// build an object holding all the old values, both date-related and misc.
			// for the undo function.
			oldProps = {
				start: event.start.clone(),
				end: event.end ? event.end.clone() : null,
				allDay: event.allDay
			};
			$.each(miscProps, function(name) {
				oldProps[name] = event[name];
			});

			// new date-related properties. work off the original date snapshot.
			// ok to use references because they will be thrown away when backupEventDates is called.
			newProps = {
				start: event._start,
				end: event._end,
				allDay: allDay // normalize the dates in the same regard as the new properties
			};
			normalizeEventDates(newProps); // massages start/end/allDay

			// strip or ensure the end date
			if (clearEnd) {
				newProps.end = null;
			}
			else if (durationDelta && !newProps.end) { // the duration translation requires an end date
				newProps.end = t.getDefaultEventEnd(newProps.allDay, newProps.start);
			}

			if (dateDelta) {
				newProps.start.add(dateDelta);
				if (newProps.end) {
					newProps.end.add(dateDelta);
				}
			}

			if (durationDelta) {
				newProps.end.add(durationDelta); // end already ensured above
			}

			// if the dates have changed, and we know it is impossible to recompute the
			// timezone offsets, strip the zone.
			if (
				isAmbigTimezone &&
				!newProps.allDay &&
				(dateDelta || durationDelta)
			) {
				newProps.start.stripZone();
				if (newProps.end) {
					newProps.end.stripZone();
				}
			}

			$.extend(event, miscProps, newProps); // copy over misc props, then date-related props
			backupEventDates(event); // regenerate internal _start/_end/_allDay

			undoFunctions.push(function() {
				$.extend(event, oldProps);
				backupEventDates(event); // regenerate internal _start/_end/_allDay
			});
		});

		return function() {
			for (var i = 0; i < undoFunctions.length; i++) {
				undoFunctions[i]();
			}
		};
	}

}


// hook for external libs to manipulate event properties upon creation.
// should manipulate the event in-place.
Calendar.prototype.normalizeEvent = function(event) {
};


// Does the given span (start, end, and other location information)
// fully contain the other?
Calendar.prototype.spanContainsSpan = function(outerSpan, innerSpan) {
	var eventStart = outerSpan.start.clone().stripZone();
	var eventEnd = this.getEventEnd(outerSpan).stripZone();

	return innerSpan.start >= eventStart && innerSpan.end <= eventEnd;
};


// Returns a list of events that the given event should be compared against when being considered for a move to
// the specified span. Attached to the Calendar's prototype because EventManager is a mixin for a Calendar.
Calendar.prototype.getPeerEvents = function(span, event) {
	var cache = this.getEventCache();
	var peerEvents = [];
	var i, otherEvent;

	for (i = 0; i < cache.length; i++) {
		otherEvent = cache[i];
		if (
			!event ||
			event._id !== otherEvent._id // don't compare the event to itself or other related [repeating] events
		) {
			peerEvents.push(otherEvent);
		}
	}

	return peerEvents;
};


// updates the "backup" properties, which are preserved in order to compute diffs later on.
function backupEventDates(event) {
	event._allDay = event.allDay;
	event._start = event.start.clone();
	event._end = event.end ? event.end.clone() : null;
}


/* Overlapping / Constraining
-----------------------------------------------------------------------------------------*/


// Determines if the given event can be relocated to the given span (unzoned start/end with other misc data)
Calendar.prototype.isEventSpanAllowed = function(span, event) {
	var source = event.source || {};

	var constraint = firstDefined(
		event.constraint,
		source.constraint,
		this.options.eventConstraint
	);

	var overlap = firstDefined(
		event.overlap,
		source.overlap,
		this.options.eventOverlap
	);

	return this.isSpanAllowed(span, constraint, overlap, event) &&
		(!this.options.eventAllow || this.options.eventAllow(span, event) !== false);
};


// Determines if an external event can be relocated to the given span (unzoned start/end with other misc data)
Calendar.prototype.isExternalSpanAllowed = function(eventSpan, eventLocation, eventProps) {
	var eventInput;
	var event;

	// note: very similar logic is in View's reportExternalDrop
	if (eventProps) {
		eventInput = $.extend({}, eventProps, eventLocation);
		event = this.expandEvent(
			this.buildEventFromInput(eventInput)
		)[0];
	}

	if (event) {
		return this.isEventSpanAllowed(eventSpan, event);
	}
	else { // treat it as a selection

		return this.isSelectionSpanAllowed(eventSpan);
	}
};


// Determines the given span (unzoned start/end with other misc data) can be selected.
Calendar.prototype.isSelectionSpanAllowed = function(span) {
	return this.isSpanAllowed(span, this.options.selectConstraint, this.options.selectOverlap) &&
		(!this.options.selectAllow || this.options.selectAllow(span) !== false);
};


// Returns true if the given span (caused by an event drop/resize or a selection) is allowed to exist
// according to the constraint/overlap settings.
// `event` is not required if checking a selection.
Calendar.prototype.isSpanAllowed = function(span, constraint, overlap, event) {
	var constraintEvents;
	var anyContainment;
	var peerEvents;
	var i, peerEvent;
	var peerOverlap;

	// the range must be fully contained by at least one of produced constraint events
	if (constraint != null) {

		// not treated as an event! intermediate data structure
		// TODO: use ranges in the future
		constraintEvents = this.constraintToEvents(constraint);
		if (constraintEvents) { // not invalid

			anyContainment = false;
			for (i = 0; i < constraintEvents.length; i++) {
				if (this.spanContainsSpan(constraintEvents[i], span)) {
					anyContainment = true;
					break;
				}
			}

			if (!anyContainment) {
				return false;
			}
		}
	}

	peerEvents = this.getPeerEvents(span, event);

	for (i = 0; i < peerEvents.length; i++)  {
		peerEvent = peerEvents[i];

		// there needs to be an actual intersection before disallowing anything
		if (this.eventIntersectsRange(peerEvent, span)) {

			// evaluate overlap for the given range and short-circuit if necessary
			if (overlap === false) {
				return false;
			}
			// if the event's overlap is a test function, pass the peer event in question as the first param
			else if (typeof overlap === 'function' && !overlap(peerEvent, event)) {
				return false;
			}

			// if we are computing if the given range is allowable for an event, consider the other event's
			// EventObject-specific or Source-specific `overlap` property
			if (event) {
				peerOverlap = firstDefined(
					peerEvent.overlap,
					(peerEvent.source || {}).overlap
					// we already considered the global `eventOverlap`
				);
				if (peerOverlap === false) {
					return false;
				}
				// if the peer event's overlap is a test function, pass the subject event as the first param
				if (typeof peerOverlap === 'function' && !peerOverlap(event, peerEvent)) {
					return false;
				}
			}
		}
	}

	return true;
};


// Given an event input from the API, produces an array of event objects. Possible event inputs:
// 'businessHours'
// An event ID (number or string)
// An object with specific start/end dates or a recurring event (like what businessHours accepts)
Calendar.prototype.constraintToEvents = function(constraintInput) {

	if (constraintInput === 'businessHours') {
		return this.getCurrentBusinessHourEvents();
	}

	if (typeof constraintInput === 'object') {
		if (constraintInput.start != null) { // needs to be event-like input
			return this.expandEvent(this.buildEventFromInput(constraintInput));
		}
		else {
			return null; // invalid
		}
	}

	return this.clientEvents(constraintInput); // probably an ID
};


// Does the event's date range intersect with the given range?
// start/end already assumed to have stripped zones :(
Calendar.prototype.eventIntersectsRange = function(event, range) {
	var eventStart = event.start.clone().stripZone();
	var eventEnd = this.getEventEnd(event).stripZone();

	return range.start < eventEnd && range.end > eventStart;
};


/* Business Hours
-----------------------------------------------------------------------------------------*/

var BUSINESS_HOUR_EVENT_DEFAULTS = {
	id: '_fcBusinessHours', // will relate events from different calls to expandEvent
	start: '09:00',
	end: '17:00',
	dow: [ 1, 2, 3, 4, 5 ], // monday - friday
	rendering: 'inverse-background'
	// classNames are defined in businessHoursSegClasses
};

// Return events objects for business hours within the current view.
// Abuse of our event system :(
Calendar.prototype.getCurrentBusinessHourEvents = function(wholeDay) {
	return this.computeBusinessHourEvents(wholeDay, this.options.businessHours);
};

// Given a raw input value from options, return events objects for business hours within the current view.
Calendar.prototype.computeBusinessHourEvents = function(wholeDay, input) {
	if (input === true) {
		return this.expandBusinessHourEvents(wholeDay, [ {} ]);
	}
	else if ($.isPlainObject(input)) {
		return this.expandBusinessHourEvents(wholeDay, [ input ]);
	}
	else if ($.isArray(input)) {
		return this.expandBusinessHourEvents(wholeDay, input, true);
	}
	else {
		return [];
	}
};

// inputs expected to be an array of objects.
// if ignoreNoDow is true, will ignore entries that don't specify a day-of-week (dow) key.
Calendar.prototype.expandBusinessHourEvents = function(wholeDay, inputs, ignoreNoDow) {
	var view = this.getView();
	var events = [];
	var i, input;

	for (i = 0; i < inputs.length; i++) {
		input = inputs[i];

		if (ignoreNoDow && !input.dow) {
			continue;
		}

		// give defaults. will make a copy
		input = $.extend({}, BUSINESS_HOUR_EVENT_DEFAULTS, input);

		// if a whole-day series is requested, clear the start/end times
		if (wholeDay) {
			input.start = null;
			input.end = null;
		}

		events.push.apply(events, // append
			this.expandEvent(
				this.buildEventFromInput(input),
				view.start,
				view.end
			)
		);
	}

	return events;
};

;;

/* An abstract class for the "basic" views, as well as month view. Renders one or more rows of day cells.
----------------------------------------------------------------------------------------------------------------------*/
// It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.
// It is responsible for managing width/height.

var BasicView = FC.BasicView = View.extend({

	scroller: null,

	dayGridClass: DayGrid, // class the dayGrid will be instantiated from (overridable by subclasses)
	dayGrid: null, // the main subcomponent that does most of the heavy lifting

	dayNumbersVisible: false, // display day numbers on each day cell?
	colWeekNumbersVisible: false, // display week numbers along the side?
	cellWeekNumbersVisible: false, // display week numbers in day cell?

	weekNumberWidth: null, // width of all the week-number cells running down the side

	headContainerEl: null, // div that hold's the dayGrid's rendered date header
	headRowEl: null, // the fake row element of the day-of-week header


	initialize: function() {
		this.dayGrid = this.instantiateDayGrid();

		this.scroller = new Scroller({
			overflowX: 'hidden',
			overflowY: 'auto'
		});
	},


	// Generates the DayGrid object this view needs. Draws from this.dayGridClass
	instantiateDayGrid: function() {
		// generate a subclass on the fly with BasicView-specific behavior
		// TODO: cache this subclass
		var subclass = this.dayGridClass.extend(basicDayGridMethods);

		return new subclass(this);
	},


	// Sets the display range and computes all necessary dates
	setRange: function(range) {
		View.prototype.setRange.call(this, range); // call the super-method

		this.dayGrid.breakOnWeeks = /year|month|week/.test(this.intervalUnit); // do before setRange
		this.dayGrid.setRange(range);
	},


	// Compute the value to feed into setRange. Overrides superclass.
	computeRange: function(date) {
		var range = View.prototype.computeRange.call(this, date); // get value from the super-method

		// year and month views should be aligned with weeks. this is already done for week
		if (/year|month/.test(range.intervalUnit)) {
			range.start.startOf('week');
			range.start = this.skipHiddenDays(range.start);

			// make end-of-week if not already
			if (range.end.weekday()) {
				range.end.add(1, 'week').startOf('week');
				range.end = this.skipHiddenDays(range.end, -1, true); // exclusively move backwards
			}
		}

		return range;
	},


	// Renders the view into `this.el`, which should already be assigned
	renderDates: function() {

		this.dayNumbersVisible = this.dayGrid.rowCnt > 1; // TODO: make grid responsible
		if (this.opt('weekNumbers')) {
			if (this.opt('weekNumbersWithinDays')) {
				this.cellWeekNumbersVisible = true;
				this.colWeekNumbersVisible = false;
			}
			else {
				this.cellWeekNumbersVisible = false;
				this.colWeekNumbersVisible = true;
			};
		}
		this.dayGrid.numbersVisible = this.dayNumbersVisible ||
			this.cellWeekNumbersVisible || this.colWeekNumbersVisible;

		this.el.addClass('fc-basic-view').html(this.renderSkeletonHtml());
		this.renderHead();

		this.scroller.render();
		var dayGridContainerEl = this.scroller.el.addClass('fc-day-grid-container');
		var dayGridEl = $('<div class="fc-day-grid" />').appendTo(dayGridContainerEl);
		this.el.find('.fc-body > tr > td').append(dayGridContainerEl);

		this.dayGrid.setElement(dayGridEl);
		this.dayGrid.renderDates(this.hasRigidRows());
	},


	// render the day-of-week headers
	renderHead: function() {
		this.headContainerEl =
			this.el.find('.fc-head-container')
				.html(this.dayGrid.renderHeadHtml());
		this.headRowEl = this.headContainerEl.find('.fc-row');
	},


	// Unrenders the content of the view. Since we haven't separated skeleton rendering from date rendering,
	// always completely kill the dayGrid's rendering.
	unrenderDates: function() {
		this.dayGrid.unrenderDates();
		this.dayGrid.removeElement();
		this.scroller.destroy();
	},


	renderBusinessHours: function() {
		this.dayGrid.renderBusinessHours();
	},


	unrenderBusinessHours: function() {
		this.dayGrid.unrenderBusinessHours();
	},


	// Builds the HTML skeleton for the view.
	// The day-grid component will render inside of a container defined by this HTML.
	renderSkeletonHtml: function() {
		return '' +
			'<table>' +
				'<thead class="fc-head">' +
					'<tr>' +
						'<td class="fc-head-container ' + this.widgetHeaderClass + '"></td>' +
					'</tr>' +
				'</thead>' +
				'<tbody class="fc-body">' +
					'<tr>' +
						'<td class="' + this.widgetContentClass + '"></td>' +
					'</tr>' +
				'</tbody>' +
			'</table>';
	},


	// Generates an HTML attribute string for setting the width of the week number column, if it is known
	weekNumberStyleAttr: function() {
		if (this.weekNumberWidth !== null) {
			return 'style="width:' + this.weekNumberWidth + 'px"';
		}
		return '';
	},


	// Determines whether each row should have a constant height
	hasRigidRows: function() {
		var eventLimit = this.opt('eventLimit');
		return eventLimit && typeof eventLimit !== 'number';
	},


	/* Dimensions
	------------------------------------------------------------------------------------------------------------------*/


	// Refreshes the horizontal dimensions of the view
	updateWidth: function() {
		if (this.colWeekNumbersVisible) {
			// Make sure all week number cells running down the side have the same width.
			// Record the width for cells created later.
			this.weekNumberWidth = matchCellWidths(
				this.el.find('.fc-week-number')
			);
		}
	},


	// Adjusts the vertical dimensions of the view to the specified values
	setHeight: function(totalHeight, isAuto) {
		var eventLimit = this.opt('eventLimit');
		var scrollerHeight;
		var scrollbarWidths;

		// reset all heights to be natural
		this.scroller.clear();
		uncompensateScroll(this.headRowEl);

		this.dayGrid.removeSegPopover(); // kill the "more" popover if displayed

		// is the event limit a constant level number?
		if (eventLimit && typeof eventLimit === 'number') {
			this.dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after
		}

		// distribute the height to the rows
		// (totalHeight is a "recommended" value if isAuto)
		scrollerHeight = this.computeScrollerHeight(totalHeight);
		this.setGridHeight(scrollerHeight, isAuto);

		// is the event limit dynamically calculated?
		if (eventLimit && typeof eventLimit !== 'number') {
			this.dayGrid.limitRows(eventLimit); // limit the levels after the grid's row heights have been set
		}

		if (!isAuto) { // should we force dimensions of the scroll container?

			this.scroller.setHeight(scrollerHeight);
			scrollbarWidths = this.scroller.getScrollbarWidths();

			if (scrollbarWidths.left || scrollbarWidths.right) { // using scrollbars?

				compensateScroll(this.headRowEl, scrollbarWidths);

				// doing the scrollbar compensation might have created text overflow which created more height. redo
				scrollerHeight = this.computeScrollerHeight(totalHeight);
				this.scroller.setHeight(scrollerHeight);
			}

			// guarantees the same scrollbar widths
			this.scroller.lockOverflow(scrollbarWidths);
		}
	},


	// given a desired total height of the view, returns what the height of the scroller should be
	computeScrollerHeight: function(totalHeight) {
		return totalHeight -
			subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
	},


	// Sets the height of just the DayGrid component in this view
	setGridHeight: function(height, isAuto) {
		if (isAuto) {
			undistributeHeight(this.dayGrid.rowEls); // let the rows be their natural height with no expanding
		}
		else {
			distributeHeight(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows
		}
	},


	/* Scroll
	------------------------------------------------------------------------------------------------------------------*/


	computeInitialScroll: function() {
		return { top: 0 };
	},


	queryScroll: function() {
		return { top: this.scroller.getScrollTop() };
	},


	setScroll: function(scroll) {
		this.scroller.setScrollTop(scroll.top);
	},


	/* Hit Areas
	------------------------------------------------------------------------------------------------------------------*/
	// forward all hit-related method calls to dayGrid


	prepareHits: function() {
		this.dayGrid.prepareHits();
	},


	releaseHits: function() {
		this.dayGrid.releaseHits();
	},


	queryHit: function(left, top) {
		return this.dayGrid.queryHit(left, top);
	},


	getHitSpan: function(hit) {
		return this.dayGrid.getHitSpan(hit);
	},


	getHitEl: function(hit) {
		return this.dayGrid.getHitEl(hit);
	},


	/* Events
	------------------------------------------------------------------------------------------------------------------*/


	// Renders the given events onto the view and populates the segments array
	renderEvents: function(events) {
		this.dayGrid.renderEvents(events);

		this.updateHeight(); // must compensate for events that overflow the row
	},


	// Retrieves all segment objects that are rendered in the view
	getEventSegs: function() {
		return this.dayGrid.getEventSegs();
	},


	// Unrenders all event elements and clears internal segment data
	unrenderEvents: function() {
		this.dayGrid.unrenderEvents();

		// we DON'T need to call updateHeight() because
		// a renderEvents() call always happens after this, which will eventually call updateHeight()
	},


	/* Dragging (for both events and external elements)
	------------------------------------------------------------------------------------------------------------------*/


	// A returned value of `true` signals that a mock "helper" event has been rendered.
	renderDrag: function(dropLocation, seg) {
		return this.dayGrid.renderDrag(dropLocation, seg);
	},


	unrenderDrag: function() {
		this.dayGrid.unrenderDrag();
	},


	/* Selection
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of a selection
	renderSelection: function(span) {
		this.dayGrid.renderSelection(span);
	},


	// Unrenders a visual indications of a selection
	unrenderSelection: function() {
		this.dayGrid.unrenderSelection();
	}

});


// Methods that will customize the rendering behavior of the BasicView's dayGrid
var basicDayGridMethods = {


	// Generates the HTML that will go before the day-of week header cells
	renderHeadIntroHtml: function() {
		var view = this.view;

		if (view.colWeekNumbersVisible) {
			return '' +
				'<th class="fc-week-number ' + view.widgetHeaderClass + '" ' + view.weekNumberStyleAttr() + '>' +
					'<span>' + // needed for matchCellWidths
						htmlEscape(view.opt('weekNumberTitle')) +
					'</span>' +
				'</th>';
		}

		return '';
	},


	// Generates the HTML that will go before content-skeleton cells that display the day/week numbers
	renderNumberIntroHtml: function(row) {
		var view = this.view;
		var weekStart = this.getCellDate(row, 0);

		if (view.colWeekNumbersVisible) {
			return '' +
				'<td class="fc-week-number" ' + view.weekNumberStyleAttr() + '>' +
					view.buildGotoAnchorHtml( // aside from link, important for matchCellWidths
						{ date: weekStart, type: 'week', forceOff: this.colCnt === 1 },
						weekStart.format('w') // inner HTML
					) +
				'</td>';
		}

		return '';
	},


	// Generates the HTML that goes before the day bg cells for each day-row
	renderBgIntroHtml: function() {
		var view = this.view;

		if (view.colWeekNumbersVisible) {
			return '<td class="fc-week-number ' + view.widgetContentClass + '" ' +
				view.weekNumberStyleAttr() + '></td>';
		}

		return '';
	},


	// Generates the HTML that goes before every other type of row generated by DayGrid.
	// Affects helper-skeleton and highlight-skeleton rows.
	renderIntroHtml: function() {
		var view = this.view;

		if (view.colWeekNumbersVisible) {
			return '<td class="fc-week-number" ' + view.weekNumberStyleAttr() + '></td>';
		}

		return '';
	}

};

;;

/* A month view with day cells running in rows (one-per-week) and columns
----------------------------------------------------------------------------------------------------------------------*/

var MonthView = FC.MonthView = BasicView.extend({

	// Produces information about what range to display
	computeRange: function(date) {
		var range = BasicView.prototype.computeRange.call(this, date); // get value from super-method
		var rowCnt;

		// ensure 6 weeks
		if (this.isFixedWeeks()) {
			rowCnt = Math.ceil(range.end.diff(range.start, 'weeks', true)); // could be partial weeks due to hiddenDays
			range.end.add(6 - rowCnt, 'weeks');
		}

		return range;
	},


	// Overrides the default BasicView behavior to have special multi-week auto-height logic
	setGridHeight: function(height, isAuto) {

		// if auto, make the height of each row the height that it would be if there were 6 weeks
		if (isAuto) {
			height *= this.rowCnt / 6;
		}

		distributeHeight(this.dayGrid.rowEls, height, !isAuto); // if auto, don't compensate for height-hogging rows
	},


	isFixedWeeks: function() {
		return this.opt('fixedWeekCount');
	}

});

;;

fcViews.basic = {
	'class': BasicView
};

fcViews.basicDay = {
	type: 'basic',
	duration: { days: 1 }
};

fcViews.basicWeek = {
	type: 'basic',
	duration: { weeks: 1 }
};

fcViews.month = {
	'class': MonthView,
	duration: { months: 1 }, // important for prev/next
	defaults: {
		fixedWeekCount: true
	}
};
;;

/* An abstract class for all agenda-related views. Displays one more columns with time slots running vertically.
----------------------------------------------------------------------------------------------------------------------*/
// Is a manager for the TimeGrid subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).
// Responsible for managing width/height.

var AgendaView = FC.AgendaView = View.extend({

	scroller: null,

	timeGridClass: TimeGrid, // class used to instantiate the timeGrid. subclasses can override
	timeGrid: null, // the main time-grid subcomponent of this view

	dayGridClass: DayGrid, // class used to instantiate the dayGrid. subclasses can override
	dayGrid: null, // the "all-day" subcomponent. if all-day is turned off, this will be null

	axisWidth: null, // the width of the time axis running down the side

	headContainerEl: null, // div that hold's the timeGrid's rendered date header
	noScrollRowEls: null, // set of fake row elements that must compensate when scroller has scrollbars

	// when the time-grid isn't tall enough to occupy the given height, we render an <hr> underneath
	bottomRuleEl: null,


	initialize: function() {
		this.timeGrid = this.instantiateTimeGrid();

		if (this.opt('allDaySlot')) { // should we display the "all-day" area?
			this.dayGrid = this.instantiateDayGrid(); // the all-day subcomponent of this view
		}

		this.scroller = new Scroller({
			overflowX: 'hidden',
			overflowY: 'auto'
		});
	},


	// Instantiates the TimeGrid object this view needs. Draws from this.timeGridClass
	instantiateTimeGrid: function() {
		var subclass = this.timeGridClass.extend(agendaTimeGridMethods);

		return new subclass(this);
	},


	// Instantiates the DayGrid object this view might need. Draws from this.dayGridClass
	instantiateDayGrid: function() {
		var subclass = this.dayGridClass.extend(agendaDayGridMethods);

		return new subclass(this);
	},


	/* Rendering
	------------------------------------------------------------------------------------------------------------------*/


	// Sets the display range and computes all necessary dates
	setRange: function(range) {
		View.prototype.setRange.call(this, range); // call the super-method

		this.timeGrid.setRange(range);
		if (this.dayGrid) {
			this.dayGrid.setRange(range);
		}
	},


	// Renders the view into `this.el`, which has already been assigned
	renderDates: function() {

		this.el.addClass('fc-agenda-view').html(this.renderSkeletonHtml());
		this.renderHead();

		this.scroller.render();
		var timeGridWrapEl = this.scroller.el.addClass('fc-time-grid-container');
		var timeGridEl = $('<div class="fc-time-grid" />').appendTo(timeGridWrapEl);
		this.el.find('.fc-body > tr > td').append(timeGridWrapEl);

		this.timeGrid.setElement(timeGridEl);
		this.timeGrid.renderDates();

		// the <hr> that sometimes displays under the time-grid
		this.bottomRuleEl = $('<hr class="fc-divider ' + this.widgetHeaderClass + '"/>')
			.appendTo(this.timeGrid.el); // inject it into the time-grid

		if (this.dayGrid) {
			this.dayGrid.setElement(this.el.find('.fc-day-grid'));
			this.dayGrid.renderDates();

			// have the day-grid extend it's coordinate area over the <hr> dividing the two grids
			this.dayGrid.bottomCoordPadding = this.dayGrid.el.next('hr').outerHeight();
		}

		this.noScrollRowEls = this.el.find('.fc-row:not(.fc-scroller *)'); // fake rows not within the scroller
	},


	// render the day-of-week headers
	renderHead: function() {
		this.headContainerEl =
			this.el.find('.fc-head-container')
				.html(this.timeGrid.renderHeadHtml());
	},


	// Unrenders the content of the view. Since we haven't separated skeleton rendering from date rendering,
	// always completely kill each grid's rendering.
	unrenderDates: function() {
		this.timeGrid.unrenderDates();
		this.timeGrid.removeElement();

		if (this.dayGrid) {
			this.dayGrid.unrenderDates();
			this.dayGrid.removeElement();
		}

		this.scroller.destroy();
	},


	// Builds the HTML skeleton for the view.
	// The day-grid and time-grid components will render inside containers defined by this HTML.
	renderSkeletonHtml: function() {
		return '' +
			'<table>' +
				'<thead class="fc-head">' +
					'<tr>' +
						'<td class="fc-head-container ' + this.widgetHeaderClass + '"></td>' +
					'</tr>' +
				'</thead>' +
				'<tbody class="fc-body">' +
					'<tr>' +
						'<td class="' + this.widgetContentClass + '">' +
							(this.dayGrid ?
								'<div class="fc-day-grid"/>' +
								'<hr class="fc-divider ' + this.widgetHeaderClass + '"/>' :
								''
								) +
						'</td>' +
					'</tr>' +
				'</tbody>' +
			'</table>';
	},


	// Generates an HTML attribute string for setting the width of the axis, if it is known
	axisStyleAttr: function() {
		if (this.axisWidth !== null) {
			 return 'style="width:' + this.axisWidth + 'px"';
		}
		return '';
	},


	/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/


	renderBusinessHours: function() {
		this.timeGrid.renderBusinessHours();

		if (this.dayGrid) {
			this.dayGrid.renderBusinessHours();
		}
	},


	unrenderBusinessHours: function() {
		this.timeGrid.unrenderBusinessHours();

		if (this.dayGrid) {
			this.dayGrid.unrenderBusinessHours();
		}
	},


	/* Now Indicator
	------------------------------------------------------------------------------------------------------------------*/


	getNowIndicatorUnit: function() {
		return this.timeGrid.getNowIndicatorUnit();
	},


	renderNowIndicator: function(date) {
		this.timeGrid.renderNowIndicator(date);
	},


	unrenderNowIndicator: function() {
		this.timeGrid.unrenderNowIndicator();
	},


	/* Dimensions
	------------------------------------------------------------------------------------------------------------------*/


	updateSize: function(isResize) {
		this.timeGrid.updateSize(isResize);

		View.prototype.updateSize.call(this, isResize); // call the super-method
	},


	// Refreshes the horizontal dimensions of the view
	updateWidth: function() {
		// make all axis cells line up, and record the width so newly created axis cells will have it
		this.axisWidth = matchCellWidths(this.el.find('.fc-axis'));
	},


	// Adjusts the vertical dimensions of the view to the specified values
	setHeight: function(totalHeight, isAuto) {
		var eventLimit;
		var scrollerHeight;
		var scrollbarWidths;

		// reset all dimensions back to the original state
		this.bottomRuleEl.hide(); // .show() will be called later if this <hr> is necessary
		this.scroller.clear(); // sets height to 'auto' and clears overflow
		uncompensateScroll(this.noScrollRowEls);

		// limit number of events in the all-day area
		if (this.dayGrid) {
			this.dayGrid.removeSegPopover(); // kill the "more" popover if displayed

			eventLimit = this.opt('eventLimit');
			if (eventLimit && typeof eventLimit !== 'number') {
				eventLimit = AGENDA_ALL_DAY_EVENT_LIMIT; // make sure "auto" goes to a real number
			}
			if (eventLimit) {
				this.dayGrid.limitRows(eventLimit);
			}
		}

		if (!isAuto) { // should we force dimensions of the scroll container?

			scrollerHeight = this.computeScrollerHeight(totalHeight);
			this.scroller.setHeight(scrollerHeight);
			scrollbarWidths = this.scroller.getScrollbarWidths();

			if (scrollbarWidths.left || scrollbarWidths.right) { // using scrollbars?

				// make the all-day and header rows lines up
				compensateScroll(this.noScrollRowEls, scrollbarWidths);

				// the scrollbar compensation might have changed text flow, which might affect height, so recalculate
				// and reapply the desired height to the scroller.
				scrollerHeight = this.computeScrollerHeight(totalHeight);
				this.scroller.setHeight(scrollerHeight);
			}

			// guarantees the same scrollbar widths
			this.scroller.lockOverflow(scrollbarWidths);

			// if there's any space below the slats, show the horizontal rule.
			// this won't cause any new overflow, because lockOverflow already called.
			if (this.timeGrid.getTotalSlatHeight() < scrollerHeight) {
				this.bottomRuleEl.show();
			}
		}
	},


	// given a desired total height of the view, returns what the height of the scroller should be
	computeScrollerHeight: function(totalHeight) {
		return totalHeight -
			subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
	},


	/* Scroll
	------------------------------------------------------------------------------------------------------------------*/


	// Computes the initial pre-configured scroll state prior to allowing the user to change it
	computeInitialScroll: function() {
		var scrollTime = moment.duration(this.opt('scrollTime'));
		var top = this.timeGrid.computeTimeTop(scrollTime);

		// zoom can give weird floating-point values. rather scroll a little bit further
		top = Math.ceil(top);

		if (top) {
			top++; // to overcome top border that slots beyond the first have. looks better
		}

		return { top: top };
	},


	queryScroll: function() {
		return { top: this.scroller.getScrollTop() };
	},


	setScroll: function(scroll) {
		this.scroller.setScrollTop(scroll.top);
	},


	/* Hit Areas
	------------------------------------------------------------------------------------------------------------------*/
	// forward all hit-related method calls to the grids (dayGrid might not be defined)


	prepareHits: function() {
		this.timeGrid.prepareHits();
		if (this.dayGrid) {
			this.dayGrid.prepareHits();
		}
	},


	releaseHits: function() {
		this.timeGrid.releaseHits();
		if (this.dayGrid) {
			this.dayGrid.releaseHits();
		}
	},


	queryHit: function(left, top) {
		var hit = this.timeGrid.queryHit(left, top);

		if (!hit && this.dayGrid) {
			hit = this.dayGrid.queryHit(left, top);
		}

		return hit;
	},


	getHitSpan: function(hit) {
		// TODO: hit.component is set as a hack to identify where the hit came from
		return hit.component.getHitSpan(hit);
	},


	getHitEl: function(hit) {
		// TODO: hit.component is set as a hack to identify where the hit came from
		return hit.component.getHitEl(hit);
	},


	/* Events
	------------------------------------------------------------------------------------------------------------------*/


	// Renders events onto the view and populates the View's segment array
	renderEvents: function(events) {
		var dayEvents = [];
		var timedEvents = [];
		var daySegs = [];
		var timedSegs;
		var i;

		// separate the events into all-day and timed
		for (i = 0; i < events.length; i++) {
			if (events[i].allDay) {
				dayEvents.push(events[i]);
			}
			else {
				timedEvents.push(events[i]);
			}
		}

		// render the events in the subcomponents
		timedSegs = this.timeGrid.renderEvents(timedEvents);
		if (this.dayGrid) {
			daySegs = this.dayGrid.renderEvents(dayEvents);
		}

		// the all-day area is flexible and might have a lot of events, so shift the height
		this.updateHeight();
	},


	// Retrieves all segment objects that are rendered in the view
	getEventSegs: function() {
		return this.timeGrid.getEventSegs().concat(
			this.dayGrid ? this.dayGrid.getEventSegs() : []
		);
	},


	// Unrenders all event elements and clears internal segment data
	unrenderEvents: function() {

		// unrender the events in the subcomponents
		this.timeGrid.unrenderEvents();
		if (this.dayGrid) {
			this.dayGrid.unrenderEvents();
		}

		// we DON'T need to call updateHeight() because
		// a renderEvents() call always happens after this, which will eventually call updateHeight()
	},


	/* Dragging (for events and external elements)
	------------------------------------------------------------------------------------------------------------------*/


	// A returned value of `true` signals that a mock "helper" event has been rendered.
	renderDrag: function(dropLocation, seg) {
		if (dropLocation.start.hasTime()) {
			return this.timeGrid.renderDrag(dropLocation, seg);
		}
		else if (this.dayGrid) {
			return this.dayGrid.renderDrag(dropLocation, seg);
		}
	},


	unrenderDrag: function() {
		this.timeGrid.unrenderDrag();
		if (this.dayGrid) {
			this.dayGrid.unrenderDrag();
		}
	},


	/* Selection
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of a selection
	renderSelection: function(span) {
		if (span.start.hasTime() || span.end.hasTime()) {
			this.timeGrid.renderSelection(span);
		}
		else if (this.dayGrid) {
			this.dayGrid.renderSelection(span);
		}
	},


	// Unrenders a visual indications of a selection
	unrenderSelection: function() {
		this.timeGrid.unrenderSelection();
		if (this.dayGrid) {
			this.dayGrid.unrenderSelection();
		}
	}

});


// Methods that will customize the rendering behavior of the AgendaView's timeGrid
// TODO: move into TimeGrid
var agendaTimeGridMethods = {


	// Generates the HTML that will go before the day-of week header cells
	renderHeadIntroHtml: function() {
		var view = this.view;
		var weekText;

		if (view.opt('weekNumbers')) {
			weekText = this.start.format(view.opt('smallWeekFormat'));

			return '' +
				'<th class="fc-axis fc-week-number ' + view.widgetHeaderClass + '" ' + view.axisStyleAttr() + '>' +
					view.buildGotoAnchorHtml( // aside from link, important for matchCellWidths
						{ date: this.start, type: 'week', forceOff: this.colCnt > 1 },
						htmlEscape(weekText) // inner HTML
					) +
				'</th>';
		}
		else {
			return '<th class="fc-axis ' + view.widgetHeaderClass + '" ' + view.axisStyleAttr() + '></th>';
		}
	},


	// Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.
	renderBgIntroHtml: function() {
		var view = this.view;

		return '<td class="fc-axis ' + view.widgetContentClass + '" ' + view.axisStyleAttr() + '></td>';
	},


	// Generates the HTML that goes before all other types of cells.
	// Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.
	renderIntroHtml: function() {
		var view = this.view;

		return '<td class="fc-axis" ' + view.axisStyleAttr() + '></td>';
	}

};


// Methods that will customize the rendering behavior of the AgendaView's dayGrid
var agendaDayGridMethods = {


	// Generates the HTML that goes before the all-day cells
	renderBgIntroHtml: function() {
		var view = this.view;

		return '' +
			'<td class="fc-axis ' + view.widgetContentClass + '" ' + view.axisStyleAttr() + '>' +
				'<span>' + // needed for matchCellWidths
					view.getAllDayHtml() +
				'</span>' +
			'</td>';
	},


	// Generates the HTML that goes before all other types of cells.
	// Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.
	renderIntroHtml: function() {
		var view = this.view;

		return '<td class="fc-axis" ' + view.axisStyleAttr() + '></td>';
	}

};

;;

var AGENDA_ALL_DAY_EVENT_LIMIT = 5;

// potential nice values for the slot-duration and interval-duration
// from largest to smallest
var AGENDA_STOCK_SUB_DURATIONS = [
	{ hours: 1 },
	{ minutes: 30 },
	{ minutes: 15 },
	{ seconds: 30 },
	{ seconds: 15 }
];

fcViews.agenda = {
	'class': AgendaView,
	defaults: {
		allDaySlot: true,
		slotDuration: '00:30:00',
		minTime: '00:00:00',
		maxTime: '24:00:00',
		slotEventOverlap: true // a bad name. confused with overlap/constraint system
	}
};

fcViews.agendaDay = {
	type: 'agenda',
	duration: { days: 1 }
};

fcViews.agendaWeek = {
	type: 'agenda',
	duration: { weeks: 1 }
};
;;

/*
Responsible for the scroller, and forwarding event-related actions into the "grid"
*/
var ListView = View.extend({

	grid: null,
	scroller: null,

	initialize: function() {
		this.grid = new ListViewGrid(this);
		this.scroller = new Scroller({
			overflowX: 'hidden',
			overflowY: 'auto'
		});
	},

	setRange: function(range) {
		View.prototype.setRange.call(this, range); // super

		this.grid.setRange(range); // needs to process range-related options
	},

	renderSkeleton: function() {
		this.el.addClass(
			'fc-list-view ' +
			this.widgetContentClass
		);

		this.scroller.render();
		this.scroller.el.appendTo(this.el);

		this.grid.setElement(this.scroller.scrollEl);
	},

	unrenderSkeleton: function() {
		this.scroller.destroy(); // will remove the Grid too
	},

	setHeight: function(totalHeight, isAuto) {
		this.scroller.setHeight(this.computeScrollerHeight(totalHeight));
	},

	computeScrollerHeight: function(totalHeight) {
		return totalHeight -
			subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
	},

	renderEvents: function(events) {
		this.grid.renderEvents(events);
	},

	unrenderEvents: function() {
		this.grid.unrenderEvents();
	},

	isEventResizable: function(event) {
		return false;
	},

	isEventDraggable: function(event) {
		return false;
	}

});

/*
Responsible for event rendering and user-interaction.
Its "el" is the inner-content of the above view's scroller.
*/
var ListViewGrid = Grid.extend({

	segSelector: '.fc-list-item', // which elements accept event actions
	hasDayInteractions: false, // no day selection or day clicking

	// slices by day
	spanToSegs: function(span) {
		var view = this.view;
		var dayStart = view.start.clone().time(0); // timed, so segs get times!
		var dayIndex = 0;
		var seg;
		var segs = [];

		while (dayStart < view.end) {

			seg = intersectRanges(span, {
				start: dayStart,
				end: dayStart.clone().add(1, 'day')
			});

			if (seg) {
				seg.dayIndex = dayIndex;
				segs.push(seg);
			}

			dayStart.add(1, 'day');
			dayIndex++;

			// detect when span won't go fully into the next day,
			// and mutate the latest seg to the be the end.
			if (
				seg && !seg.isEnd && span.end.hasTime() &&
				span.end < dayStart.clone().add(this.view.nextDayThreshold)
			) {
				seg.end = span.end.clone();
				seg.isEnd = true;
				break;
			}
		}

		return segs;
	},

	// like "4:00am"
	computeEventTimeFormat: function() {
		return this.view.opt('mediumTimeFormat');
	},

	// for events with a url, the whole <tr> should be clickable,
	// but it's impossible to wrap with an <a> tag. simulate this.
	handleSegClick: function(seg, ev) {
		var url;

		Grid.prototype.handleSegClick.apply(this, arguments); // super. might prevent the default action

		// not clicking on or within an <a> with an href
		if (!$(ev.target).closest('a[href]').length) {
			url = seg.event.url;
			if (url && !ev.isDefaultPrevented()) { // jsEvent not cancelled in handler
				window.location.href = url; // simulate link click
			}
		}
	},

	// returns list of foreground segs that were actually rendered
	renderFgSegs: function(segs) {
		segs = this.renderFgSegEls(segs); // might filter away hidden events

		if (!segs.length) {
			this.renderEmptyMessage();
		}
		else {
			this.renderSegList(segs);
		}

		return segs;
	},

	renderEmptyMessage: function() {
		this.el.html(
			'<div class="fc-list-empty-wrap2">' + // TODO: try less wraps
			'<div class="fc-list-empty-wrap1">' +
			'<div class="fc-list-empty">' +
				htmlEscape(this.view.opt('noEventsMessage')) +
			'</div>' +
			'</div>' +
			'</div>'
		);
	},

	// render the event segments in the view
	renderSegList: function(allSegs) {
		var segsByDay = this.groupSegsByDay(allSegs); // sparse array
		var dayIndex;
		var daySegs;
		var i;
		var tableEl = $('<table class="fc-list-table"><tbody/></table>');
		var tbodyEl = tableEl.find('tbody');

		for (dayIndex = 0; dayIndex < segsByDay.length; dayIndex++) {
			daySegs = segsByDay[dayIndex];
			if (daySegs) { // sparse array, so might be undefined

				// append a day header
				tbodyEl.append(this.dayHeaderHtml(
					this.view.start.clone().add(dayIndex, 'days')
				));

				this.sortEventSegs(daySegs);

				for (i = 0; i < daySegs.length; i++) {
					tbodyEl.append(daySegs[i].el); // append event row
				}
			}
		}

		this.el.empty().append(tableEl);
	},

	// Returns a sparse array of arrays, segs grouped by their dayIndex
	groupSegsByDay: function(segs) {
		var segsByDay = []; // sparse array
		var i, seg;

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			(segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = []))
				.push(seg);
		}

		return segsByDay;
	},

	// generates the HTML for the day headers that live amongst the event rows
	dayHeaderHtml: function(dayDate) {
		var view = this.view;
		var mainFormat = view.opt('listDayFormat');
		var altFormat = view.opt('listDayAltFormat');

		return '<tr class="fc-list-heading" data-date="' + dayDate.format('YYYY-MM-DD') + '">' +
			'<td class="' + view.widgetHeaderClass + '" colspan="3">' +
				(mainFormat ?
					view.buildGotoAnchorHtml(
						dayDate,
						{ 'class': 'fc-list-heading-main' },
						htmlEscape(dayDate.format(mainFormat)) // inner HTML
					) :
					'') +
				(altFormat ?
					view.buildGotoAnchorHtml(
						dayDate,
						{ 'class': 'fc-list-heading-alt' },
						htmlEscape(dayDate.format(altFormat)) // inner HTML
					) :
					'') +
			'</td>' +
		'</tr>';
	},

	// generates the HTML for a single event row
	fgSegHtml: function(seg) {
		var view = this.view;
		var classes = [ 'fc-list-item' ].concat(this.getSegCustomClasses(seg));
		var bgColor = this.getSegBackgroundColor(seg);
		var event = seg.event;
		var url = event.url;
		var timeHtml;

		if (event.allDay) {
			timeHtml = view.getAllDayHtml();
		}
		else if (view.isMultiDayEvent(event)) { // if the event appears to span more than one day
			if (seg.isStart || seg.isEnd) { // outer segment that probably lasts part of the day
				timeHtml = htmlEscape(this.getEventTimeText(seg));
			}
			else { // inner segment that lasts the whole day
				timeHtml = view.getAllDayHtml();
			}
		}
		else {
			// Display the normal time text for the *event's* times
			timeHtml = htmlEscape(this.getEventTimeText(event));
		}

		if (url) {
			classes.push('fc-has-url');
		}

		return '<tr class="' + classes.join(' ') + '">' +
			(this.displayEventTime ?
				'<td class="fc-list-item-time ' + view.widgetContentClass + '">' +
					(timeHtml || '') +
				'</td>' :
				'') +
			'<td class="fc-list-item-marker ' + view.widgetContentClass + '">' +
				'<span class="fc-event-dot"' +
				(bgColor ?
					' style="background-color:' + bgColor + '"' :
					'') +
				'></span>' +
			'</td>' +
			'<td class="fc-list-item-title ' + view.widgetContentClass + '">' +
				'<a' + (url ? ' href="' + htmlEscape(url) + '"' : '') + '>' +
					htmlEscape(seg.event.title || '') +
				'</a>' +
			'</td>' +
		'</tr>';
	}

});

;;

fcViews.list = {
	'class': ListView,
	buttonTextKey: 'list', // what to lookup in locale files
	defaults: {
		buttonText: 'list', // text to display for English
		listDayFormat: 'LL', // like "January 1, 2016"
		noEventsMessage: 'No events to display'
	}
};

fcViews.listDay = {
	type: 'list',
	duration: { days: 1 },
	defaults: {
		listDayFormat: 'dddd' // day-of-week is all we need. full date is probably in header
	}
};

fcViews.listWeek = {
	type: 'list',
	duration: { weeks: 1 },
	defaults: {
		listDayFormat: 'dddd', // day-of-week is more important
		listDayAltFormat: 'LL'
	}
};

fcViews.listMonth = {
	type: 'list',
	duration: { month: 1 },
	defaults: {
		listDayAltFormat: 'dddd' // day-of-week is nice-to-have
	}
};

fcViews.listYear = {
	type: 'list',
	duration: { year: 1 },
	defaults: {
		listDayAltFormat: 'dddd' // day-of-week is nice-to-have
	}
};

;;

return FC; // export for Node/CommonJS
});
var FC = $.fullCalendar;
var View = FC.View;      
var Grid = FC.Grid;      
var CoordCache = FC.CoordCache;     
var ScheduleView;


var ScheduleGrid = Grid.extend({
    timeTable: null,
    eventTimeFormat: "H:mm",
    displayEventEnd:true,
    displayEventTime:true,

    constructor: function () {
        Grid.apply(this, arguments); // call the super-constructor

        this.minTime = moment.duration('00:00:00');
        this.maxTime = moment.duration('24:00:00');
        this.slotDuration = moment.duration('00:30:00');
    },

    setIntervalMin: function(min){
        this.intervalMin = min;
    },

    getTotalSlatHeight: function() {
		return this.slatContainerEl.outerHeight();
	},
    //To regenerate time object of the header from 00:00 to 23:59 of the current day
    updateTimeTable: function(){
        var view = this.view;
        var currentDay = view.start.clone();
        var timeTable = [];
        var time;
        var m = moment({ hour: 0, minute: 0, seconds: 0 });

        currentDay.hour(0);
        currentDay.minute(0);
        currentDay.second(0);

        headerTime = ScheduleView.generateTimes(m, this.intervalMin);
        for (var i = 0; i < this.colCnt; i++) {
            currentDay.hour(headerTime[i].hour);
            currentDay.minute(headerTime[i].minute);
            timeTable.push(currentDay.clone());
        }

        currentDay.minute(59);
        currentDay.second(59);
        timeTable.push(currentDay.clone());
        this.timeTable = timeTable;
    },

    renderDates: function() {
        this.el.html(this.renderHtml());
        this.slatContainerEl = this.el.find('.fc-slats');
        this.slatEls = this.slatContainerEl.find('tr');

        this.slatCoordCache = new CoordCache({
            els: this.slatEls,
            isHorizontal: true,
            isVertical: true
        });

        this.renderContentSkeleton();

        this.timeContainerEl = this.el.find('.fc-content-skeleton');
        this.timeEls = this.timeContainerEl.find('td');
        this.timeHeaderCoordCache = new CoordCache({
            els: this.timeEls,
            isHorizontal: true,
        });
    },

    // Renders the basic HTML skeleton for the grid
    renderHtml: function() {
        return `
            <div class="fc-bg">
                <table>
                    ${this.renderBgTrHtml()}
                </table>
            </div>
            <div class="fc-slats">
                <table>
                    ${this.renderSlatRowHtml()}
                </table>
            </div>
        `;
    },

    renderBgTrHtml: function(){
        return `
            <tr>
                ${this.renderBgIntroHtml() + this.renderBgCellsHtml()}
            </tr>
        `
    },

    renderBgIntroHtml: function() {
        var view = this.view;
        return `<td class="fc-axis ${view.widgetContentClass}" ${view.axisStyleAttr()}></td>\n`;
    },

    renderBgCellsHtml: function() {
        var view = this.view;
        let m = moment({ hour: 0, minute: 0, seconds: 0 });
        let timeInterval = ScheduleView.generateTimes(m, this.intervalMin);
        let th = timeInterval.map((item) => {
            return `<td class="${view.widgetContentClass}" data-time='${item.text}'></td>`;
        });

        // Set colCnt after create header
        this.colCnt = th.length;

        return th.join("\n");
    },

    // Generates the HTML for the horizontal "slats" that run width-wise. Has a time axis on a side. Depends on RTL.
    renderSlatRowHtml: function(){
        var view = this.view;
        var resources = view.opt('resources');
        var resourceHeight = view.opt('resourceHeight');
        var html = '';
        var axisHtml;

        resources.forEach((resource) => {
            axisHtml = `
                    <td class="fc-axis fc-time ${view.widgetContentClass} ${view.axisStyleAttr()}">
                        <span>${resource.text}</span>
                    </td>
            `;

            html += `
                <tr height="${resourceHeight}" data-resource-id="${resource.id}">
                    ${axisHtml}
                    <td class="${view.widgetContentClass}"/>
                </tr>
            `;
        });

        return html;
    },

    updateSize: function (isResize) { // NOT a standard Grid method
        this.slatCoordCache.build();
        this.timeHeaderCoordCache.build();

        if (isResize) {
            this.updateSegVerticals(
                [].concat(this.fgSegs || [], this.bgSegs || [], this.businessSegs || [])
            );
        }
    },
});

// *********************************** ScheduleGrid Event SECTION *******************************//

ScheduleGrid.mixin({

    colContainerEls: null, // containers for each column

    // inner-containers for each column where different types of segs live
    fgContainerEls: null,
    bgContainerEls: null,
    helperContainerEls: null,
    highlightContainerEls: null,
    businessContainerEls: null,

    // arrays of different types of displayed segments
    fgSegs: null,
    bgSegs: null,
    helperSegs: null,
    highlightSegs: null,
    businessSegs: null,


    // Renders the DOM that the view's content will live in
    renderContentSkeleton: function () {
        var cellHtml = this.renderBgIntroHtml();
        var i;
        var skeletonEl;

        for (i = 0; i < this.colCnt; i++) {
            cellHtml += `
                <td>
                    <div class="fc-content-col">
                        <div class="fc-event-container fc-helper-container"></div>
                        <div class="fc-event-container"></div>
                        <div class="fc-highlight-container"></div>
                        <div class="fc-bgevent-container"></div>
                        <div class="fc-business-container"></div>
                    </div>
                </td>
            `;
        }

        skeletonEl = $(`
            <div class="fc-content-skeleton">
                <table>
                    <tr>${cellHtml}</tr>
                </table>
            </div>
        `);

        this.colContainerEls = skeletonEl.find('.fc-content-col');
        this.helperContainerEls = skeletonEl.find('.fc-helper-container');
        this.fgContainerEls = skeletonEl.find('.fc-event-container:not(.fc-helper-container)');
        this.bgContainerEls = skeletonEl.find('.fc-bgevent-container');
        this.highlightContainerEls = skeletonEl.find('.fc-highlight-container');
        this.businessContainerEls = skeletonEl.find('.fc-business-container');

        this.bookendCells(skeletonEl.find('tr')); // TODO: do this on string level
        this.el.append(skeletonEl);
    },

    // Will be called when render event (called from Grid.js)
    // Slices up the given span (unzoned start/end with other misc data) into an array of segments
    spanToSegs: function (span) {
        var segs = this.sliceRangeByTimes(span);
        var i;

        for (i = 0; i < segs.length; i++) {
            segs[i].col = segs[i].timeIndex;
        }
        return segs;
    },

    sliceRangeByTimes: function (range) {
        var segs = [];
        var seg;
        var timeIndex;
        var timeRange;
        for (timeIndex = 1; timeIndex < this.timeTable.length; timeIndex++) {
            timeRange = {
                start: this.timeTable[timeIndex - 1].clone(),
                end: this.timeTable[timeIndex].clone(),
            };

            //if range is in timeRange, so we found timeIndex
            if(ScheduleGrid.intersectRanges(range, timeRange)){
                break;
            }
        }

        seg = ScheduleGrid.intersectRanges(range, {
            start: this.timeTable[0].clone().time(this.minTime),
            end: this.timeTable[0].clone().time(this.maxTime),
        });

        if (seg) {
            seg.timeIndex = timeIndex - 1;
            segs.push(seg);
        }

        return segs;
    },


	/* Foreground Events
	------------------------------------------------------------------------------------------------------------------*/


    renderFgSegs: function (segs) {
        segs = this.renderFgSegsIntoContainers(segs, this.fgContainerEls);
        this.fgSegs = segs;
        return segs; // needed for Grid::renderEvents
    },


    unrenderFgSegs: function () {
        this.unrenderNamedSegs('fgSegs');
    },


	/* Foreground Helper Events
	------------------------------------------------------------------------------------------------------------------*/


    renderHelperSegs: function (segs, sourceSeg) {
        var helperEls = [];
        var i, seg;
        var sourceEl;

        segs = this.renderFgSegsIntoContainers(segs, this.helperContainerEls);

        // Try to make the segment that is in the same row as sourceSeg look the same
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            if (sourceSeg && sourceSeg.col === seg.col) {
                sourceEl = sourceSeg.el;
                seg.el.css({
                    left: sourceEl.css('left'),
                    right: sourceEl.css('right'),
                    'margin-left': sourceEl.css('margin-left'),
                    'margin-right': sourceEl.css('margin-right')
                });
            }
            helperEls.push(seg.el[0]);
        }

        this.helperSegs = segs;

        return $(helperEls); // must return rendered helpers
    },


    unrenderHelperSegs: function () {
        this.unrenderNamedSegs('helperSegs');
    },


	/* Background Events
	------------------------------------------------------------------------------------------------------------------*/


    renderBgSegs: function (segs) {
        segs = this.renderFillSegEls('bgEvent', segs); // TODO: old fill system
        this.updateHorizontalFgSegCoords(segs);
        this.updateSegVerticals(segs);
        this.attachSegsByCol(this.groupSegsByCol(segs), this.bgContainerEls);
        this.bgSegs = segs;
        return segs; // needed for Grid::renderEvents
    },


    unrenderBgSegs: function () {
        this.unrenderNamedSegs('bgSegs');
    },
	/* Seg Rendering Utils
	------------------------------------------------------------------------------------------------------------------*/


    // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col
    groupSegsByCol: function (segs) {
        var segsByCol = [];
        var i;

        for (i = 0; i < this.colCnt; i++) {
            segsByCol.push([]);
        }

        for (i = 0; i < segs.length; i++) {
            segsByCol[segs[i].col].push(segs[i]);
        }

        return segsByCol;
    },


    // Given segments grouped by column, insert the segments' elements into a parallel array of container
    // elements, each living within a column.
    attachSegsByCol: function (segsByCol, containerEls) {
        var col;
        var segs;
        var i;

        for (col = 0; col < this.colCnt; col++) { // iterate each column grouping
            segs = segsByCol[col];

            for (i = 0; i < segs.length; i++) {
                containerEls.eq(col).append(segs[i].el);
            }
        }
    },

    // Given the name of a property of `this` object, assumed to be an array of segments,
    // loops through each segment and removes from DOM. Will null-out the property afterwards.
    unrenderNamedSegs: function (propName) {
        var segs = this[propName];
        var i;

        if (segs) {
            for (i = 0; i < segs.length; i++) {
                segs[i].el.remove();
            }
            this[propName] = null;
        }
    },



	/* Foreground Event Rendering Utils
	------------------------------------------------------------------------------------------------------------------*/
    renderFgSegsIntoContainers: function (segs, containerEls) {
        var segsByCol;
        var segsByRow;
        var col;
        var row;

        var view = this.view;
        var resources = view.opt("resources") || [];

        segs = this.renderFgSegEls(segs); // will call fgSegHtml
        segsByCol = this.groupSegsByCol(segs);
        segsByRow = this.groupSegsByRow(segs);

        for (col = 0; col < this.colCnt; col++) {
            this.updateHorizontalFgSegCoords(segsByCol[col]);
        }

        for (i = 0; i < resources.length; i++) {
             this.updateVertialFgSegCoords(segsByRow[resources[i].id]);
        }

        this.attachSegsByCol(segsByCol, containerEls);

        return segs;
    },

    fgSegHtml: function (seg, disableResizing) {
        var view = this.view;
        var event = seg.event;
        var isDraggable = view.isEventDraggable(event);
        var isResizableFromStart = !disableResizing && seg.isStart && view.isEventResizableFromStart(event);
        var isResizableFromEnd = !disableResizing && seg.isEnd && view.isEventResizableFromEnd(event);
        var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
        var skinCss = FC.cssToStr(this.getSegSkinCss(seg));
        var timeText;
        var fullTimeText; // more verbose time text. for the print stylesheet
        var startTimeText; // just the start time text

        classes.unshift('fc-schedule-grid-event', 'fc-v-event');

        if (view.isMultiDayEvent(event)) { // if the event appears to span more than one day...
            // Don't display time text on segments that run entirely through a day.
            // That would appear as midnight-midnight and would look dumb.
            // Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)
            if (seg.isStart || seg.isEnd) {
                timeText = this.getEventTimeText(seg);
                fullTimeText = this.getEventTimeText(seg, 'LT');
                startTimeText = this.getEventTimeText(seg, null, false); // displayEnd=false
            }
        } else {
            // Display the normal time text for the *event's* times
            timeText = this.getEventTimeText(event);
            fullTimeText = this.getEventTimeText(event, 'LT');
            startTimeText = this.getEventTimeText(event, null, false); // displayEnd=false
        }

        return '<a class="' + classes.join(' ') + '"' +
            (event.url ?
                ' href="' + FC.htmlEscape(event.url) + '"' :
                ''
            ) +
            (skinCss ?
                ' style="' + skinCss + '"' :
                ''
            ) +
            '>' +
            '<div class="fc-content">' +
            (timeText ?
                '<div class="fc-time"' +
                ' data-start="' + FC.htmlEscape(startTimeText) + '"' +
                ' data-full="' + FC.htmlEscape(fullTimeText) + '"' +
                '>' +
                // '<span>' + FC.htmlEscape(timeText) + '</span>' +
                '</div>' :
                ''
            ) +
            (event.title ?
                '<div class="fc-title">' +
                FC.htmlEscape(event.title) +
                '</div>' :
                ''
            ) +
            '</div>' +
            '<div class="fc-bg"/>' +
            (isResizableFromEnd ?
                '<div class="fc-resizer fc-end-resizer" />' :
                ''
            ) +
            '</a>';
    },


	/* Seg Position Utils
	------------------------------------------------------------------------------------------------------------------*/
    updateSegVerticals: function (segs) {
        this.computeSegVerticals(segs);
        this.assignSegVerticals(segs);
    },

    // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col
    groupSegsByRow: function (segs) {
        var view = this.view;
        var resources = view.opt("resources") || [];
        var segsByRow = {};
        var i;

        for (i = 0; i < resources.length; i++) {
            segsByRow[resources[i].id] = [];
        }

        for (i = 0; i < segs.length; i++) {
            if (segsByRow[segs[i].event.resourceID]) {
                segsByRow[segs[i].event.resourceID].push(segs[i]);
            }
        }

        return segsByRow;
    },

    computeSegVerticals: function (segs) {
        var levels;
        var level0;
        var i;

        this.sortEventSegs(segs); // order by certain criteria
        levels = this.buildSlotSegLevels(segs);
        this.computeForwardSlotSegs(levels);

        if ((level0 = levels[0])) {

            for (i = 0; i < level0.length; i++) {
                this.computeSlotSegPressures(level0[i]);
            }

            for (i = 0; i < level0.length; i++) {
                this.computeFgSegForwardBack(level0[i], 0, 0);
            }
        }
    },

    computeFgSegForwardBack: function (seg, seriesBackwardPressure, seriesBackwardCoord) {
        var forwardSegs = seg.forwardSegs;
        var i;

        if (seg.forwardCoord === undefined) { // not already computed

            if (!forwardSegs.length) {

                // if there are no forward segments, this segment should butt up against the edge
                seg.forwardCoord = 1;
            }
            else {

                // sort highest pressure first
                this.sortForwardSegs(forwardSegs);

                // this segment's forwardCoord will be calculated from the backwardCoord of the
                // highest-pressure forward segment.
                this.computeFgSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);
                seg.forwardCoord = forwardSegs[0].backwardCoord;
            }

            // calculate the backwardCoord from the forwardCoord. consider the series
            seg.backwardCoord = seg.forwardCoord -
                (seg.forwardCoord - seriesBackwardCoord) / // available width for series
                (seriesBackwardPressure + 1); // # of segments in the series

            // use this segment's coordinates to computed the coordinates of the less-pressurized
            // forward segments
            for (i = 0; i < forwardSegs.length; i++) {
                this.computeFgSegForwardBack(forwardSegs[i], 0, seg.forwardCoord);
            }
        }
    },

    sortForwardSegs: function (forwardSegs) {
        forwardSegs.sort(FC.proxy(this, 'compareForwardSegs'));
    },

    compareForwardSegs: function (seg1, seg2) {
        // put higher-pressure first
        return seg2.forwardPressure - seg1.forwardPressure ||
            // put segments that are closer to initial edge first (and favor ones with no coords yet)
            (seg1.backwardCoord || 0) - (seg2.backwardCoord || 0) ||
            // do normal sorting...
            this.compareEventSegs(seg1, seg2);
    },

    buildSlotSegLevels: function(segs) {
        var levels = [];
        var i, seg;
        var j;

        for(i = 0; i<segs.length; i++) {
            seg = segs[i];

            // go through all the levels and stop on the first level where there are no collisions
            for (j = 0; j < levels.length; j++) {
                if (!this.computeSlotSegCollisions(seg, levels[j]).length) {
                    break;
                }
            }

            seg.level = j;

            (levels[j] || (levels[j] = [])).push(seg);
        }

        return levels;
    },

    computeForwardSlotSegs: function(levels) {
        var i, level;
        var j, seg;
        var k;

        for(i = 0; i <levels.length; i++) {
            level = levels[i];

            for (j = 0; j < level.length; j++) {
                seg = level[j];

                seg.forwardSegs = [];
                for (k = i + 1; k < levels.length; k++) {
                    this.computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);
                }
            }
        }
    },

    computeSlotSegCollisions: function (seg, otherSegs, results) {
        results = results || [];

        for (var i = 0; i < otherSegs.length; i++) {
            if (this.isSlotSegCollision(seg, otherSegs[i])) {
                results.push(otherSegs[i]);
            }
        }

        return results;
    },

    isSlotSegCollision: function (seg1, seg2) {
        var max = moment.max(seg1.start.clone(), seg2.start.clone());
        var min = moment.min(seg1.end.clone(), seg2.end.clone());
        return max <= min;
    },

    computeSlotSegPressures: function (seg) {
        var forwardSegs = seg.forwardSegs;
        var forwardPressure = 0;
        var i, forwardSeg;

        if (seg.forwardPressure === undefined) { // not already computed

            for (i = 0; i < forwardSegs.length; i++) {
                forwardSeg = forwardSegs[i];

                // figure out the child's maximum forward path
                this.computeSlotSegPressures(forwardSeg);

                // either use the existing maximum, or use the child's forward pressure
                // plus one (for the forwardSeg itself)
                forwardPressure = Math.max(
                    forwardPressure,
                    1 + forwardSeg.forwardPressure
                );
            }

            seg.forwardPressure = forwardPressure;
        }
    },

    mapResourceTopPos(seg){
        var resoureID;
        var eventID = seg.event.resourceID;
        var top, height;
        $.each(this.slatCoordCache.els, (index, el) => {
            resoureID = $(el).data("resource-id");
            if(resoureID == eventID){
                top = this.slatCoordCache.getTopPosition(index);
                height = this.slatCoordCache.getBottomPosition(index)
                         - this.slatCoordCache.getTopPosition(index);
            }
        });
        return { top: top, height: height};
    },

    mapResourceHeightPos(seg){
        return seg.top + this.view.opt("resourceHeight");
    },

    assignSegVerticals: function (segs) {
        var i, seg;

        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            seg.el.css(this.generateSegVerticalCss(seg));
        }
    },

    generateSegVerticalCss: function (seg) {
        var shouldOverlap = this.view.opt('slotEventOverlap');
        var backwardCoord = seg.backwardCoord; // the top side if LTR. the bottom side if RTL. floating-point
        var forwardCoord = seg.forwardCoord; // the bottom side if LTR. the top side if RTL. floating-point
        var props = {}; // get top/bottom first
        var top; // amount of space from top edge, a fraction of the total width
        var bottom; // amount of space from bottom edge, a fraction of the total width

        if (shouldOverlap) {
            // double the width, but don't go beyond the maximum forward coordinate (1.0)
            forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);
        }


        top = backwardCoord;
        bottom = 1 - forwardCoord;

        props.zIndex = seg.level + 1; // convert from 0-base to 1-based
        props.top = this.mapResourceTopPos(seg).height * top;
        props.top += this.mapResourceTopPos(seg).top;
        props.bottom = this.mapResourceTopPos(seg).height * bottom;

        if(props.bottom == 0){
            props.bottom = this.mapResourceTopPos(seg).top + this.mapResourceTopPos(seg).height;
        }
        else{
            props.bottom = this.mapResourceTopPos(seg).top + this.mapResourceTopPos(seg).height - props.bottom;
        }
        props.bottom *= -1;


        if (shouldOverlap && seg.forwardPressure) {
            // add padding to the edge so that forward stacked events don't cover the resizer's icon
            props[this.isRTL ? 'marginTop' : 'marginBottom'] = 10 * 2; // 10 is a guesstimate of the icon's width
        }

        //if event has no any resource slot rendered then hide it
        if (typeof this.mapResourceTopPos(seg).top === "undefined") {
            props.display = "none";
        }

        return props;
    },


	/* Foreground Event Positioning Utils
	------------------------------------------------------------------------------------------------------------------*/
    updateHorizontalFgSegCoords: function (segs) {
        this.computeFgSegHorizontals(segs); 
        this.assignFgSegHorizontals(segs);
    },

    updateVertialFgSegCoords: function (segs) {
        this.computeSegVerticals(segs); 
        this.assignSegVerticals(segs);
    },

    computeFgSegHorizontals: function (segs) {
        var i, seg, pos;

        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            pos = this.mapResourceLeftAndRight(seg);
            seg.left = pos.left;
            seg.right = pos.right;
        }
    },

    mapResourceLeftAndRight(range) {
        var timeIndex, 
            timeRange, 
            firstCol,
            lastCol,
            timeRangeIndex = [];

        for (timeIndex = 1; timeIndex < this.timeTable.length; timeIndex++) {

            timeRange = {
                start: this.timeTable[timeIndex - 1].clone(),
                end: this.timeTable[timeIndex].clone(),
            };

            //if range is in timeRange, so we found timeIndex
            if (ScheduleGrid.intersectRanges(range, timeRange)) {
                timeRangeIndex.push(timeIndex);
            }
        }

        firstCol = timeRangeIndex.slice(0,1)[0];
        lastCol   = timeRangeIndex.slice(-1)[0];

        var startTime = this.timeTable[firstCol - 1];
        var endTime = this.timeTable[lastCol];
        var endOfStartTime = this.timeTable[firstCol];

        //period time of range
        var fullTimeDiff  = moment.duration(endTime.clone() - startTime.clone()).asMilliseconds();
        //width between start slot and end slot
        var fullWidthDiff = this.timeHeaderCoordCache.getRightPosition(lastCol) 
                            - this.timeHeaderCoordCache.getLeftPosition(firstCol);

        //period time between start time of a startSlot and start of a range
        var leftTimeDiff  = moment.duration(range.start.clone() - startTime.clone()).asMilliseconds();
        //period time between end time of a startSlot and end of range
        var rightTimeDiff = moment.duration(range.end.clone() - endOfStartTime.clone()).asMilliseconds();

        var left  = leftTimeDiff * fullWidthDiff / fullTimeDiff;

        //if the value is position the right position of the element has to be negative
        if (rightTimeDiff > 0){
            var _fullTimeDiff = moment.duration(endTime.clone() - endOfStartTime.clone()).asMilliseconds(); 
            var _fullWidthDiff = this.timeHeaderCoordCache.getRightPosition(lastCol)
                                - this.timeHeaderCoordCache.getRightPosition(firstCol);

            var right = -(rightTimeDiff * _fullWidthDiff / _fullTimeDiff);
        }
        else if (rightTimeDiff < 0) {
            var _fullTimeDiff = moment.duration(endOfStartTime.clone() - startTime.clone()).asMilliseconds(); 
            var _fullWidthDiff = this.timeHeaderCoordCache.getLeftPosition(firstCol)
                                - this.timeHeaderCoordCache.getRightPosition(firstCol);

            var right = rightTimeDiff * _fullWidthDiff / _fullTimeDiff;
        }
        else if (rightTimeDiff === 0){
            var right = 0;
        }

        return { left: left, right: right };
    },

    assignFgSegHorizontals: function (segs) {
        var i, seg;

        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            seg.el.css(this.generateFgSegHorizontalCss(seg));
        }
    },

    generateFgSegHorizontalCss: function(seg){
        var props = this.generateSegVerticalCss(seg);
        props.left = seg.left;
        props.right = seg.right;
        return props;
    }
    

});


//**************************************  ScheduleView Section ******************************//

ScheduleView = View.extend({ // make a subclass of View
    scroller: null,

    intervalMin: 60,

    axisWidth: null,
    
    initialize: function () {
        // called once when the view is instantiated, when the user switches to the view.
        // initialize member variables or do other setup tasks.
        this.grid = new ScheduleGrid(this);
        this.scroller = new FC.Scroller({
            overflowX: 'hidden',
            overflowY: 'auto'
        });
    },

    render: function () {
        this.el.addClass('fc-schedule-view').html(this.renderSkeletonHtml());
        this.renderHead();
        this.scroller.render();
        var scheduleGridWrapEl = this.scroller.el.addClass('fc-schedule-grid-container');
        var scheduleGridEl = $('<div class="fc-schedule-grid" />').appendTo(scheduleGridWrapEl);
        this.el.find('.fc-body > tr > td').append(scheduleGridWrapEl);

        this.grid.setElement(scheduleGridEl);
        this.grid.setIntervalMin(this.intervalMin);
        this.grid.renderDates();

        // the <hr> that sometimes displays under the time-grid
		this.bottomRuleEl = $('<hr class="fc-divider ' + this.widgetHeaderClass + '"/>')
            .appendTo(this.grid.el); // inject it into the time-grid

        this.noScrollRowEls = this.el.find('.fc-row:not(.fc-scroller)'); // fake rows not within the scroller
    },

    updateSize: function (isResize) {
        this.grid.updateSize(isResize);

        View.prototype.updateSize.call(this, isResize); // call the super-method
    },

    // Refreshes the horizontal dimensions of the view
    updateWidth: function () {
        // make all axis cells line up, and record the width so newly created axis cells will have it
        this.axisWidth = this.matchCellWidths(this.el.find('.fc-axis'));
    },

    setHeight: function (totalHeight, isAuto) {
        var eventLimit;
        var scrollerHeight;
        var scrollbarWidths;

        // this.scroller.clear();

        ScheduleView.uncompensateScroll(this.noScrollRowEls);

        if (!isAuto) { // should we force dimensions of the scroll container?

            scrollerHeight = this.computeScrollerHeight(totalHeight);
            this.scroller.setHeight(scrollerHeight);
            scrollbarWidths = this.scroller.getScrollbarWidths();
            
            if (scrollbarWidths.left || scrollbarWidths.right) { // using scrollbars?

                // make the all-day and header rows lines up
                ScheduleView.compensateScroll(this.noScrollRowEls, scrollbarWidths);

                // the scrollbar compensation might have changed text flow, which might affect height, so recalculate
                // and reapply the desired height to the scroller.
                scrollerHeight = this.computeScrollerHeight(totalHeight);
                this.scroller.setHeight(scrollerHeight);
            }

            // guarantees the same scrollbar widths
            this.scroller.lockOverflow(scrollbarWidths);

            // if there's any space below the slats, show the horizontal rule.
            // this won't cause any new overflow, because lockOverflow already called.
            if (this.grid.getTotalSlatHeight() < scrollerHeight) {
                this.bottomRuleEl.show();
            }
        }

        // responsible for adjusting the pixel-height of the view. if isAuto is true, the
        // view may be its natural height, and `height` becomes merely a suggestion.
    },

    renderEvents: function (events) {
        var timedEvents = [];
        var timedSegs;
        var i;

        for (i = 0; i < events.length; i++) {
            if (!events[i].allDay) {
                timedEvents.push(events[i]);
            }
        }

        // render the events in the subcomponents
        this.grid.updateTimeTable();
        timedSegs = this.grid.renderEvents(timedEvents);

        // // the all-day area is flexible and might have a lot of events, so shift the height
        this.updateHeight();

        //register popup event
        this.grid.el.find('.fc-event-container a').popup({
            onShow: function(target){
                var title = $(target).find('.fc-title').html();
                var time = $(target).find('.fc-time').data("full");
                this.html(`
                    <div class="header">${time}</div>
                    <div class="content">${title}</div>
                `);
                title = null;
                time = null;
            },
            title: ' ',//must not be empty string
            content: ' ',//must not be empty string
        });
    },

    destroyEvents: function () {
        this.unrenderEvents();
    },

    unrenderEvents: function () {
        this.grid.unrenderEvents();
    },

    renderSelection: function (range) {
        // accepts a {start,end} object made of Moments, and must render the selection
    },

    destroySelection: function () {
        // responsible for undoing everything in renderSelection
    },

    axisStyleAttr: function () {
        if (this.axisWidth !== null) {
            return 'style="width:' + this.axisWidth + 'px"';
        }
        return '';
    },

    renderSkeletonHtml: function () {
        return `
            <table>
                <thead class="fc-head">
                    <tr>
                        <td class="fc-head-container  ${this.widgetHeaderClass}"></td>
                    </tr>
                </thead>
                <tbody class="fc-body">
                    <tr>
                        <td class="${this.widgetContentClass}"></td>
                    </tr>
                </tbody>
            </table>
        `
    },

    renderHead: function () {
        this.headContainerEl =
            this.el.find('.fc-head-container')
                .html(this.renderHeadHtml());
    },

    renderHeadHtml: function () {
        return `
            <div class="fc-row">
                <table>
                    <thead>
                        ${this.renderHeadTrHtml()}
                    </thead>
                </table>
            </div>
        `;
    },

    renderHeadTrHtml: function () {
        return `
            <tr>
				${this.renderIntroHtml() + this.renderHeadDateCellsHtml()}
            </tr>
        `;
    },

    renderIntroHtml: function () {
        return `<th class="fc-axis" ${this.axisStyleAttr()}>Time</th>\n`;
    },

    renderHeadDateCellsHtml: function () {
        let m = moment({ hour: 0, minute: 0, seconds: 0 });
        let timeInterval = ScheduleView.generateTimes(m, this.intervalMin);
        let th = timeInterval.map((item, index) => {
            return `<th data-time='${index}'>${item.id}</th>`;
        });
        return th.join("\n");
    },

    

    // ******************************* START UTILITY SECTION *********************************

    computeScrollerHeight: function (totalHeight) {
        //check if content is not overflow then return height of Horizontal divider
        if (this.scroller.el.find('.fc-slats').innerHeight() <= totalHeight){
            return null;
        }
        else {
            return totalHeight -
                this.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
        }
    },

    // Given one element that resides inside another,
    // Subtracts the height of the inner element from the outer element.
    subtractInnerElHeight: function (outerEl, innerEl) {
        var both = outerEl.add(innerEl);
        var diff;

        // effin' IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked
        both.css({
            position: 'relative', // cause a reflow, which will force fresh dimension recalculation
            left: -1 // ensure reflow in case the el was already relative. negative is less likely to cause new scroll
        });
        diff = outerEl.outerHeight() - innerEl.outerHeight(); // grab the dimensions
        both.css({ position: '', left: '' }); // undo hack

        return diff;
    },

    // Given `els`, a jQuery set of <td> cells, find the cell with the largest natural width and set the widths of all the
    // cells to be that width.
    // PREREQUISITE: if you want a cell to take up width, it needs to have a single inner element w/ display:inline
    matchCellWidths: function (els) {
        var maxInnerWidth = 0;

        els.find('> *').each(function (i, innerEl) {
            var innerWidth = $(innerEl).outerWidth();
            if (innerWidth > maxInnerWidth) {
                maxInnerWidth = innerWidth;
            }
        });

        maxInnerWidth++; // sometimes not accurate of width the text needs to stay on one line. insurance

        els.width(maxInnerWidth);

        return maxInnerWidth;
    },

    // ******************************* END UTILITY SECTION *********************************

});

ScheduleGrid.intersectRanges = function (subjectRange, constraintRange){
    var subjectStart = subjectRange.start;
    var subjectEnd = subjectRange.end;
    var constraintStart = constraintRange.start;
    var constraintEnd = constraintRange.end;
    var segStart, segEnd;
    var isStart, isEnd;


    if (subjectEnd > constraintStart && subjectStart < constraintEnd) { // in bounds at all?
        if (subjectStart >= constraintStart) {
            segStart = subjectStart.clone();
            isStart = true;
        }
        else {
            segStart = constraintStart.clone();
            isStart = false;
        }

        if (subjectEnd <= constraintEnd) {
            segEnd = subjectEnd.clone();
            isEnd = true;
        }
        else {
            segEnd = constraintEnd.clone();
            isEnd = false;
        }

        return {
            start: segStart,
            end: segEnd,
            isStart: isStart,
            isEnd: isEnd
        };
    }
}

ScheduleView.compensateScroll = function(rowEls, scrollbarWidths) {
    if (scrollbarWidths.left) {
        rowEls.css({
            'border-left-width': 1,
            'margin-left': scrollbarWidths.left - 1
        });
    }
    if (scrollbarWidths.right) {
        rowEls.css({
            'border-right-width': 1,
            'margin-right': scrollbarWidths.right - 1
        });
    }
}

ScheduleView.uncompensateScroll = function (rowEls) {
    rowEls.css({
        'margin-left': '',
        'margin-right': '',
        'border-left-width': '',
        'border-right-width': ''
    });
}

ScheduleView.generateTimes = function(m, intervalMin) {
    let intervalRound = 1440 / intervalMin, items = [];
    for (let i = 0; i < intervalRound; i++) {
        items.push({
            id: m.format("HH"),
            text: m.format("HH:mm"),
            hour: parseInt(m.format("H")),
            minute: parseInt(m.format("mm")),
        });
        m.add(intervalMin, "m");
    }
    return items;
}


FC.views.scheduleView = ScheduleView; // register our class with the view system
!function(e){"function"==typeof define&&define.amd?define(["jquery","moment"],e):"object"==typeof exports?module.exports=e(require("jquery"),require("moment")):e(jQuery,moment)}(function(e,t){!function(){var e=t.defineLocale("th",{months:"มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม".split("_"),monthsShort:"ม.ค._ก.พ._มี.ค._เม.ย._พ.ค._มิ.ย._ก.ค._ส.ค._ก.ย._ต.ค._พ.ย._ธ.ค.".split("_"),monthsParseExact:!0,weekdays:"อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์".split("_"),weekdaysShort:"อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์".split("_"),weekdaysMin:"อา._จ._อ._พ._พฤ._ศ._ส.".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"YYYY/MM/DD",LL:"D MMMM YYYY",LLL:"D MMMM YYYY เวลา H:mm",LLLL:"วันddddที่ D MMMM YYYY เวลา H:mm"},meridiemParse:/ก่อนเที่ยง|หลังเที่ยง/,isPM:function(e){return"หลังเที่ยง"===e},meridiem:function(e,t,a){return e<12?"ก่อนเที่ยง":"หลังเที่ยง"},calendar:{sameDay:"[วันนี้ เวลา] LT",nextDay:"[พรุ่งนี้ เวลา] LT",nextWeek:"dddd[หน้า เวลา] LT",lastDay:"[เมื่อวานนี้ เวลา] LT",lastWeek:"[วัน]dddd[ที่แล้ว เวลา] LT",sameElse:"L"},relativeTime:{future:"อีก %s",past:"%sที่แล้ว",s:"ไม่กี่วินาที",m:"1 นาที",mm:"%d นาที",h:"1 ชั่วโมง",hh:"%d ชั่วโมง",d:"1 วัน",dd:"%d วัน",M:"1 เดือน",MM:"%d เดือน",y:"1 ปี",yy:"%d ปี"}});return e}(),e.fullCalendar.datepickerLocale("th","th",{closeText:"ปิด",prevText:"&#xAB;&#xA0;ย้อน",nextText:"ถัดไป&#xA0;&#xBB;",currentText:"วันนี้",monthNames:["มกราคม","กุมภาพันธ์","มีนาคม","เมษายน","พฤษภาคม","มิถุนายน","กรกฎาคม","สิงหาคม","กันยายน","ตุลาคม","พฤศจิกายน","ธันวาคม"],monthNamesShort:["ม.ค.","ก.พ.","มี.ค.","เม.ย.","พ.ค.","มิ.ย.","ก.ค.","ส.ค.","ก.ย.","ต.ค.","พ.ย.","ธ.ค."],dayNames:["อาทิตย์","จันทร์","อังคาร","พุธ","พฤหัสบดี","ศุกร์","เสาร์"],dayNamesShort:["อา.","จ.","อ.","พ.","พฤ.","ศ.","ส."],dayNamesMin:["อา.","จ.","อ.","พ.","พฤ.","ศ.","ส."],weekHeader:"Wk",dateFormat:"dd/mm/yy",firstDay:0,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""}),e.fullCalendar.locale("th",{buttonText:{month:"เดือน",week:"สัปดาห์",day:"วัน",list:"แผนงาน"},allDayText:"ตลอดวัน",eventLimitText:"เพิ่มเติม",noEventsMessage:"ไม่มีกิจกรรมที่จะแสดง"})});
/*
 * VC Websocket library.
 * Responsible for connect to VC websocket server and listen to incoming messages.
 * Connect to server with method connect(div, reconnectTime); and disconnect with disconnect()
 * Listen to various event with callback method
 * - onConnectionOpen
 * - onConnectionClose
 * - onMessage
 * Check capability of the browser on websocket with isSupported flag
 * Example :
 * QMLComponent {
 *   Component.onCompleted: {
 *     vcMessenger.onConnectionOpen( function() {
 *       //..... blah blah
 *     });
 *     vcMessenger.onConnectionClose( function() {
 *       //..... blah blah
 *     });
 *     vcMessenger.onMessage( function(msg) {
 *       //..... print out message with
 *       //..... console.log(msg);
 *     });
 *
 *     vcMessenger.connect(_div);
 *     //..... do something ......
 *     vcMessenger.disconnect();
 * 
 *     vcMessenger.send_local_message(msg);
 *   }
 * }
 */

var WS_RECONNECTION_TIME = 5000; // Reconnection time in millisecond
var LOCAL_MSG_BUS = "VC_MSG_BUS";

var WSMessenger = function() {
  var self = this;
  // Check websocket compatibility
  if ("WebSocket" in window) {
    self.isSupported = true;
  } else {
    self.isSupported = false;
  }

  // Add listener to local message connection
  // Use BroadcastChannel Technology to accomplish this
  // more info at
  // https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API
  // https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API
  self.localMessenger = new BroadcastChannel(LOCAL_MSG_BUS);
  self.localMessenger.onmessage = function(ev) {
    // Binding to fire listener when local message received.
    self.fireOnMessage(ev.data);
  };

  self.websocket = null;
  self.forceClose = false;
  self.onConnectionOpenHandlers = []; // observers
  self.onConnectionCloseHandlers = []; // observers
  self.onMessageHandlers = []; // observers
};


/**
* Add & Remove listeners
**/
WSMessenger.prototype.onConnectionOpen = function (fn) {
  this.onConnectionOpenHandlers.push(fn);
};

WSMessenger.prototype.removeOnConnectionOpen = function(fn) {
  this.onConnectionOpenHandlers = this.onConnectionOpenHandlers.filter(
      function(item) {
          if (item !== fn) {
              return item;
          }
      }
  );
};

WSMessenger.prototype.onConnectionClose = function(fn) {
  this.onConnectionCloseHandlers.push(fn);
};

WSMessenger.prototype.removeOnConnectionClose = function(fn) {
  this.onConnectionCloseHandlers = this.onConnectionCloseHandlers.filter(
      function(item) {
          if (item !== fn) {
              return item;
          }
      }
  );
};

WSMessenger.prototype.onMessage = function(fn) {
  this.onMessageHandlers.push(fn);
};

WSMessenger.prototype.removeOnMessage = function(fn) {
  this.onMessageHandlers = this.onMessageHandlers.filter(
      function(item) {
          if (item !== fn) {
              return item;
          }
      }
  );
};


/**
* Fire events to various handlers
**/
WSMessenger.prototype.fireOnConnectionOpen = function() {
  var self = this;
  self.onConnectionOpenHandlers.forEach(function(item) {
      try {
        item.call(self);
      }
      catch(err) {
        console.error("Error notifying websocket on connection open : " + err.message);
      }
  });
};

WSMessenger.prototype.fireOnConnectionClose = function() {
  var self = this;
  self.onConnectionCloseHandlers.forEach(function(item) {
      try{
        item.call(self);
      }
      catch(err) {
        console.error("Error notifying websocket on connection close : " + err.message);
      }
  });
};

WSMessenger.prototype.fireOnMessage = function(msg) {
  var self = this;
  self.onMessageHandlers.forEach(function(item) {
    try{
        item.call(self, msg);
      }
      catch(err) {
        console.error("Error notifying websocket on message : " + err.message + " with message : " + msg);
      }
  });
};


/**
* Connect to websocket. The IP address of server will getting from function ${window.location.host}
* div : Division of this PC ( location of this PC )
* reconnectTime : Reconnection Time in ms
**/
WSMessenger.prototype.connect = function(div) {
  var self = this; // Hold this object for using in callback methods
  var wsUrl = "ws://" + window.location.host + "/ws/" + div;
  //console.log("Trying to connect to URL : " + wsUrl);

  if( !self.isSupported ) {
    // Websocket not supported
    self.fireOnConnectionClose();
    return;
  }

  if( self.websocket != null && self.websocket.readyState === self.websocket.OPEN ) {
    // Already connected to server. Do nothing
    return
  }

  // Open websocket
  self.websocket = new WebSocket(wsUrl);

  // Bind the events to this client
  self.websocket.onopen = function() {
    self.fireOnConnectionOpen();
  }

  self.websocket.onclose = function() {
      self.fireOnConnectionClose(this);
      if( !self.forceClose ) {
        setTimeout(function(){self.connect(div)}, WS_RECONNECTION_TIME);
      }
      else {
        // Intentionally close this websocket. Do not reconnect
        self.forceClose = false;
      }
  }

  self.websocket.onmessage = function(msg) {
      self.fireOnMessage(msg.data);
  }
};

/**
* Close the websocket & broadcastChannel connection
**/
WSMessenger.prototype.disconnect = function() {
  var self = this;
  if( self.websocket != null ) {
    self.forceClose = true;
    self.websocket.close();
    self.websocket = null;
  }

  if( self.localMessenger != null ) {
    self.localMessenger.close();
    self.localMessenger = null;
  }
}


/**
* Disconnect and clear all resources ( all handlers included ) of this object.
**/
WSMessenger.prototype.dispose = function() {
  var self = this;
  self.disconnect();
  self.onConnectionOpenHandlers = [];
  self.onConnectionCloseHandlers = [];
  self.onMessageHandlers = [];
}

/**
* Function to send local message.
* Use for broadcast message between browser window in same machine
* e.g. two screen in doctor examination room.
**/
WSMessenger.prototype.send_local_message = function(message) {
  this.localMessenger.postMessage(message);
}

var vcMessenger =  new WSMessenger();
/*!
 * Chart.js
 * http://chartjs.org/
 * Version: 2.5.0
 *
 * Copyright 2017 Nick Downie
 * Released under the MIT license
 * https://github.com/chartjs/Chart.js/blob/master/LICENSE.md
 */
!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var e;e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,e.Chart=t()}}(function(){return function t(e,n,i){function a(r,l){if(!n[r]){if(!e[r]){var s="function"==typeof require&&require;if(!l&&s)return s(r,!0);if(o)return o(r,!0);var u=new Error("Cannot find module '"+r+"'");throw u.code="MODULE_NOT_FOUND",u}var d=n[r]={exports:{}};e[r][0].call(d.exports,function(t){var n=e[r][1][t];return a(n?n:t)},d,d.exports,t,e,n,i)}return n[r].exports}for(var o="function"==typeof require&&require,r=0;r<i.length;r++)a(i[r]);return a}({1:[function(t,e,n){},{}],2:[function(t,e,n){function i(t){if(t){var e=/^#([a-fA-F0-9]{3})$/,n=/^#([a-fA-F0-9]{6})$/,i=/^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/,a=/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/,o=/(\w+)/,r=[0,0,0],l=1,s=t.match(e);if(s){s=s[1];for(var u=0;u<r.length;u++)r[u]=parseInt(s[u]+s[u],16)}else if(s=t.match(n)){s=s[1];for(var u=0;u<r.length;u++)r[u]=parseInt(s.slice(2*u,2*u+2),16)}else if(s=t.match(i)){for(var u=0;u<r.length;u++)r[u]=parseInt(s[u+1]);l=parseFloat(s[4])}else if(s=t.match(a)){for(var u=0;u<r.length;u++)r[u]=Math.round(2.55*parseFloat(s[u+1]));l=parseFloat(s[4])}else if(s=t.match(o)){if("transparent"==s[1])return[0,0,0,0];if(r=y[s[1]],!r)return}for(var u=0;u<r.length;u++)r[u]=b(r[u],0,255);return l=l||0==l?b(l,0,1):1,r[3]=l,r}}function a(t){if(t){var e=/^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/,n=t.match(e);if(n){var i=parseFloat(n[4]),a=b(parseInt(n[1]),0,360),o=b(parseFloat(n[2]),0,100),r=b(parseFloat(n[3]),0,100),l=b(isNaN(i)?1:i,0,1);return[a,o,r,l]}}}function o(t){if(t){var e=/^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/,n=t.match(e);if(n){var i=parseFloat(n[4]),a=b(parseInt(n[1]),0,360),o=b(parseFloat(n[2]),0,100),r=b(parseFloat(n[3]),0,100),l=b(isNaN(i)?1:i,0,1);return[a,o,r,l]}}}function r(t){var e=i(t);return e&&e.slice(0,3)}function l(t){var e=a(t);return e&&e.slice(0,3)}function s(t){var e=i(t);return e?e[3]:(e=a(t))?e[3]:(e=o(t))?e[3]:void 0}function u(t){return"#"+x(t[0])+x(t[1])+x(t[2])}function d(t,e){return e<1||t[3]&&t[3]<1?c(t,e):"rgb("+t[0]+", "+t[1]+", "+t[2]+")"}function c(t,e){return void 0===e&&(e=void 0!==t[3]?t[3]:1),"rgba("+t[0]+", "+t[1]+", "+t[2]+", "+e+")"}function h(t,e){if(e<1||t[3]&&t[3]<1)return f(t,e);var n=Math.round(t[0]/255*100),i=Math.round(t[1]/255*100),a=Math.round(t[2]/255*100);return"rgb("+n+"%, "+i+"%, "+a+"%)"}function f(t,e){var n=Math.round(t[0]/255*100),i=Math.round(t[1]/255*100),a=Math.round(t[2]/255*100);return"rgba("+n+"%, "+i+"%, "+a+"%, "+(e||t[3]||1)+")"}function g(t,e){return e<1||t[3]&&t[3]<1?p(t,e):"hsl("+t[0]+", "+t[1]+"%, "+t[2]+"%)"}function p(t,e){return void 0===e&&(e=void 0!==t[3]?t[3]:1),"hsla("+t[0]+", "+t[1]+"%, "+t[2]+"%, "+e+")"}function m(t,e){return void 0===e&&(e=void 0!==t[3]?t[3]:1),"hwb("+t[0]+", "+t[1]+"%, "+t[2]+"%"+(void 0!==e&&1!==e?", "+e:"")+")"}function v(t){return k[t.slice(0,3)]}function b(t,e,n){return Math.min(Math.max(e,t),n)}function x(t){var e=t.toString(16).toUpperCase();return e.length<2?"0"+e:e}var y=t(6);e.exports={getRgba:i,getHsla:a,getRgb:r,getHsl:l,getHwb:o,getAlpha:s,hexString:u,rgbString:d,rgbaString:c,percentString:h,percentaString:f,hslString:g,hslaString:p,hwbString:m,keyword:v};var k={};for(var w in y)k[y[w]]=w},{6:6}],3:[function(t,e,n){var i=t(5),a=t(2),o=function(t){if(t instanceof o)return t;if(!(this instanceof o))return new o(t);this.valid=!1,this.values={rgb:[0,0,0],hsl:[0,0,0],hsv:[0,0,0],hwb:[0,0,0],cmyk:[0,0,0,0],alpha:1};var e;"string"==typeof t?(e=a.getRgba(t),e?this.setValues("rgb",e):(e=a.getHsla(t))?this.setValues("hsl",e):(e=a.getHwb(t))&&this.setValues("hwb",e)):"object"==typeof t&&(e=t,void 0!==e.r||void 0!==e.red?this.setValues("rgb",e):void 0!==e.l||void 0!==e.lightness?this.setValues("hsl",e):void 0!==e.v||void 0!==e.value?this.setValues("hsv",e):void 0!==e.w||void 0!==e.whiteness?this.setValues("hwb",e):void 0===e.c&&void 0===e.cyan||this.setValues("cmyk",e))};o.prototype={isValid:function(){return this.valid},rgb:function(){return this.setSpace("rgb",arguments)},hsl:function(){return this.setSpace("hsl",arguments)},hsv:function(){return this.setSpace("hsv",arguments)},hwb:function(){return this.setSpace("hwb",arguments)},cmyk:function(){return this.setSpace("cmyk",arguments)},rgbArray:function(){return this.values.rgb},hslArray:function(){return this.values.hsl},hsvArray:function(){return this.values.hsv},hwbArray:function(){var t=this.values;return 1!==t.alpha?t.hwb.concat([t.alpha]):t.hwb},cmykArray:function(){return this.values.cmyk},rgbaArray:function(){var t=this.values;return t.rgb.concat([t.alpha])},hslaArray:function(){var t=this.values;return t.hsl.concat([t.alpha])},alpha:function(t){return void 0===t?this.values.alpha:(this.setValues("alpha",t),this)},red:function(t){return this.setChannel("rgb",0,t)},green:function(t){return this.setChannel("rgb",1,t)},blue:function(t){return this.setChannel("rgb",2,t)},hue:function(t){return t&&(t%=360,t=t<0?360+t:t),this.setChannel("hsl",0,t)},saturation:function(t){return this.setChannel("hsl",1,t)},lightness:function(t){return this.setChannel("hsl",2,t)},saturationv:function(t){return this.setChannel("hsv",1,t)},whiteness:function(t){return this.setChannel("hwb",1,t)},blackness:function(t){return this.setChannel("hwb",2,t)},value:function(t){return this.setChannel("hsv",2,t)},cyan:function(t){return this.setChannel("cmyk",0,t)},magenta:function(t){return this.setChannel("cmyk",1,t)},yellow:function(t){return this.setChannel("cmyk",2,t)},black:function(t){return this.setChannel("cmyk",3,t)},hexString:function(){return a.hexString(this.values.rgb)},rgbString:function(){return a.rgbString(this.values.rgb,this.values.alpha)},rgbaString:function(){return a.rgbaString(this.values.rgb,this.values.alpha)},percentString:function(){return a.percentString(this.values.rgb,this.values.alpha)},hslString:function(){return a.hslString(this.values.hsl,this.values.alpha)},hslaString:function(){return a.hslaString(this.values.hsl,this.values.alpha)},hwbString:function(){return a.hwbString(this.values.hwb,this.values.alpha)},keyword:function(){return a.keyword(this.values.rgb,this.values.alpha)},rgbNumber:function(){var t=this.values.rgb;return t[0]<<16|t[1]<<8|t[2]},luminosity:function(){for(var t=this.values.rgb,e=[],n=0;n<t.length;n++){var i=t[n]/255;e[n]=i<=.03928?i/12.92:Math.pow((i+.055)/1.055,2.4)}return.2126*e[0]+.7152*e[1]+.0722*e[2]},contrast:function(t){var e=this.luminosity(),n=t.luminosity();return e>n?(e+.05)/(n+.05):(n+.05)/(e+.05)},level:function(t){var e=this.contrast(t);return e>=7.1?"AAA":e>=4.5?"AA":""},dark:function(){var t=this.values.rgb,e=(299*t[0]+587*t[1]+114*t[2])/1e3;return e<128},light:function(){return!this.dark()},negate:function(){for(var t=[],e=0;e<3;e++)t[e]=255-this.values.rgb[e];return this.setValues("rgb",t),this},lighten:function(t){var e=this.values.hsl;return e[2]+=e[2]*t,this.setValues("hsl",e),this},darken:function(t){var e=this.values.hsl;return e[2]-=e[2]*t,this.setValues("hsl",e),this},saturate:function(t){var e=this.values.hsl;return e[1]+=e[1]*t,this.setValues("hsl",e),this},desaturate:function(t){var e=this.values.hsl;return e[1]-=e[1]*t,this.setValues("hsl",e),this},whiten:function(t){var e=this.values.hwb;return e[1]+=e[1]*t,this.setValues("hwb",e),this},blacken:function(t){var e=this.values.hwb;return e[2]+=e[2]*t,this.setValues("hwb",e),this},greyscale:function(){var t=this.values.rgb,e=.3*t[0]+.59*t[1]+.11*t[2];return this.setValues("rgb",[e,e,e]),this},clearer:function(t){var e=this.values.alpha;return this.setValues("alpha",e-e*t),this},opaquer:function(t){var e=this.values.alpha;return this.setValues("alpha",e+e*t),this},rotate:function(t){var e=this.values.hsl,n=(e[0]+t)%360;return e[0]=n<0?360+n:n,this.setValues("hsl",e),this},mix:function(t,e){var n=this,i=t,a=void 0===e?.5:e,o=2*a-1,r=n.alpha()-i.alpha(),l=((o*r===-1?o:(o+r)/(1+o*r))+1)/2,s=1-l;return this.rgb(l*n.red()+s*i.red(),l*n.green()+s*i.green(),l*n.blue()+s*i.blue()).alpha(n.alpha()*a+i.alpha()*(1-a))},toJSON:function(){return this.rgb()},clone:function(){var t,e,n=new o,i=this.values,a=n.values;for(var r in i)i.hasOwnProperty(r)&&(t=i[r],e={}.toString.call(t),"[object Array]"===e?a[r]=t.slice(0):"[object Number]"===e?a[r]=t:console.error("unexpected color value:",t));return n}},o.prototype.spaces={rgb:["red","green","blue"],hsl:["hue","saturation","lightness"],hsv:["hue","saturation","value"],hwb:["hue","whiteness","blackness"],cmyk:["cyan","magenta","yellow","black"]},o.prototype.maxes={rgb:[255,255,255],hsl:[360,100,100],hsv:[360,100,100],hwb:[360,100,100],cmyk:[100,100,100,100]},o.prototype.getValues=function(t){for(var e=this.values,n={},i=0;i<t.length;i++)n[t.charAt(i)]=e[t][i];return 1!==e.alpha&&(n.a=e.alpha),n},o.prototype.setValues=function(t,e){var n,a=this.values,o=this.spaces,r=this.maxes,l=1;if(this.valid=!0,"alpha"===t)l=e;else if(e.length)a[t]=e.slice(0,t.length),l=e[t.length];else if(void 0!==e[t.charAt(0)]){for(n=0;n<t.length;n++)a[t][n]=e[t.charAt(n)];l=e.a}else if(void 0!==e[o[t][0]]){var s=o[t];for(n=0;n<t.length;n++)a[t][n]=e[s[n]];l=e.alpha}if(a.alpha=Math.max(0,Math.min(1,void 0===l?a.alpha:l)),"alpha"===t)return!1;var u;for(n=0;n<t.length;n++)u=Math.max(0,Math.min(r[t][n],a[t][n])),a[t][n]=Math.round(u);for(var d in o)d!==t&&(a[d]=i[t][d](a[t]));return!0},o.prototype.setSpace=function(t,e){var n=e[0];return void 0===n?this.getValues(t):("number"==typeof n&&(n=Array.prototype.slice.call(e)),this.setValues(t,n),this)},o.prototype.setChannel=function(t,e,n){var i=this.values[t];return void 0===n?i[e]:n===i[e]?this:(i[e]=n,this.setValues(t,i),this)},"undefined"!=typeof window&&(window.Color=o),e.exports=o},{2:2,5:5}],4:[function(t,e,n){function i(t){var e,n,i,a=t[0]/255,o=t[1]/255,r=t[2]/255,l=Math.min(a,o,r),s=Math.max(a,o,r),u=s-l;return s==l?e=0:a==s?e=(o-r)/u:o==s?e=2+(r-a)/u:r==s&&(e=4+(a-o)/u),e=Math.min(60*e,360),e<0&&(e+=360),i=(l+s)/2,n=s==l?0:i<=.5?u/(s+l):u/(2-s-l),[e,100*n,100*i]}function a(t){var e,n,i,a=t[0],o=t[1],r=t[2],l=Math.min(a,o,r),s=Math.max(a,o,r),u=s-l;return n=0==s?0:u/s*1e3/10,s==l?e=0:a==s?e=(o-r)/u:o==s?e=2+(r-a)/u:r==s&&(e=4+(a-o)/u),e=Math.min(60*e,360),e<0&&(e+=360),i=s/255*1e3/10,[e,n,i]}function o(t){var e=t[0],n=t[1],a=t[2],o=i(t)[0],r=1/255*Math.min(e,Math.min(n,a)),a=1-1/255*Math.max(e,Math.max(n,a));return[o,100*r,100*a]}function l(t){var e,n,i,a,o=t[0]/255,r=t[1]/255,l=t[2]/255;return a=Math.min(1-o,1-r,1-l),e=(1-o-a)/(1-a)||0,n=(1-r-a)/(1-a)||0,i=(1-l-a)/(1-a)||0,[100*e,100*n,100*i,100*a]}function s(t){return Z[JSON.stringify(t)]}function u(t){var e=t[0]/255,n=t[1]/255,i=t[2]/255;e=e>.04045?Math.pow((e+.055)/1.055,2.4):e/12.92,n=n>.04045?Math.pow((n+.055)/1.055,2.4):n/12.92,i=i>.04045?Math.pow((i+.055)/1.055,2.4):i/12.92;var a=.4124*e+.3576*n+.1805*i,o=.2126*e+.7152*n+.0722*i,r=.0193*e+.1192*n+.9505*i;return[100*a,100*o,100*r]}function d(t){var e,n,i,a=u(t),o=a[0],r=a[1],l=a[2];return o/=95.047,r/=100,l/=108.883,o=o>.008856?Math.pow(o,1/3):7.787*o+16/116,r=r>.008856?Math.pow(r,1/3):7.787*r+16/116,l=l>.008856?Math.pow(l,1/3):7.787*l+16/116,e=116*r-16,n=500*(o-r),i=200*(r-l),[e,n,i]}function c(t){return B(d(t))}function h(t){var e,n,i,a,o,r=t[0]/360,l=t[1]/100,s=t[2]/100;if(0==l)return o=255*s,[o,o,o];n=s<.5?s*(1+l):s+l-s*l,e=2*s-n,a=[0,0,0];for(var u=0;u<3;u++)i=r+1/3*-(u-1),i<0&&i++,i>1&&i--,o=6*i<1?e+6*(n-e)*i:2*i<1?n:3*i<2?e+(n-e)*(2/3-i)*6:e,a[u]=255*o;return a}function f(t){var e,n,i=t[0],a=t[1]/100,o=t[2]/100;return 0===o?[0,0,0]:(o*=2,a*=o<=1?o:2-o,n=(o+a)/2,e=2*a/(o+a),[i,100*e,100*n])}function p(t){return o(h(t))}function m(t){return l(h(t))}function v(t){return s(h(t))}function x(t){var e=t[0]/60,n=t[1]/100,i=t[2]/100,a=Math.floor(e)%6,o=e-Math.floor(e),r=255*i*(1-n),l=255*i*(1-n*o),s=255*i*(1-n*(1-o)),i=255*i;switch(a){case 0:return[i,s,r];case 1:return[l,i,r];case 2:return[r,i,s];case 3:return[r,l,i];case 4:return[s,r,i];case 5:return[i,r,l]}}function y(t){var e,n,i=t[0],a=t[1]/100,o=t[2]/100;return n=(2-a)*o,e=a*o,e/=n<=1?n:2-n,e=e||0,n/=2,[i,100*e,100*n]}function k(t){return o(x(t))}function w(t){return l(x(t))}function M(t){return s(x(t))}function S(t){var e,n,i,a,o=t[0]/360,l=t[1]/100,s=t[2]/100,u=l+s;switch(u>1&&(l/=u,s/=u),e=Math.floor(6*o),n=1-s,i=6*o-e,0!=(1&e)&&(i=1-i),a=l+i*(n-l),e){default:case 6:case 0:r=n,g=a,b=l;break;case 1:r=a,g=n,b=l;break;case 2:r=l,g=n,b=a;break;case 3:r=l,g=a,b=n;break;case 4:r=a,g=l,b=n;break;case 5:r=n,g=l,b=a}return[255*r,255*g,255*b]}function C(t){return i(S(t))}function D(t){return a(S(t))}function I(t){return l(S(t))}function A(t){return s(S(t))}function P(t){var e,n,i,a=t[0]/100,o=t[1]/100,r=t[2]/100,l=t[3]/100;return e=1-Math.min(1,a*(1-l)+l),n=1-Math.min(1,o*(1-l)+l),i=1-Math.min(1,r*(1-l)+l),[255*e,255*n,255*i]}function _(t){return i(P(t))}function F(t){return a(P(t))}function T(t){return o(P(t))}function R(t){return s(P(t))}function L(t){var e,n,i,a=t[0]/100,o=t[1]/100,r=t[2]/100;return e=3.2406*a+o*-1.5372+r*-.4986,n=a*-.9689+1.8758*o+.0415*r,i=.0557*a+o*-.204+1.057*r,e=e>.0031308?1.055*Math.pow(e,1/2.4)-.055:e*=12.92,n=n>.0031308?1.055*Math.pow(n,1/2.4)-.055:n*=12.92,i=i>.0031308?1.055*Math.pow(i,1/2.4)-.055:i*=12.92,e=Math.min(Math.max(0,e),1),n=Math.min(Math.max(0,n),1),i=Math.min(Math.max(0,i),1),[255*e,255*n,255*i]}function V(t){var e,n,i,a=t[0],o=t[1],r=t[2];return a/=95.047,o/=100,r/=108.883,a=a>.008856?Math.pow(a,1/3):7.787*a+16/116,o=o>.008856?Math.pow(o,1/3):7.787*o+16/116,r=r>.008856?Math.pow(r,1/3):7.787*r+16/116,e=116*o-16,n=500*(a-o),i=200*(o-r),[e,n,i]}function O(t){return B(V(t))}function z(t){var e,n,i,a,o=t[0],r=t[1],l=t[2];return o<=8?(n=100*o/903.3,a=7.787*(n/100)+16/116):(n=100*Math.pow((o+16)/116,3),a=Math.pow(n/100,1/3)),e=e/95.047<=.008856?e=95.047*(r/500+a-16/116)/7.787:95.047*Math.pow(r/500+a,3),i=i/108.883<=.008859?i=108.883*(a-l/200-16/116)/7.787:108.883*Math.pow(a-l/200,3),[e,n,i]}function B(t){var e,n,i,a=t[0],o=t[1],r=t[2];return e=Math.atan2(r,o),n=360*e/2/Math.PI,n<0&&(n+=360),i=Math.sqrt(o*o+r*r),[a,i,n]}function W(t){return L(z(t))}function N(t){var e,n,i,a=t[0],o=t[1],r=t[2];return i=r/360*2*Math.PI,e=o*Math.cos(i),n=o*Math.sin(i),[a,e,n]}function E(t){return z(N(t))}function H(t){return W(N(t))}function q(t){return J[t]}function j(t){return i(q(t))}function Y(t){return a(q(t))}function U(t){return o(q(t))}function X(t){return l(q(t))}function K(t){return d(q(t))}function G(t){return u(q(t))}e.exports={rgb2hsl:i,rgb2hsv:a,rgb2hwb:o,rgb2cmyk:l,rgb2keyword:s,rgb2xyz:u,rgb2lab:d,rgb2lch:c,hsl2rgb:h,hsl2hsv:f,hsl2hwb:p,hsl2cmyk:m,hsl2keyword:v,hsv2rgb:x,hsv2hsl:y,hsv2hwb:k,hsv2cmyk:w,hsv2keyword:M,hwb2rgb:S,hwb2hsl:C,hwb2hsv:D,hwb2cmyk:I,hwb2keyword:A,cmyk2rgb:P,cmyk2hsl:_,cmyk2hsv:F,cmyk2hwb:T,cmyk2keyword:R,keyword2rgb:q,keyword2hsl:j,keyword2hsv:Y,keyword2hwb:U,keyword2cmyk:X,keyword2lab:K,keyword2xyz:G,xyz2rgb:L,xyz2lab:V,xyz2lch:O,lab2xyz:z,lab2rgb:W,lab2lch:B,lch2lab:N,lch2xyz:E,lch2rgb:H};var J={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},Z={};for(var Q in J)Z[JSON.stringify(J[Q])]=Q},{}],5:[function(t,e,n){var i=t(4),a=function(){return new u};for(var o in i){a[o+"Raw"]=function(t){return function(e){return"number"==typeof e&&(e=Array.prototype.slice.call(arguments)),i[t](e)}}(o);var r=/(\w+)2(\w+)/.exec(o),l=r[1],s=r[2];a[l]=a[l]||{},a[l][s]=a[o]=function(t){return function(e){"number"==typeof e&&(e=Array.prototype.slice.call(arguments));var n=i[t](e);if("string"==typeof n||void 0===n)return n;for(var a=0;a<n.length;a++)n[a]=Math.round(n[a]);return n}}(o)}var u=function(){this.convs={}};u.prototype.routeSpace=function(t,e){var n=e[0];return void 0===n?this.getValues(t):("number"==typeof n&&(n=Array.prototype.slice.call(e)),this.setValues(t,n))},u.prototype.setValues=function(t,e){return this.space=t,this.convs={},this.convs[t]=e,this},u.prototype.getValues=function(t){var e=this.convs[t];if(!e){var n=this.space,i=this.convs[n];e=a[n][t](i),this.convs[t]=e}return e},["rgb","hsl","hsv","cmyk","keyword"].forEach(function(t){u.prototype[t]=function(e){return this.routeSpace(t,arguments)}}),e.exports=a},{4:4}],6:[function(t,e,n){e.exports={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]}},{}],7:[function(t,e,n){var i=t(28)();t(26)(i),t(40)(i),t(22)(i),t(25)(i),t(30)(i),t(21)(i),t(23)(i),t(24)(i),t(29)(i),t(32)(i),t(33)(i),t(31)(i),t(27)(i),t(34)(i),t(35)(i),t(36)(i),t(37)(i),t(38)(i),t(46)(i),t(44)(i),t(45)(i),t(47)(i),t(48)(i),t(49)(i),t(15)(i),t(16)(i),t(17)(i),t(18)(i),t(19)(i),t(20)(i),t(8)(i),t(9)(i),t(10)(i),t(11)(i),t(12)(i),t(13)(i),t(14)(i);var a=[];a.push(t(41)(i),t(42)(i),t(43)(i)),i.plugins.register(a),e.exports=i,"undefined"!=typeof window&&(window.Chart=i)},{10:10,11:11,12:12,13:13,14:14,15:15,16:16,17:17,18:18,19:19,20:20,21:21,22:22,23:23,24:24,25:25,26:26,27:27,28:28,29:29,30:30,31:31,32:32,33:33,34:34,35:35,36:36,37:37,38:38,40:40,41:41,42:42,43:43,44:44,45:45,46:46,47:47,48:48,49:49,8:8,9:9}],8:[function(t,e,n){"use strict";e.exports=function(t){t.Bar=function(e,n){return n.type="bar",new t(e,n)}}},{}],9:[function(t,e,n){"use strict";e.exports=function(t){t.Bubble=function(e,n){return n.type="bubble",new t(e,n)}}},{}],10:[function(t,e,n){"use strict";e.exports=function(t){t.Doughnut=function(e,n){return n.type="doughnut",new t(e,n)}}},{}],11:[function(t,e,n){"use strict";e.exports=function(t){t.Line=function(e,n){return n.type="line",new t(e,n)}}},{}],12:[function(t,e,n){"use strict";e.exports=function(t){t.PolarArea=function(e,n){return n.type="polarArea",new t(e,n)}}},{}],13:[function(t,e,n){"use strict";e.exports=function(t){t.Radar=function(e,n){return n.type="radar",new t(e,n)}}},{}],14:[function(t,e,n){"use strict";e.exports=function(t){var e={hover:{mode:"single"},scales:{xAxes:[{type:"linear",position:"bottom",id:"x-axis-1"}],yAxes:[{type:"linear",position:"left",id:"y-axis-1"}]},tooltips:{callbacks:{title:function(){return""},label:function(t){return"("+t.xLabel+", "+t.yLabel+")"}}}};t.defaults.scatter=e,t.controllers.scatter=t.controllers.line,t.Scatter=function(e,n){return n.type="scatter",new t(e,n)}}},{}],15:[function(t,e,n){"use strict";e.exports=function(t){var e=t.helpers;t.defaults.bar={hover:{mode:"label"},scales:{xAxes:[{type:"category",categoryPercentage:.8,barPercentage:.9,gridLines:{offsetGridLines:!0}}],yAxes:[{type:"linear"}]}},t.controllers.bar=t.DatasetController.extend({dataElementType:t.elements.Rectangle,initialize:function(){var e,n=this;t.DatasetController.prototype.initialize.apply(n,arguments),e=n.getMeta(),e.stack=n.getDataset().stack,e.bar=!0},update:function(t){var e,n,i=this,a=i.getMeta().data;for(i._ruler=i.getRuler(),e=0,n=a.length;e<n;++e)i.updateElement(a[e],e,t)},updateElement:function(t,n,i){var a=this,o=a.chart,r=a.getMeta(),l=a.getDataset(),s=t.custom||{},u=o.options.elements.rectangle;t._xScale=a.getScaleForId(r.xAxisID),t._yScale=a.getScaleForId(r.yAxisID),t._datasetIndex=a.index,t._index=n,t._model={datasetLabel:l.label,label:o.data.labels[n],borderSkipped:s.borderSkipped?s.borderSkipped:u.borderSkipped,backgroundColor:s.backgroundColor?s.backgroundColor:e.getValueAtIndexOrDefault(l.backgroundColor,n,u.backgroundColor),borderColor:s.borderColor?s.borderColor:e.getValueAtIndexOrDefault(l.borderColor,n,u.borderColor),borderWidth:s.borderWidth?s.borderWidth:e.getValueAtIndexOrDefault(l.borderWidth,n,u.borderWidth)},a.updateElementGeometry(t,n,i),t.pivot()},updateElementGeometry:function(t,e,n){var i=this,a=t._model,o=i.getValueScale(),r=o.getBasePixel(),l=o.isHorizontal(),s=i._ruler||i.getRuler(),u=i.calculateBarValuePixels(i.index,e),d=i.calculateBarIndexPixels(i.index,e,s);a.horizontal=l,a.base=n?r:u.base,a.x=l?n?r:u.head:d.center,a.y=l?d.center:n?r:u.head,a.height=l?d.size:void 0,a.width=l?void 0:d.size},getValueScaleId:function(){return this.getMeta().yAxisID},getIndexScaleId:function(){return this.getMeta().xAxisID},getValueScale:function(){return this.getScaleForId(this.getValueScaleId())},getIndexScale:function(){return this.getScaleForId(this.getIndexScaleId())},getStackCount:function(t){var e,n,i=this,a=i.chart,o=i.getIndexScale(),r=o.options.stacked,l=void 0===t?a.data.datasets.length:t+1,s=[];for(e=0;e<l;++e)n=a.getDatasetMeta(e),n.bar&&a.isDatasetVisible(e)&&(r===!1||r===!0&&s.indexOf(n.stack)===-1||void 0===r&&(void 0===n.stack||s.indexOf(n.stack)===-1))&&s.push(n.stack);return s.length},getStackIndex:function(t){return this.getStackCount(t)-1},getRuler:function(){var t=this,n=t.getIndexScale(),i=n.options,a=t.getStackCount(),o=n.isHorizontal()?n.width:n.height,r=o/n.ticks.length,l=r*i.categoryPercentage,s=l/a,u=s*i.barPercentage;return u=Math.min(e.getValueOrDefault(i.barThickness,u),e.getValueOrDefault(i.maxBarThickness,1/0)),{stackCount:a,tickSize:r,categorySize:l,categorySpacing:r-l,fullBarSize:s,barSize:u,barSpacing:s-u,scale:n}},calculateBarValuePixels:function(t,e){var n,i,a,o,r,l,s=this,u=s.chart,d=s.getMeta(),c=s.getValueScale(),h=u.data.datasets,f=h[t].minData,g=Number(h[t].data[e]),p=c.options.stacked,m=d.stack,v=0;if(p||void 0===p&&void 0!==m)for(n=0;n<t;++n)i=u.getDatasetMeta(n),i.bar&&i.stack===m&&i.controller.getValueScaleId()===c.id&&u.isDatasetVisible(n)&&(a=Number(h[n].data[e]),(g<0&&a<0||g>=0&&a>0)&&(v+=a));return o=void 0!=f&&e in f?c.getPixelForValue(f[e]):c.getPixelForValue(v),r=c.getPixelForValue(v+g),l=(r-o)/2,{size:l,base:o,head:r,center:r+l/2}},calculateBarIndexPixels:function(t,e,n){var i=this,a=n.scale,o=i.chart.isCombo,r=i.getStackIndex(t),l=a.getPixelForValue(null,e,t,o),s=n.barSize;return l-=o?n.tickSize/2:0,l+=n.fullBarSize*r,l+=n.categorySpacing/2,l+=n.barSpacing/2,{size:s,base:l,head:l+s,center:l+s/2}},draw:function(){var t,n=this,i=n.chart,a=n.getMeta().data,o=n.getDataset(),r=a.length,l=0;for(e.canvas.clipArea(i.ctx,i.chartArea);l<r;++l)t=o.data[l],null===t||void 0===t||isNaN(t)||a[l].draw();e.canvas.unclipArea(i.ctx)},setHoverStyle:function(t){var n=this.chart.data.datasets[t._datasetIndex],i=t._index,a=t.custom||{},o=t._model;o.backgroundColor=a.hoverBackgroundColor?a.hoverBackgroundColor:e.getValueAtIndexOrDefault(n.hoverBackgroundColor,i,e.getHoverColor(o.backgroundColor)),o.borderColor=a.hoverBorderColor?a.hoverBorderColor:e.getValueAtIndexOrDefault(n.hoverBorderColor,i,e.getHoverColor(o.borderColor)),o.borderWidth=a.hoverBorderWidth?a.hoverBorderWidth:e.getValueAtIndexOrDefault(n.hoverBorderWidth,i,o.borderWidth)},removeHoverStyle:function(t){var n=this.chart.data.datasets[t._datasetIndex],i=t._index,a=t.custom||{},o=t._model,r=this.chart.options.elements.rectangle;o.backgroundColor=a.backgroundColor?a.backgroundColor:e.getValueAtIndexOrDefault(n.backgroundColor,i,r.backgroundColor),o.borderColor=a.borderColor?a.borderColor:e.getValueAtIndexOrDefault(n.borderColor,i,r.borderColor),o.borderWidth=a.borderWidth?a.borderWidth:e.getValueAtIndexOrDefault(n.borderWidth,i,r.borderWidth)}}),t.defaults.horizontalBar={hover:{mode:"label"},scales:{xAxes:[{type:"linear",position:"bottom"}],yAxes:[{position:"left",type:"category",categoryPercentage:.8,barPercentage:.9,gridLines:{offsetGridLines:!0}}]},elements:{rectangle:{borderSkipped:"left"}},tooltips:{callbacks:{title:function(t,e){var n="";return t.length>0&&(t[0].yLabel?n=t[0].yLabel:e.labels.length>0&&t[0].index<e.labels.length&&(n=e.labels[t[0].index])),n},label:function(t,e){var n=e.datasets[t.datasetIndex].label||"";return n+": "+t.xLabel}}}},t.controllers.horizontalBar=t.controllers.bar.extend({getValueScaleId:function(){return this.getMeta().xAxisID},getIndexScaleId:function(){return this.getMeta().yAxisID}})}},{}],16:[function(t,e,n){"use strict";e.exports=function(t){var e=t.helpers;t.defaults.bubble={hover:{mode:"single"},scales:{xAxes:[{type:"linear",position:"bottom",id:"x-axis-0"}],yAxes:[{type:"linear",position:"left",id:"y-axis-0"}]},tooltips:{callbacks:{title:function(){return""},label:function(t,e){var n=e.datasets[t.datasetIndex].label||"",i=e.datasets[t.datasetIndex].data[t.index];return n+": ("+t.xLabel+", "+t.yLabel+", "+i.r+")"}}}},t.controllers.bubble=t.DatasetController.extend({dataElementType:t.elements.Point,update:function(t){var n=this,i=n.getMeta(),a=i.data;e.each(a,function(e,i){n.updateElement(e,i,t)})},updateElement:function(n,i,a){var o=this,r=o.getMeta(),l=o.getScaleForId(r.xAxisID),s=o.getScaleForId(r.yAxisID),u=n.custom||{},d=o.getDataset(),c=d.data[i],h=o.chart.options.elements.point,f=o.index;e.extend(n,{_xScale:l,_yScale:s,_datasetIndex:f,_index:i,_model:{x:a?l.getPixelForDecimal(.5):l.getPixelForValue("object"==typeof c?c:NaN,i,f,o.chart.isCombo),y:a?s.getBasePixel():s.getPixelForValue(c,i,f),radius:a?0:u.radius?u.radius:o.getRadius(c),hitRadius:u.hitRadius?u.hitRadius:e.getValueAtIndexOrDefault(d.hitRadius,i,h.hitRadius)}}),t.DatasetController.prototype.removeHoverStyle.call(o,n,h);var g=n._model;g.skip=u.skip?u.skip:isNaN(g.x)||isNaN(g.y),n.pivot()},getRadius:function(t){return t.r||this.chart.options.elements.point.radius},setHoverStyle:function(n){var i=this;t.DatasetController.prototype.setHoverStyle.call(i,n);
var a=i.chart.data.datasets[n._datasetIndex],o=n._index,r=n.custom||{},l=n._model;l.radius=r.hoverRadius?r.hoverRadius:e.getValueAtIndexOrDefault(a.hoverRadius,o,i.chart.options.elements.point.hoverRadius)+i.getRadius(a.data[o])},removeHoverStyle:function(e){var n=this;t.DatasetController.prototype.removeHoverStyle.call(n,e,n.chart.options.elements.point);var i=n.chart.data.datasets[e._datasetIndex].data[e._index],a=e.custom||{},o=e._model;o.radius=a.radius?a.radius:n.getRadius(i)}})}},{}],17:[function(t,e,n){"use strict";e.exports=function(t){var e=t.helpers,n=t.defaults;n.doughnut={animation:{animateRotate:!0,animateScale:!1},aspectRatio:1,hover:{mode:"single"},legendCallback:function(t){var e=[];e.push('<ul class="'+t.id+'-legend">');var n=t.data,i=n.datasets,a=n.labels;if(i.length)for(var o=0;o<i[0].data.length;++o)e.push('<li><span style="background-color:'+i[0].backgroundColor[o]+'"></span>'),a[o]&&e.push(a[o]),e.push("</li>");return e.push("</ul>"),e.join("")},legend:{labels:{generateLabels:function(t){var n=t.data;return n.labels.length&&n.datasets.length?n.labels.map(function(i,a){var o=t.getDatasetMeta(0),r=n.datasets[0],l=o.data[a],s=l&&l.custom||{},u=e.getValueAtIndexOrDefault,d=t.options.elements.arc,c=s.backgroundColor?s.backgroundColor:u(r.backgroundColor,a,d.backgroundColor),h=s.borderColor?s.borderColor:u(r.borderColor,a,d.borderColor),f=s.borderWidth?s.borderWidth:u(r.borderWidth,a,d.borderWidth);return{text:i,fillStyle:c,strokeStyle:h,lineWidth:f,hidden:isNaN(r.data[a])||o.data[a].hidden,index:a}}):[]}},onClick:function(t,e){var n,i,a,o=e.index,r=this.chart;for(n=0,i=(r.data.datasets||[]).length;n<i;++n)a=r.getDatasetMeta(n),a.data[o]&&(a.data[o].hidden=!a.data[o].hidden);r.update()}},cutoutPercentage:50,rotation:Math.PI*-.5,circumference:2*Math.PI,tooltips:{callbacks:{title:function(){return""},label:function(t,n){var i=n.labels[t.index],a=": "+n.datasets[t.datasetIndex].data[t.index];return e.isArray(i)?(i=i.slice(),i[0]+=a):i+=a,i}}}},n.pie=e.clone(n.doughnut),e.extend(n.pie,{cutoutPercentage:0}),t.controllers.doughnut=t.controllers.pie=t.DatasetController.extend({dataElementType:t.elements.Arc,linkScales:e.noop,getRingIndex:function(t){for(var e=0,n=0;n<t;++n)this.chart.isDatasetVisible(n)&&++e;return e},update:function(t){var n=this,i=n.chart,a=i.chartArea,o=i.options,r=o.elements.arc,l=a.right-a.left-r.borderWidth,s=a.bottom-a.top-r.borderWidth,u=Math.min(l,s),d={x:0,y:0},c=n.getMeta(),h=o.cutoutPercentage,f=o.circumference;if(f<2*Math.PI){var g=o.rotation%(2*Math.PI);g+=2*Math.PI*(g>=Math.PI?-1:g<-Math.PI?1:0);var p=g+f,m={x:Math.cos(g),y:Math.sin(g)},v={x:Math.cos(p),y:Math.sin(p)},b=g<=0&&0<=p||g<=2*Math.PI&&2*Math.PI<=p,x=g<=.5*Math.PI&&.5*Math.PI<=p||g<=2.5*Math.PI&&2.5*Math.PI<=p,y=g<=-Math.PI&&-Math.PI<=p||g<=Math.PI&&Math.PI<=p,k=g<=.5*-Math.PI&&.5*-Math.PI<=p||g<=1.5*Math.PI&&1.5*Math.PI<=p,w=h/100,M={x:y?-1:Math.min(m.x*(m.x<0?1:w),v.x*(v.x<0?1:w)),y:k?-1:Math.min(m.y*(m.y<0?1:w),v.y*(v.y<0?1:w))},S={x:b?1:Math.max(m.x*(m.x>0?1:w),v.x*(v.x>0?1:w)),y:x?1:Math.max(m.y*(m.y>0?1:w),v.y*(v.y>0?1:w))},C={width:.5*(S.x-M.x),height:.5*(S.y-M.y)};u=Math.min(l/C.width,s/C.height),d={x:(S.x+M.x)*-.5,y:(S.y+M.y)*-.5}}i.borderWidth=n.getMaxBorderWidth(c.data),i.outerRadius=Math.max((u-i.borderWidth)/2,0),i.innerRadius=Math.max(h?i.outerRadius/100*h:0,0),i.radiusLength=(i.outerRadius-i.innerRadius)/i.getVisibleDatasetCount(),i.offsetX=d.x*i.outerRadius,i.offsetY=d.y*i.outerRadius,c.total=n.calculateTotal(),n.outerRadius=i.outerRadius-i.radiusLength*n.getRingIndex(n.index),n.innerRadius=Math.max(n.outerRadius-i.radiusLength,0),e.each(c.data,function(e,i){n.updateElement(e,i,t)})},updateElement:function(t,n,i){var a=this,o=a.chart,r=o.chartArea,l=o.options,s=l.animation,u=(r.left+r.right)/2,d=(r.top+r.bottom)/2,c=l.rotation,h=l.rotation,f=a.getDataset(),g=i&&s.animateRotate?0:t.hidden?0:a.calculateCircumference(f.data[n])*(l.circumference/(2*Math.PI)),p=i&&s.animateScale?0:a.innerRadius,m=i&&s.animateScale?0:a.outerRadius,v=e.getValueAtIndexOrDefault;e.extend(t,{_datasetIndex:a.index,_index:n,_model:{x:u+o.offsetX,y:d+o.offsetY,startAngle:c,endAngle:h,circumference:g,outerRadius:m,innerRadius:p,label:v(f.label,n,o.data.labels[n])}});var b=t._model;this.removeHoverStyle(t),i&&s.animateRotate||(0===n?b.startAngle=l.rotation:b.startAngle=a.getMeta().data[n-1]._model.endAngle,b.endAngle=b.startAngle+b.circumference),t.pivot()},removeHoverStyle:function(e){t.DatasetController.prototype.removeHoverStyle.call(this,e,this.chart.options.elements.arc)},calculateTotal:function(){var t,n=this.getDataset(),i=this.getMeta(),a=0;return e.each(i.data,function(e,i){t=n.data[i],isNaN(t)||e.hidden||(a+=Math.abs(t))}),a},calculateCircumference:function(t){var e=this.getMeta().total;return e>0&&!isNaN(t)?2*Math.PI*(t/e):0},getMaxBorderWidth:function(t){for(var e,n,i=0,a=this.index,o=t.length,r=0;r<o;r++)e=t[r]._model?t[r]._model.borderWidth:0,n=t[r]._chart?t[r]._chart.config.data.datasets[a].hoverBorderWidth:0,i=e>i?e:i,i=n>i?n:i;return i}})}},{}],18:[function(t,e,n){"use strict";e.exports=function(t){function e(t,e){return n.getValueOrDefault(t.showLine,e.showLines)}var n=t.helpers;t.defaults.line={showLines:!0,spanGaps:!1,hover:{mode:"label"},scales:{xAxes:[{type:"category",id:"x-axis-0"}],yAxes:[{type:"linear",id:"y-axis-0"}]}},t.controllers.line=t.DatasetController.extend({datasetElementType:t.elements.Line,dataElementType:t.elements.Point,update:function(t){var i,a,o,r=this,l=r.getMeta(),s=l.dataset,u=l.data||[],d=r.chart.options,c=d.elements.line,h=r.getScaleForId(l.yAxisID),f=r.getDataset(),g=e(f,d);for(g&&(o=s.custom||{},void 0!==f.tension&&void 0===f.lineTension&&(f.lineTension=f.tension),s._scale=h,s._datasetIndex=r.index,s._children=u,s._model={spanGaps:f.spanGaps?f.spanGaps:d.spanGaps,tension:o.tension?o.tension:n.getValueOrDefault(f.lineTension,c.tension),backgroundColor:o.backgroundColor?o.backgroundColor:f.backgroundColor||c.backgroundColor,borderWidth:o.borderWidth?o.borderWidth:f.borderWidth||c.borderWidth,borderColor:o.borderColor?o.borderColor:f.borderColor||c.borderColor,borderCapStyle:o.borderCapStyle?o.borderCapStyle:f.borderCapStyle||c.borderCapStyle,borderDash:o.borderDash?o.borderDash:f.borderDash||c.borderDash,borderDashOffset:o.borderDashOffset?o.borderDashOffset:f.borderDashOffset||c.borderDashOffset,borderJoinStyle:o.borderJoinStyle?o.borderJoinStyle:f.borderJoinStyle||c.borderJoinStyle,fill:o.fill?o.fill:void 0!==f.fill?f.fill:c.fill,steppedLine:o.steppedLine?o.steppedLine:n.getValueOrDefault(f.steppedLine,c.stepped),cubicInterpolationMode:o.cubicInterpolationMode?o.cubicInterpolationMode:n.getValueOrDefault(f.cubicInterpolationMode,c.cubicInterpolationMode)},s.pivot()),i=0,a=u.length;i<a;++i)r.updateElement(u[i],i,t);for(g&&0!==s._model.tension&&r.updateBezierControlPoints(),i=0,a=u.length;i<a;++i)u[i].pivot()},getPointBackgroundColor:function(t,e){var i=this.chart.options.elements.point.backgroundColor,a=this.getDataset(),o=t.custom||{};return o.backgroundColor?i=o.backgroundColor:a.pointBackgroundColor?i=n.getValueAtIndexOrDefault(a.pointBackgroundColor,e,i):a.backgroundColor&&(i=a.backgroundColor),i},getPointBorderColor:function(t,e){var i=this.chart.options.elements.point.borderColor,a=this.getDataset(),o=t.custom||{};return o.borderColor?i=o.borderColor:a.pointBorderColor?i=n.getValueAtIndexOrDefault(a.pointBorderColor,e,i):a.borderColor&&(i=a.borderColor),i},getPointBorderWidth:function(t,e){var i=this.chart.options.elements.point.borderWidth,a=this.getDataset(),o=t.custom||{};return isNaN(o.borderWidth)?isNaN(a.pointBorderWidth)?isNaN(a.borderWidth)||(i=a.borderWidth):i=n.getValueAtIndexOrDefault(a.pointBorderWidth,e,i):i=o.borderWidth,i},updateElement:function(t,e,i){var a,o,r=this,l=r.getMeta(),s=t.custom||{},u=r.getDataset(),d=r.index,c=u.data[e],h=r.getScaleForId(l.yAxisID),f=r.getScaleForId(l.xAxisID),g=r.chart.options.elements.point,p=r.chart.data.labels||[],m=1===p.length||1===u.data.length||r.chart.isCombo;void 0!==u.radius&&void 0===u.pointRadius&&(u.pointRadius=u.radius),void 0!==u.hitRadius&&void 0===u.pointHitRadius&&(u.pointHitRadius=u.hitRadius),a=f.getPixelForValue("object"==typeof c?c:NaN,e,d,m),o=i?h.getBasePixel():r.calculatePointY(c,e,d),t._xScale=f,t._yScale=h,t._datasetIndex=d,t._index=e,t._model={x:a,y:o,skip:s.skip||isNaN(a)||isNaN(o),radius:s.radius||n.getValueAtIndexOrDefault(u.pointRadius,e,g.radius),pointStyle:s.pointStyle||n.getValueAtIndexOrDefault(u.pointStyle,e,g.pointStyle),backgroundColor:r.getPointBackgroundColor(t,e),borderColor:r.getPointBorderColor(t,e),borderWidth:r.getPointBorderWidth(t,e),tension:l.dataset._model?l.dataset._model.tension:0,steppedLine:!!l.dataset._model&&l.dataset._model.steppedLine,hitRadius:s.hitRadius||n.getValueAtIndexOrDefault(u.pointHitRadius,e,g.hitRadius)}},calculatePointY:function(t,e,n){var i,a,o,r=this,l=r.chart,s=r.getMeta(),u=r.getScaleForId(s.yAxisID),d=0,c=0;if(u.options.stacked){for(i=0;i<n;i++)if(a=l.data.datasets[i],o=l.getDatasetMeta(i),"line"===o.type&&o.yAxisID===u.id&&l.isDatasetVisible(i)){var h=Number(u.getRightValue(a.data[e]));h<0?c+=h||0:d+=h||0}var f=Number(u.getRightValue(t));return f<0?u.getPixelForValue(c+f):u.getPixelForValue(d+f)}return u.getPixelForValue(t)},updateBezierControlPoints:function(){function t(t,e,n){return Math.max(Math.min(t,n),e)}var e,i,a,o,r,l=this,s=l.getMeta(),u=l.chart.chartArea,d=s.data||[];if(s.dataset._model.spanGaps&&(d=d.filter(function(t){return!t._model.skip})),"monotone"===s.dataset._model.cubicInterpolationMode)n.splineCurveMonotone(d);else for(e=0,i=d.length;e<i;++e)a=d[e],o=a._model,r=n.splineCurve(n.previousItem(d,e)._model,o,n.nextItem(d,e)._model,s.dataset._model.tension),o.controlPointPreviousX=r.previous.x,o.controlPointPreviousY=r.previous.y,o.controlPointNextX=r.next.x,o.controlPointNextY=r.next.y;if(l.chart.options.elements.line.capBezierPoints)for(e=0,i=d.length;e<i;++e)o=d[e]._model,o.controlPointPreviousX=t(o.controlPointPreviousX,u.left,u.right),o.controlPointPreviousY=t(o.controlPointPreviousY,u.top,u.bottom),o.controlPointNextX=t(o.controlPointNextX,u.left,u.right),o.controlPointNextY=t(o.controlPointNextY,u.top,u.bottom)},draw:function(){var n=this,i=n.chart,a=n.getMeta(),o=a.data||[],r=i.chartArea,l=o.length,s=0;for(t.canvasHelpers.clipArea(i.ctx,r),e(n.getDataset(),i.options)&&a.dataset.draw(),t.canvasHelpers.unclipArea(i.ctx);s<l;++s)o[s].draw(r)},setHoverStyle:function(t){var e=this.chart.data.datasets[t._datasetIndex],i=t._index,a=t.custom||{},o=t._model;o.radius=a.hoverRadius||n.getValueAtIndexOrDefault(e.pointHoverRadius,i,this.chart.options.elements.point.hoverRadius),o.backgroundColor=a.hoverBackgroundColor||n.getValueAtIndexOrDefault(e.pointHoverBackgroundColor,i,n.getHoverColor(o.backgroundColor)),o.borderColor=a.hoverBorderColor||n.getValueAtIndexOrDefault(e.pointHoverBorderColor,i,n.getHoverColor(o.borderColor)),o.borderWidth=a.hoverBorderWidth||n.getValueAtIndexOrDefault(e.pointHoverBorderWidth,i,o.borderWidth)},removeHoverStyle:function(t){var e=this,i=e.chart.data.datasets[t._datasetIndex],a=t._index,o=t.custom||{},r=t._model;void 0!==i.radius&&void 0===i.pointRadius&&(i.pointRadius=i.radius),r.radius=o.radius||n.getValueAtIndexOrDefault(i.pointRadius,a,e.chart.options.elements.point.radius),r.backgroundColor=e.getPointBackgroundColor(t,a),r.borderColor=e.getPointBorderColor(t,a),r.borderWidth=e.getPointBorderWidth(t,a)}})}},{}],19:[function(t,e,n){"use strict";e.exports=function(t){var e=t.helpers;t.defaults.polarArea={scale:{type:"radialLinear",angleLines:{display:!1},gridLines:{circular:!0},pointLabels:{display:!1},ticks:{beginAtZero:!0}},animation:{animateRotate:!0,animateScale:!0},startAngle:-.5*Math.PI,aspectRatio:1,legendCallback:function(t){var e=[];e.push('<ul class="'+t.id+'-legend">');var n=t.data,i=n.datasets,a=n.labels;if(i.length)for(var o=0;o<i[0].data.length;++o)e.push('<li><span style="background-color:'+i[0].backgroundColor[o]+'"></span>'),a[o]&&e.push(a[o]),e.push("</li>");return e.push("</ul>"),e.join("")},legend:{labels:{generateLabels:function(t){var n=t.data;return n.labels.length&&n.datasets.length?n.labels.map(function(i,a){var o=t.getDatasetMeta(0),r=n.datasets[0],l=o.data[a],s=l.custom||{},u=e.getValueAtIndexOrDefault,d=t.options.elements.arc,c=s.backgroundColor?s.backgroundColor:u(r.backgroundColor,a,d.backgroundColor),h=s.borderColor?s.borderColor:u(r.borderColor,a,d.borderColor),f=s.borderWidth?s.borderWidth:u(r.borderWidth,a,d.borderWidth);return{text:i,fillStyle:c,strokeStyle:h,lineWidth:f,hidden:isNaN(r.data[a])||o.data[a].hidden,index:a}}):[]}},onClick:function(t,e){var n,i,a,o=e.index,r=this.chart;for(n=0,i=(r.data.datasets||[]).length;n<i;++n)a=r.getDatasetMeta(n),a.data[o].hidden=!a.data[o].hidden;r.update()}},tooltips:{callbacks:{title:function(){return""},label:function(t,e){return e.labels[t.index]+": "+t.yLabel}}}},t.controllers.polarArea=t.DatasetController.extend({dataElementType:t.elements.Arc,linkScales:e.noop,update:function(t){var n=this,i=n.chart,a=i.chartArea,o=n.getMeta(),r=i.options,l=r.elements.arc,s=Math.min(a.right-a.left,a.bottom-a.top);i.outerRadius=Math.max((s-l.borderWidth/2)/2,0),i.innerRadius=Math.max(r.cutoutPercentage?i.outerRadius/100*r.cutoutPercentage:1,0),i.radiusLength=(i.outerRadius-i.innerRadius)/i.getVisibleDatasetCount(),n.outerRadius=i.outerRadius-i.radiusLength*n.index,n.innerRadius=n.outerRadius-i.radiusLength,o.count=n.countVisibleElements(),e.each(o.data,function(e,i){n.updateElement(e,i,t)})},updateElement:function(t,n,i){for(var a=this,o=a.chart,r=a.getDataset(),l=o.options,s=l.animation,u=o.scale,d=e.getValueAtIndexOrDefault,c=o.data.labels,h=a.calculateCircumference(r.data[n]),f=u.xCenter,g=u.yCenter,p=0,m=a.getMeta(),v=0;v<n;++v)isNaN(r.data[v])||m.data[v].hidden||++p;var b=l.startAngle,x=t.hidden?0:u.getDistanceFromCenterForValue(r.data[n]),y=b+h*p,k=y+(t.hidden?0:h),w=s.animateScale?0:u.getDistanceFromCenterForValue(r.data[n]);e.extend(t,{_datasetIndex:a.index,_index:n,_scale:u,_model:{x:f,y:g,innerRadius:0,outerRadius:i?w:x,startAngle:i&&s.animateRotate?b:y,endAngle:i&&s.animateRotate?b:k,label:d(c,n,c[n])}}),a.removeHoverStyle(t),t.pivot()},removeHoverStyle:function(e){t.DatasetController.prototype.removeHoverStyle.call(this,e,this.chart.options.elements.arc)},countVisibleElements:function(){var t=this.getDataset(),n=this.getMeta(),i=0;return e.each(n.data,function(e,n){isNaN(t.data[n])||e.hidden||i++}),i},calculateCircumference:function(t){var e=this.getMeta().count;return e>0&&!isNaN(t)?2*Math.PI/e:0}})}},{}],20:[function(t,e,n){"use strict";e.exports=function(t){var e=t.helpers;t.defaults.radar={aspectRatio:1,scale:{type:"radialLinear"},elements:{line:{tension:0}}},t.controllers.radar=t.DatasetController.extend({datasetElementType:t.elements.Line,dataElementType:t.elements.Point,linkScales:e.noop,update:function(t){var n=this,i=n.getMeta(),a=i.dataset,o=i.data,r=a.custom||{},l=n.getDataset(),s=n.chart.options.elements.line,u=n.chart.scale;void 0!==l.tension&&void 0===l.lineTension&&(l.lineTension=l.tension),e.extend(i.dataset,{_datasetIndex:n.index,_scale:u,_children:o,_loop:!0,_model:{tension:r.tension?r.tension:e.getValueOrDefault(l.lineTension,s.tension),backgroundColor:r.backgroundColor?r.backgroundColor:l.backgroundColor||s.backgroundColor,borderWidth:r.borderWidth?r.borderWidth:l.borderWidth||s.borderWidth,borderColor:r.borderColor?r.borderColor:l.borderColor||s.borderColor,fill:r.fill?r.fill:void 0!==l.fill?l.fill:s.fill,borderCapStyle:r.borderCapStyle?r.borderCapStyle:l.borderCapStyle||s.borderCapStyle,borderDash:r.borderDash?r.borderDash:l.borderDash||s.borderDash,borderDashOffset:r.borderDashOffset?r.borderDashOffset:l.borderDashOffset||s.borderDashOffset,borderJoinStyle:r.borderJoinStyle?r.borderJoinStyle:l.borderJoinStyle||s.borderJoinStyle}}),i.dataset.pivot(),e.each(o,function(e,i){n.updateElement(e,i,t)},n),n.updateBezierControlPoints()},updateElement:function(t,n,i){var a=this,o=t.custom||{},r=a.getDataset(),l=a.chart.scale,s=a.chart.options.elements.point,u=l.getPointPositionForValue(n,r.data[n]);void 0!==r.radius&&void 0===r.pointRadius&&(r.pointRadius=r.radius),void 0!==r.hitRadius&&void 0===r.pointHitRadius&&(r.pointHitRadius=r.hitRadius),e.extend(t,{_datasetIndex:a.index,_index:n,_scale:l,_model:{x:i?l.xCenter:u.x,y:i?l.yCenter:u.y,tension:o.tension?o.tension:e.getValueOrDefault(r.lineTension,a.chart.options.elements.line.tension),radius:o.radius?o.radius:e.getValueAtIndexOrDefault(r.pointRadius,n,s.radius),backgroundColor:o.backgroundColor?o.backgroundColor:e.getValueAtIndexOrDefault(r.pointBackgroundColor,n,s.backgroundColor),borderColor:o.borderColor?o.borderColor:e.getValueAtIndexOrDefault(r.pointBorderColor,n,s.borderColor),borderWidth:o.borderWidth?o.borderWidth:e.getValueAtIndexOrDefault(r.pointBorderWidth,n,s.borderWidth),pointStyle:o.pointStyle?o.pointStyle:e.getValueAtIndexOrDefault(r.pointStyle,n,s.pointStyle),hitRadius:o.hitRadius?o.hitRadius:e.getValueAtIndexOrDefault(r.pointHitRadius,n,s.hitRadius)}}),t._model.skip=o.skip?o.skip:isNaN(t._model.x)||isNaN(t._model.y)},updateBezierControlPoints:function(){var t=this.chart.chartArea,n=this.getMeta();e.each(n.data,function(i,a){var o=i._model,r=e.splineCurve(e.previousItem(n.data,a,!0)._model,o,e.nextItem(n.data,a,!0)._model,o.tension);o.controlPointPreviousX=Math.max(Math.min(r.previous.x,t.right),t.left),o.controlPointPreviousY=Math.max(Math.min(r.previous.y,t.bottom),t.top),o.controlPointNextX=Math.max(Math.min(r.next.x,t.right),t.left),o.controlPointNextY=Math.max(Math.min(r.next.y,t.bottom),t.top),i.pivot()})},setHoverStyle:function(t){var n=this.chart.data.datasets[t._datasetIndex],i=t.custom||{},a=t._index,o=t._model;o.radius=i.hoverRadius?i.hoverRadius:e.getValueAtIndexOrDefault(n.pointHoverRadius,a,this.chart.options.elements.point.hoverRadius),o.backgroundColor=i.hoverBackgroundColor?i.hoverBackgroundColor:e.getValueAtIndexOrDefault(n.pointHoverBackgroundColor,a,e.getHoverColor(o.backgroundColor)),o.borderColor=i.hoverBorderColor?i.hoverBorderColor:e.getValueAtIndexOrDefault(n.pointHoverBorderColor,a,e.getHoverColor(o.borderColor)),o.borderWidth=i.hoverBorderWidth?i.hoverBorderWidth:e.getValueAtIndexOrDefault(n.pointHoverBorderWidth,a,o.borderWidth)},removeHoverStyle:function(t){var n=this.chart.data.datasets[t._datasetIndex],i=t.custom||{},a=t._index,o=t._model,r=this.chart.options.elements.point;o.radius=i.radius?i.radius:e.getValueAtIndexOrDefault(n.pointRadius,a,r.radius),o.backgroundColor=i.backgroundColor?i.backgroundColor:e.getValueAtIndexOrDefault(n.pointBackgroundColor,a,r.backgroundColor),o.borderColor=i.borderColor?i.borderColor:e.getValueAtIndexOrDefault(n.pointBorderColor,a,r.borderColor),o.borderWidth=i.borderWidth?i.borderWidth:e.getValueAtIndexOrDefault(n.pointBorderWidth,a,r.borderWidth)}})}},{}],21:[function(t,e,n){"use strict";e.exports=function(t){var e=t.helpers;t.defaults.global.animation={duration:1e3,easing:"easeOutQuart",onProgress:e.noop,onComplete:e.noop},t.Animation=t.Element.extend({chart:null,currentStep:0,numSteps:60,easing:"",render:null,onAnimationProgress:null,onAnimationComplete:null}),t.animationService={frameDuration:17,animations:[],dropFrames:0,request:null,addAnimation:function(t,e,n,i){var a,o,r=this.animations;for(e.chart=t,i||(t.animating=!0),a=0,o=r.length;a<o;++a)if(r[a].chart===t)return void(r[a]=e);r.push(e),1===r.length&&this.requestAnimationFrame()},cancelAnimation:function(t){var n=e.findIndex(this.animations,function(e){return e.chart===t});n!==-1&&(this.animations.splice(n,1),t.animating=!1)},requestAnimationFrame:function(){var t=this;null===t.request&&(t.request=e.requestAnimFrame.call(window,function(){t.request=null,t.startDigest()}))},startDigest:function(){var t=this,e=Date.now(),n=0;t.dropFrames>1&&(n=Math.floor(t.dropFrames),t.dropFrames=t.dropFrames%1),t.advance(1+n);var i=Date.now();t.dropFrames+=(i-e)/t.frameDuration,t.animations.length>0&&t.requestAnimationFrame()},advance:function(t){for(var n,i,a=this.animations,o=0;o<a.length;)n=a[o],i=n.chart,n.currentStep=(n.currentStep||0)+t,n.currentStep=Math.min(n.currentStep,n.numSteps),e.callback(n.render,[i,n],i),e.callback(n.onAnimationProgress,[n],i),n.currentStep>=n.numSteps?(e.callback(n.onAnimationComplete,[n],i),i.animating=!1,a.splice(o,1)):++o}},Object.defineProperty(t.Animation.prototype,"animationObject",{get:function(){return this}}),Object.defineProperty(t.Animation.prototype,"chartInstance",{get:function(){return this.chart},set:function(t){this.chart=t}})}},{}],22:[function(t,e,n){"use strict";e.exports=function(t){var e=t.canvasHelpers={};e.drawPoint=function(e,n,i,a,o){var r,l,s,u,d,c;if("object"==typeof n&&(r=n.toString(),"[object HTMLImageElement]"===r||"[object HTMLCanvasElement]"===r))return void e.drawImage(n,a-n.width/2,o-n.height/2);if(!(isNaN(i)||i<=0)){switch(n){default:e.beginPath(),e.arc(a,o,i,0,2*Math.PI),e.closePath(),e.fill();break;case"triangle":e.beginPath(),l=3*i/Math.sqrt(3),d=l*Math.sqrt(3)/2,e.moveTo(a-l/2,o+d/3),e.lineTo(a+l/2,o+d/3),e.lineTo(a,o-2*d/3),e.closePath(),e.fill();break;case"rect":c=1/Math.SQRT2*i,e.beginPath(),e.fillRect(a-c,o-c,2*c,2*c),e.strokeRect(a-c,o-c,2*c,2*c);break;case"rectRounded":var h=i/Math.SQRT2,f=a-h,g=o-h,p=Math.SQRT2*i;t.helpers.drawRoundedRectangle(e,f,g,p,p,i/2),e.fill();break;case"rectRot":c=1/Math.SQRT2*i,e.beginPath(),e.moveTo(a-c,o),e.lineTo(a,o+c),e.lineTo(a+c,o),e.lineTo(a,o-c),e.closePath(),e.fill();break;case"cross":e.beginPath(),e.moveTo(a,o+i),e.lineTo(a,o-i),e.moveTo(a-i,o),e.lineTo(a+i,o),e.closePath();break;case"crossRot":e.beginPath(),s=Math.cos(Math.PI/4)*i,u=Math.sin(Math.PI/4)*i,e.moveTo(a-s,o-u),e.lineTo(a+s,o+u),e.moveTo(a-s,o+u),e.lineTo(a+s,o-u),e.closePath();break;case"star":e.beginPath(),e.moveTo(a,o+i),e.lineTo(a,o-i),e.moveTo(a-i,o),e.lineTo(a+i,o),s=Math.cos(Math.PI/4)*i,u=Math.sin(Math.PI/4)*i,e.moveTo(a-s,o-u),e.lineTo(a+s,o+u),e.moveTo(a-s,o+u),e.lineTo(a+s,o-u),e.closePath();break;case"line":e.beginPath(),e.moveTo(a-i,o),e.lineTo(a+i,o),e.closePath();break;case"dash":e.beginPath(),e.moveTo(a,o),e.lineTo(a+i,o),e.closePath()}e.stroke()}},e.clipArea=function(t,e){t.save(),t.beginPath(),t.rect(e.left,e.top,e.right-e.left,e.bottom-e.top),t.clip()},e.unclipArea=function(t){t.restore()},e.lineTo=function(t,e,n,i){return n.steppedLine?("after"===n.steppedLine?t.lineTo(e.x,n.y):t.lineTo(n.x,e.y),void t.lineTo(n.x,n.y)):n.tension?void t.bezierCurveTo(i?e.controlPointPreviousX:e.controlPointNextX,i?e.controlPointPreviousY:e.controlPointNextY,i?n.controlPointNextX:n.controlPointPreviousX,i?n.controlPointNextY:n.controlPointPreviousY,n.x,n.y):void t.lineTo(n.x,n.y)},t.helpers.canvas=e}},{}],23:[function(t,e,n){"use strict";e.exports=function(t){function e(e){e=e||{};var n=e.data=e.data||{};return n.datasets=n.datasets||[],n.labels=n.labels||[],e.options=a.configMerge(t.defaults.global,t.defaults[e.type],e.options||{}),e}function n(t){var e=t.options;e.scale?t.scale.options=e.scale:e.scales&&e.scales.xAxes.concat(e.scales.yAxes).forEach(function(e){t.scales[e.id].options=e}),t.tooltip._options=e.tooltips}function i(t){return"top"===t||"bottom"===t}var a=t.helpers,o=t.plugins,r=t.platform;t.types={},t.instances={},t.controllers={},a.extend(t.prototype,{construct:function(n,i){var o=this;i=e(i);var l=r.acquireContext(n,i),s=l&&l.canvas,u=s&&s.height,d=s&&s.width;return o.id=a.uid(),o.ctx=l,o.canvas=s,o.config=i,o.width=d,o.height=u,o.aspectRatio=u?d/u:null,o.options=i.options,o._bufferedRender=!1,o.chart=o,o.controller=o,t.instances[o.id]=o,Object.defineProperty(o,"data",{get:function(){return o.config.data},set:function(t){o.config.data=t}}),l&&s?(o.initialize(),void o.update()):void console.error("Failed to create chart: can't acquire context from the given item")},initialize:function(){var t=this;return o.notify(t,"beforeInit"),a.retinaScale(t),t.bindEvents(),t.options.responsive&&t.resize(!0),t.ensureScalesHaveIDs(),t.buildScales(),t.initToolTip(),o.notify(t,"afterInit"),t},clear:function(){return a.clear(this),this},stop:function(){return t.animationService.cancelAnimation(this),this},resize:function(t){var e=this,n=e.options,i=e.canvas,r=n.maintainAspectRatio&&e.aspectRatio||null,l=Math.floor(a.getMaximumWidth(i)),s=Math.floor(r?l/r:a.getMaximumHeight(i));if((e.width!==l||e.height!==s)&&(i.width=e.width=l,i.height=e.height=s,i.style.width=l+"px",i.style.height=s+"px",a.retinaScale(e),!t)){var u={width:l,height:s};o.notify(e,"resize",[u]),e.options.onResize&&e.options.onResize(e,u),e.stop(),e.update(e.options.responsiveAnimationDuration)}},ensureScalesHaveIDs:function(){var t=this.options,e=t.scales||{},n=t.scale;a.each(e.xAxes,function(t,e){t.id=t.id||"x-axis-"+e}),a.each(e.yAxes,function(t,e){t.id=t.id||"y-axis-"+e}),n&&(n.id=n.id||"scale")},buildScales:function(){var e=this,n=e.options,o=e.scales={},r=[];n.scales&&(r=r.concat((n.scales.xAxes||[]).map(function(t){return{options:t,dtype:"category",dposition:"bottom"}}),(n.scales.yAxes||[]).map(function(t){return{options:t,dtype:"linear",dposition:"left"}}))),n.scale&&r.push({options:n.scale,dtype:"radialLinear",isDefault:!0,dposition:"chartArea"}),a.each(r,function(n){var r=n.options,l=a.getValueOrDefault(r.type,n.dtype),s=t.scaleService.getScaleConstructor(l);if(s){i(r.position)!==i(n.dposition)&&(r.position=n.dposition);var u=new s({id:r.id,options:r,ctx:e.ctx,chart:e});o[u.id]=u,n.isDefault&&(e.scale=u)}}),t.scaleService.addScalesToLayout(this)},buildOrUpdateControllers:function(){var e=this,n=[],i=[];if(a.each(e.data.datasets,function(a,o){var r=e.getDatasetMeta(o);if(r.type||(r.type=a.type||e.config.type),n.push(r.type),r.controller)r.controller.updateIndex(o);else{var l=t.controllers[r.type];if(void 0===l)throw new Error('"'+r.type+'" is not a chart type.');r.controller=new l(e,o),i.push(r.controller)}},e),n.length>1)for(var o=1;o<n.length;o++)if(n[o]!==n[o-1]){e.isCombo=!0;break}return i},resetElements:function(){var t=this;a.each(t.data.datasets,function(e,n){t.getDatasetMeta(n).controller.reset()},t)},reset:function(){this.resetElements(),this.tooltip.initialize()},update:function(t,e){var i=this;if(n(i),o.notify(i,"beforeUpdate")!==!1){i.tooltip._data=i.data;var r=i.buildOrUpdateControllers();a.each(i.data.datasets,function(t,e){i.getDatasetMeta(e).controller.buildOrUpdateElements()},i),i.updateLayout(),a.each(r,function(t){t.reset()}),i.updateDatasets(),o.notify(i,"afterUpdate"),i._bufferedRender?i._bufferedRequest={lazy:e,duration:t}:i.render(t,e)}},updateLayout:function(){var e=this;o.notify(e,"beforeLayout")!==!1&&(t.layoutService.update(this,this.width,this.height),o.notify(e,"afterScaleUpdate"),o.notify(e,"afterLayout"))},updateDatasets:function(){var t=this;if(o.notify(t,"beforeDatasetsUpdate")!==!1){for(var e=0,n=t.data.datasets.length;e<n;++e)t.updateDataset(e);o.notify(t,"afterDatasetsUpdate")}},updateDataset:function(t){var e=this,n=e.getDatasetMeta(t),i={meta:n,index:t};o.notify(e,"beforeDatasetUpdate",[i])!==!1&&(n.controller.update(),o.notify(e,"afterDatasetUpdate",[i]))},render:function(e,n){var i=this;if(o.notify(i,"beforeRender")!==!1){var r=i.options.animation,l=function(t){o.notify(i,"afterRender"),a.callback(r&&r.onComplete,[t],i)};if(r&&("undefined"!=typeof e&&0!==e||"undefined"==typeof e&&0!==r.duration)){var s=new t.Animation({numSteps:(e||r.duration)/16.66,easing:r.easing,render:function(t,e){var n=a.easingEffects[e.easing],i=e.currentStep,o=i/e.numSteps;t.draw(n(o),o,i)},onAnimationProgress:r.onProgress,onAnimationComplete:l});t.animationService.addAnimation(i,s,e,n)}else i.draw(),l(new t.Animation({numSteps:0,chart:i}));return i}},draw:function(t){var e=this;e.clear(),void 0!==t&&null!==t||(t=1),e.transition(t),o.notify(e,"beforeDraw",[t])!==!1&&(a.each(e.boxes,function(t){t.draw(e.chartArea)},e),e.scale&&e.scale.draw(),e.drawDatasets(t),e.tooltip.draw(),o.notify(e,"afterDraw",[t]))},transition:function(t){for(var e=this,n=0,i=(e.data.datasets||[]).length;n<i;++n)e.isDatasetVisible(n)&&e.getDatasetMeta(n).controller.transition(t);e.tooltip.transition(t)},drawDatasets:function(t){var e=this;if(o.notify(e,"beforeDatasetsDraw",[t])!==!1){for(var n=(e.data.datasets||[]).length-1;n>=0;--n)e.isDatasetVisible(n)&&e.drawDataset(n,t);o.notify(e,"afterDatasetsDraw",[t])}},drawDataset:function(t,e){var n=this,i=n.getDatasetMeta(t),a={meta:i,index:t,easingValue:e};o.notify(n,"beforeDatasetDraw",[a])!==!1&&(i.controller.draw(e),o.notify(n,"afterDatasetDraw",[a]))},getElementAtEvent:function(e){return t.Interaction.modes.single(this,e)},getElementsAtEvent:function(e){return t.Interaction.modes.label(this,e,{intersect:!0})},getElementsAtXAxis:function(e){return t.Interaction.modes["x-axis"](this,e,{intersect:!0})},getElementsAtEventForMode:function(e,n,i){var a=t.Interaction.modes[n];return"function"==typeof a?a(this,e,i):[]},getDatasetAtEvent:function(e){return t.Interaction.modes.dataset(this,e,{intersect:!0})},getDatasetMeta:function(t){var e=this,n=e.data.datasets[t];n._meta||(n._meta={});var i=n._meta[e.id];return i||(i=n._meta[e.id]={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null}),i},getVisibleDatasetCount:function(){for(var t=0,e=0,n=this.data.datasets.length;e<n;++e)this.isDatasetVisible(e)&&t++;return t},isDatasetVisible:function(t){var e=this.getDatasetMeta(t);return"boolean"==typeof e.hidden?!e.hidden:!this.data.datasets[t].hidden},generateLegend:function(){return this.options.legendCallback(this)},destroy:function(){var e,n,i,l=this,s=l.canvas;for(l.stop(),n=0,i=l.data.datasets.length;n<i;++n)e=l.getDatasetMeta(n),e.controller&&(e.controller.destroy(),e.controller=null);s&&(l.unbindEvents(),a.clear(l),r.releaseContext(l.ctx),l.canvas=null,l.ctx=null),o.notify(l,"destroy"),delete t.instances[l.id]},toBase64Image:function(){return this.canvas.toDataURL.apply(this.canvas,arguments)},initToolTip:function(){var e=this;e.tooltip=new t.Tooltip({_chart:e,_chartInstance:e,_data:e.data,_options:e.options.tooltips},e),e.tooltip.initialize()},bindEvents:function(){var t=this,e=t._listeners={},n=function(){t.eventHandler.apply(t,arguments)};a.each(t.options.events,function(i){r.addEventListener(t,i,n),e[i]=n}),t.options.responsive&&(n=function(){t.resize()},r.addEventListener(t,"resize",n),e.resize=n)},unbindEvents:function(){var t=this,e=t._listeners;e&&(delete t._listeners,a.each(e,function(e,n){r.removeEventListener(t,n,e)}))},updateHoverStyle:function(t,e,n){var i,a,o,r=n?"setHoverStyle":"removeHoverStyle";for(a=0,o=t.length;a<o;++a)i=t[a],i&&this.getDatasetMeta(i._datasetIndex).controller[r](i)},eventHandler:function(t){var e=this,n=e.tooltip;if(o.notify(e,"beforeEvent",[t])!==!1){e._bufferedRender=!0,e._bufferedRequest=null;var i=e.handleEvent(t);i|=n&&n.handleEvent(t),o.notify(e,"afterEvent",[t]);var a=e._bufferedRequest;return a?e.render(a.duration,a.lazy):i&&!e.animating&&(e.stop(),e.render(e.options.hover.animationDuration,!0)),e._bufferedRender=!1,e._bufferedRequest=null,e}},handleEvent:function(t){var e=this,n=e.options||{},i=n.hover,o=!1;return e.lastActive=e.lastActive||[],"mouseout"===t.type?e.active=[]:e.active=e.getElementsAtEventForMode(t,i.mode,i),i.onHover&&i.onHover.call(e,t.native,e.active),"mouseup"!==t.type&&"click"!==t.type||n.onClick&&n.onClick.call(e,t.native,e.active),e.lastActive.length&&e.updateHoverStyle(e.lastActive,i.mode,!1),e.active.length&&i.mode&&e.updateHoverStyle(e.active,i.mode,!0),o=!a.arrayEquals(e.active,e.lastActive),e.lastActive=e.active,o}}),t.Controller=t}},{}],24:[function(t,e,n){"use strict";e.exports=function(t){function e(t,e){return t._chartjs?void t._chartjs.listeners.push(e):(Object.defineProperty(t,"_chartjs",{configurable:!0,enumerable:!1,value:{listeners:[e]}}),void a.forEach(function(e){var n="onData"+e.charAt(0).toUpperCase()+e.slice(1),a=t[e];Object.defineProperty(t,e,{configurable:!0,enumerable:!1,value:function(){var e=Array.prototype.slice.call(arguments),o=a.apply(this,e);return i.each(t._chartjs.listeners,function(t){"function"==typeof t[n]&&t[n].apply(t,e);
}),o}})}))}function n(t,e){var n=t._chartjs;if(n){var i=n.listeners,o=i.indexOf(e);o!==-1&&i.splice(o,1),i.length>0||(a.forEach(function(e){delete t[e]}),delete t._chartjs)}}var i=t.helpers,a=["push","pop","shift","splice","unshift"];t.DatasetController=function(t,e){this.initialize(t,e)},i.extend(t.DatasetController.prototype,{datasetElementType:null,dataElementType:null,initialize:function(t,e){var n=this;n.chart=t,n.index=e,n.linkScales(),n.addElements()},updateIndex:function(t){this.index=t},linkScales:function(){var t=this,e=t.getMeta(),n=t.getDataset();null===e.xAxisID&&(e.xAxisID=n.xAxisID||t.chart.options.scales.xAxes[0].id),null===e.yAxisID&&(e.yAxisID=n.yAxisID||t.chart.options.scales.yAxes[0].id)},getDataset:function(){return this.chart.data.datasets[this.index]},getMeta:function(){return this.chart.getDatasetMeta(this.index)},getScaleForId:function(t){return this.chart.scales[t]},reset:function(){this.update(!0)},destroy:function(){this._data&&n(this._data,this)},createMetaDataset:function(){var t=this,e=t.datasetElementType;return e&&new e({_chart:t.chart,_datasetIndex:t.index})},createMetaData:function(t){var e=this,n=e.dataElementType;return n&&new n({_chart:e.chart,_datasetIndex:e.index,_index:t})},addElements:function(){var t,e,n=this,i=n.getMeta(),a=n.getDataset().data||[],o=i.data;for(t=0,e=a.length;t<e;++t)o[t]=o[t]||n.createMetaData(t);i.dataset=i.dataset||n.createMetaDataset()},addElementAndReset:function(t){var e=this.createMetaData(t);this.getMeta().data.splice(t,0,e),this.updateElement(e,t,!0)},buildOrUpdateElements:function(){var t=this,i=t.getDataset(),a=i.data||(i.data=[]);t._data!==a&&(t._data&&n(t._data,t),e(a,t),t._data=a),t.resyncElements()},update:i.noop,transition:function(t){for(var e=this.getMeta(),n=e.data||[],i=n.length,a=0;a<i;++a)n[a].transition(t);e.dataset&&e.dataset.transition(t)},draw:function(){var t=this.getMeta(),e=t.data||[],n=e.length,i=0;for(t.dataset&&t.dataset.draw();i<n;++i)e[i].draw()},removeHoverStyle:function(t,e){var n=this.chart.data.datasets[t._datasetIndex],a=t._index,o=t.custom||{},r=i.getValueAtIndexOrDefault,l=t._model;l.backgroundColor=o.backgroundColor?o.backgroundColor:r(n.backgroundColor,a,e.backgroundColor),l.borderColor=o.borderColor?o.borderColor:r(n.borderColor,a,e.borderColor),l.borderWidth=o.borderWidth?o.borderWidth:r(n.borderWidth,a,e.borderWidth)},setHoverStyle:function(t){var e=this.chart.data.datasets[t._datasetIndex],n=t._index,a=t.custom||{},o=i.getValueAtIndexOrDefault,r=i.getHoverColor,l=t._model;l.backgroundColor=a.hoverBackgroundColor?a.hoverBackgroundColor:o(e.hoverBackgroundColor,n,r(l.backgroundColor)),l.borderColor=a.hoverBorderColor?a.hoverBorderColor:o(e.hoverBorderColor,n,r(l.borderColor)),l.borderWidth=a.hoverBorderWidth?a.hoverBorderWidth:o(e.hoverBorderWidth,n,l.borderWidth)},resyncElements:function(){var t=this,e=t.getMeta(),n=t.getDataset().data,i=e.data.length,a=n.length;a<i?e.data.splice(a,i-a):a>i&&t.insertElements(i,a-i)},insertElements:function(t,e){for(var n=0;n<e;++n)this.addElementAndReset(t+n)},onDataPush:function(){this.insertElements(this.getDataset().data.length-1,arguments.length)},onDataPop:function(){this.getMeta().data.pop()},onDataShift:function(){this.getMeta().data.shift()},onDataSplice:function(t,e){this.getMeta().data.splice(t,e),this.insertElements(t,arguments.length-2)},onDataUnshift:function(){this.insertElements(0,arguments.length)}}),t.DatasetController.extend=i.inherits}},{}],25:[function(t,e,n){"use strict";var i=t(3);e.exports=function(t){function e(t,e,n,a){var o,r,l,s,u,d,c,h,f,g=Object.keys(n);for(o=0,r=g.length;o<r;++o)if(l=g[o],d=n[l],e.hasOwnProperty(l)||(e[l]=d),s=e[l],s!==d&&"_"!==l[0]){if(t.hasOwnProperty(l)||(t[l]=s),u=t[l],c=typeof d,c===typeof u)if("string"===c){if(h=i(u),h.valid&&(f=i(d),f.valid)){e[l]=f.mix(h,a).rgbString();continue}}else if("number"===c&&isFinite(u)&&isFinite(d)){e[l]=u+(d-u)*a;continue}e[l]=d}}var n=t.helpers;t.elements={},t.Element=function(t){n.extend(this,t),this.initialize.apply(this,arguments)},n.extend(t.Element.prototype,{initialize:function(){this.hidden=!1},pivot:function(){var t=this;return t._view||(t._view=n.clone(t._model)),t._start={},t},transition:function(t){var n=this,i=n._model,a=n._start,o=n._view;return i&&1!==t?(o||(o=n._view={}),a||(a=n._start={}),e(a,o,i,t),n):(n._view=i,n._start=null,n)},tooltipPosition:function(){return{x:this._model.x,y:this._model.y}},hasValue:function(){return n.isNumber(this._model.x)&&n.isNumber(this._model.y)}}),t.Element.extend=n.inherits}},{3:3}],26:[function(t,e,n){"use strict";var i=t(3);e.exports=function(t){function e(t,e,n){var i;return"string"==typeof t?(i=parseInt(t,10),t.indexOf("%")!==-1&&(i=i/100*e.parentNode[n])):i=t,i}function n(t){return void 0!==t&&null!==t&&"none"!==t}function a(t,i,a){var o=document.defaultView,r=t.parentNode,l=o.getComputedStyle(t)[i],s=o.getComputedStyle(r)[i],u=n(l),d=n(s),c=Number.POSITIVE_INFINITY;return u||d?Math.min(u?e(l,t,a):c,d?e(s,r,a):c):"none"}var o=t.helpers={};o.each=function(t,e,n,i){var a,r;if(o.isArray(t))if(r=t.length,i)for(a=r-1;a>=0;a--)e.call(n,t[a],a);else for(a=0;a<r;a++)e.call(n,t[a],a);else if("object"==typeof t){var l=Object.keys(t);for(r=l.length,a=0;a<r;a++)e.call(n,t[l[a]],l[a])}},o.clone=function(t){var e={};return o.each(t,function(t,n){o.isArray(t)?e[n]=t.slice(0):"object"==typeof t&&null!==t?e[n]=o.clone(t):e[n]=t}),e},o.extend=function(t){for(var e=function(e,n){t[n]=e},n=1,i=arguments.length;n<i;n++)o.each(arguments[n],e);return t},o.configMerge=function(e){var n=o.clone(e);return o.each(Array.prototype.slice.call(arguments,1),function(e){o.each(e,function(e,i){var a=n.hasOwnProperty(i),r=a?n[i]:{};"scales"===i?n[i]=o.scaleMerge(r,e):"scale"===i?n[i]=o.configMerge(r,t.scaleService.getScaleDefaults(e.type),e):!a||"object"!=typeof r||o.isArray(r)||null===r||"object"!=typeof e||o.isArray(e)?n[i]=e:n[i]=o.configMerge(r,e)})}),n},o.scaleMerge=function(e,n){var i=o.clone(e);return o.each(n,function(e,n){"xAxes"===n||"yAxes"===n?i.hasOwnProperty(n)?o.each(e,function(e,a){var r=o.getValueOrDefault(e.type,"xAxes"===n?"category":"linear"),l=t.scaleService.getScaleDefaults(r);a>=i[n].length||!i[n][a].type?i[n].push(o.configMerge(l,e)):e.type&&e.type!==i[n][a].type?i[n][a]=o.configMerge(i[n][a],l,e):i[n][a]=o.configMerge(i[n][a],e)}):(i[n]=[],o.each(e,function(e){var a=o.getValueOrDefault(e.type,"xAxes"===n?"category":"linear");i[n].push(o.configMerge(t.scaleService.getScaleDefaults(a),e))})):i.hasOwnProperty(n)&&"object"==typeof i[n]&&null!==i[n]&&"object"==typeof e?i[n]=o.configMerge(i[n],e):i[n]=e}),i},o.getValueAtIndexOrDefault=function(t,e,n){return void 0===t||null===t?n:o.isArray(t)?e<t.length?t[e]:n:t},o.getValueOrDefault=function(t,e){return void 0===t?e:t},o.indexOf=Array.prototype.indexOf?function(t,e){return t.indexOf(e)}:function(t,e){for(var n=0,i=t.length;n<i;++n)if(t[n]===e)return n;return-1},o.where=function(t,e){if(o.isArray(t)&&Array.prototype.filter)return t.filter(e);var n=[];return o.each(t,function(t){e(t)&&n.push(t)}),n},o.findIndex=Array.prototype.findIndex?function(t,e,n){return t.findIndex(e,n)}:function(t,e,n){n=void 0===n?t:n;for(var i=0,a=t.length;i<a;++i)if(e.call(n,t[i],i,t))return i;return-1},o.findNextWhere=function(t,e,n){void 0!==n&&null!==n||(n=-1);for(var i=n+1;i<t.length;i++){var a=t[i];if(e(a))return a}},o.findPreviousWhere=function(t,e,n){void 0!==n&&null!==n||(n=t.length);for(var i=n-1;i>=0;i--){var a=t[i];if(e(a))return a}},o.inherits=function(t){var e=this,n=t&&t.hasOwnProperty("constructor")?t.constructor:function(){return e.apply(this,arguments)},i=function(){this.constructor=n};return i.prototype=e.prototype,n.prototype=new i,n.extend=o.inherits,t&&o.extend(n.prototype,t),n.__super__=e.prototype,n},o.noop=function(){},o.uid=function(){var t=0;return function(){return t++}}(),o.isNumber=function(t){return!isNaN(parseFloat(t))&&isFinite(t)},o.almostEquals=function(t,e,n){return Math.abs(t-e)<n},o.almostWhole=function(t,e){var n=Math.round(t);return n-e<t&&n+e>t},o.max=function(t){return t.reduce(function(t,e){return isNaN(e)?t:Math.max(t,e)},Number.NEGATIVE_INFINITY)},o.min=function(t){return t.reduce(function(t,e){return isNaN(e)?t:Math.min(t,e)},Number.POSITIVE_INFINITY)},o.sign=Math.sign?function(t){return Math.sign(t)}:function(t){return t=+t,0===t||isNaN(t)?t:t>0?1:-1},o.log10=Math.log10?function(t){return Math.log10(t)}:function(t){return Math.log(t)/Math.LN10},o.toRadians=function(t){return t*(Math.PI/180)},o.toDegrees=function(t){return t*(180/Math.PI)},o.getAngleFromPoint=function(t,e){var n=e.x-t.x,i=e.y-t.y,a=Math.sqrt(n*n+i*i),o=Math.atan2(i,n);return o<-.5*Math.PI&&(o+=2*Math.PI),{angle:o,distance:a}},o.distanceBetweenPoints=function(t,e){return Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))},o.aliasPixel=function(t){return t%2===0?0:.5},o.splineCurve=function(t,e,n,i){var a=t.skip?e:t,o=e,r=n.skip?e:n,l=Math.sqrt(Math.pow(o.x-a.x,2)+Math.pow(o.y-a.y,2)),s=Math.sqrt(Math.pow(r.x-o.x,2)+Math.pow(r.y-o.y,2)),u=l/(l+s),d=s/(l+s);u=isNaN(u)?0:u,d=isNaN(d)?0:d;var c=i*u,h=i*d;return{previous:{x:o.x-c*(r.x-a.x),y:o.y-c*(r.y-a.y)},next:{x:o.x+h*(r.x-a.x),y:o.y+h*(r.y-a.y)}}},o.EPSILON=Number.EPSILON||1e-14,o.splineCurveMonotone=function(t){var e,n,i,a,r=(t||[]).map(function(t){return{model:t._model,deltaK:0,mK:0}}),l=r.length;for(e=0;e<l;++e)if(i=r[e],!i.model.skip){if(n=e>0?r[e-1]:null,a=e<l-1?r[e+1]:null,a&&!a.model.skip){var s=a.model.x-i.model.x;i.deltaK=0!==s?(a.model.y-i.model.y)/s:0}!n||n.model.skip?i.mK=i.deltaK:!a||a.model.skip?i.mK=n.deltaK:this.sign(n.deltaK)!==this.sign(i.deltaK)?i.mK=0:i.mK=(n.deltaK+i.deltaK)/2}var u,d,c,h;for(e=0;e<l-1;++e)i=r[e],a=r[e+1],i.model.skip||a.model.skip||(o.almostEquals(i.deltaK,0,this.EPSILON)?i.mK=a.mK=0:(u=i.mK/i.deltaK,d=a.mK/i.deltaK,h=Math.pow(u,2)+Math.pow(d,2),h<=9||(c=3/Math.sqrt(h),i.mK=u*c*i.deltaK,a.mK=d*c*i.deltaK)));var f;for(e=0;e<l;++e)i=r[e],i.model.skip||(n=e>0?r[e-1]:null,a=e<l-1?r[e+1]:null,n&&!n.model.skip&&(f=(i.model.x-n.model.x)/3,i.model.controlPointPreviousX=i.model.x-f,i.model.controlPointPreviousY=i.model.y-f*i.mK),a&&!a.model.skip&&(f=(a.model.x-i.model.x)/3,i.model.controlPointNextX=i.model.x+f,i.model.controlPointNextY=i.model.y+f*i.mK))},o.nextItem=function(t,e,n){return n?e>=t.length-1?t[0]:t[e+1]:e>=t.length-1?t[t.length-1]:t[e+1]},o.previousItem=function(t,e,n){return n?e<=0?t[t.length-1]:t[e-1]:e<=0?t[0]:t[e-1]},o.niceNum=function(t,e){var n,i=Math.floor(o.log10(t)),a=t/Math.pow(10,i);return n=e?a<1.5?1:a<3?2:a<7?5:10:a<=1?1:a<=2?2:a<=5?5:10,n*Math.pow(10,i)};var r=o.easingEffects={linear:function(t){return t},easeInQuad:function(t){return t*t},easeOutQuad:function(t){return-1*t*(t-2)},easeInOutQuad:function(t){return(t/=.5)<1?.5*t*t:-.5*(--t*(t-2)-1)},easeInCubic:function(t){return t*t*t},easeOutCubic:function(t){return 1*((t=t/1-1)*t*t+1)},easeInOutCubic:function(t){return(t/=.5)<1?.5*t*t*t:.5*((t-=2)*t*t+2)},easeInQuart:function(t){return t*t*t*t},easeOutQuart:function(t){return-1*((t=t/1-1)*t*t*t-1)},easeInOutQuart:function(t){return(t/=.5)<1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2)},easeInQuint:function(t){return 1*(t/=1)*t*t*t*t},easeOutQuint:function(t){return 1*((t=t/1-1)*t*t*t*t+1)},easeInOutQuint:function(t){return(t/=.5)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2)},easeInSine:function(t){return-1*Math.cos(t/1*(Math.PI/2))+1},easeOutSine:function(t){return 1*Math.sin(t/1*(Math.PI/2))},easeInOutSine:function(t){return-.5*(Math.cos(Math.PI*t/1)-1)},easeInExpo:function(t){return 0===t?1:1*Math.pow(2,10*(t/1-1))},easeOutExpo:function(t){return 1===t?1:1*(-Math.pow(2,-10*t/1)+1)},easeInOutExpo:function(t){return 0===t?0:1===t?1:(t/=.5)<1?.5*Math.pow(2,10*(t-1)):.5*(-Math.pow(2,-10*--t)+2)},easeInCirc:function(t){return t>=1?t:-1*(Math.sqrt(1-(t/=1)*t)-1)},easeOutCirc:function(t){return 1*Math.sqrt(1-(t=t/1-1)*t)},easeInOutCirc:function(t){return(t/=.5)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)},easeInElastic:function(t){var e=1.70158,n=0,i=1;return 0===t?0:1===(t/=1)?1:(n||(n=.3),i<Math.abs(1)?(i=1,e=n/4):e=n/(2*Math.PI)*Math.asin(1/i),-(i*Math.pow(2,10*(t-=1))*Math.sin((1*t-e)*(2*Math.PI)/n)))},easeOutElastic:function(t){var e=1.70158,n=0,i=1;return 0===t?0:1===(t/=1)?1:(n||(n=.3),i<Math.abs(1)?(i=1,e=n/4):e=n/(2*Math.PI)*Math.asin(1/i),i*Math.pow(2,-10*t)*Math.sin((1*t-e)*(2*Math.PI)/n)+1)},easeInOutElastic:function(t){var e=1.70158,n=0,i=1;return 0===t?0:2===(t/=.5)?1:(n||(n=1*(.3*1.5)),i<Math.abs(1)?(i=1,e=n/4):e=n/(2*Math.PI)*Math.asin(1/i),t<1?-.5*(i*Math.pow(2,10*(t-=1))*Math.sin((1*t-e)*(2*Math.PI)/n)):i*Math.pow(2,-10*(t-=1))*Math.sin((1*t-e)*(2*Math.PI)/n)*.5+1)},easeInBack:function(t){var e=1.70158;return 1*(t/=1)*t*((e+1)*t-e)},easeOutBack:function(t){var e=1.70158;return 1*((t=t/1-1)*t*((e+1)*t+e)+1)},easeInOutBack:function(t){var e=1.70158;return(t/=.5)<1?.5*(t*t*(((e*=1.525)+1)*t-e)):.5*((t-=2)*t*(((e*=1.525)+1)*t+e)+2)},easeInBounce:function(t){return 1-r.easeOutBounce(1-t)},easeOutBounce:function(t){return(t/=1)<1/2.75?1*(7.5625*t*t):t<2/2.75?1*(7.5625*(t-=1.5/2.75)*t+.75):t<2.5/2.75?1*(7.5625*(t-=2.25/2.75)*t+.9375):1*(7.5625*(t-=2.625/2.75)*t+.984375)},easeInOutBounce:function(t){return t<.5?.5*r.easeInBounce(2*t):.5*r.easeOutBounce(2*t-1)+.5}};o.requestAnimFrame=function(){return"undefined"==typeof window?function(t){t()}:window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(t){return window.setTimeout(t,1e3/60)}}(),o.getRelativePosition=function(t,e){var n,i,a=t.originalEvent||t,r=t.currentTarget||t.srcElement,l=r.getBoundingClientRect(),s=a.touches;s&&s.length>0?(n=s[0].clientX,i=s[0].clientY):(n=a.clientX,i=a.clientY);var u=parseFloat(o.getStyle(r,"padding-left")),d=parseFloat(o.getStyle(r,"padding-top")),c=parseFloat(o.getStyle(r,"padding-right")),h=parseFloat(o.getStyle(r,"padding-bottom")),f=l.right-l.left-u-c,g=l.bottom-l.top-d-h;return n=Math.round((n-l.left-u)/f*r.width/e.currentDevicePixelRatio),i=Math.round((i-l.top-d)/g*r.height/e.currentDevicePixelRatio),{x:n,y:i}},o.addEvent=function(t,e,n){t.addEventListener?t.addEventListener(e,n):t.attachEvent?t.attachEvent("on"+e,n):t["on"+e]=n},o.removeEvent=function(t,e,n){t.removeEventListener?t.removeEventListener(e,n,!1):t.detachEvent?t.detachEvent("on"+e,n):t["on"+e]=o.noop},o.getConstraintWidth=function(t){return a(t,"max-width","clientWidth")},o.getConstraintHeight=function(t){return a(t,"max-height","clientHeight")},o.getMaximumWidth=function(t){var e=t.parentNode,n=parseInt(o.getStyle(e,"padding-left"),10),i=parseInt(o.getStyle(e,"padding-right"),10),a=e.clientWidth-n-i,r=o.getConstraintWidth(t);return isNaN(r)?a:Math.min(a,r)},o.getMaximumHeight=function(t){var e=t.parentNode,n=parseInt(o.getStyle(e,"padding-top"),10),i=parseInt(o.getStyle(e,"padding-bottom"),10),a=e.clientHeight-n-i,r=o.getConstraintHeight(t);return isNaN(r)?a:Math.min(a,r)},o.getStyle=function(t,e){return t.currentStyle?t.currentStyle[e]:document.defaultView.getComputedStyle(t,null).getPropertyValue(e)},o.retinaScale=function(t){var e=t.currentDevicePixelRatio=window.devicePixelRatio||1;if(1!==e){var n=t.canvas,i=t.height,a=t.width;n.height=i*e,n.width=a*e,t.ctx.scale(e,e),n.style.height=i+"px",n.style.width=a+"px"}},o.clear=function(t){t.ctx.clearRect(0,0,t.width,t.height)},o.fontString=function(t,e,n){return e+" "+t+"px "+n},o.longestText=function(t,e,n,i){i=i||{};var a=i.data=i.data||{},r=i.garbageCollect=i.garbageCollect||[];i.font!==e&&(a=i.data={},r=i.garbageCollect=[],i.font=e),t.font=e;var l=0;o.each(n,function(e){void 0!==e&&null!==e&&o.isArray(e)!==!0?l=o.measureText(t,a,r,l,e):o.isArray(e)&&o.each(e,function(e){void 0===e||null===e||o.isArray(e)||(l=o.measureText(t,a,r,l,e))})});var s=r.length/2;if(s>n.length){for(var u=0;u<s;u++)delete a[r[u]];r.splice(0,s)}return l},o.measureText=function(t,e,n,i,a){var o=e[a];return o||(o=e[a]=t.measureText(a).width,n.push(a)),o>i&&(i=o),i},o.numberOfLabelLines=function(t){var e=1;return o.each(t,function(t){o.isArray(t)&&t.length>e&&(e=t.length)}),e},o.drawRoundedRectangle=function(t,e,n,i,a,o){t.beginPath(),t.moveTo(e+o,n),t.lineTo(e+i-o,n),t.quadraticCurveTo(e+i,n,e+i,n+o),t.lineTo(e+i,n+a-o),t.quadraticCurveTo(e+i,n+a,e+i-o,n+a),t.lineTo(e+o,n+a),t.quadraticCurveTo(e,n+a,e,n+a-o),t.lineTo(e,n+o),t.quadraticCurveTo(e,n,e+o,n),t.closePath()},o.color=i?function(e){return e instanceof CanvasGradient&&(e=t.defaults.global.defaultColor),i(e)}:function(t){return console.error("Color.js not found!"),t},o.isArray=Array.isArray?function(t){return Array.isArray(t)}:function(t){return"[object Array]"===Object.prototype.toString.call(t)},o.arrayEquals=function(t,e){var n,i,a,r;if(!t||!e||t.length!==e.length)return!1;for(n=0,i=t.length;n<i;++n)if(a=t[n],r=e[n],a instanceof Array&&r instanceof Array){if(!o.arrayEquals(a,r))return!1}else if(a!==r)return!1;return!0},o.callback=function(t,e,n){t&&"function"==typeof t.call&&t.apply(n,e)},o.getHoverColor=function(t){return t instanceof CanvasPattern?t:o.color(t).saturate(.5).darken(.1).rgbString()},o.callCallback=o.callback}},{3:3}],27:[function(t,e,n){"use strict";e.exports=function(t){function e(t,e){return t.native?{x:t.x,y:t.y}:r.getRelativePosition(t,e)}function n(t,e){var n,i,a,o,r,l=t.data.datasets;for(i=0,o=l.length;i<o;++i)if(t.isDatasetVisible(i))for(n=t.getDatasetMeta(i),a=0,r=n.data.length;a<r;++a){var s=n.data[a];s._view.skip||e(s)}}function i(t,e){var i=[];return n(t,function(t){t.inRange(e.x,e.y)&&i.push(t)}),i}function a(t,e,i,a){var o=Number.POSITIVE_INFINITY,l=[];return a||(a=r.distanceBetweenPoints),n(t,function(t){if(!i||t.inRange(e.x,e.y)){var n=t.getCenterPoint(),r=a(e,n);r<o?(l=[t],o=r):r===o&&l.push(t)}}),l}function o(t,n,o){var r=e(n,t),l=function(t,e){return Math.abs(t.x-e.x)},s=o.intersect?i(t,r):a(t,r,!1,l),u=[];return s.length?(t.data.datasets.forEach(function(e,n){if(t.isDatasetVisible(n)){var i=t.getDatasetMeta(n),a=i.data[s[0]._index];a&&!a._view.skip&&u.push(a)}}),u):[]}var r=t.helpers;t.Interaction={modes:{single:function(t,i){var a=e(i,t),o=[];return n(t,function(t){if(t.inRange(a.x,a.y))return o.push(t),o}),o.slice(0,1)},label:o,index:o,dataset:function(t,n,o){var r=e(n,t),l=o.intersect?i(t,r):a(t,r,!1);return l.length>0&&(l=t.getDatasetMeta(l[0]._datasetIndex).data),l},"x-axis":function(t,e){return o(t,e,!0)},point:function(t,n){var a=e(n,t);return i(t,a)},nearest:function(t,n,i){var o=e(n,t),r=a(t,o,i.intersect);return r.length>1&&r.sort(function(t,e){var n=t.getArea(),i=e.getArea(),a=n-i;return 0===a&&(a=t._datasetIndex-e._datasetIndex),a}),r.slice(0,1)},x:function(t,i,a){var o=e(i,t),r=[],l=!1;return n(t,function(t){t.inXRange(o.x)&&r.push(t),t.inRange(o.x,o.y)&&(l=!0)}),a.intersect&&!l&&(r=[]),r},y:function(t,i,a){var o=e(i,t),r=[],l=!1;return n(t,function(t){t.inYRange(o.y)&&r.push(t),t.inRange(o.x,o.y)&&(l=!0)}),a.intersect&&!l&&(r=[]),r}}}}},{}],28:[function(t,e,n){"use strict";e.exports=function(){var t=function(t,e){return this.construct(t,e),this};return t.defaults={global:{responsive:!0,responsiveAnimationDuration:0,maintainAspectRatio:!0,events:["mousemove","mouseout","click","touchstart","touchmove"],hover:{onHover:null,mode:"nearest",intersect:!0,animationDuration:400},onClick:null,defaultColor:"rgba(0,0,0,0.1)",defaultFontColor:"#666",defaultFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",defaultFontSize:12,defaultFontStyle:"normal",showLines:!0,elements:{},legendCallback:function(t){var e=[];e.push('<ul class="'+t.id+'-legend">');for(var n=0;n<t.data.datasets.length;n++)e.push('<li><span style="background-color:'+t.data.datasets[n].backgroundColor+'"></span>'),t.data.datasets[n].label&&e.push(t.data.datasets[n].label),e.push("</li>");return e.push("</ul>"),e.join("")}}},t.Chart=t,t}},{}],29:[function(t,e,n){"use strict";e.exports=function(t){function e(t,e){return i.where(t,function(t){return t.position===e})}function n(t,e){t.forEach(function(t,e){return t._tmpIndex_=e,t}),t.sort(function(t,n){var i=e?n:t,a=e?t:n;return i.weight===a.weight?i._tmpIndex_-a._tmpIndex_:i.weight-a.weight}),t.forEach(function(t){delete t._tmpIndex_})}var i=t.helpers;t.layoutService={defaults:{},addBox:function(t,e){t.boxes||(t.boxes=[]),e.fullWidth=e.fullWidth||!1,e.position=e.position||"top",e.weight=e.weight||0,t.boxes.push(e)},removeBox:function(t,e){var n=t.boxes?t.boxes.indexOf(e):-1;n!==-1&&t.boxes.splice(n,1)},configure:function(t,e,n){for(var i,a=["fullWidth","position","weight"],o=a.length,r=0;r<o;++r)i=a[r],n.hasOwnProperty(i)&&(e[i]=n[i])},update:function(t,a,o){function r(t){var e,n=t.isHorizontal();n?(e=t.update(t.fullWidth?k:I,D),A-=e.height):(e=t.update(C,S),I-=e.width),P.push({horizontal:n,minSize:e,box:t})}function l(t){var e=i.findNextWhere(P,function(e){return e.box===t});if(e)if(t.isHorizontal()){var n={left:Math.max(L,_),right:Math.max(V,F),top:0,bottom:0};t.update(t.fullWidth?k:I,w/2,n)}else t.update(e.minSize.width,A)}function s(t){var e=i.findNextWhere(P,function(e){return e.box===t}),n={left:0,right:0,top:O,bottom:z};e&&t.update(e.minSize.width,A,n)}function u(t){t.isHorizontal()?(t.left=t.fullWidth?h:L,t.right=t.fullWidth?a-f:L+I,t.top=q,t.bottom=q+t.height,q=t.bottom):(t.left=H,t.right=H+t.width,t.top=O,t.bottom=O+A,H=t.right)}if(t){var d=t.options.layout,c=d?d.padding:null,h=0,f=0,g=0,p=0;isNaN(c)?(h=c.left||0,f=c.right||0,g=c.top||0,p=c.bottom||0):(h=c,f=c,g=c,p=c);var m=e(t.boxes,"left"),v=e(t.boxes,"right"),b=e(t.boxes,"top"),x=e(t.boxes,"bottom"),y=e(t.boxes,"chartArea");n(m,!0),n(v,!1),n(b,!0),n(x,!1);var k=a-h-f,w=o-g-p,M=k/2,S=w/2,C=(a-M)/(m.length+v.length),D=(o-S)/(b.length+x.length),I=k,A=w,P=[];i.each(m.concat(v,b,x),r);var _=0,F=0,T=0,R=0;i.each(b.concat(x),function(t){if(t.getPadding){var e=t.getPadding();_=Math.max(_,e.left),F=Math.max(F,e.right)}}),i.each(m.concat(v),function(t){if(t.getPadding){var e=t.getPadding();T=Math.max(T,e.top),R=Math.max(R,e.bottom)}});var L=h,V=f,O=g,z=p;i.each(m.concat(v),l),i.each(m,function(t){L+=t.width}),i.each(v,function(t){V+=t.width}),i.each(b.concat(x),l),i.each(b,function(t){O+=t.height}),i.each(x,function(t){z+=t.height}),i.each(m.concat(v),s),L=h,V=f,O=g,z=p,i.each(m,function(t){L+=t.width}),i.each(v,function(t){V+=t.width}),i.each(b,function(t){O+=t.height}),i.each(x,function(t){z+=t.height});var B=Math.max(_-L,0);L+=B,V+=Math.max(F-V,0);var W=Math.max(T-O,0);O+=W,z+=Math.max(R-z,0);var N=o-O-z,E=a-L-V;E===I&&N===A||(i.each(m,function(t){t.height=N}),i.each(v,function(t){t.height=N}),i.each(b,function(t){t.fullWidth||(t.width=E)}),i.each(x,function(t){t.fullWidth||(t.width=E)}),A=N,I=E);var H=h+B,q=g+W;i.each(m.concat(b),u),H+=I,q+=A,i.each(v,u),i.each(x,u),t.chartArea={left:L,top:O,right:L+I,bottom:O+A},i.each(y,function(e){e.left=t.chartArea.left,e.top=t.chartArea.top,e.right=t.chartArea.right,e.bottom=t.chartArea.bottom,e.update(I,A)})}}}}},{}],30:[function(t,e,n){"use strict";e.exports=function(t){var e=t.helpers;t.defaults.global.plugins={},t.plugins={_plugins:[],_cacheId:0,register:function(t){var e=this._plugins;[].concat(t).forEach(function(t){e.indexOf(t)===-1&&e.push(t)}),this._cacheId++},unregister:function(t){var e=this._plugins;[].concat(t).forEach(function(t){var n=e.indexOf(t);n!==-1&&e.splice(n,1)}),this._cacheId++},clear:function(){this._plugins=[],this._cacheId++},count:function(){return this._plugins.length},getAll:function(){return this._plugins},notify:function(t,e,n){var i,a,o,r,l,s=this.descriptors(t),u=s.length;for(i=0;i<u;++i)if(a=s[i],o=a.plugin,l=o[e],"function"==typeof l&&(r=[t].concat(n||[]),r.push(a.options),l.apply(o,r)===!1))return!1;return!0},descriptors:function(n){var i=n._plugins||(n._plugins={});if(i.id===this._cacheId)return i.descriptors;var a=[],o=[],r=n&&n.config||{},l=t.defaults.global.plugins,s=r.options&&r.options.plugins||{};return this._plugins.concat(r.plugins||[]).forEach(function(t){var n=a.indexOf(t);if(n===-1){var i=t.id,r=s[i];r!==!1&&(r===!0&&(r=e.clone(l[i])),a.push(t),o.push({plugin:t,options:r||{}}))}}),i.descriptors=o,i.id=this._cacheId,o}},t.pluginService=t.plugins,t.PluginBase=t.Element.extend({})}},{}],31:[function(t,e,n){"use strict";e.exports=function(t){function e(t,e,n){return i.isArray(e)?i.longestText(t,n,e):t.measureText(e).width}function n(e){var n=i.getValueOrDefault,a=t.defaults.global,o=n(e.fontSize,a.defaultFontSize),r=n(e.fontStyle,a.defaultFontStyle),l=n(e.fontFamily,a.defaultFontFamily);return{size:o,style:r,family:l,font:i.fontString(o,r,l)}}var i=t.helpers;t.defaults.scale={display:!0,position:"left",gridLines:{display:!0,color:"rgba(0, 0, 0, 0.1)",lineWidth:1,drawBorder:!0,drawOnChartArea:!0,drawTicks:!0,tickMarkLength:10,zeroLineWidth:1,zeroLineColor:"rgba(0,0,0,0.25)",zeroLineBorderDash:[],zeroLineBorderDashOffset:0,offsetGridLines:!1,borderDash:[],borderDashOffset:0},scaleLabel:{labelString:"",display:!1},ticks:{beginAtZero:!1,minRotation:0,maxRotation:50,mirror:!1,padding:0,reverse:!1,display:!0,autoSkip:!0,autoSkipPadding:0,labelOffset:0,callback:t.Ticks.formatters.values}},t.Scale=t.Element.extend({getPadding:function(){var t=this;return{left:t.paddingLeft||0,top:t.paddingTop||0,right:t.paddingRight||0,bottom:t.paddingBottom||0}},beforeUpdate:function(){i.callback(this.options.beforeUpdate,[this])},update:function(t,e,n){var a=this;return a.beforeUpdate(),a.maxWidth=t,a.maxHeight=e,a.margins=i.extend({left:0,right:0,top:0,bottom:0},n),a.longestTextCache=a.longestTextCache||{},a.beforeSetDimensions(),a.setDimensions(),a.afterSetDimensions(),a.beforeDataLimits(),a.determineDataLimits(),a.afterDataLimits(),a.beforeBuildTicks(),a.buildTicks(),a.afterBuildTicks(),a.beforeTickToLabelConversion(),a.convertTicksToLabels(),a.afterTickToLabelConversion(),a.beforeCalculateTickRotation(),a.calculateTickRotation(),a.afterCalculateTickRotation(),a.beforeFit(),a.fit(),a.afterFit(),a.afterUpdate(),a.minSize},afterUpdate:function(){i.callback(this.options.afterUpdate,[this])},beforeSetDimensions:function(){i.callback(this.options.beforeSetDimensions,[this])},setDimensions:function(){var t=this;t.isHorizontal()?(t.width=t.maxWidth,t.left=0,t.right=t.width):(t.height=t.maxHeight,t.top=0,t.bottom=t.height),t.paddingLeft=0,t.paddingTop=0,t.paddingRight=0,t.paddingBottom=0},afterSetDimensions:function(){i.callback(this.options.afterSetDimensions,[this])},beforeDataLimits:function(){i.callback(this.options.beforeDataLimits,[this])},determineDataLimits:i.noop,afterDataLimits:function(){i.callback(this.options.afterDataLimits,[this])},beforeBuildTicks:function(){i.callback(this.options.beforeBuildTicks,[this])},buildTicks:i.noop,afterBuildTicks:function(){i.callback(this.options.afterBuildTicks,[this])},beforeTickToLabelConversion:function(){i.callback(this.options.beforeTickToLabelConversion,[this])},convertTicksToLabels:function(){var t=this,e=t.options.ticks;t.ticks=t.ticks.map(e.userCallback||e.callback)},afterTickToLabelConversion:function(){i.callback(this.options.afterTickToLabelConversion,[this])},beforeCalculateTickRotation:function(){i.callback(this.options.beforeCalculateTickRotation,[this])},calculateTickRotation:function(){var t=this,e=t.ctx,a=t.options.ticks,o=n(a);e.font=o.font;var r=a.minRotation||0;if(t.options.display&&t.isHorizontal())for(var l,s,u=i.longestText(e,o.font,t.ticks,t.longestTextCache),d=u,c=t.getPixelForTick(1)-t.getPixelForTick(0)-6;d>c&&r<a.maxRotation;){var h=i.toRadians(r);if(l=Math.cos(h),s=Math.sin(h),s*u>t.maxHeight){r--;break}r++,d=l*u}t.labelRotation=r},afterCalculateTickRotation:function(){i.callback(this.options.afterCalculateTickRotation,[this])},beforeFit:function(){i.callback(this.options.beforeFit,[this])},fit:function(){var t=this,a=t.minSize={width:0,height:0},o=t.options,r=o.ticks,l=o.scaleLabel,s=o.gridLines,u=o.display,d=t.isHorizontal(),c=n(r),h=1.5*n(l).size,f=o.gridLines.tickMarkLength;if(d?a.width=t.isFullWidth()?t.maxWidth-t.margins.left-t.margins.right:t.maxWidth:a.width=u&&s.drawTicks?f:0,d?a.height=u&&s.drawTicks?f:0:a.height=t.maxHeight,l.display&&u&&(d?a.height+=h:a.width+=h),r.display&&u){var g=i.longestText(t.ctx,c.font,t.ticks,t.longestTextCache),p=i.numberOfLabelLines(t.ticks),m=.5*c.size;if(d){t.longestLabelWidth=g;var v=i.toRadians(t.labelRotation),b=Math.cos(v),x=Math.sin(v),y=x*g+c.size*p+m*p;a.height=Math.min(t.maxHeight,a.height+y),t.ctx.font=c.font;var k=t.ticks[0],w=e(t.ctx,k,c.font),M=t.ticks[t.ticks.length-1],S=e(t.ctx,M,c.font);0!==t.labelRotation?(t.paddingLeft="bottom"===o.position?b*w+3:b*m+3,t.paddingRight="bottom"===o.position?b*m+3:b*S+3):(t.paddingLeft=w/2+3,t.paddingRight=S/2+3)}else r.mirror?g=0:g+=t.options.ticks.padding,a.width=Math.min(t.maxWidth,a.width+g),t.paddingTop=c.size/2,t.paddingBottom=c.size/2}t.handleMargins(),t.width=a.width,t.height=a.height},handleMargins:function(){var t=this;t.margins&&(t.paddingLeft=Math.max(t.paddingLeft-t.margins.left,0),t.paddingTop=Math.max(t.paddingTop-t.margins.top,0),t.paddingRight=Math.max(t.paddingRight-t.margins.right,0),t.paddingBottom=Math.max(t.paddingBottom-t.margins.bottom,0))},afterFit:function(){i.callback(this.options.afterFit,[this])},isHorizontal:function(){return"top"===this.options.position||"bottom"===this.options.position},isFullWidth:function(){return this.options.fullWidth},getRightValue:function(t){return null===t||"undefined"==typeof t?NaN:"number"!=typeof t||isFinite(t)?"object"==typeof t?t instanceof Date||t.isValid?t:this.getRightValue(this.isHorizontal()?t.x:t.y):t:NaN},getLabelForIndex:i.noop,getPixelForValue:i.noop,getValueForPixel:i.noop,getPixelForTick:function(t,e){var n=this;if(n.isHorizontal()){var i=n.width-(n.paddingLeft+n.paddingRight),a=i/Math.max(n.ticks.length-(n.options.gridLines.offsetGridLines?0:1),1),o=a*t+n.paddingLeft;e&&(o+=a/2);var r=n.left+Math.round(o);return r+=n.isFullWidth()?n.margins.left:0}var l=n.height-(n.paddingTop+n.paddingBottom);return n.top+t*(l/(n.ticks.length-1))},getPixelForDecimal:function(t){var e=this;if(e.isHorizontal()){var n=e.width-(e.paddingLeft+e.paddingRight),i=n*t+e.paddingLeft,a=e.left+Math.round(i);return a+=e.isFullWidth()?e.margins.left:0}return e.top+t*e.height},getBasePixel:function(){return this.getPixelForValue(this.getBaseValue())},getBaseValue:function(){var t=this,e=t.min,n=t.max;return t.beginAtZero?0:e<0&&n<0?n:e>0&&n>0?e:0},draw:function(e){var a=this,o=a.options;if(o.display){var r,l,s=a.ctx,u=t.defaults.global,d=o.ticks,c=o.gridLines,h=o.scaleLabel,f=0!==a.labelRotation,g=d.autoSkip,p=a.isHorizontal();d.maxTicksLimit&&(l=d.maxTicksLimit);var m=i.getValueOrDefault(d.fontColor,u.defaultFontColor),v=n(d),b=c.drawTicks?c.tickMarkLength:0,x=i.getValueOrDefault(h.fontColor,u.defaultFontColor),y=n(h),k=i.toRadians(a.labelRotation),w=Math.cos(k),M=a.longestLabelWidth*w;s.fillStyle=m;var S=[];if(p){if(r=!1,(M+d.autoSkipPadding)*a.ticks.length>a.width-(a.paddingLeft+a.paddingRight)&&(r=1+Math.floor((M+d.autoSkipPadding)*a.ticks.length/(a.width-(a.paddingLeft+a.paddingRight)))),l&&a.ticks.length>l)for(;!r||a.ticks.length/(r||1)>l;)r||(r=1),r+=1;g||(r=!1)}var C="right"===o.position?a.left:a.right-b,D="right"===o.position?a.left+b:a.right,I="bottom"===o.position?a.top:a.bottom-b,A="bottom"===o.position?a.top+b:a.bottom;if(i.each(a.ticks,function(t,n){if(void 0!==t&&null!==t){var l=a.ticks.length===n+1,s=r>1&&n%r>0||n%r===0&&n+r>=a.ticks.length;if((!s||l)&&void 0!==t&&null!==t){var h,g,m,v;n===("undefined"!=typeof a.zeroLineIndex?a.zeroLineIndex:0)?(h=c.zeroLineWidth,g=c.zeroLineColor,m=c.zeroLineBorderDash,v=c.zeroLineBorderDashOffset):(h=i.getValueAtIndexOrDefault(c.lineWidth,n),g=i.getValueAtIndexOrDefault(c.color,n),m=i.getValueOrDefault(c.borderDash,u.borderDash),v=i.getValueOrDefault(c.borderDashOffset,u.borderDashOffset));var x,y,w,M,P,_,F,T,R,L,V="middle",O="middle";if(p){"bottom"===o.position?(O=f?"middle":"top",V=f?"right":"center",L=a.top+b):(O=f?"middle":"bottom",V=f?"left":"center",L=a.bottom-b);var z=a.getPixelForTick(n)+i.aliasPixel(h);R=a.getPixelForTick(n,c.offsetGridLines)+d.labelOffset,x=w=P=F=z,y=I,M=A,_=e.top,T=e.bottom}else{var B,W="left"===o.position,N=d.padding;
d.mirror?(V=W?"left":"right",B=N):(V=W?"right":"left",B=b+N),R=W?a.right-B:a.left+B;var E=a.getPixelForTick(n);E+=i.aliasPixel(h),L=a.getPixelForTick(n,c.offsetGridLines),x=C,w=D,P=e.left,F=e.right,y=M=_=T=E}S.push({tx1:x,ty1:y,tx2:w,ty2:M,x1:P,y1:_,x2:F,y2:T,labelX:R,labelY:L,glWidth:h,glColor:g,glBorderDash:m,glBorderDashOffset:v,rotation:-1*k,label:t,textBaseline:O,textAlign:V})}}}),i.each(S,function(t){if(c.display&&(s.save(),s.lineWidth=t.glWidth,s.strokeStyle=t.glColor,s.setLineDash&&(s.setLineDash(t.glBorderDash),s.lineDashOffset=t.glBorderDashOffset),s.beginPath(),c.drawTicks&&(s.moveTo(t.tx1,t.ty1),s.lineTo(t.tx2,t.ty2)),c.drawOnChartArea&&(s.moveTo(t.x1,t.y1),s.lineTo(t.x2,t.y2)),s.stroke(),s.restore()),d.display){s.save(),s.translate(t.labelX,t.labelY),s.rotate(t.rotation),s.font=v.font,s.textBaseline=t.textBaseline,s.textAlign=t.textAlign;var e=t.label;if(i.isArray(e))for(var n=0,a=0;n<e.length;++n)s.fillText(""+e[n],0,a),a+=1.5*v.size;else s.fillText(e,0,0);s.restore()}}),h.display){var P,_,F=0;if(p)P=a.left+(a.right-a.left)/2,_="bottom"===o.position?a.bottom-y.size/2:a.top+y.size/2;else{var T="left"===o.position;P=T?a.left+y.size/2:a.right-y.size/2,_=a.top+(a.bottom-a.top)/2,F=T?-.5*Math.PI:.5*Math.PI}s.save(),s.translate(P,_),s.rotate(F),s.textAlign="center",s.textBaseline="middle",s.fillStyle=x,s.font=y.font,s.fillText(h.labelString,0,0),s.restore()}if(c.drawBorder){s.lineWidth=i.getValueAtIndexOrDefault(c.lineWidth,0),s.strokeStyle=i.getValueAtIndexOrDefault(c.color,0);var R=a.left,L=a.right,V=a.top,O=a.bottom,z=i.aliasPixel(s.lineWidth);p?(V=O="top"===o.position?a.bottom:a.top,V+=z,O+=z):(R=L="left"===o.position?a.right:a.left,R+=z,L+=z),s.beginPath(),s.moveTo(R,V),s.lineTo(L,O),s.stroke()}}}})}},{}],32:[function(t,e,n){"use strict";e.exports=function(t){var e=t.helpers;t.scaleService={constructors:{},defaults:{},registerScaleType:function(t,n,i){this.constructors[t]=n,this.defaults[t]=e.clone(i)},getScaleConstructor:function(t){return this.constructors.hasOwnProperty(t)?this.constructors[t]:void 0},getScaleDefaults:function(n){return this.defaults.hasOwnProperty(n)?e.scaleMerge(t.defaults.scale,this.defaults[n]):{}},updateScaleDefaults:function(t,n){var i=this.defaults;i.hasOwnProperty(t)&&(i[t]=e.extend(i[t],n))},addScalesToLayout:function(n){e.each(n.scales,function(e){e.fullWidth=e.options.fullWidth,e.position=e.options.position,e.weight=e.options.weight,t.layoutService.addBox(n,e)})}}}},{}],33:[function(t,e,n){"use strict";e.exports=function(t){var e=t.helpers;t.Ticks={generators:{linear:function(t,n){var i,a=[];if(t.stepSize&&t.stepSize>0)i=t.stepSize;else{var o=e.niceNum(n.max-n.min,!1);i=e.niceNum(o/(t.maxTicks-1),!0)}var r=Math.floor(n.min/i)*i,l=Math.ceil(n.max/i)*i;t.min&&t.max&&t.stepSize&&e.almostWhole((t.max-t.min)/t.stepSize,i/1e3)&&(r=t.min,l=t.max);var s=(l-r)/i;s=e.almostEquals(s,Math.round(s),i/1e3)?Math.round(s):Math.ceil(s),a.push(void 0!==t.min?t.min:r);for(var u=1;u<s;++u)a.push(r+u*i);return a.push(void 0!==t.max?t.max:l),a},logarithmic:function(t,n){var i,a,o=[],r=e.getValueOrDefault,l=r(t.min,Math.pow(10,Math.floor(e.log10(n.min)))),s=Math.floor(e.log10(n.max)),u=Math.ceil(n.max/Math.pow(10,s));0===l?(i=Math.floor(e.log10(n.minNotZero)),a=Math.floor(n.minNotZero/Math.pow(10,i)),o.push(l),l=a*Math.pow(10,i)):(i=Math.floor(e.log10(l)),a=Math.floor(l/Math.pow(10,i)));do o.push(l),++a,10===a&&(a=1,++i),l=a*Math.pow(10,i);while(i<s||i===s&&a<u);var d=r(t.max,l);return o.push(d),o}},formatters:{values:function(t){return e.isArray(t)?t:""+t},linear:function(t,n,i){var a=i.length>3?i[2]-i[1]:i[1]-i[0];Math.abs(a)>1&&t!==Math.floor(t)&&(a=t-Math.floor(t));var o=e.log10(Math.abs(a)),r="";if(0!==t){var l=-1*Math.floor(o);l=Math.max(Math.min(l,20),0),r=t.toFixed(l)}else r="0";return r},logarithmic:function(t,n,i){var a=t/Math.pow(10,Math.floor(e.log10(t)));return 0===t?"0":1===a||2===a||5===a||0===n||n===i.length-1?t.toExponential():""}}}}},{}],34:[function(t,e,n){"use strict";e.exports=function(t){function e(t,e){var n=s.color(t);return n.alpha(e*n.alpha()).rgbaString()}function n(t,e){return e&&(s.isArray(e)?Array.prototype.push.apply(t,e):t.push(e)),t}function i(t){var e=t._xScale,n=t._yScale||t._scale,i=t._index,a=t._datasetIndex;return{xLabel:e?e.getLabelForIndex(i,a):"",yLabel:n?n.getLabelForIndex(i,a):"",index:i,datasetIndex:a,x:t._model.x,y:t._model.y}}function a(e){var n=t.defaults.global,i=s.getValueOrDefault;return{xPadding:e.xPadding,yPadding:e.yPadding,xAlign:e.xAlign,yAlign:e.yAlign,bodyFontColor:e.bodyFontColor,_bodyFontFamily:i(e.bodyFontFamily,n.defaultFontFamily),_bodyFontStyle:i(e.bodyFontStyle,n.defaultFontStyle),_bodyAlign:e.bodyAlign,bodyFontSize:i(e.bodyFontSize,n.defaultFontSize),bodySpacing:e.bodySpacing,titleFontColor:e.titleFontColor,_titleFontFamily:i(e.titleFontFamily,n.defaultFontFamily),_titleFontStyle:i(e.titleFontStyle,n.defaultFontStyle),titleFontSize:i(e.titleFontSize,n.defaultFontSize),_titleAlign:e.titleAlign,titleSpacing:e.titleSpacing,titleMarginBottom:e.titleMarginBottom,footerFontColor:e.footerFontColor,_footerFontFamily:i(e.footerFontFamily,n.defaultFontFamily),_footerFontStyle:i(e.footerFontStyle,n.defaultFontStyle),footerFontSize:i(e.footerFontSize,n.defaultFontSize),_footerAlign:e.footerAlign,footerSpacing:e.footerSpacing,footerMarginTop:e.footerMarginTop,caretSize:e.caretSize,cornerRadius:e.cornerRadius,backgroundColor:e.backgroundColor,opacity:0,legendColorBackground:e.multiKeyBackground,displayColors:e.displayColors,borderColor:e.borderColor,borderWidth:e.borderWidth}}function o(t,e){var n=t._chart.ctx,i=2*e.yPadding,a=0,o=e.body,r=o.reduce(function(t,e){return t+e.before.length+e.lines.length+e.after.length},0);r+=e.beforeBody.length+e.afterBody.length;var l=e.title.length,u=e.footer.length,d=e.titleFontSize,c=e.bodyFontSize,h=e.footerFontSize;i+=l*d,i+=l?(l-1)*e.titleSpacing:0,i+=l?e.titleMarginBottom:0,i+=r*c,i+=r?(r-1)*e.bodySpacing:0,i+=u?e.footerMarginTop:0,i+=u*h,i+=u?(u-1)*e.footerSpacing:0;var f=0,g=function(t){a=Math.max(a,n.measureText(t).width+f)};return n.font=s.fontString(d,e._titleFontStyle,e._titleFontFamily),s.each(e.title,g),n.font=s.fontString(c,e._bodyFontStyle,e._bodyFontFamily),s.each(e.beforeBody.concat(e.afterBody),g),f=e.displayColors?c+2:0,s.each(o,function(t){s.each(t.before,g),s.each(t.lines,g),s.each(t.after,g)}),f=0,n.font=s.fontString(h,e._footerFontStyle,e._footerFontFamily),s.each(e.footer,g),a+=2*e.xPadding,{width:a,height:i}}function r(t,e){var n=t._model,i=t._chart,a=t._chart.chartArea,o="center",r="center";n.y<e.height?r="top":n.y>i.height-e.height&&(r="bottom");var l,s,u,d,c,h=(a.left+a.right)/2,f=(a.top+a.bottom)/2;"center"===r?(l=function(t){return t<=h},s=function(t){return t>h}):(l=function(t){return t<=e.width/2},s=function(t){return t>=i.width-e.width/2}),u=function(t){return t+e.width>i.width},d=function(t){return t-e.width<0},c=function(t){return t<=f?"top":"bottom"},l(n.x)?(o="left",u(n.x)&&(o="center",r=c(n.y))):s(n.x)&&(o="right",d(n.x)&&(o="center",r=c(n.y)));var g=t._options;return{xAlign:g.xAlign?g.xAlign:o,yAlign:g.yAlign?g.yAlign:r}}function l(t,e,n){var i=t.x,a=t.y,o=t.caretSize,r=t.caretPadding,l=t.cornerRadius,s=n.xAlign,u=n.yAlign,d=o+r,c=l+r;return"right"===s?i-=e.width:"center"===s&&(i-=e.width/2),"top"===u?a+=d:a-="bottom"===u?e.height+d:e.height/2,"center"===u?"left"===s?i+=d:"right"===s&&(i-=d):"left"===s?i-=c:"right"===s&&(i+=c),{x:i,y:a}}var s=t.helpers;t.defaults.global.tooltips={enabled:!0,custom:null,mode:"nearest",position:"average",intersect:!0,backgroundColor:"rgba(0,0,0,0.8)",titleFontStyle:"bold",titleSpacing:2,titleMarginBottom:6,titleFontColor:"#fff",titleAlign:"left",bodySpacing:2,bodyFontColor:"#fff",bodyAlign:"left",footerFontStyle:"bold",footerSpacing:2,footerMarginTop:6,footerFontColor:"#fff",footerAlign:"left",yPadding:6,xPadding:6,caretPadding:2,caretSize:5,cornerRadius:6,multiKeyBackground:"#fff",displayColors:!0,borderColor:"rgba(0,0,0,0)",borderWidth:0,callbacks:{beforeTitle:s.noop,title:function(t,e){var n="",i=e.labels,a=i?i.length:0;if(t.length>0){var o=t[0];o.xLabel?n=o.xLabel:a>0&&o.index<a&&(n=i[o.index])}return n},afterTitle:s.noop,beforeBody:s.noop,beforeLabel:s.noop,label:function(t,e){var n=e.datasets[t.datasetIndex].label||"",i=e.datasets[t.datasetIndex].minData;return n&&(n+=": "),n+=t.yLabel,void 0!==i&&t.index in i&&0!==i[t.index]&&(n+="/",n+=i[t.index]),n},labelColor:function(t,e){var n=e.getDatasetMeta(t.datasetIndex),i=n.data[t.index],a=i._view;return{borderColor:a.borderColor,backgroundColor:a.backgroundColor}},afterLabel:s.noop,afterBody:s.noop,beforeFooter:s.noop,footer:s.noop,afterFooter:s.noop}},t.Tooltip=t.Element.extend({initialize:function(){this._model=a(this._options)},getTitle:function(){var t=this,e=t._options,i=e.callbacks,a=i.beforeTitle.apply(t,arguments),o=i.title.apply(t,arguments),r=i.afterTitle.apply(t,arguments),l=[];return l=n(l,a),l=n(l,o),l=n(l,r)},getBeforeBody:function(){var t=this._options.callbacks.beforeBody.apply(this,arguments);return s.isArray(t)?t:void 0!==t?[t]:[]},getBody:function(t,e){var i=this,a=i._options.callbacks,o=[];return s.each(t,function(t){var r={before:[],lines:[],after:[]};n(r.before,a.beforeLabel.call(i,t,e)),n(r.lines,a.label.call(i,t,e)),n(r.after,a.afterLabel.call(i,t,e)),o.push(r)}),o},getAfterBody:function(){var t=this._options.callbacks.afterBody.apply(this,arguments);return s.isArray(t)?t:void 0!==t?[t]:[]},getFooter:function(){var t=this,e=t._options.callbacks,i=e.beforeFooter.apply(t,arguments),a=e.footer.apply(t,arguments),o=e.afterFooter.apply(t,arguments),r=[];return r=n(r,i),r=n(r,a),r=n(r,o)},update:function(e){var n,u,d=this,c=d._options,h=d._model,f=d._model=a(c),g=d._active,p=d._data,m={xAlign:h.xAlign,yAlign:h.yAlign},v={x:h.x,y:h.y},b={width:h.width,height:h.height},x={x:h.caretX,y:h.caretY};if(g.length){f.opacity=1;var y=[];x=t.Tooltip.positioners[c.position](g,d._eventPosition);var k=[];for(n=0,u=g.length;n<u;++n)k.push(i(g[n]));c.filter&&(k=k.filter(function(t){return c.filter(t,p)})),c.itemSort&&(k=k.sort(function(t,e){return c.itemSort(t,e,p)})),s.each(k,function(t){y.push(c.callbacks.labelColor.call(d,t,d._chart))}),f.title=d.getTitle(k,p),f.beforeBody=d.getBeforeBody(k,p),f.body=d.getBody(k,p),f.afterBody=d.getAfterBody(k,p),f.footer=d.getFooter(k,p),f.x=Math.round(x.x),f.y=Math.round(x.y),f.caretPadding=c.caretPadding,f.labelColors=y,f.dataPoints=k,b=o(this,f),m=r(this,b),v=l(f,b,m)}else f.opacity=0;return f.xAlign=m.xAlign,f.yAlign=m.yAlign,f.x=v.x,f.y=v.y,f.width=b.width,f.height=b.height,f.caretX=x.x,f.caretY=x.y,d._model=f,e&&c.custom&&c.custom.call(d,f),d},drawCaret:function(t,e){var n=this._chart.ctx,i=this._view,a=this.getCaretPosition(t,e,i);n.lineTo(a.x1,a.y1),n.lineTo(a.x2,a.y2),n.lineTo(a.x3,a.y3)},getCaretPosition:function(t,e,n){var i,a,o,r,l,s,u=n.caretSize,d=n.cornerRadius,c=n.xAlign,h=n.yAlign,f=t.x,g=t.y,p=e.width,m=e.height;if("center"===h)l=g+m/2,"left"===c?(i=f,a=i-u,o=i,r=l+u,s=l-u):(i=f+p,a=i+u,o=i,r=l-u,s=l+u);else if("left"===c?(a=f+d+u,i=a-u,o=a+u):"right"===c?(a=f+p-d-u,i=a-u,o=a+u):(a=f+p/2,i=a-u,o=a+u),"top"===h)r=g,l=r-u,s=r;else{r=g+m,l=r+u,s=r;var v=o;o=i,i=v}return{x1:i,x2:a,x3:o,y1:r,y2:l,y3:s}},drawTitle:function(t,n,i,a){var o=n.title;if(o.length){i.textAlign=n._titleAlign,i.textBaseline="top";var r=n.titleFontSize,l=n.titleSpacing;i.fillStyle=e(n.titleFontColor,a),i.font=s.fontString(r,n._titleFontStyle,n._titleFontFamily);var u,d;for(u=0,d=o.length;u<d;++u)i.fillText(o[u],t.x,t.y),t.y+=r+l,u+1===o.length&&(t.y+=n.titleMarginBottom-l)}},drawBody:function(t,n,i,a){var o=n.bodyFontSize,r=n.bodySpacing,l=n.body;i.textAlign=n._bodyAlign,i.textBaseline="top";var u=e(n.bodyFontColor,a);i.fillStyle=u,i.font=s.fontString(o,n._bodyFontStyle,n._bodyFontFamily);var d=0,c=function(e){i.fillText(e,t.x+d,t.y),t.y+=o+r};s.each(n.beforeBody,c);var h=n.displayColors;d=h?o+2:0,s.each(l,function(r,l){s.each(r.before,c),s.each(r.lines,function(r){h&&(i.fillStyle=e(n.legendColorBackground,a),i.fillRect(t.x,t.y,o,o),i.strokeStyle=e(n.labelColors[l].borderColor,a),i.strokeRect(t.x,t.y,o,o),i.fillStyle=e(n.labelColors[l].backgroundColor,a),i.fillRect(t.x+1,t.y+1,o-2,o-2),i.fillStyle=u),c(r)}),s.each(r.after,c)}),d=0,s.each(n.afterBody,c),t.y-=r},drawFooter:function(t,n,i,a){var o=n.footer;o.length&&(t.y+=n.footerMarginTop,i.textAlign=n._footerAlign,i.textBaseline="top",i.fillStyle=e(n.footerFontColor,a),i.font=s.fontString(n.footerFontSize,n._footerFontStyle,n._footerFontFamily),s.each(o,function(e){i.fillText(e,t.x,t.y),t.y+=n.footerFontSize+n.footerSpacing}))},drawBackground:function(t,n,i,a,o){i.fillStyle=e(n.backgroundColor,o),i.strokeStyle=e(n.borderColor,o),i.lineWidth=n.borderWidth;var r=n.xAlign,l=n.yAlign,s=t.x,u=t.y,d=a.width,c=a.height,h=n.cornerRadius;i.beginPath(),i.moveTo(s+h,u),"top"===l&&this.drawCaret(t,a),i.lineTo(s+d-h,u),i.quadraticCurveTo(s+d,u,s+d,u+h),"center"===l&&"right"===r&&this.drawCaret(t,a),i.lineTo(s+d,u+c-h),i.quadraticCurveTo(s+d,u+c,s+d-h,u+c),"bottom"===l&&this.drawCaret(t,a),i.lineTo(s+h,u+c),i.quadraticCurveTo(s,u+c,s,u+c-h),"center"===l&&"left"===r&&this.drawCaret(t,a),i.lineTo(s,u+h),i.quadraticCurveTo(s,u,s+h,u),i.closePath(),i.fill(),n.borderWidth>0&&i.stroke()},draw:function(){var t=this._chart.ctx,e=this._view;if(0!==e.opacity){var n={width:e.width,height:e.height},i={x:e.x,y:e.y},a=Math.abs(e.opacity<.001)?0:e.opacity,o=e.title.length||e.beforeBody.length||e.body.length||e.afterBody.length||e.footer.length;this._options.enabled&&o&&(this.drawBackground(i,e,t,n,a),i.x+=e.xPadding,i.y+=e.yPadding,this.drawTitle(i,e,t,a),this.drawBody(i,e,t,a),this.drawFooter(i,e,t,a))}},handleEvent:function(t){var e=this,n=e._options,i=!1;if(e._lastActive=e._lastActive||[],"mouseout"===t.type?e._active=[]:e._active=e._chart.getElementsAtEventForMode(t,n.mode,n),i=!s.arrayEquals(e._active,e._lastActive),!i)return!1;if(e._lastActive=e._active,n.enabled||n.custom){e._eventPosition={x:t.x,y:t.y};var a=e._model;e.update(!0),e.pivot(),i|=a.x!==e._model.x||a.y!==e._model.y}return i}}),t.Tooltip.positioners={average:function(t){if(!t.length)return!1;var e,n,i=0,a=0,o=0;for(e=0,n=t.length;e<n;++e){var r=t[e];if(r&&r.hasValue()){var l=r.tooltipPosition();i+=l.x,a+=l.y,++o}}return{x:Math.round(i/o),y:Math.round(a/o)}},nearest:function(t,e){var n,i,a,o=e.x,r=e.y,l=Number.POSITIVE_INFINITY;for(i=0,a=t.length;i<a;++i){var u=t[i];if(u&&u.hasValue()){var d=u.getCenterPoint(),c=s.distanceBetweenPoints(e,d);c<l&&(l=c,n=u)}}if(n){var h=n.tooltipPosition();o=h.x,r=h.y}return{x:o,y:r}}}}},{}],35:[function(t,e,n){"use strict";e.exports=function(t){var e=t.helpers,n=t.defaults.global;n.elements.arc={backgroundColor:n.defaultColor,borderColor:"#fff",borderWidth:2},t.elements.Arc=t.Element.extend({inLabelRange:function(t){var e=this._view;return!!e&&Math.pow(t-e.x,2)<Math.pow(e.radius+e.hoverRadius,2)},inRange:function(t,n){var i=this._view;if(i){for(var a=e.getAngleFromPoint(i,{x:t,y:n}),o=a.angle,r=a.distance,l=i.startAngle,s=i.endAngle;s<l;)s+=2*Math.PI;for(;o>s;)o-=2*Math.PI;for(;o<l;)o+=2*Math.PI;var u=o>=l&&o<=s,d=r>=i.innerRadius&&r<=i.outerRadius;return u&&d}return!1},getCenterPoint:function(){var t=this._view,e=(t.startAngle+t.endAngle)/2,n=(t.innerRadius+t.outerRadius)/2;return{x:t.x+Math.cos(e)*n,y:t.y+Math.sin(e)*n}},getArea:function(){var t=this._view;return Math.PI*((t.endAngle-t.startAngle)/(2*Math.PI))*(Math.pow(t.outerRadius,2)-Math.pow(t.innerRadius,2))},tooltipPosition:function(){var t=this._view,e=t.startAngle+(t.endAngle-t.startAngle)/2,n=(t.outerRadius-t.innerRadius)/2+t.innerRadius;return{x:t.x+Math.cos(e)*n,y:t.y+Math.sin(e)*n}},draw:function(){var t=this._chart.ctx,e=this._view,n=e.startAngle,i=e.endAngle;t.beginPath(),t.arc(e.x,e.y,e.outerRadius,n,i),t.arc(e.x,e.y,e.innerRadius,i,n,!0),t.closePath(),t.strokeStyle=e.borderColor,t.lineWidth=e.borderWidth,t.fillStyle=e.backgroundColor,t.fill(),t.lineJoin="bevel",e.borderWidth&&t.stroke()}})}},{}],36:[function(t,e,n){"use strict";e.exports=function(t){var e=t.helpers,n=t.defaults.global;t.defaults.global.elements.line={tension:.4,backgroundColor:n.defaultColor,borderWidth:3,borderColor:n.defaultColor,borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",capBezierPoints:!0,fill:!0},t.elements.Line=t.Element.extend({draw:function(){var t,i,a,o,r=this,l=r._view,s=r._chart.ctx,u=l.spanGaps,d=r._children.slice(),c=n.elements.line,h=-1;for(r._loop&&d.length&&d.push(d[0]),s.save(),s.lineCap=l.borderCapStyle||c.borderCapStyle,s.setLineDash&&s.setLineDash(l.borderDash||c.borderDash),s.lineDashOffset=l.borderDashOffset||c.borderDashOffset,s.lineJoin=l.borderJoinStyle||c.borderJoinStyle,s.lineWidth=l.borderWidth||c.borderWidth,s.strokeStyle=l.borderColor||n.defaultColor,s.beginPath(),h=-1,t=0;t<d.length;++t)i=d[t],a=e.previousItem(d,t),o=i._view,0===t?o.skip||(s.moveTo(o.x,o.y),h=t):(a=h===-1?a:d[h],o.skip||(h!==t-1&&!u||h===-1?s.moveTo(o.x,o.y):e.canvas.lineTo(s,a._view,i._view),h=t));s.stroke(),s.restore()}})}},{}],37:[function(t,e,n){"use strict";e.exports=function(t){function e(t){var e=this._view;return!!e&&Math.pow(t-e.x,2)<Math.pow(e.radius+e.hitRadius,2)}function n(t){var e=this._view;return!!e&&Math.pow(t-e.y,2)<Math.pow(e.radius+e.hitRadius,2)}var i=t.helpers,a=t.defaults.global,o=a.defaultColor;a.elements.point={radius:3,pointStyle:"circle",backgroundColor:o,borderWidth:1,borderColor:o,hitRadius:1,hoverRadius:4,hoverBorderWidth:1},t.elements.Point=t.Element.extend({inRange:function(t,e){var n=this._view;return!!n&&Math.pow(t-n.x,2)+Math.pow(e-n.y,2)<Math.pow(n.hitRadius+n.radius,2)},inLabelRange:e,inXRange:e,inYRange:n,getCenterPoint:function(){var t=this._view;return{x:t.x,y:t.y}},getArea:function(){return Math.PI*Math.pow(this._view.radius,2)},tooltipPosition:function(){var t=this._view;return{x:t.x,y:t.y,padding:t.radius+t.borderWidth}},draw:function(e){var n=this._view,r=this._model,l=this._chart.ctx,s=n.pointStyle,u=n.radius,d=n.x,c=n.y,h=t.helpers.color,f=1.01,g=0;n.skip||(l.strokeStyle=n.borderColor||o,l.lineWidth=i.getValueOrDefault(n.borderWidth,a.elements.point.borderWidth),l.fillStyle=n.backgroundColor||o,void 0!==e&&(r.x<e.left||e.right*f<r.x||r.y<e.top||e.bottom*f<r.y)&&(r.x<e.left?g=(d-r.x)/(e.left-r.x):e.right*f<r.x?g=(r.x-d)/(r.x-e.right):r.y<e.top?g=(c-r.y)/(e.top-r.y):e.bottom*f<r.y&&(g=(r.y-c)/(r.y-e.bottom)),g=Math.round(100*g)/100,l.strokeStyle=h(l.strokeStyle).alpha(g).rgbString(),l.fillStyle=h(l.fillStyle).alpha(g).rgbString()),t.canvasHelpers.drawPoint(l,s,u,d,c))}})}},{}],38:[function(t,e,n){"use strict";e.exports=function(t){function e(t){return void 0!==t._view.width}function n(t){var n,i,a,o,r=t._view;if(e(t)){var l=r.width/2;n=r.x-l,i=r.x+l,a=Math.min(r.y,r.base),o=Math.max(r.y,r.base)}else{var s=r.height/2;n=Math.min(r.x,r.base),i=Math.max(r.x,r.base),a=r.y-s,o=r.y+s}return{left:n,top:a,right:i,bottom:o}}var i=t.defaults.global;i.elements.rectangle={backgroundColor:i.defaultColor,borderWidth:0,borderColor:i.defaultColor,borderSkipped:"bottom"},t.elements.Rectangle=t.Element.extend({draw:function(){function t(t){return v[(x+t)%4]}var e,n,i,a,o,r,l,s=this._chart.ctx,u=this._view,d=u.borderWidth;if(u.horizontal?(e=u.base,n=u.x,i=u.y-u.height/2,a=u.y+u.height/2,o=n>e?1:-1,r=1,l=u.borderSkipped||"left"):(e=u.x-u.width/2,n=u.x+u.width/2,i=u.y,a=u.base,o=1,r=a>i?1:-1,l=u.borderSkipped||"bottom"),d){var c=Math.min(Math.abs(e-n),Math.abs(i-a));d=d>c?c:d;var h=d/2,f=e+("left"!==l?h*o:0),g=n+("right"!==l?-h*o:0),p=i+("top"!==l?h*r:0),m=a+("bottom"!==l?-h*r:0);f!==g&&(i=p,a=m),p!==m&&(e=f,n=g)}s.beginPath(),s.fillStyle=u.backgroundColor,s.strokeStyle=u.borderColor,s.lineWidth=d;var v=[[e,a],[e,i],[n,i],[n,a]],b=["bottom","left","top","right"],x=b.indexOf(l,0);x===-1&&(x=0);var y=t(0);s.moveTo(y[0],y[1]);for(var k=1;k<4;k++)y=t(k),s.lineTo(y[0],y[1]);s.fill(),d&&s.stroke()},height:function(){var t=this._view;return t.base-t.y},inRange:function(t,e){var i=!1;if(this._view){var a=n(this);i=t>=a.left&&t<=a.right&&e>=a.top&&e<=a.bottom}return i},inLabelRange:function(t,i){var a=this;if(!a._view)return!1;var o=!1,r=n(a);return o=e(a)?t>=r.left&&t<=r.right:i>=r.top&&i<=r.bottom},inXRange:function(t){var e=n(this);return t>=e.left&&t<=e.right},inYRange:function(t){var e=n(this);return t>=e.top&&t<=e.bottom},getCenterPoint:function(){var t,n,i=this._view;return e(this)?(t=i.x,n=(i.y+i.base)/2):(t=(i.x+i.base)/2,n=i.y),{x:t,y:n}},getArea:function(){var t=this._view;return t.width*Math.abs(t.y-t.base)},tooltipPosition:function(){var t=this._view;return{x:t.x,y:t.y}}})}},{}],39:[function(t,e,n){"use strict";e.exports=function(t){function e(t,e){var n=s.getStyle(t,e),i=n&&n.match(/^(\d+)(\.\d+)?px$/);return i?Number(i[1]):void 0}function n(t,n){var i=t.style,a=t.getAttribute("height"),o=t.getAttribute("width");if(t._chartjs={initial:{height:a,width:o,style:{display:i.display,height:i.height,width:i.width}}},i.display=i.display||"block",null===o||""===o){var r=e(t,"width");void 0!==r&&(t.width=r)}if(null===a||""===a)if(""===t.style.height)t.height=t.width/(n.options.aspectRatio||2);else{var l=e(t,"height");void 0!==r&&(t.height=l)}return t}function i(t,e,n,i,a){return{type:t,chart:e,native:a||null,x:void 0!==n?n:null,y:void 0!==i?i:null}}function a(t,e){var n=u[t.type]||t.type,a=s.getRelativePosition(t,e);return i(n,e,a.x,a.y,t)}function o(t){var e=document.createElement("iframe");return e.className="chartjs-hidden-iframe",e.style.cssText="display:block;overflow:hidden;border:0;margin:0;top:0;left:0;bottom:0;right:0;height:100%;width:100%;position:absolute;pointer-events:none;z-index:-1;",e.tabIndex=-1,s.addEvent(e,"load",function(){s.addEvent(e.contentWindow||e,"resize",t),t()}),e}function r(t,e,n){var a=t._chartjs={ticking:!1},r=function(){a.ticking||(a.ticking=!0,s.requestAnimFrame.call(window,function(){if(a.resizer)return a.ticking=!1,e(i("resize",n))}))};a.resizer=o(r),t.insertBefore(a.resizer,t.firstChild)}function l(t){if(t&&t._chartjs){var e=t._chartjs.resizer;e&&(e.parentNode.removeChild(e),t._chartjs.resizer=null),delete t._chartjs}}var s=t.helpers,u={touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"};return{acquireContext:function(t,e){"string"==typeof t?t=document.getElementById(t):t.length&&(t=t[0]),t&&t.canvas&&(t=t.canvas);var i=t&&t.getContext&&t.getContext("2d");return i&&i.canvas===t?(n(t,e),i):null},releaseContext:function(t){var e=t.canvas;if(e._chartjs){var n=e._chartjs.initial;["height","width"].forEach(function(t){var i=n[t];void 0===i||null===i?e.removeAttribute(t):e.setAttribute(t,i)}),s.each(n.style||{},function(t,n){e.style[n]=t}),e.width=e.width,delete e._chartjs}},addEventListener:function(t,e,n){var i=t.canvas;if("resize"===e)return void r(i.parentNode,n,t);var o=n._chartjs||(n._chartjs={}),l=o.proxies||(o.proxies={}),u=l[t.id+"_"+e]=function(e){n(a(e,t))};s.addEvent(i,e,u)},removeEventListener:function(t,e,n){var i=t.canvas;if("resize"===e)return void l(i.parentNode,n);var a=n._chartjs||{},o=a.proxies||{},r=o[t.id+"_"+e];r&&s.removeEvent(i,e,r)}}}},{}],40:[function(t,e,n){"use strict";var i=t(39);e.exports=function(t){t.platform={acquireContext:function(){},releaseContext:function(){},addEventListener:function(){},removeEventListener:function(){}},t.helpers.extend(t.platform,i(t))}},{39:39}],41:[function(t,e,n){"use strict";e.exports=function(t){function e(t,e,n){var i,a=t._model||{},o=a.fill;if(void 0===o&&(o=!!a.backgroundColor),o===!1||null===o)return!1;if(o===!0)return"origin";if(i=parseFloat(o,10),isFinite(i)&&Math.floor(i)===i)return"-"!==o[0]&&"+"!==o[0]||(i=e+i),!(i===e||i<0||i>=n)&&i;switch(o){case"bottom":return"start";case"top":return"end";case"zero":return"origin";case"origin":case"start":case"end":return o;default:return!1}}function n(t){var e,n=t.el._model||{},i=t.el._scale||{},a=t.fill,o=null;if(isFinite(a))return null;if("start"===a?o=void 0===n.scaleBottom?i.bottom:n.scaleBottom:"end"===a?o=void 0===n.scaleTop?i.top:n.scaleTop:void 0!==n.scaleZero?o=n.scaleZero:i.getBasePosition?o=i.getBasePosition():i.getBasePixel&&(o=i.getBasePixel()),void 0!==o&&null!==o){if(void 0!==o.x&&void 0!==o.y)return o;if("number"==typeof o&&isFinite(o))return e=i.isHorizontal(),{x:e?o:null,y:e?null:o}}return null}function i(t,e,n){var i,a=t[e],o=a.fill,r=[e];if(!n)return o;for(;o!==!1&&r.indexOf(o)===-1;){if(!isFinite(o))return o;if(i=t[o],!i)return!1;if(i.visible)return o;r.push(o),o=i.fill}return!1}function a(t){var e=t.fill,n="dataset";return e===!1?null:(isFinite(e)||(n="boundary"),d[n](t))}function o(t){return t&&!t.skip}function r(t,e,n,i,a){var o;if(i&&a){for(t.moveTo(e[0].x,e[0].y),o=1;o<i;++o)u.canvas.lineTo(t,e[o-1],e[o]);for(t.lineTo(n[a-1].x,n[a-1].y),o=a-1;o>0;--o)u.canvas.lineTo(t,n[o],n[o-1],!0)}}function l(t,e,n,i,a,l){var s,u,d,c,h,f,g,p=e.length,m=i.spanGaps,v=[],b=[],x=0,y=0;for(t.beginPath(),s=0,u=p+!!l;s<u;++s)d=s%p,c=e[d]._view,h=n(c,d,i),f=o(c),g=o(h),f&&g?(x=v.push(c),y=b.push(h)):x&&y&&(m?(f&&v.push(c),g&&b.push(h)):(r(t,v,b,x,y),x=y=0,v=[],b=[]));r(t,v,b,x,y),t.closePath(),t.fillStyle=a,t.fill()}t.defaults.global.plugins.filler={propagate:!0};var s=t.defaults,u=t.helpers,d={dataset:function(t){var e=t.fill,n=t.chart,i=n.getDatasetMeta(e),a=i&&n.isDatasetVisible(e),o=a&&i.dataset._children||[];return o.length?function(t,e){return o[e]._view||null}:null},boundary:function(t){var e=t.boundary,n=e?e.x:null,i=e?e.y:null;return function(t){return{x:null===n?t.x:n,y:null===i?t.y:i}}}};return{id:"filler",afterDatasetsUpdate:function(o,r){var l,s,u,d,c=(o.data.datasets||[]).length,h=r.propagate,f=[];for(s=0;s<c;++s)l=o.getDatasetMeta(s),u=l.dataset,d=null,u&&u._model&&u instanceof t.elements.Line&&(d={visible:o.isDatasetVisible(s),fill:e(u,s,c),chart:o,el:u}),l.$filler=d,f.push(d);for(s=0;s<c;++s)d=f[s],d&&(d.fill=i(f,s,h),d.boundary=n(d),d.mapper=a(d))},beforeDatasetDraw:function(t,e){var n=e.meta.$filler;if(n){var i=n.el,a=i._view,o=i._children||[],r=n.mapper,u=a.backgroundColor||s.global.defaultColor;r&&u&&o.length&&l(t.ctx,o,r,a,u,i._loop)}}}}},{}],42:[function(t,e,n){"use strict";e.exports=function(t){function e(t,e){return t.usePointStyle?e*Math.SQRT2:t.boxWidth}function n(e,n){var i=new t.Legend({ctx:e.ctx,options:n,chart:e});a.configure(e,i,n),a.addBox(e,i),e.legend=i}var i=t.helpers,a=t.layoutService,o=i.noop;return t.defaults.global.legend={display:!0,position:"top",fullWidth:!0,reverse:!1,weight:1e3,onClick:function(t,e){var n=e.datasetIndex,i=this.chart,a=i.getDatasetMeta(n);a.hidden=null===a.hidden?!i.data.datasets[n].hidden:null,i.update()},onHover:null,labels:{boxWidth:40,padding:10,generateLabels:function(t){var e=t.data;return i.isArray(e.datasets)?e.datasets.map(function(e,n){return{text:e.label,fillStyle:i.isArray(e.backgroundColor)?e.backgroundColor[0]:e.backgroundColor,hidden:!t.isDatasetVisible(n),lineCap:e.borderCapStyle,lineDash:e.borderDash,lineDashOffset:e.borderDashOffset,lineJoin:e.borderJoinStyle,lineWidth:e.borderWidth,strokeStyle:e.borderColor,pointStyle:e.pointStyle,datasetIndex:n}},this):[]}}},t.Legend=t.Element.extend({initialize:function(t){i.extend(this,t),this.legendHitBoxes=[],this.doughnutMode=!1},beforeUpdate:o,update:function(t,e,n){var i=this;return i.beforeUpdate(),i.maxWidth=t,i.maxHeight=e,i.margins=n,i.beforeSetDimensions(),i.setDimensions(),i.afterSetDimensions(),i.beforeBuildLabels(),i.buildLabels(),i.afterBuildLabels(),i.beforeFit(),i.fit(),i.afterFit(),i.afterUpdate(),i.minSize},afterUpdate:o,beforeSetDimensions:o,setDimensions:function(){var t=this;t.isHorizontal()?(t.width=t.maxWidth,t.left=0,t.right=t.width):(t.height=t.maxHeight,t.top=0,t.bottom=t.height),t.paddingLeft=0,t.paddingTop=0,t.paddingRight=0,t.paddingBottom=0,t.minSize={width:0,height:0}},afterSetDimensions:o,beforeBuildLabels:o,buildLabels:function(){var t=this,e=t.options.labels,n=e.generateLabels.call(t,t.chart);e.filter&&(n=n.filter(function(n){return e.filter(n,t.chart.data)})),t.options.reverse&&n.reverse(),t.legendItems=n},afterBuildLabels:o,beforeFit:o,fit:function(){var n=this,a=n.options,o=a.labels,r=a.display,l=n.ctx,s=t.defaults.global,u=i.getValueOrDefault,d=u(o.fontSize,s.defaultFontSize),c=u(o.fontStyle,s.defaultFontStyle),h=u(o.fontFamily,s.defaultFontFamily),f=i.fontString(d,c,h),g=n.legendHitBoxes=[],p=n.minSize,m=n.isHorizontal();if(m?(p.width=n.maxWidth,p.height=r?10:0):(p.width=r?10:0,p.height=n.maxHeight),r)if(l.font=f,m){var v=n.lineWidths=[0],b=n.legendItems.length?d+o.padding:0;l.textAlign="left",l.textBaseline="top",i.each(n.legendItems,function(t,i){var a=e(o,d),r=a+d/2+l.measureText(t.text).width;v[v.length-1]+r+o.padding>=n.width&&(b+=d+o.padding,v[v.length]=n.left),g[i]={left:0,top:0,width:r,height:d},v[v.length-1]+=r+o.padding}),p.height+=b}else{var x=o.padding,y=n.columnWidths=[],k=o.padding,w=0,M=0,S=d+x;i.each(n.legendItems,function(t,n){var i=e(o,d),a=i+d/2+l.measureText(t.text).width;M+S>p.height&&(k+=w+o.padding,y.push(w),w=0,M=0),w=Math.max(w,a),M+=S,g[n]={left:0,top:0,width:a,height:d}}),k+=w,y.push(w),p.width+=k}n.width=p.width,n.height=p.height},afterFit:o,isHorizontal:function(){return"top"===this.options.position||"bottom"===this.options.position},draw:function(){var n=this,a=n.options,o=a.labels,r=t.defaults.global,l=r.elements.line,s=n.width,u=n.lineWidths;if(a.display){var d,c=n.ctx,h=i.getValueOrDefault,f=h(o.fontColor,r.defaultFontColor),g=h(o.fontSize,r.defaultFontSize),p=h(o.fontStyle,r.defaultFontStyle),m=h(o.fontFamily,r.defaultFontFamily),v=i.fontString(g,p,m);c.textAlign="left",c.textBaseline="top",c.lineWidth=.5,c.strokeStyle=f,c.fillStyle=f,c.font=v;var b=e(o,g),x=n.legendHitBoxes,y=function(e,n,i){if(!(isNaN(b)||b<=0)){c.save(),c.fillStyle=h(i.fillStyle,r.defaultColor),c.lineCap=h(i.lineCap,l.borderCapStyle),c.lineDashOffset=h(i.lineDashOffset,l.borderDashOffset),c.lineJoin=h(i.lineJoin,l.borderJoinStyle),c.lineWidth=h(i.lineWidth,l.borderWidth),c.strokeStyle=h(i.strokeStyle,r.defaultColor);var o=0===h(i.lineWidth,l.borderWidth);if(c.setLineDash&&c.setLineDash(h(i.lineDash,l.borderDash)),a.labels&&a.labels.usePointStyle){var s=g*Math.SQRT2/2,u=s/Math.SQRT2,d=e+u,f=n+u;t.canvasHelpers.drawPoint(c,i.pointStyle,s,d,f)}else o||c.strokeRect(e,n,b,g),c.fillRect(e,n,b,g);c.restore()}},k=function(t,e,n,i){c.fillText(n.text,b+g/2+t,e),n.hidden&&(c.beginPath(),c.lineWidth=2,c.moveTo(b+g/2+t,e+g/2),c.lineTo(b+g/2+t+i,e+g/2),c.stroke())},w=n.isHorizontal();d=w?{x:n.left+(s-u[0])/2,y:n.top+o.padding,line:0}:{x:n.left+o.padding,y:n.top+o.padding,line:0};var M=g+o.padding;i.each(n.legendItems,function(t,e){var i=c.measureText(t.text).width,a=b+g/2+i,r=d.x,l=d.y;w?r+a>=s&&(l=d.y+=M,d.line++,r=d.x=n.left+(s-u[d.line])/2):l+M>n.bottom&&(r=d.x=r+n.columnWidths[d.line]+o.padding,l=d.y=n.top+o.padding,d.line++),y(r,l,t),x[e].left=r,x[e].top=l,k(r,l,t,i),w?d.x+=a+o.padding:d.y+=M})}},handleEvent:function(t){var e=this,n=e.options,i="mouseup"===t.type?"click":t.type,a=!1;if("mousemove"===i){if(!n.onHover)return}else{if("click"!==i)return;if(!n.onClick)return}var o=t.x,r=t.y;if(o>=e.left&&o<=e.right&&r>=e.top&&r<=e.bottom)for(var l=e.legendHitBoxes,s=0;s<l.length;++s){var u=l[s];if(o>=u.left&&o<=u.left+u.width&&r>=u.top&&r<=u.top+u.height){if("click"===i){n.onClick.call(e,t.native,e.legendItems[s]),a=!0;break}if("mousemove"===i){n.onHover.call(e,t.native,e.legendItems[s]),a=!0;break}}}return a}}),{id:"legend",beforeInit:function(t){var e=t.options.legend;e&&n(t,e)},beforeUpdate:function(e){var o=e.options.legend,r=e.legend;o?(o=i.configMerge(t.defaults.global.legend,o),r?(a.configure(e,r,o),r.options=o):n(e,o)):r&&(a.removeBox(e,r),delete e.legend)},afterEvent:function(t,e){var n=t.legend;n&&n.handleEvent(e)}}}},{}],43:[function(t,e,n){"use strict";e.exports=function(t){function e(e,n){var a=new t.Title({ctx:e.ctx,options:n,chart:e});i.configure(e,a,n),i.addBox(e,a),e.titleBlock=a}var n=t.helpers,i=t.layoutService,a=n.noop;return t.defaults.global.title={display:!1,position:"top",
fullWidth:!0,weight:2e3,fontStyle:"bold",padding:10,text:""},t.Title=t.Element.extend({initialize:function(t){var e=this;n.extend(e,t),e.legendHitBoxes=[]},beforeUpdate:a,update:function(t,e,n){var i=this;return i.beforeUpdate(),i.maxWidth=t,i.maxHeight=e,i.margins=n,i.beforeSetDimensions(),i.setDimensions(),i.afterSetDimensions(),i.beforeBuildLabels(),i.buildLabels(),i.afterBuildLabels(),i.beforeFit(),i.fit(),i.afterFit(),i.afterUpdate(),i.minSize},afterUpdate:a,beforeSetDimensions:a,setDimensions:function(){var t=this;t.isHorizontal()?(t.width=t.maxWidth,t.left=0,t.right=t.width):(t.height=t.maxHeight,t.top=0,t.bottom=t.height),t.paddingLeft=0,t.paddingTop=0,t.paddingRight=0,t.paddingBottom=0,t.minSize={width:0,height:0}},afterSetDimensions:a,beforeBuildLabels:a,buildLabels:a,afterBuildLabels:a,beforeFit:a,fit:function(){var e=this,i=n.getValueOrDefault,a=e.options,o=t.defaults.global,r=a.display,l=i(a.fontSize,o.defaultFontSize),s=e.minSize;e.isHorizontal()?(s.width=e.maxWidth,s.height=r?l+2*a.padding:0):(s.width=r?l+2*a.padding:0,s.height=e.maxHeight),e.width=s.width,e.height=s.height},afterFit:a,isHorizontal:function(){var t=this.options.position;return"top"===t||"bottom"===t},draw:function(){var e=this,i=e.ctx,a=n.getValueOrDefault,o=e.options,r=t.defaults.global;if(o.display){var l,s,u,d=a(o.fontSize,r.defaultFontSize),c=a(o.fontStyle,r.defaultFontStyle),h=a(o.fontFamily,r.defaultFontFamily),f=n.fontString(d,c,h),g=0,p=e.top,m=e.left,v=e.bottom,b=e.right;i.fillStyle=a(o.fontColor,r.defaultFontColor),i.font=f,e.isHorizontal()?(l=m+(b-m)/2,s=p+(v-p)/2,u=b-m):(l="left"===o.position?m+d/2:b-d/2,s=p+(v-p)/2,u=v-p,g=Math.PI*("left"===o.position?-.5:.5)),i.save(),i.translate(l,s),i.rotate(g),i.textAlign="center",i.textBaseline="middle",i.fillText(o.text,0,0,u),i.restore()}}}),{id:"title",beforeInit:function(t){var n=t.options.title;n&&e(t,n)},beforeUpdate:function(a){var o=a.options.title,r=a.titleBlock;o?(o=n.configMerge(t.defaults.global.title,o),r?(i.configure(a,r,o),r.options=o):e(a,o)):r&&(t.layoutService.removeBox(a,r),delete a.titleBlock)}}}},{}],44:[function(t,e,n){"use strict";e.exports=function(t){var e=t.helpers,n={position:"bottom"},i=t.Scale.extend({getLabels:function(){var t=this.chart.data;return(this.isHorizontal()?t.xLabels:t.yLabels)||t.labels},determineDataLimits:function(){var t=this,n=t.getLabels();t.minIndex=0,t.maxIndex=n.length-1;var i;void 0!==t.options.ticks.min&&(i=e.indexOf(n,t.options.ticks.min),t.minIndex=i!==-1?i:t.minIndex),void 0!==t.options.ticks.max&&(i=e.indexOf(n,t.options.ticks.max),t.maxIndex=i!==-1?i:t.maxIndex),t.min=n[t.minIndex],t.max=n[t.maxIndex]},buildTicks:function(){var t=this,e=t.getLabels();t.ticks=0===t.minIndex&&t.maxIndex===e.length-1?e:e.slice(t.minIndex,t.maxIndex+1)},getLabelForIndex:function(t,e){var n=this,i=n.chart.data,a=n.isHorizontal();return i.yLabels&&!a?n.getRightValue(i.datasets[e].data[t]):n.ticks[t-n.minIndex]},getPixelForValue:function(t,e,n,i){var a,o=this,r=Math.max(o.maxIndex+1-o.minIndex-(o.options.gridLines.offsetGridLines?0:1),1);if(void 0!==t&&null!==t&&(a=o.isHorizontal()?t.x:t.y),void 0!==a||void 0!==t&&isNaN(e)){var l=o.getLabels();t=a||t;var s=l.indexOf(t);e=s!==-1?s:e}if(o.isHorizontal()){var u=o.width/r,d=u*(e-o.minIndex);return(o.options.gridLines.offsetGridLines&&i||o.maxIndex===o.minIndex&&i)&&(d+=u/2),o.left+Math.round(d)}var c=o.height/r,h=c*(e-o.minIndex);return o.options.gridLines.offsetGridLines&&i&&(h+=c/2),o.top+Math.round(h)},getPixelForTick:function(t,e){return this.getPixelForValue(this.ticks[t],t+this.minIndex,null,e)},getValueForPixel:function(t){var e,n=this,i=Math.max(n.ticks.length-(n.options.gridLines.offsetGridLines?0:1),1),a=n.isHorizontal(),o=(a?n.width:n.height)/i;return t-=a?n.left:n.top,n.options.gridLines.offsetGridLines&&(t-=o/2),e=t<=0?0:Math.round(t/o)},getBasePixel:function(){return this.bottom}});t.scaleService.registerScaleType("category",i,n)}},{}],45:[function(t,e,n){"use strict";e.exports=function(t){var e=t.helpers,n={position:"left",ticks:{callback:t.Ticks.formatters.linear}},i=t.LinearScaleBase.extend({determineDataLimits:function(){function t(t){return l?t.xAxisID===n.id:t.yAxisID===n.id}var n=this,i=n.options,a=n.chart,o=a.data,r=o.datasets,l=n.isHorizontal(),s=0,u=1;n.min=null,n.max=null;var d=i.stacked;if(void 0===d&&e.each(r,function(e,n){if(!d){var i=a.getDatasetMeta(n);a.isDatasetVisible(n)&&t(i)&&void 0!==i.stack&&(d=!0)}}),i.stacked||d){var c={};e.each(r,function(o,r){var l=a.getDatasetMeta(r),s=[l.type,void 0===i.stacked&&void 0===l.stack?r:"",l.stack].join(".");void 0===c[s]&&(c[s]={positiveValues:[],negativeValues:[]});var u=c[s].positiveValues,d=c[s].negativeValues;a.isDatasetVisible(r)&&t(l)&&e.each(o.data,function(t,e){var a=+n.getRightValue(t);isNaN(a)||l.data[e].hidden||(u[e]=u[e]||0,d[e]=d[e]||0,i.relativePoints?u[e]=100:a<0?d[e]+=a:u[e]+=a)})}),e.each(c,function(t){var i=t.positiveValues.concat(t.negativeValues),a=e.min(i),o=e.max(i);n.min=null===n.min?a:Math.min(n.min,a),n.max=null===n.max?o:Math.max(n.max,o)})}else e.each(r,function(i,o){var r=a.getDatasetMeta(o);a.isDatasetVisible(o)&&t(r)&&e.each(i.data,function(t,e){var i=+n.getRightValue(t);isNaN(i)||r.data[e].hidden||(null===n.min?n.min=i:i<n.min&&(n.min=i),null===n.max?n.max=i:i>n.max&&(n.max=i))})});n.min=isFinite(n.min)?n.min:s,n.max=isFinite(n.max)?n.max:u,this.handleTickRangeOptions()},getTickLimit:function(){var n,i=this,a=i.options.ticks;if(i.isHorizontal())n=Math.min(a.maxTicksLimit?a.maxTicksLimit:11,Math.ceil(i.width/50));else{var o=e.getValueOrDefault(a.fontSize,t.defaults.global.defaultFontSize);n=Math.min(a.maxTicksLimit?a.maxTicksLimit:11,Math.ceil(i.height/(2*o)))}return n},handleDirectionalChanges:function(){this.isHorizontal()||this.ticks.reverse()},getLabelForIndex:function(t,e){return+this.getRightValue(this.chart.data.datasets[e].data[t])},getPixelForValue:function(t){var e,n=this,i=n.start,a=+n.getRightValue(t),o=n.end-i;return n.isHorizontal()?(e=n.left+n.width/o*(a-i),Math.round(e)):(e=n.bottom-n.height/o*(a-i),Math.round(e))},getValueForPixel:function(t){var e=this,n=e.isHorizontal(),i=n?e.width:e.height,a=(n?t-e.left:e.bottom-t)/i;return e.start+(e.end-e.start)*a},getPixelForTick:function(t){return this.getPixelForValue(this.ticksAsNumbers[t])}});t.scaleService.registerScaleType("linear",i,n)}},{}],46:[function(t,e,n){"use strict";e.exports=function(t){var e=t.helpers,n=e.noop;t.LinearScaleBase=t.Scale.extend({handleTickRangeOptions:function(){var t=this,n=t.options,i=n.ticks;if(i.beginAtZero){var a=e.sign(t.min),o=e.sign(t.max);a<0&&o<0?t.max=0:a>0&&o>0&&(t.min=0)}void 0!==i.min?t.min=i.min:void 0!==i.suggestedMin&&(null===t.min?t.min=i.suggestedMin:t.min=Math.min(t.min,i.suggestedMin)),void 0!==i.max?t.max=i.max:void 0!==i.suggestedMax&&(null===t.max?t.max=i.suggestedMax:t.max=Math.max(t.max,i.suggestedMax)),t.min===t.max&&(t.max++,i.beginAtZero||t.min--)},getTickLimit:n,handleDirectionalChanges:n,buildTicks:function(){var n=this,i=n.options,a=i.ticks,o=n.getTickLimit();o=Math.max(2,o);var r={maxTicks:o,min:a.min,max:a.max,stepSize:e.getValueOrDefault(a.fixedStepSize,a.stepSize)},l=n.ticks=t.Ticks.generators.linear(r,n);n.handleDirectionalChanges(),n.max=e.max(l),n.min=e.min(l),a.reverse?(l.reverse(),n.start=n.max,n.end=n.min):(n.start=n.min,n.end=n.max)},convertTicksToLabels:function(){var e=this;e.ticksAsNumbers=e.ticks.slice(),e.zeroLineIndex=e.ticks.indexOf(0),t.Scale.prototype.convertTicksToLabels.call(e)}})}},{}],47:[function(t,e,n){"use strict";e.exports=function(t){var e=t.helpers,n={position:"left",ticks:{callback:t.Ticks.formatters.logarithmic}},i=t.Scale.extend({determineDataLimits:function(){function t(t){return u?t.xAxisID===n.id:t.yAxisID===n.id}var n=this,i=n.options,a=i.ticks,o=n.chart,r=o.data,l=r.datasets,s=e.getValueOrDefault,u=n.isHorizontal();n.min=null,n.max=null,n.minNotZero=null;var d=i.stacked;if(void 0===d&&e.each(l,function(e,n){if(!d){var i=o.getDatasetMeta(n);o.isDatasetVisible(n)&&t(i)&&void 0!==i.stack&&(d=!0)}}),i.stacked||d){var c={};e.each(l,function(a,r){var l=o.getDatasetMeta(r),s=[l.type,void 0===i.stacked&&void 0===l.stack?r:"",l.stack].join(".");o.isDatasetVisible(r)&&t(l)&&(void 0===c[s]&&(c[s]=[]),e.each(a.data,function(t,e){var a=c[s],o=+n.getRightValue(t);isNaN(o)||l.data[e].hidden||(a[e]=a[e]||0,i.relativePoints?a[e]=100:a[e]+=o)}))}),e.each(c,function(t){var i=e.min(t),a=e.max(t);n.min=null===n.min?i:Math.min(n.min,i),n.max=null===n.max?a:Math.max(n.max,a)})}else e.each(l,function(i,a){var r=o.getDatasetMeta(a);o.isDatasetVisible(a)&&t(r)&&e.each(i.data,function(t,e){var i=+n.getRightValue(t);isNaN(i)||r.data[e].hidden||(null===n.min?n.min=i:i<n.min&&(n.min=i),null===n.max?n.max=i:i>n.max&&(n.max=i),0!==i&&(null===n.minNotZero||i<n.minNotZero)&&(n.minNotZero=i))})});n.min=s(a.min,n.min),n.max=s(a.max,n.max),n.min===n.max&&(0!==n.min&&null!==n.min?(n.min=Math.pow(10,Math.floor(e.log10(n.min))-1),n.max=Math.pow(10,Math.floor(e.log10(n.max))+1)):(n.min=1,n.max=10))},buildTicks:function(){var n=this,i=n.options,a=i.ticks,o={min:a.min,max:a.max},r=n.ticks=t.Ticks.generators.logarithmic(o,n);n.isHorizontal()||r.reverse(),n.max=e.max(r),n.min=e.min(r),a.reverse?(r.reverse(),n.start=n.max,n.end=n.min):(n.start=n.min,n.end=n.max)},convertTicksToLabels:function(){this.tickValues=this.ticks.slice(),t.Scale.prototype.convertTicksToLabels.call(this)},getLabelForIndex:function(t,e){return+this.getRightValue(this.chart.data.datasets[e].data[t])},getPixelForTick:function(t){return this.getPixelForValue(this.tickValues[t])},getPixelForValue:function(t){var n,i,a,o=this,r=o.start,l=+o.getRightValue(t),s=o.options,u=s.ticks;return o.isHorizontal()?(a=e.log10(o.end)-e.log10(r),0===l?i=o.left:(n=o.width,i=o.left+n/a*(e.log10(l)-e.log10(r)))):(n=o.height,0!==r||u.reverse?0===o.end&&u.reverse?(a=e.log10(o.start)-e.log10(o.minNotZero),i=l===o.end?o.top:l===o.minNotZero?o.top+.02*n:o.top+.02*n+.98*n/a*(e.log10(l)-e.log10(o.minNotZero))):0===l?i=u.reverse?o.top:o.bottom:(a=e.log10(o.end)-e.log10(r),n=o.height,i=o.bottom-n/a*(e.log10(l)-e.log10(r))):(a=e.log10(o.end)-e.log10(o.minNotZero),i=l===r?o.bottom:l===o.minNotZero?o.bottom-.02*n:o.bottom-.02*n-.98*n/a*(e.log10(l)-e.log10(o.minNotZero)))),i},getValueForPixel:function(t){var n,i,a=this,o=e.log10(a.end)-e.log10(a.start);return a.isHorizontal()?(i=a.width,n=a.start*Math.pow(10,(t-a.left)*o/i)):(i=a.height,n=Math.pow(10,(a.bottom-t)*o/i)/a.start),n}});t.scaleService.registerScaleType("logarithmic",i,n)}},{}],48:[function(t,e,n){"use strict";e.exports=function(t){function e(t){var e=t.options;return e.angleLines.display||e.pointLabels.display?t.chart.data.labels.length:0}function n(t){var e=t.options.pointLabels,n=f.getValueOrDefault(e.fontSize,g.defaultFontSize),i=f.getValueOrDefault(e.fontStyle,g.defaultFontStyle),a=f.getValueOrDefault(e.fontFamily,g.defaultFontFamily),o=f.fontString(n,i,a);return{size:n,style:i,family:a,font:o}}function i(t,e,n){return f.isArray(n)?{w:f.longestText(t,t.font,n),h:n.length*e+1.5*(n.length-1)*e}:{w:t.measureText(n).width,h:e}}function a(t,e,n,i,a){return t===i||t===a?{start:e-n/2,end:e+n/2}:t<i||t>a?{start:e-n-5,end:e}:{start:e,end:e+n+5}}function o(t){var o,r,l,s=n(t),u=Math.min(t.height/2,t.width/2),d={r:t.width,l:0,t:t.height,b:0},c={};t.ctx.font=s.font,t._pointLabelSizes=[];var h=e(t);for(o=0;o<h;o++){l=t.getPointPosition(o,u),r=i(t.ctx,s.size,t.pointLabels[o]||""),t._pointLabelSizes[o]=r;var g=t.getIndexAngle(o),p=f.toDegrees(g)%360,m=a(p,l.x,r.w,0,180),v=a(p,l.y,r.h,90,270);m.start<d.l&&(d.l=m.start,c.l=g),m.end>d.r&&(d.r=m.end,c.r=g),v.start<d.t&&(d.t=v.start,c.t=g),v.end>d.b&&(d.b=v.end,c.b=g)}t.setReductions(u,d,c)}function r(t){var e=Math.min(t.height/2,t.width/2);t.drawingArea=Math.round(e),t.setCenterPoint(0,0,0,0)}function l(t){return 0===t||180===t?"center":t<180?"left":"right"}function s(t,e,n,i){if(f.isArray(e))for(var a=n.y,o=1.5*i,r=0;r<e.length;++r)t.fillText(e[r],n.x,a),a+=o;else t.fillText(e,n.x,n.y)}function u(t,e,n){90===t||270===t?n.y-=e.h/2:(t>270||t<90)&&(n.y-=e.h)}function d(t){var i=t.ctx,a=f.getValueOrDefault,o=t.options,r=o.angleLines,d=o.pointLabels;i.lineWidth=r.lineWidth,i.strokeStyle=r.color;var c=t.getDistanceFromCenterForValue(o.reverse?t.min:t.max),h=n(t);i.textBaseline="top";for(var p=e(t)-1;p>=0;p--){if(r.display){var m=t.getPointPosition(p,c);i.beginPath(),i.moveTo(t.xCenter,t.yCenter),i.lineTo(m.x,m.y),i.stroke(),i.closePath()}if(d.display){var v=t.getPointPosition(p,c+5),b=a(d.fontColor,g.defaultFontColor);i.font=h.font,i.fillStyle=b;var x=t.getIndexAngle(p),y=f.toDegrees(x);i.textAlign=l(y),u(y,t._pointLabelSizes[p],v),s(i,t.pointLabels[p]||"",v,h.size)}}}function c(t,n,i,a){var o=t.ctx;if(o.strokeStyle=f.getValueAtIndexOrDefault(n.color,a-1),o.lineWidth=f.getValueAtIndexOrDefault(n.lineWidth,a-1),t.options.gridLines.circular)o.beginPath(),o.arc(t.xCenter,t.yCenter,i,0,2*Math.PI),o.closePath(),o.stroke();else{var r=e(t);if(0===r)return;o.beginPath();var l=t.getPointPosition(0,i);o.moveTo(l.x,l.y);for(var s=1;s<r;s++)l=t.getPointPosition(s,i),o.lineTo(l.x,l.y);o.closePath(),o.stroke()}}function h(t){return f.isNumber(t)?t:0}var f=t.helpers,g=t.defaults.global,p={display:!0,animate:!0,position:"chartArea",angleLines:{display:!0,color:"rgba(0, 0, 0, 0.1)",lineWidth:1},gridLines:{circular:!1},ticks:{showLabelBackdrop:!0,backdropColor:"rgba(255,255,255,0.75)",backdropPaddingY:2,backdropPaddingX:2,callback:t.Ticks.formatters.linear},pointLabels:{display:!0,fontSize:10,callback:function(t){return t}}},m=t.LinearScaleBase.extend({setDimensions:function(){var t=this,e=t.options,n=e.ticks;t.width=t.maxWidth,t.height=t.maxHeight,t.xCenter=Math.round(t.width/2),t.yCenter=Math.round(t.height/2);var i=f.min([t.height,t.width]),a=f.getValueOrDefault(n.fontSize,g.defaultFontSize);t.drawingArea=e.display?i/2-(a/2+n.backdropPaddingY):i/2},determineDataLimits:function(){var t=this,e=t.chart,n=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY;f.each(e.data.datasets,function(a,o){if(e.isDatasetVisible(o)){var r=e.getDatasetMeta(o);f.each(a.data,function(e,a){var o=+t.getRightValue(e);isNaN(o)||r.data[a].hidden||(n=Math.min(o,n),i=Math.max(o,i))})}}),t.min=n===Number.POSITIVE_INFINITY?0:n,t.max=i===Number.NEGATIVE_INFINITY?0:i,t.handleTickRangeOptions()},getTickLimit:function(){var t=this.options.ticks,e=f.getValueOrDefault(t.fontSize,g.defaultFontSize);return Math.min(t.maxTicksLimit?t.maxTicksLimit:11,Math.ceil(this.drawingArea/(1.5*e)))},convertTicksToLabels:function(){var e=this;t.LinearScaleBase.prototype.convertTicksToLabels.call(e),e.pointLabels=e.chart.data.labels.map(e.options.pointLabels.callback,e)},getLabelForIndex:function(t,e){return+this.getRightValue(this.chart.data.datasets[e].data[t])},fit:function(){this.options.pointLabels.display?o(this):r(this)},setReductions:function(t,e,n){var i=this,a=e.l/Math.sin(n.l),o=Math.max(e.r-i.width,0)/Math.sin(n.r),r=-e.t/Math.cos(n.t),l=-Math.max(e.b-i.height,0)/Math.cos(n.b);a=h(a),o=h(o),r=h(r),l=h(l),i.drawingArea=Math.min(Math.round(t-(a+o)/2),Math.round(t-(r+l)/2)),i.setCenterPoint(a,o,r,l)},setCenterPoint:function(t,e,n,i){var a=this,o=a.width-e-a.drawingArea,r=t+a.drawingArea,l=n+a.drawingArea,s=a.height-i-a.drawingArea;a.xCenter=Math.round((r+o)/2+a.left),a.yCenter=Math.round((l+s)/2+a.top)},getIndexAngle:function(t){var n=2*Math.PI/e(this),i=this.chart.options&&this.chart.options.startAngle?this.chart.options.startAngle:0,a=i*Math.PI*2/360;return t*n+a},getDistanceFromCenterForValue:function(t){var e=this;if(null===t)return 0;var n=e.drawingArea/(e.max-e.min);return e.options.reverse?(e.max-t)*n:(t-e.min)*n},getPointPosition:function(t,e){var n=this,i=n.getIndexAngle(t)-Math.PI/2;return{x:Math.round(Math.cos(i)*e)+n.xCenter,y:Math.round(Math.sin(i)*e)+n.yCenter}},getPointPositionForValue:function(t,e){return this.getPointPosition(t,this.getDistanceFromCenterForValue(e))},getBasePosition:function(){var t=this,e=t.min,n=t.max;return t.getPointPositionForValue(0,t.beginAtZero?0:e<0&&n<0?n:e>0&&n>0?e:0)},draw:function(){var t=this,e=t.options,n=e.gridLines,i=e.ticks,a=f.getValueOrDefault;if(e.display){var o=t.ctx,r=a(i.fontSize,g.defaultFontSize),l=a(i.fontStyle,g.defaultFontStyle),s=a(i.fontFamily,g.defaultFontFamily),u=f.fontString(r,l,s);f.each(t.ticks,function(l,s){if(s>0||e.reverse){var d=t.getDistanceFromCenterForValue(t.ticksAsNumbers[s]),h=t.yCenter-d;if(n.display&&0!==s&&c(t,n,d,s),i.display){var f=a(i.fontColor,g.defaultFontColor);if(o.font=u,i.showLabelBackdrop){var p=o.measureText(l).width;o.fillStyle=i.backdropColor,o.fillRect(t.xCenter-p/2-i.backdropPaddingX,h-r/2-i.backdropPaddingY,p+2*i.backdropPaddingX,r+2*i.backdropPaddingY)}o.textAlign="center",o.textBaseline="middle",o.fillStyle=f,o.fillText(l,t.xCenter,h)}}}),(e.angleLines.display||e.pointLabels.display)&&d(t)}}});t.scaleService.registerScaleType("radialLinear",m,p)}},{}],49:[function(t,e,n){"use strict";var i=t(1);i="function"==typeof i?i:window.moment,e.exports=function(t){function e(t,e){var n=t.options.time;if("string"==typeof n.parser)return i(e,n.parser);if("function"==typeof n.parser)return n.parser(e);if("function"==typeof e.getMonth||"number"==typeof e)return i(e);if(e.isValid&&e.isValid())return e;var a=n.format;return"string"!=typeof a&&a.call?(console.warn("options.time.format is deprecated and replaced by options.time.parser."),a(e)):i(e,a)}function n(t,e,n,i){for(var a,o=Object.keys(l),r=o.length,s=o.indexOf(t);s<r;s++){a=o[s];var u=l[a],d=u.steps&&u.steps[u.steps.length-1]||u.maxStep;if(void 0===d||Math.ceil((n-e)/(d*u.size))<=i)break}return a}function a(t,e,n,i){var a=l[n],o=a.size,r=Math.ceil((e-t)/o),s=1,u=e-t;if(a.steps)for(var d=a.steps.length,c=0;c<d&&r>i;c++)s=a.steps[c],r=Math.ceil(u/(o*s));else for(;r>i&&i>0;)++s,r=Math.ceil(u/(o*s));return s}function o(t,e,n){var a=[];if(t.maxTicks){var o=t.stepSize;a.push(void 0!==t.min?t.min:n.min);for(var r=i(n.min);r.add(o,t.unit).valueOf()<n.max;)a.push(r.valueOf());var l=t.max||n.max;a[a.length-1]!==l&&a.push(l)}return a}var r=t.helpers,l={millisecond:{size:1,steps:[1,2,5,10,20,50,100,250,500]},second:{size:1e3,steps:[1,2,5,10,30]},minute:{size:6e4,steps:[1,2,5,10,30]},hour:{size:36e5,steps:[1,2,3,6,12]},day:{size:864e5,steps:[1,2,5]},week:{size:6048e5,maxStep:4},month:{size:2628e6,maxStep:3},quarter:{size:7884e6,maxStep:4},year:{size:3154e7,maxStep:!1}},s={position:"bottom",time:{parser:!1,format:!1,unit:!1,round:!1,displayFormat:!1,isoWeekday:!1,minUnit:"millisecond",displayFormats:{millisecond:"h:mm:ss.SSS a",second:"h:mm:ss a",minute:"h:mm:ss a",hour:"MMM D, hA",day:"ll",week:"ll",month:"MMM YYYY",quarter:"[Q]Q - YYYY",year:"YYYY"}},ticks:{autoSkip:!1}};t.Ticks.generators.time=function(t,e){var n,a,r=t.isoWeekday;return"week"===t.unit&&r!==!1?(n=i(e.min).startOf("isoWeek").isoWeekday(r).valueOf(),a=i(e.max).startOf("isoWeek").isoWeekday(r),e.max-a>0&&a.add(1,"week"),a=a.valueOf()):(n=i(e.min).startOf(t.unit).valueOf(),a=i(e.max).startOf(t.unit),e.max-a>0&&a.add(1,t.unit),a=a.valueOf()),o(t,e,{min:n,max:a})};var u=t.Scale.extend({initialize:function(){if(!i)throw new Error("Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com");t.Scale.prototype.initialize.call(this)},determineDataLimits:function(){var t,n=this,i=n.options.time,a=Number.MAX_SAFE_INTEGER,o=Number.MIN_SAFE_INTEGER,l=n.chart.data,s={labels:[],datasets:[]};r.each(l.labels,function(r,l){var u=e(n,r);u.isValid()&&(i.round&&u.startOf(i.round),t=u.valueOf(),a=Math.min(t,a),o=Math.max(t,o),s.labels[l]=t)}),r.each(l.datasets,function(l,u){var d=[];"object"==typeof l.data[0]&&null!==l.data[0]&&n.chart.isDatasetVisible(u)?r.each(l.data,function(r,l){var s=e(n,n.getRightValue(r));s.isValid()&&(i.round&&s.startOf(i.round),t=s.valueOf(),a=Math.min(t,a),o=Math.max(t,o),d[l]=t)}):d=s.labels.slice(),s.datasets[u]=d}),n.dataMin=a,n.dataMax=o,n._parsedData=s},buildTicks:function(){var i,o,l=this,s=l.options.time,u=l.dataMin,d=l.dataMax;if(s.min){var c=e(l,s.min);s.round&&c.round(s.round),i=c.valueOf()}s.max&&(o=e(l,s.max).valueOf());var h=l.getLabelCapacity(i||u),f=s.unit||n(s.minUnit,i||u,o||d,h);l.displayFormat=s.displayFormats[f];var g=s.stepSize||a(i||u,o||d,f,h);l.ticks=t.Ticks.generators.time({maxTicks:h,min:i,max:o,stepSize:g,unit:f,isoWeekday:s.isoWeekday},{min:u,max:d}),l.max=r.max(l.ticks),l.min=r.min(l.ticks)},getLabelForIndex:function(t,n){var i=this,a=i.chart.data.labels&&t<i.chart.data.labels.length?i.chart.data.labels[t]:"",o=i.chart.data.datasets[n].data[t];return null!==o&&"object"==typeof o&&(a=i.getRightValue(o)),i.options.time.tooltipFormat&&(a=e(i,a).format(i.options.time.tooltipFormat)),a},tickFormatFunction:function(t,e,n){var i=t.format(this.displayFormat),a=this.options.ticks,o=r.getValueOrDefault(a.callback,a.userCallback);return o?o(i,e,n):i},convertTicksToLabels:function(){var t=this;t.ticksAsTimestamps=t.ticks,t.ticks=t.ticks.map(function(t){return i(t)}).map(t.tickFormatFunction,t)},getPixelForOffset:function(t){var e=this,n=e.max-e.min,i=n?(t-e.min)/n:0;if(e.isHorizontal()){var a=e.width*i;return e.left+Math.round(a)}var o=e.height*i;return e.top+Math.round(o)},getPixelForValue:function(t,n,i){var a=this,o=null;if(void 0!==n&&void 0!==i&&(o=a._parsedData.datasets[i][n]),null===o&&(t&&t.isValid||(t=e(a,a.getRightValue(t))),t&&t.isValid&&t.isValid()&&(o=t.valueOf())),null!==o)return a.getPixelForOffset(o)},getPixelForTick:function(t){return this.getPixelForOffset(this.ticksAsTimestamps[t])},getValueForPixel:function(t){var e=this,n=e.isHorizontal()?e.width:e.height,a=(t-(e.isHorizontal()?e.left:e.top))/n;return i(e.min+a*(e.max-e.min))},getLabelWidth:function(e){var n=this,i=n.options.ticks,a=n.ctx.measureText(e).width,o=Math.cos(r.toRadians(i.maxRotation)),l=Math.sin(r.toRadians(i.maxRotation)),s=r.getValueOrDefault(i.fontSize,t.defaults.global.defaultFontSize);return a*o+s*l},getLabelCapacity:function(t){var e=this;e.displayFormat=e.options.time.displayFormats.millisecond;var n=e.tickFormatFunction(i(t),0,[]),a=e.getLabelWidth(n),o=e.isHorizontal()?e.width:e.height,r=o/a;return r}});t.scaleService.registerScaleType("time",u,s)}},{1:1}]},{},[7])(7)});
/*! Hammer.JS - v2.0.8 - 2016-04-23
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
!function(a,b,c,d){"use strict";function e(a,b,c){return setTimeout(j(a,c),b)}function f(a,b,c){return Array.isArray(a)?(g(a,c[b],c),!0):!1}function g(a,b,c){var e;if(a)if(a.forEach)a.forEach(b,c);else if(a.length!==d)for(e=0;e<a.length;)b.call(c,a[e],e,a),e++;else for(e in a)a.hasOwnProperty(e)&&b.call(c,a[e],e,a)}function h(b,c,d){var e="DEPRECATED METHOD: "+c+"\n"+d+" AT \n";return function(){var c=new Error("get-stack-trace"),d=c&&c.stack?c.stack.replace(/^[^\(]+?[\n$]/gm,"").replace(/^\s+at\s+/gm,"").replace(/^Object.<anonymous>\s*\(/gm,"{anonymous}()@"):"Unknown Stack Trace",f=a.console&&(a.console.warn||a.console.log);return f&&f.call(a.console,e,d),b.apply(this,arguments)}}function i(a,b,c){var d,e=b.prototype;d=a.prototype=Object.create(e),d.constructor=a,d._super=e,c&&la(d,c)}function j(a,b){return function(){return a.apply(b,arguments)}}function k(a,b){return typeof a==oa?a.apply(b?b[0]||d:d,b):a}function l(a,b){return a===d?b:a}function m(a,b,c){g(q(b),function(b){a.addEventListener(b,c,!1)})}function n(a,b,c){g(q(b),function(b){a.removeEventListener(b,c,!1)})}function o(a,b){for(;a;){if(a==b)return!0;a=a.parentNode}return!1}function p(a,b){return a.indexOf(b)>-1}function q(a){return a.trim().split(/\s+/g)}function r(a,b,c){if(a.indexOf&&!c)return a.indexOf(b);for(var d=0;d<a.length;){if(c&&a[d][c]==b||!c&&a[d]===b)return d;d++}return-1}function s(a){return Array.prototype.slice.call(a,0)}function t(a,b,c){for(var d=[],e=[],f=0;f<a.length;){var g=b?a[f][b]:a[f];r(e,g)<0&&d.push(a[f]),e[f]=g,f++}return c&&(d=b?d.sort(function(a,c){return a[b]>c[b]}):d.sort()),d}function u(a,b){for(var c,e,f=b[0].toUpperCase()+b.slice(1),g=0;g<ma.length;){if(c=ma[g],e=c?c+f:b,e in a)return e;g++}return d}function v(){return ua++}function w(b){var c=b.ownerDocument||b;return c.defaultView||c.parentWindow||a}function x(a,b){var c=this;this.manager=a,this.callback=b,this.element=a.element,this.target=a.options.inputTarget,this.domHandler=function(b){k(a.options.enable,[a])&&c.handler(b)},this.init()}function y(a){var b,c=a.options.inputClass;return new(b=c?c:xa?M:ya?P:wa?R:L)(a,z)}function z(a,b,c){var d=c.pointers.length,e=c.changedPointers.length,f=b&Ea&&d-e===0,g=b&(Ga|Ha)&&d-e===0;c.isFirst=!!f,c.isFinal=!!g,f&&(a.session={}),c.eventType=b,A(a,c),a.emit("hammer.input",c),a.recognize(c),a.session.prevInput=c}function A(a,b){var c=a.session,d=b.pointers,e=d.length;c.firstInput||(c.firstInput=D(b)),e>1&&!c.firstMultiple?c.firstMultiple=D(b):1===e&&(c.firstMultiple=!1);var f=c.firstInput,g=c.firstMultiple,h=g?g.center:f.center,i=b.center=E(d);b.timeStamp=ra(),b.deltaTime=b.timeStamp-f.timeStamp,b.angle=I(h,i),b.distance=H(h,i),B(c,b),b.offsetDirection=G(b.deltaX,b.deltaY);var j=F(b.deltaTime,b.deltaX,b.deltaY);b.overallVelocityX=j.x,b.overallVelocityY=j.y,b.overallVelocity=qa(j.x)>qa(j.y)?j.x:j.y,b.scale=g?K(g.pointers,d):1,b.rotation=g?J(g.pointers,d):0,b.maxPointers=c.prevInput?b.pointers.length>c.prevInput.maxPointers?b.pointers.length:c.prevInput.maxPointers:b.pointers.length,C(c,b);var k=a.element;o(b.srcEvent.target,k)&&(k=b.srcEvent.target),b.target=k}function B(a,b){var c=b.center,d=a.offsetDelta||{},e=a.prevDelta||{},f=a.prevInput||{};b.eventType!==Ea&&f.eventType!==Ga||(e=a.prevDelta={x:f.deltaX||0,y:f.deltaY||0},d=a.offsetDelta={x:c.x,y:c.y}),b.deltaX=e.x+(c.x-d.x),b.deltaY=e.y+(c.y-d.y)}function C(a,b){var c,e,f,g,h=a.lastInterval||b,i=b.timeStamp-h.timeStamp;if(b.eventType!=Ha&&(i>Da||h.velocity===d)){var j=b.deltaX-h.deltaX,k=b.deltaY-h.deltaY,l=F(i,j,k);e=l.x,f=l.y,c=qa(l.x)>qa(l.y)?l.x:l.y,g=G(j,k),a.lastInterval=b}else c=h.velocity,e=h.velocityX,f=h.velocityY,g=h.direction;b.velocity=c,b.velocityX=e,b.velocityY=f,b.direction=g}function D(a){for(var b=[],c=0;c<a.pointers.length;)b[c]={clientX:pa(a.pointers[c].clientX),clientY:pa(a.pointers[c].clientY)},c++;return{timeStamp:ra(),pointers:b,center:E(b),deltaX:a.deltaX,deltaY:a.deltaY}}function E(a){var b=a.length;if(1===b)return{x:pa(a[0].clientX),y:pa(a[0].clientY)};for(var c=0,d=0,e=0;b>e;)c+=a[e].clientX,d+=a[e].clientY,e++;return{x:pa(c/b),y:pa(d/b)}}function F(a,b,c){return{x:b/a||0,y:c/a||0}}function G(a,b){return a===b?Ia:qa(a)>=qa(b)?0>a?Ja:Ka:0>b?La:Ma}function H(a,b,c){c||(c=Qa);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return Math.sqrt(d*d+e*e)}function I(a,b,c){c||(c=Qa);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return 180*Math.atan2(e,d)/Math.PI}function J(a,b){return I(b[1],b[0],Ra)+I(a[1],a[0],Ra)}function K(a,b){return H(b[0],b[1],Ra)/H(a[0],a[1],Ra)}function L(){this.evEl=Ta,this.evWin=Ua,this.pressed=!1,x.apply(this,arguments)}function M(){this.evEl=Xa,this.evWin=Ya,x.apply(this,arguments),this.store=this.manager.session.pointerEvents=[]}function N(){this.evTarget=$a,this.evWin=_a,this.started=!1,x.apply(this,arguments)}function O(a,b){var c=s(a.touches),d=s(a.changedTouches);return b&(Ga|Ha)&&(c=t(c.concat(d),"identifier",!0)),[c,d]}function P(){this.evTarget=bb,this.targetIds={},x.apply(this,arguments)}function Q(a,b){var c=s(a.touches),d=this.targetIds;if(b&(Ea|Fa)&&1===c.length)return d[c[0].identifier]=!0,[c,c];var e,f,g=s(a.changedTouches),h=[],i=this.target;if(f=c.filter(function(a){return o(a.target,i)}),b===Ea)for(e=0;e<f.length;)d[f[e].identifier]=!0,e++;for(e=0;e<g.length;)d[g[e].identifier]&&h.push(g[e]),b&(Ga|Ha)&&delete d[g[e].identifier],e++;return h.length?[t(f.concat(h),"identifier",!0),h]:void 0}function R(){x.apply(this,arguments);var a=j(this.handler,this);this.touch=new P(this.manager,a),this.mouse=new L(this.manager,a),this.primaryTouch=null,this.lastTouches=[]}function S(a,b){a&Ea?(this.primaryTouch=b.changedPointers[0].identifier,T.call(this,b)):a&(Ga|Ha)&&T.call(this,b)}function T(a){var b=a.changedPointers[0];if(b.identifier===this.primaryTouch){var c={x:b.clientX,y:b.clientY};this.lastTouches.push(c);var d=this.lastTouches,e=function(){var a=d.indexOf(c);a>-1&&d.splice(a,1)};setTimeout(e,cb)}}function U(a){for(var b=a.srcEvent.clientX,c=a.srcEvent.clientY,d=0;d<this.lastTouches.length;d++){var e=this.lastTouches[d],f=Math.abs(b-e.x),g=Math.abs(c-e.y);if(db>=f&&db>=g)return!0}return!1}function V(a,b){this.manager=a,this.set(b)}function W(a){if(p(a,jb))return jb;var b=p(a,kb),c=p(a,lb);return b&&c?jb:b||c?b?kb:lb:p(a,ib)?ib:hb}function X(){if(!fb)return!1;var b={},c=a.CSS&&a.CSS.supports;return["auto","manipulation","pan-y","pan-x","pan-x pan-y","none"].forEach(function(d){b[d]=c?a.CSS.supports("touch-action",d):!0}),b}function Y(a){this.options=la({},this.defaults,a||{}),this.id=v(),this.manager=null,this.options.enable=l(this.options.enable,!0),this.state=nb,this.simultaneous={},this.requireFail=[]}function Z(a){return a&sb?"cancel":a&qb?"end":a&pb?"move":a&ob?"start":""}function $(a){return a==Ma?"down":a==La?"up":a==Ja?"left":a==Ka?"right":""}function _(a,b){var c=b.manager;return c?c.get(a):a}function aa(){Y.apply(this,arguments)}function ba(){aa.apply(this,arguments),this.pX=null,this.pY=null}function ca(){aa.apply(this,arguments)}function da(){Y.apply(this,arguments),this._timer=null,this._input=null}function ea(){aa.apply(this,arguments)}function fa(){aa.apply(this,arguments)}function ga(){Y.apply(this,arguments),this.pTime=!1,this.pCenter=!1,this._timer=null,this._input=null,this.count=0}function ha(a,b){return b=b||{},b.recognizers=l(b.recognizers,ha.defaults.preset),new ia(a,b)}function ia(a,b){this.options=la({},ha.defaults,b||{}),this.options.inputTarget=this.options.inputTarget||a,this.handlers={},this.session={},this.recognizers=[],this.oldCssProps={},this.element=a,this.input=y(this),this.touchAction=new V(this,this.options.touchAction),ja(this,!0),g(this.options.recognizers,function(a){var b=this.add(new a[0](a[1]));a[2]&&b.recognizeWith(a[2]),a[3]&&b.requireFailure(a[3])},this)}function ja(a,b){var c=a.element;if(c.style){var d;g(a.options.cssProps,function(e,f){d=u(c.style,f),b?(a.oldCssProps[d]=c.style[d],c.style[d]=e):c.style[d]=a.oldCssProps[d]||""}),b||(a.oldCssProps={})}}function ka(a,c){var d=b.createEvent("Event");d.initEvent(a,!0,!0),d.gesture=c,c.target.dispatchEvent(d)}var la,ma=["","webkit","Moz","MS","ms","o"],na=b.createElement("div"),oa="function",pa=Math.round,qa=Math.abs,ra=Date.now;la="function"!=typeof Object.assign?function(a){if(a===d||null===a)throw new TypeError("Cannot convert undefined or null to object");for(var b=Object(a),c=1;c<arguments.length;c++){var e=arguments[c];if(e!==d&&null!==e)for(var f in e)e.hasOwnProperty(f)&&(b[f]=e[f])}return b}:Object.assign;var sa=h(function(a,b,c){for(var e=Object.keys(b),f=0;f<e.length;)(!c||c&&a[e[f]]===d)&&(a[e[f]]=b[e[f]]),f++;return a},"extend","Use `assign`."),ta=h(function(a,b){return sa(a,b,!0)},"merge","Use `assign`."),ua=1,va=/mobile|tablet|ip(ad|hone|od)|android/i,wa="ontouchstart"in a,xa=u(a,"PointerEvent")!==d,ya=wa&&va.test(navigator.userAgent),za="touch",Aa="pen",Ba="mouse",Ca="kinect",Da=25,Ea=1,Fa=2,Ga=4,Ha=8,Ia=1,Ja=2,Ka=4,La=8,Ma=16,Na=Ja|Ka,Oa=La|Ma,Pa=Na|Oa,Qa=["x","y"],Ra=["clientX","clientY"];x.prototype={handler:function(){},init:function(){this.evEl&&m(this.element,this.evEl,this.domHandler),this.evTarget&&m(this.target,this.evTarget,this.domHandler),this.evWin&&m(w(this.element),this.evWin,this.domHandler)},destroy:function(){this.evEl&&n(this.element,this.evEl,this.domHandler),this.evTarget&&n(this.target,this.evTarget,this.domHandler),this.evWin&&n(w(this.element),this.evWin,this.domHandler)}};var Sa={mousedown:Ea,mousemove:Fa,mouseup:Ga},Ta="mousedown",Ua="mousemove mouseup";i(L,x,{handler:function(a){var b=Sa[a.type];b&Ea&&0===a.button&&(this.pressed=!0),b&Fa&&1!==a.which&&(b=Ga),this.pressed&&(b&Ga&&(this.pressed=!1),this.callback(this.manager,b,{pointers:[a],changedPointers:[a],pointerType:Ba,srcEvent:a}))}});var Va={pointerdown:Ea,pointermove:Fa,pointerup:Ga,pointercancel:Ha,pointerout:Ha},Wa={2:za,3:Aa,4:Ba,5:Ca},Xa="pointerdown",Ya="pointermove pointerup pointercancel";a.MSPointerEvent&&!a.PointerEvent&&(Xa="MSPointerDown",Ya="MSPointerMove MSPointerUp MSPointerCancel"),i(M,x,{handler:function(a){var b=this.store,c=!1,d=a.type.toLowerCase().replace("ms",""),e=Va[d],f=Wa[a.pointerType]||a.pointerType,g=f==za,h=r(b,a.pointerId,"pointerId");e&Ea&&(0===a.button||g)?0>h&&(b.push(a),h=b.length-1):e&(Ga|Ha)&&(c=!0),0>h||(b[h]=a,this.callback(this.manager,e,{pointers:b,changedPointers:[a],pointerType:f,srcEvent:a}),c&&b.splice(h,1))}});var Za={touchstart:Ea,touchmove:Fa,touchend:Ga,touchcancel:Ha},$a="touchstart",_a="touchstart touchmove touchend touchcancel";i(N,x,{handler:function(a){var b=Za[a.type];if(b===Ea&&(this.started=!0),this.started){var c=O.call(this,a,b);b&(Ga|Ha)&&c[0].length-c[1].length===0&&(this.started=!1),this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:za,srcEvent:a})}}});var ab={touchstart:Ea,touchmove:Fa,touchend:Ga,touchcancel:Ha},bb="touchstart touchmove touchend touchcancel";i(P,x,{handler:function(a){var b=ab[a.type],c=Q.call(this,a,b);c&&this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:za,srcEvent:a})}});var cb=2500,db=25;i(R,x,{handler:function(a,b,c){var d=c.pointerType==za,e=c.pointerType==Ba;if(!(e&&c.sourceCapabilities&&c.sourceCapabilities.firesTouchEvents)){if(d)S.call(this,b,c);else if(e&&U.call(this,c))return;this.callback(a,b,c)}},destroy:function(){this.touch.destroy(),this.mouse.destroy()}});var eb=u(na.style,"touchAction"),fb=eb!==d,gb="compute",hb="auto",ib="manipulation",jb="none",kb="pan-x",lb="pan-y",mb=X();V.prototype={set:function(a){a==gb&&(a=this.compute()),fb&&this.manager.element.style&&mb[a]&&(this.manager.element.style[eb]=a),this.actions=a.toLowerCase().trim()},update:function(){this.set(this.manager.options.touchAction)},compute:function(){var a=[];return g(this.manager.recognizers,function(b){k(b.options.enable,[b])&&(a=a.concat(b.getTouchAction()))}),W(a.join(" "))},preventDefaults:function(a){var b=a.srcEvent,c=a.offsetDirection;if(this.manager.session.prevented)return void b.preventDefault();var d=this.actions,e=p(d,jb)&&!mb[jb],f=p(d,lb)&&!mb[lb],g=p(d,kb)&&!mb[kb];if(e){var h=1===a.pointers.length,i=a.distance<2,j=a.deltaTime<250;if(h&&i&&j)return}return g&&f?void 0:e||f&&c&Na||g&&c&Oa?this.preventSrc(b):void 0},preventSrc:function(a){this.manager.session.prevented=!0,a.preventDefault()}};var nb=1,ob=2,pb=4,qb=8,rb=qb,sb=16,tb=32;Y.prototype={defaults:{},set:function(a){return la(this.options,a),this.manager&&this.manager.touchAction.update(),this},recognizeWith:function(a){if(f(a,"recognizeWith",this))return this;var b=this.simultaneous;return a=_(a,this),b[a.id]||(b[a.id]=a,a.recognizeWith(this)),this},dropRecognizeWith:function(a){return f(a,"dropRecognizeWith",this)?this:(a=_(a,this),delete this.simultaneous[a.id],this)},requireFailure:function(a){if(f(a,"requireFailure",this))return this;var b=this.requireFail;return a=_(a,this),-1===r(b,a)&&(b.push(a),a.requireFailure(this)),this},dropRequireFailure:function(a){if(f(a,"dropRequireFailure",this))return this;a=_(a,this);var b=r(this.requireFail,a);return b>-1&&this.requireFail.splice(b,1),this},hasRequireFailures:function(){return this.requireFail.length>0},canRecognizeWith:function(a){return!!this.simultaneous[a.id]},emit:function(a){function b(b){c.manager.emit(b,a)}var c=this,d=this.state;qb>d&&b(c.options.event+Z(d)),b(c.options.event),a.additionalEvent&&b(a.additionalEvent),d>=qb&&b(c.options.event+Z(d))},tryEmit:function(a){return this.canEmit()?this.emit(a):void(this.state=tb)},canEmit:function(){for(var a=0;a<this.requireFail.length;){if(!(this.requireFail[a].state&(tb|nb)))return!1;a++}return!0},recognize:function(a){var b=la({},a);return k(this.options.enable,[this,b])?(this.state&(rb|sb|tb)&&(this.state=nb),this.state=this.process(b),void(this.state&(ob|pb|qb|sb)&&this.tryEmit(b))):(this.reset(),void(this.state=tb))},process:function(a){},getTouchAction:function(){},reset:function(){}},i(aa,Y,{defaults:{pointers:1},attrTest:function(a){var b=this.options.pointers;return 0===b||a.pointers.length===b},process:function(a){var b=this.state,c=a.eventType,d=b&(ob|pb),e=this.attrTest(a);return d&&(c&Ha||!e)?b|sb:d||e?c&Ga?b|qb:b&ob?b|pb:ob:tb}}),i(ba,aa,{defaults:{event:"pan",threshold:10,pointers:1,direction:Pa},getTouchAction:function(){var a=this.options.direction,b=[];return a&Na&&b.push(lb),a&Oa&&b.push(kb),b},directionTest:function(a){var b=this.options,c=!0,d=a.distance,e=a.direction,f=a.deltaX,g=a.deltaY;return e&b.direction||(b.direction&Na?(e=0===f?Ia:0>f?Ja:Ka,c=f!=this.pX,d=Math.abs(a.deltaX)):(e=0===g?Ia:0>g?La:Ma,c=g!=this.pY,d=Math.abs(a.deltaY))),a.direction=e,c&&d>b.threshold&&e&b.direction},attrTest:function(a){return aa.prototype.attrTest.call(this,a)&&(this.state&ob||!(this.state&ob)&&this.directionTest(a))},emit:function(a){this.pX=a.deltaX,this.pY=a.deltaY;var b=$(a.direction);b&&(a.additionalEvent=this.options.event+b),this._super.emit.call(this,a)}}),i(ca,aa,{defaults:{event:"pinch",threshold:0,pointers:2},getTouchAction:function(){return[jb]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.scale-1)>this.options.threshold||this.state&ob)},emit:function(a){if(1!==a.scale){var b=a.scale<1?"in":"out";a.additionalEvent=this.options.event+b}this._super.emit.call(this,a)}}),i(da,Y,{defaults:{event:"press",pointers:1,time:251,threshold:9},getTouchAction:function(){return[hb]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime>b.time;if(this._input=a,!d||!c||a.eventType&(Ga|Ha)&&!f)this.reset();else if(a.eventType&Ea)this.reset(),this._timer=e(function(){this.state=rb,this.tryEmit()},b.time,this);else if(a.eventType&Ga)return rb;return tb},reset:function(){clearTimeout(this._timer)},emit:function(a){this.state===rb&&(a&&a.eventType&Ga?this.manager.emit(this.options.event+"up",a):(this._input.timeStamp=ra(),this.manager.emit(this.options.event,this._input)))}}),i(ea,aa,{defaults:{event:"rotate",threshold:0,pointers:2},getTouchAction:function(){return[jb]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.rotation)>this.options.threshold||this.state&ob)}}),i(fa,aa,{defaults:{event:"swipe",threshold:10,velocity:.3,direction:Na|Oa,pointers:1},getTouchAction:function(){return ba.prototype.getTouchAction.call(this)},attrTest:function(a){var b,c=this.options.direction;return c&(Na|Oa)?b=a.overallVelocity:c&Na?b=a.overallVelocityX:c&Oa&&(b=a.overallVelocityY),this._super.attrTest.call(this,a)&&c&a.offsetDirection&&a.distance>this.options.threshold&&a.maxPointers==this.options.pointers&&qa(b)>this.options.velocity&&a.eventType&Ga},emit:function(a){var b=$(a.offsetDirection);b&&this.manager.emit(this.options.event+b,a),this.manager.emit(this.options.event,a)}}),i(ga,Y,{defaults:{event:"tap",pointers:1,taps:1,interval:300,time:250,threshold:9,posThreshold:10},getTouchAction:function(){return[ib]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime<b.time;if(this.reset(),a.eventType&Ea&&0===this.count)return this.failTimeout();if(d&&f&&c){if(a.eventType!=Ga)return this.failTimeout();var g=this.pTime?a.timeStamp-this.pTime<b.interval:!0,h=!this.pCenter||H(this.pCenter,a.center)<b.posThreshold;this.pTime=a.timeStamp,this.pCenter=a.center,h&&g?this.count+=1:this.count=1,this._input=a;var i=this.count%b.taps;if(0===i)return this.hasRequireFailures()?(this._timer=e(function(){this.state=rb,this.tryEmit()},b.interval,this),ob):rb}return tb},failTimeout:function(){return this._timer=e(function(){this.state=tb},this.options.interval,this),tb},reset:function(){clearTimeout(this._timer)},emit:function(){this.state==rb&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))}}),ha.VERSION="2.0.8",ha.defaults={domEvents:!1,touchAction:gb,enable:!0,inputTarget:null,inputClass:null,preset:[[ea,{enable:!1}],[ca,{enable:!1},["rotate"]],[fa,{direction:Na}],[ba,{direction:Na},["swipe"]],[ga],[ga,{event:"doubletap",taps:2},["tap"]],[da]],cssProps:{userSelect:"none",touchSelect:"none",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}};var ub=1,vb=2;ia.prototype={set:function(a){return la(this.options,a),a.touchAction&&this.touchAction.update(),a.inputTarget&&(this.input.destroy(),this.input.target=a.inputTarget,this.input.init()),this},stop:function(a){this.session.stopped=a?vb:ub},recognize:function(a){var b=this.session;if(!b.stopped){this.touchAction.preventDefaults(a);var c,d=this.recognizers,e=b.curRecognizer;(!e||e&&e.state&rb)&&(e=b.curRecognizer=null);for(var f=0;f<d.length;)c=d[f],b.stopped===vb||e&&c!=e&&!c.canRecognizeWith(e)?c.reset():c.recognize(a),!e&&c.state&(ob|pb|qb)&&(e=b.curRecognizer=c),f++}},get:function(a){if(a instanceof Y)return a;for(var b=this.recognizers,c=0;c<b.length;c++)if(b[c].options.event==a)return b[c];return null},add:function(a){if(f(a,"add",this))return this;var b=this.get(a.options.event);return b&&this.remove(b),this.recognizers.push(a),a.manager=this,this.touchAction.update(),a},remove:function(a){if(f(a,"remove",this))return this;if(a=this.get(a)){var b=this.recognizers,c=r(b,a);-1!==c&&(b.splice(c,1),this.touchAction.update())}return this},on:function(a,b){if(a!==d&&b!==d){var c=this.handlers;return g(q(a),function(a){c[a]=c[a]||[],c[a].push(b)}),this}},off:function(a,b){if(a!==d){var c=this.handlers;return g(q(a),function(a){b?c[a]&&c[a].splice(r(c[a],b),1):delete c[a]}),this}},emit:function(a,b){this.options.domEvents&&ka(a,b);var c=this.handlers[a]&&this.handlers[a].slice();if(c&&c.length){b.type=a,b.preventDefault=function(){b.srcEvent.preventDefault()};for(var d=0;d<c.length;)c[d](b),d++}},destroy:function(){this.element&&ja(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null}},la(ha,{INPUT_START:Ea,INPUT_MOVE:Fa,INPUT_END:Ga,INPUT_CANCEL:Ha,STATE_POSSIBLE:nb,STATE_BEGAN:ob,STATE_CHANGED:pb,STATE_ENDED:qb,STATE_RECOGNIZED:rb,STATE_CANCELLED:sb,STATE_FAILED:tb,DIRECTION_NONE:Ia,DIRECTION_LEFT:Ja,DIRECTION_RIGHT:Ka,DIRECTION_UP:La,DIRECTION_DOWN:Ma,DIRECTION_HORIZONTAL:Na,DIRECTION_VERTICAL:Oa,DIRECTION_ALL:Pa,Manager:ia,Input:x,TouchAction:V,TouchInput:P,MouseInput:L,PointerEventInput:M,TouchMouseInput:R,SingleTouchInput:N,Recognizer:Y,AttrRecognizer:aa,Tap:ga,Pan:ba,Swipe:fa,Pinch:ca,Rotate:ea,Press:da,on:m,off:n,each:g,merge:ta,extend:sa,assign:la,inherit:i,bindFn:j,prefixed:u});var wb="undefined"!=typeof a?a:"undefined"!=typeof self?self:{};wb.Hammer=ha,"function"==typeof define&&define.amd?define(function(){return ha}):"undefined"!=typeof module&&module.exports?module.exports=ha:a[c]=ha}(window,document,"Hammer");
//# sourceMappingURL=hammer.min.js.map
/*!
 * chartjs-plugin-zoom
 * http://chartjs.org/
 * Version: 0.4.5
 *
 * Copyright 2016 Evert Timberg
 * Released under the MIT license
 * https://github.com/chartjs/chartjs-plugin-zoom/blob/master/LICENSE.md
 */
!function e(t,o,n){function a(r,l){if(!o[r]){if(!t[r]){var m="function"==typeof require&&require;if(!l&&m)return m(r,!0);if(i)return i(r,!0);var u=new Error("Cannot find module '"+r+"'");throw u.code="MODULE_NOT_FOUND",u}var s=o[r]={exports:{}};t[r][0].call(s.exports,function(e){var o=t[r][1][e];return a(o?o:e)},s,s.exports,e,t,o,n)}return o[r].exports}for(var i="function"==typeof require&&require,r=0;r<n.length;r++)a(n[r]);return a}({1:[function(e,t,o){},{}],2:[function(e,t,o){function n(e,t){return void 0===e||"string"==typeof e&&e.indexOf(t)!==-1}function a(e,t,o,n){var a=e.chart.data.labels,i=e.minIndex,r=a.length-1,l=e.maxIndex,m=n.sensitivity,u=e.isHorizontal()?e.left+e.width/2:e.top+e.height/2,s=e.isHorizontal()?o.x:o.y;z.zoomCumulativeDelta=t>1?z.zoomCumulativeDelta+1:z.zoomCumulativeDelta-1,Math.abs(z.zoomCumulativeDelta)>m&&(z.zoomCumulativeDelta<0?(s<=u?i<=0?l=Math.min(r,l+1):i=Math.max(0,i-1):s>u&&(l>=r?i=Math.max(0,i-1):l=Math.min(r,l+1)),z.zoomCumulativeDelta=0):z.zoomCumulativeDelta>0&&(s<=u?i=i<l?i=Math.min(l,i+1):i:s>u&&(l=l>i?l=Math.max(i,l-1):l),z.zoomCumulativeDelta=0),e.options.ticks.min=a[i],e.options.ticks.max=a[l])}function i(e,t,o){var n,a,i=e.options;e.isHorizontal()?(n=e.right-e.left,a=(o.x-e.left)/n):(n=e.bottom-e.top,a=(o.y-e.top)/n);var r=1-a,l=n*(t-1),m=l*a,u=l*r;i.time.min=e.getValueForPixel(e.getPixelForValue(e.firstTick)+m),i.time.max=e.getValueForPixel(e.getPixelForValue(e.lastTick)-u)}function r(e,t,o){var n=e.max-e.min,a=n*(t-1),i=e.isHorizontal()?o.x:o.y,r=(e.getValueForPixel(i)-e.min)/n,l=1-r,m=a*r,u=a*l;e.options.ticks.min=e.min+m,e.options.ticks.max=e.max-u}function l(e,t,o,n){var a=x[e.options.type];a&&a(e,t,o,n)}function m(e,t,o){var a=e.chartArea;o||(o={x:(a.left+a.right)/2,y:(a.top+a.bottom)/2});var i=e.options.zoom;if(i&&g.getValueOrDefault(i.enabled,F.zoom.enabled)){var r=g.getValueOrDefault(e.options.zoom.mode,F.zoom.mode);i.sensitivity=g.getValueOrDefault(e.options.zoom.sensitivity,F.zoom.sensitivity),g.each(e.scales,function(e,a){e.isHorizontal()&&n(r,"x")?l(e,t,o,i):!e.isHorizontal()&&n(r,"y")&&l(e,t,o,i)}),e.update(0)}}function u(e,t,o){var n,a=e.chart.data.labels,i=a.length-1,r=Math.max(e.ticks.length-(e.options.gridLines.offsetGridLines?0:1),1),l=o.speed,m=e.minIndex,u=Math.round(e.width/(r*l));z.panCumulativeDelta+=t,m=z.panCumulativeDelta>u?Math.max(0,m-1):z.panCumulativeDelta<-u?Math.min(i-r+1,m+1):m,z.panCumulativeDelta=m!==e.minIndex?0:z.panCumulativeDelta,n=Math.min(i,m+r-1),e.options.ticks.min=a[m],e.options.ticks.max=a[n]}function s(e,t){var o=e.options;o.time.min=e.getValueForPixel(e.getPixelForValue(e.firstTick)-t),o.time.max=e.getValueForPixel(e.getPixelForValue(e.lastTick)-t)}function c(e,t){var o=e.options.ticks,n=e.start,a=e.end;o.reverse?(o.max=e.getValueForPixel(e.getPixelForValue(n)-t),o.min=e.getValueForPixel(e.getPixelForValue(a)-t)):(o.min=e.getValueForPixel(e.getPixelForValue(n)-t),o.max=e.getValueForPixel(e.getPixelForValue(a)-t))}function d(e,t,o){var n=D[e.options.type];n&&n(e,t,o)}function p(e,t,o){var a=e.options.pan;if(a&&g.getValueOrDefault(a.enabled,F.pan.enabled)){var i=g.getValueOrDefault(e.options.pan.mode,F.pan.mode);a.speed=g.getValueOrDefault(e.options.pan.speed,F.pan.speed),g.each(e.scales,function(e,r){e.isHorizontal()&&n(i,"x")&&0!==t?d(e,t,a):!e.isHorizontal()&&n(i,"y")&&0!==o&&d(e,o,a)}),e.update(0)}}function f(e){var t=e.scales;for(var o in t){var n=t[o];if(!n.isHorizontal())return n}}var v=e("hammerjs");v="function"==typeof v?v:window.Hammer;var h=e("chart.js");h="function"==typeof h?h:window.Chart;var g=h.helpers,z=h.Zoom=h.Zoom||{},x=z.zoomFunctions=z.zoomFunctions||{},D=z.panFunctions=z.panFunctions||{},F=z.defaults={pan:{enabled:!0,mode:"xy",speed:20,threshold:10},zoom:{enabled:!0,mode:"xy",sensitivity:3}};z.zoomFunctions.category=a,z.zoomFunctions.time=i,z.zoomFunctions.linear=r,z.zoomFunctions.logarithmic=r,z.panFunctions.category=u,z.panFunctions.time=s,z.panFunctions.linear=c,z.panFunctions.logarithmic=c,z.panCumulativeDelta=0,z.zoomCumulativeDelta=0;var _={afterInit:function(e){g.each(e.scales,function(e){e.originalOptions=JSON.parse(JSON.stringify(e.options))}),e.resetZoom=function(){g.each(e.scales,function(e,t){var o=e.options.time,n=e.options.ticks;o&&(delete o.min,delete o.max),n&&(delete n.min,delete n.max),e.options=g.configMerge(e.options,e.originalOptions)}),g.each(e.data.datasets,function(e,t){e._meta=null}),e.update()}},beforeInit:function(e){e.zoom={};var t=e.zoom.node=e.chart.ctx.canvas,o=e.options,n=g.getValueOrDefault(o.pan?o.pan.threshold:void 0,z.defaults.pan.threshold);if(o.zoom&&o.zoom.drag?(o.zoom.mode="x",e.zoom._mouseDownHandler=function(t){e.zoom._dragZoomStart=t},t.addEventListener("mousedown",e.zoom._mouseDownHandler),e.zoom._mouseMoveHandler=function(t){e.zoom._dragZoomStart&&(e.zoom._dragZoomEnd=t,e.update(0)),e.update(0)},t.addEventListener("mousemove",e.zoom._mouseMoveHandler),e.zoom._mouseUpHandler=function(t){if(e.zoom._dragZoomStart){var o=e.chartArea,n=f(e),a=e.zoom._dragZoomStart,i=a.target.getBoundingClientRect().left,r=Math.min(a.clientX,t.clientX)-i,l=Math.max(a.clientX,t.clientX)-i,u=l-r,s=o.right-o.left,c=1+(s-u)/s;u>0&&m(e,c,{x:u/2+r,y:(n.bottom-n.top)/2}),e.zoom._dragZoomStart=null,e.zoom._dragZoomEnd=null}},t.addEventListener("mouseup",e.zoom._mouseUpHandler)):(e.zoom._wheelHandler=function(t){var o=t.target.getBoundingClientRect(),n=t.clientX-o.left,a=t.clientY-o.top,i={x:n,y:a};t.deltaY<0?m(e,1.1,i):m(e,.909,i),t.preventDefault()},t.addEventListener("wheel",e.zoom._wheelHandler)),v){var a=new v.Manager(t);a.add(new v.Pinch),a.add(new v.Pan({threshold:n}));var i,r=function(t){var o=1/i*t.scale;m(e,o,t.center),i=t.scale};a.on("pinchstart",function(e){i=1}),a.on("pinch",r),a.on("pinchend",function(e){r(e),i=null,z.zoomCumulativeDelta=0});var l=null,u=null,s=!1,c=function(t){if(null!==l&&null!==u){s=!0;var o=t.deltaX-l,n=t.deltaY-u;l=t.deltaX,u=t.deltaY,p(e,o,n)}};a.on("panstart",function(e){l=0,u=0,c(e)}),a.on("panmove",c),a.on("panend",function(e){l=null,u=null,z.panCumulativeDelta=0,setTimeout(function(){s=!1},500)}),e.zoom._ghostClickHandler=function(e){s&&(e.stopImmediatePropagation(),e.preventDefault())},t.addEventListener("click",e.zoom._ghostClickHandler),e._mc=a}},beforeDatasetsDraw:function(e){var t=e.chart.ctx,o=e.chartArea;if(t.save(),t.beginPath(),e.zoom._dragZoomEnd){var n=f(e),a=e.zoom._dragZoomStart,i=e.zoom._dragZoomEnd,r=a.target.getBoundingClientRect().left,l=Math.min(a.clientX,i.clientX)-r,m=Math.max(a.clientX,i.clientX)-r,u=m-l;t.fillStyle="rgba(225,225,225,0.3)",t.lineWidth=5,t.fillRect(l,n.top,u,n.bottom-n.top)}t.rect(o.left,o.top,o.right-o.left,o.bottom-o.top),t.clip()},afterDatasetsDraw:function(e){e.chart.ctx.restore()},destroy:function(e){if(e.zoom){var t=e.options,o=e.zoom.node;t.zoom&&t.zoom.drag?(o.removeEventListener("mousedown",e.zoom._mouseDownHandler),o.removeEventListener("mousemove",e.zoom._mouseMoveHandler),o.removeEventListener("mouseup",e.zoom._mouseUpHandler)):o.removeEventListener("wheel",e.zoom._wheelHandler),v&&o.removeEventListener("click",e.zoom._ghostClickHandler),delete e.zoom;var n=e._mc;n&&(n.remove("pinchstart"),n.remove("pinch"),n.remove("pinchend"),n.remove("panstart"),n.remove("pan"),n.remove("panend"))}}};t.exports=_,h.pluginService.register(_)},{"chart.js":1,hammerjs:1}]},{},[2]);
var fabric=fabric||{version:"1.7.11"};"undefined"!=typeof exports&&(exports.fabric=fabric),"undefined"!=typeof document&&"undefined"!=typeof window?(fabric.document=document,fabric.window=window,window.fabric=fabric):(fabric.document=require("jsdom").jsdom(decodeURIComponent("%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E")),fabric.document.createWindow?fabric.window=fabric.document.createWindow():fabric.window=fabric.document.parentWindow),fabric.isTouchSupported="ontouchstart"in fabric.document.documentElement,fabric.isLikelyNode="undefined"!=typeof Buffer&&"undefined"==typeof window,fabric.SHARED_ATTRIBUTES=["display","transform","fill","fill-opacity","fill-rule","opacity","stroke","stroke-dasharray","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke-width","id"],fabric.DPI=96,fabric.reNum="(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:e[-+]?\\d+)?)",fabric.fontPaths={},fabric.iMatrix=[1,0,0,1,0,0],fabric.charWidthsCache={},fabric.devicePixelRatio=fabric.window.devicePixelRatio||fabric.window.webkitDevicePixelRatio||fabric.window.mozDevicePixelRatio||1,function(){function t(t,e){if(this.__eventListeners[t]){var i=this.__eventListeners[t];e?i[i.indexOf(e)]=!1:fabric.util.array.fill(i,!1)}}function e(t,e){if(this.__eventListeners||(this.__eventListeners={}),1===arguments.length)for(var i in t)this.on(i,t[i]);else this.__eventListeners[t]||(this.__eventListeners[t]=[]),this.__eventListeners[t].push(e);return this}function i(e,i){if(this.__eventListeners){if(0===arguments.length)for(e in this.__eventListeners)t.call(this,e);else if(1===arguments.length&&"object"==typeof arguments[0])for(var r in e)t.call(this,r,e[r]);else t.call(this,e,i);return this}}function r(t,e){if(this.__eventListeners){var i=this.__eventListeners[t];if(i){for(var r=0,n=i.length;r<n;r++)i[r]&&i[r].call(this,e||{});return this.__eventListeners[t]=i.filter(function(t){return t!==!1}),this}}}fabric.Observable={observe:e,stopObserving:i,fire:r,on:e,off:i,trigger:r}}(),fabric.Collection={_objects:[],add:function(){if(this._objects.push.apply(this._objects,arguments),this._onObjectAdded)for(var t=0,e=arguments.length;t<e;t++)this._onObjectAdded(arguments[t]);return this.renderOnAddRemove&&this.renderAll(),this},insertAt:function(t,e,i){var r=this.getObjects();return i?r[e]=t:r.splice(e,0,t),this._onObjectAdded&&this._onObjectAdded(t),this.renderOnAddRemove&&this.renderAll(),this},remove:function(){for(var t,e=this.getObjects(),i=!1,r=0,n=arguments.length;r<n;r++)t=e.indexOf(arguments[r]),t!==-1&&(i=!0,e.splice(t,1),this._onObjectRemoved&&this._onObjectRemoved(arguments[r]));return this.renderOnAddRemove&&i&&this.renderAll(),this},forEachObject:function(t,e){for(var i=this.getObjects(),r=0,n=i.length;r<n;r++)t.call(e,i[r],r,i);return this},getObjects:function(t){return"undefined"==typeof t?this._objects:this._objects.filter(function(e){return e.type===t})},item:function(t){return this.getObjects()[t]},isEmpty:function(){return 0===this.getObjects().length},size:function(){return this.getObjects().length},contains:function(t){return this.getObjects().indexOf(t)>-1},complexity:function(){return this.getObjects().reduce(function(t,e){return t+=e.complexity?e.complexity():0},0)}},fabric.CommonMethods={_setOptions:function(t){for(var e in t)this.set(e,t[e])},_initGradient:function(t,e){!t||!t.colorStops||t instanceof fabric.Gradient||this.set(e,new fabric.Gradient(t))},_initPattern:function(t,e,i){!t||!t.source||t instanceof fabric.Pattern?i&&i():this.set(e,new fabric.Pattern(t,i))},_initClipping:function(t){if(t.clipTo&&"string"==typeof t.clipTo){var e=fabric.util.getFunctionBody(t.clipTo);"undefined"!=typeof e&&(this.clipTo=new Function("ctx",e))}},_setObject:function(t){for(var e in t)this._set(e,t[e])},set:function(t,e){return"object"==typeof t?this._setObject(t):"function"==typeof e&&"clipTo"!==t?this._set(t,e(this.get(t))):this._set(t,e),this},_set:function(t,e){this[t]=e},toggle:function(t){var e=this.get(t);return"boolean"==typeof e&&this.set(t,!e),this},get:function(t){return this[t]}},function(t){var e=Math.sqrt,i=Math.atan2,r=Math.pow,n=Math.abs,s=Math.PI/180;fabric.util={removeFromArray:function(t,e){var i=t.indexOf(e);return i!==-1&&t.splice(i,1),t},getRandomInt:function(t,e){return Math.floor(Math.random()*(e-t+1))+t},degreesToRadians:function(t){return t*s},radiansToDegrees:function(t){return t/s},rotatePoint:function(t,e,i){t.subtractEquals(e);var r=fabric.util.rotateVector(t,i);return new fabric.Point(r.x,r.y).addEquals(e)},rotateVector:function(t,e){var i=Math.sin(e),r=Math.cos(e),n=t.x*r-t.y*i,s=t.x*i+t.y*r;return{x:n,y:s}},transformPoint:function(t,e,i){return i?new fabric.Point(e[0]*t.x+e[2]*t.y,e[1]*t.x+e[3]*t.y):new fabric.Point(e[0]*t.x+e[2]*t.y+e[4],e[1]*t.x+e[3]*t.y+e[5])},makeBoundingBoxFromPoints:function(t){var e=[t[0].x,t[1].x,t[2].x,t[3].x],i=fabric.util.array.min(e),r=fabric.util.array.max(e),n=Math.abs(i-r),s=[t[0].y,t[1].y,t[2].y,t[3].y],o=fabric.util.array.min(s),a=fabric.util.array.max(s),h=Math.abs(o-a);return{left:i,top:o,width:n,height:h}},invertTransform:function(t){var e=1/(t[0]*t[3]-t[1]*t[2]),i=[e*t[3],-e*t[1],-e*t[2],e*t[0]],r=fabric.util.transformPoint({x:t[4],y:t[5]},i,!0);return i[4]=-r.x,i[5]=-r.y,i},toFixed:function(t,e){return parseFloat(Number(t).toFixed(e))},parseUnit:function(t,e){var i=/\D{0,2}$/.exec(t),r=parseFloat(t);switch(e||(e=fabric.Text.DEFAULT_SVG_FONT_SIZE),i[0]){case"mm":return r*fabric.DPI/25.4;case"cm":return r*fabric.DPI/2.54;case"in":return r*fabric.DPI;case"pt":return r*fabric.DPI/72;case"pc":return r*fabric.DPI/72*12;case"em":return r*e;default:return r}},falseFunction:function(){return!1},getKlass:function(t,e){return t=fabric.util.string.camelize(t.charAt(0).toUpperCase()+t.slice(1)),fabric.util.resolveNamespace(e)[t]},resolveNamespace:function(e){if(!e)return fabric;var i,r=e.split("."),n=r.length,s=t||fabric.window;for(i=0;i<n;++i)s=s[r[i]];return s},loadImage:function(t,e,i,r){if(!t)return void(e&&e.call(i,t));var n=fabric.util.createImage();n.onload=function(){e&&e.call(i,n),n=n.onload=n.onerror=null},n.onerror=function(){fabric.log("Error loading "+n.src),e&&e.call(i,null,!0),n=n.onload=n.onerror=null},0!==t.indexOf("data")&&r&&(n.crossOrigin=r),n.src=t},enlivenObjects:function(t,e,i,r){function n(){++o===a&&e&&e(s)}t=t||[];var s=[],o=0,a=t.length,h=!0;return a?void t.forEach(function(t,e){if(!t||!t.type)return void n();var o=fabric.util.getKlass(t.type,i);o.fromObject(t,function(i,o){o||(s[e]=i),r&&r(t,i,o),n()},h)}):void(e&&e(s))},enlivenPatterns:function(t,e){function i(){++n===s&&e&&e(r)}t=t||[];var r=[],n=0,s=t.length;return s?void t.forEach(function(t,e){t&&t.source?new fabric.Pattern(t,function(t){r[e]=t,i()}):(r[e]=t,i())}):void(e&&e(r))},groupSVGElements:function(t,e,i){var r;return r=new fabric.PathGroup(t,e),"undefined"!=typeof i&&(r.sourcePath=i),r},populateWithProperties:function(t,e,i){if(i&&"[object Array]"===Object.prototype.toString.call(i))for(var r=0,n=i.length;r<n;r++)i[r]in t&&(e[i[r]]=t[i[r]])},drawDashedLine:function(t,r,n,s,o,a){var h=s-r,c=o-n,l=e(h*h+c*c),u=i(c,h),f=a.length,d=0,g=!0;for(t.save(),t.translate(r,n),t.moveTo(0,0),t.rotate(u),r=0;l>r;)r+=a[d++%f],r>l&&(r=l),t[g?"lineTo":"moveTo"](r,0),g=!g;t.restore()},createCanvasElement:function(t){return t||(t=fabric.document.createElement("canvas")),t.getContext||"undefined"==typeof G_vmlCanvasManager||G_vmlCanvasManager.initElement(t),t},createImage:function(){return fabric.isLikelyNode?new(require("canvas").Image):fabric.document.createElement("img")},createAccessors:function(t){var e,i,r,n,s,o=t.prototype;for(e=o.stateProperties.length;e--;)i=o.stateProperties[e],r=i.charAt(0).toUpperCase()+i.slice(1),n="set"+r,s="get"+r,o[s]||(o[s]=function(t){return new Function('return this.get("'+t+'")')}(i)),o[n]||(o[n]=function(t){return new Function("value",'return this.set("'+t+'", value)')}(i))},clipContext:function(t,e){e.save(),e.beginPath(),t.clipTo(e),e.clip()},multiplyTransformMatrices:function(t,e,i){return[t[0]*e[0]+t[2]*e[1],t[1]*e[0]+t[3]*e[1],t[0]*e[2]+t[2]*e[3],t[1]*e[2]+t[3]*e[3],i?0:t[0]*e[4]+t[2]*e[5]+t[4],i?0:t[1]*e[4]+t[3]*e[5]+t[5]]},qrDecompose:function(t){var n=i(t[1],t[0]),o=r(t[0],2)+r(t[1],2),a=e(o),h=(t[0]*t[3]-t[2]*t[1])/a,c=i(t[0]*t[2]+t[1]*t[3],o);return{angle:n/s,scaleX:a,scaleY:h,skewX:c/s,skewY:0,translateX:t[4],translateY:t[5]}},customTransformMatrix:function(t,e,i){var r=[1,0,n(Math.tan(i*s)),1],o=[n(t),0,0,n(e)];return fabric.util.multiplyTransformMatrices(o,r,!0)},resetObjectTransform:function(t){t.scaleX=1,t.scaleY=1,t.skewX=0,t.skewY=0,t.flipX=!1,t.flipY=!1,t.setAngle(0)},getFunctionBody:function(t){return(String(t).match(/function[^{]*\{([\s\S]*)\}/)||{})[1]},isTransparent:function(t,e,i,r){r>0&&(e>r?e-=r:e=0,i>r?i-=r:i=0);var n,s,o=!0,a=t.getImageData(e,i,2*r||1,2*r||1),h=a.data.length;for(n=3;n<h&&(s=a.data[n],o=s<=0,o!==!1);n+=4);return a=null,o},parsePreserveAspectRatioAttribute:function(t){var e,i="meet",r="Mid",n="Mid",s=t.split(" ");return s&&s.length&&(i=s.pop(),"meet"!==i&&"slice"!==i?(e=i,i="meet"):s.length&&(e=s.pop())),r="none"!==e?e.slice(1,4):"none",n="none"!==e?e.slice(5,8):"none",{meetOrSlice:i,alignX:r,alignY:n}},clearFabricFontCache:function(t){t?fabric.charWidthsCache[t]&&delete fabric.charWidthsCache[t]:fabric.charWidthsCache={}}}}("undefined"!=typeof exports?exports:this),function(){function t(t,r,s,o,h,c,l){var u=a.call(arguments);if(n[u])return n[u];var f=Math.PI,d=l*f/180,g=Math.sin(d),p=Math.cos(d),v=0,b=0;s=Math.abs(s),o=Math.abs(o);var m=-p*t*.5-g*r*.5,y=-p*r*.5+g*t*.5,_=s*s,x=o*o,C=y*y,S=m*m,w=_*x-_*C-x*S,O=0;if(w<0){var T=Math.sqrt(1-w/(_*x));s*=T,o*=T}else O=(h===c?-1:1)*Math.sqrt(w/(_*C+x*S));var j=O*s*y/o,k=-O*o*m/s,M=p*j-g*k+.5*t,D=g*j+p*k+.5*r,A=i(1,0,(m-j)/s,(y-k)/o),P=i((m-j)/s,(y-k)/o,(-m-j)/s,(-y-k)/o);0===c&&P>0?P-=2*f:1===c&&P<0&&(P+=2*f);for(var I=Math.ceil(Math.abs(P/f*2)),E=[],L=P/I,F=8/3*Math.sin(L/4)*Math.sin(L/4)/Math.sin(L/2),B=A+L,R=0;R<I;R++)E[R]=e(A,B,p,g,s,o,M,D,F,v,b),v=E[R][4],b=E[R][5],A=B,B+=L;return n[u]=E,E}function e(t,e,i,r,n,o,h,c,l,u,f){var d=a.call(arguments);if(s[d])return s[d];var g=Math.cos(t),p=Math.sin(t),v=Math.cos(e),b=Math.sin(e),m=i*n*v-r*o*b+h,y=r*n*v+i*o*b+c,_=u+l*(-i*n*p-r*o*g),x=f+l*(-r*n*p+i*o*g),C=m+l*(i*n*b+r*o*v),S=y+l*(r*n*b-i*o*v);return s[d]=[_,x,C,S,m,y],s[d]}function i(t,e,i,r){var n=Math.atan2(e,t),s=Math.atan2(r,i);return s>=n?s-n:2*Math.PI-(n-s)}function r(t,e,i,r,n,s,h,c){var l=a.call(arguments);if(o[l])return o[l];var u,f,d,g,p,v,b,m,y=Math.sqrt,_=Math.min,x=Math.max,C=Math.abs,S=[],w=[[],[]];f=6*t-12*i+6*n,u=-3*t+9*i-9*n+3*h,d=3*i-3*t;for(var O=0;O<2;++O)if(O>0&&(f=6*e-12*r+6*s,u=-3*e+9*r-9*s+3*c,d=3*r-3*e),C(u)<1e-12){if(C(f)<1e-12)continue;g=-d/f,0<g&&g<1&&S.push(g)}else b=f*f-4*d*u,b<0||(m=y(b),p=(-f+m)/(2*u),0<p&&p<1&&S.push(p),v=(-f-m)/(2*u),0<v&&v<1&&S.push(v));for(var T,j,k,M=S.length,D=M;M--;)g=S[M],k=1-g,T=k*k*k*t+3*k*k*g*i+3*k*g*g*n+g*g*g*h,w[0][M]=T,j=k*k*k*e+3*k*k*g*r+3*k*g*g*s+g*g*g*c,w[1][M]=j;w[0][D]=t,w[1][D]=e,w[0][D+1]=h,w[1][D+1]=c;var A=[{x:_.apply(null,w[0]),y:_.apply(null,w[1])},{x:x.apply(null,w[0]),y:x.apply(null,w[1])}];return o[l]=A,A}var n={},s={},o={},a=Array.prototype.join;fabric.util.drawArc=function(e,i,r,n){for(var s=n[0],o=n[1],a=n[2],h=n[3],c=n[4],l=n[5],u=n[6],f=[[],[],[],[]],d=t(l-i,u-r,s,o,h,c,a),g=0,p=d.length;g<p;g++)f[g][0]=d[g][0]+i,f[g][1]=d[g][1]+r,f[g][2]=d[g][2]+i,f[g][3]=d[g][3]+r,f[g][4]=d[g][4]+i,f[g][5]=d[g][5]+r,e.bezierCurveTo.apply(e,f[g])},fabric.util.getBoundsOfArc=function(e,i,n,s,o,a,h,c,l){for(var u,f=0,d=0,g=[],p=t(c-e,l-i,n,s,a,h,o),v=0,b=p.length;v<b;v++)u=r(f,d,p[v][0],p[v][1],p[v][2],p[v][3],p[v][4],p[v][5]),g.push({x:u[0].x+e,y:u[0].y+i}),g.push({x:u[1].x+e,y:u[1].y+i}),f=p[v][4],d=p[v][5];return g},fabric.util.getBoundsOfCurve=r}(),function(){function t(t,e){for(var i=s.call(arguments,2),r=[],n=0,o=t.length;n<o;n++)r[n]=i.length?t[n][e].apply(t[n],i):t[n][e].call(t[n]);return r}function e(t,e){return n(t,e,function(t,e){return t>=e})}function i(t,e){return n(t,e,function(t,e){return t<e})}function r(t,e){for(var i=t.length;i--;)t[i]=e;return t}function n(t,e,i){if(t&&0!==t.length){var r=t.length-1,n=e?t[r][e]:t[r];if(e)for(;r--;)i(t[r][e],n)&&(n=t[r][e]);else for(;r--;)i(t[r],n)&&(n=t[r]);return n}}var s=Array.prototype.slice;Array.prototype.indexOf||(Array.prototype.indexOf=function(t){if(void 0===this||null===this)throw new TypeError;var e=Object(this),i=e.length>>>0;if(0===i)return-1;var r=0;if(arguments.length>0&&(r=Number(arguments[1]),r!==r?r=0:0!==r&&r!==Number.POSITIVE_INFINITY&&r!==Number.NEGATIVE_INFINITY&&(r=(r>0||-1)*Math.floor(Math.abs(r)))),r>=i)return-1;for(var n=r>=0?r:Math.max(i-Math.abs(r),0);n<i;n++)if(n in e&&e[n]===t)return n;return-1}),Array.prototype.forEach||(Array.prototype.forEach=function(t,e){for(var i=0,r=this.length>>>0;i<r;i++)i in this&&t.call(e,this[i],i,this)}),Array.prototype.map||(Array.prototype.map=function(t,e){for(var i=[],r=0,n=this.length>>>0;r<n;r++)r in this&&(i[r]=t.call(e,this[r],r,this));return i}),Array.prototype.every||(Array.prototype.every=function(t,e){for(var i=0,r=this.length>>>0;i<r;i++)if(i in this&&!t.call(e,this[i],i,this))return!1;return!0}),Array.prototype.some||(Array.prototype.some=function(t,e){for(var i=0,r=this.length>>>0;i<r;i++)if(i in this&&t.call(e,this[i],i,this))return!0;return!1}),Array.prototype.filter||(Array.prototype.filter=function(t,e){for(var i,r=[],n=0,s=this.length>>>0;n<s;n++)n in this&&(i=this[n],t.call(e,i,n,this)&&r.push(i));return r}),Array.prototype.reduce||(Array.prototype.reduce=function(t){var e,i=this.length>>>0,r=0;if(arguments.length>1)e=arguments[1];else for(;;){if(r in this){e=this[r++];break}if(++r>=i)throw new TypeError}for(;r<i;r++)r in this&&(e=t.call(null,e,this[r],r,this));return e}),fabric.util.array={fill:r,invoke:t,min:i,max:e}}(),function(){function t(e,i,r){if(r)if(!fabric.isLikelyNode&&i instanceof Element)e=i;else if(i instanceof Array){e=[];for(var n=0,s=i.length;n<s;n++)e[n]=t({},i[n],r)}else if(i&&"object"==typeof i)for(var o in i)i.hasOwnProperty(o)&&(e[o]=t({},i[o],r));else e=i;else for(var o in i)e[o]=i[o];return e}function e(e,i){return t({},e,i)}fabric.util.object={extend:t,clone:e}}(),function(){function t(t){return t.replace(/-+(.)?/g,function(t,e){return e?e.toUpperCase():""})}function e(t,e){return t.charAt(0).toUpperCase()+(e?t.slice(1):t.slice(1).toLowerCase())}function i(t){return t.replace(/&/g,"&amp;").replace(/"/g,"&quot;").replace(/'/g,"&apos;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}String.prototype.trim||(String.prototype.trim=function(){return this.replace(/^[\s\xA0]+/,"").replace(/[\s\xA0]+$/,"")}),fabric.util.string={camelize:t,capitalize:e,escapeXml:i}}(),function(){var t=Array.prototype.slice,e=Function.prototype.apply,i=function(){};Function.prototype.bind||(Function.prototype.bind=function(r){var n,s=this,o=t.call(arguments,1);return n=o.length?function(){return e.call(s,this instanceof i?this:r,o.concat(t.call(arguments)))}:function(){return e.call(s,this instanceof i?this:r,arguments)},i.prototype=this.prototype,n.prototype=new i,n})}(),function(){function t(){}function e(t){for(var e=null,i=this;i.constructor.superclass;){var n=i.constructor.superclass.prototype[t];if(i[t]!==n){e=n;break}i=i.constructor.superclass.prototype}return e?arguments.length>1?e.apply(this,r.call(arguments,1)):e.call(this):console.log("tried to callSuper "+t+", method not found in prototype chain",this)}function i(){function i(){this.initialize.apply(this,arguments)}var s=null,a=r.call(arguments,0);"function"==typeof a[0]&&(s=a.shift()),i.superclass=s,i.subclasses=[],s&&(t.prototype=s.prototype,i.prototype=new t,s.subclasses.push(i));for(var h=0,c=a.length;h<c;h++)o(i,a[h],s);return i.prototype.initialize||(i.prototype.initialize=n),i.prototype.constructor=i,i.prototype.callSuper=e,i}var r=Array.prototype.slice,n=function(){},s=function(){for(var t in{toString:1})if("toString"===t)return!1;return!0}(),o=function(t,e,i){for(var r in e)r in t.prototype&&"function"==typeof t.prototype[r]&&(e[r]+"").indexOf("callSuper")>-1?t.prototype[r]=function(t){return function(){var r=this.constructor.superclass;this.constructor.superclass=i;var n=e[t].apply(this,arguments);if(this.constructor.superclass=r,"initialize"!==t)return n}}(r):t.prototype[r]=e[r],s&&(e.toString!==Object.prototype.toString&&(t.prototype.toString=e.toString),e.valueOf!==Object.prototype.valueOf&&(t.prototype.valueOf=e.valueOf))};fabric.util.createClass=i}(),function(){function t(t){var e,i,r=Array.prototype.slice.call(arguments,1),n=r.length;for(i=0;i<n;i++)if(e=typeof t[r[i]],!/^(?:function|object|unknown)$/.test(e))return!1;return!0}function e(t,e){return{handler:e,wrappedHandler:i(t,e)}}function i(t,e){return function(i){e.call(o(t),i||fabric.window.event)}}function r(t,e){return function(i){if(p[t]&&p[t][e])for(var r=p[t][e],n=0,s=r.length;n<s;n++)r[n].call(this,i||fabric.window.event)}}function n(t){t||(t=fabric.window.event);var e=t.target||(typeof t.srcElement!==h?t.srcElement:null),i=fabric.util.getScrollLeftTop(e);return{x:v(t)+i.left,y:b(t)+i.top}}function s(t,e,i){var r="touchend"===t.type?"changedTouches":"touches";return t[r]&&t[r][0]?t[r][0][e]-(t[r][0][e]-t[r][0][i])||t[i]:t[i]}var o,a,h="unknown",c=function(){var t=0;return function(e){return e.__uniqueID||(e.__uniqueID="uniqueID__"+t++)}}();!function(){var t={};o=function(e){return t[e]},a=function(e,i){t[e]=i}}();var l,u,f=t(fabric.document.documentElement,"addEventListener","removeEventListener")&&t(fabric.window,"addEventListener","removeEventListener"),d=t(fabric.document.documentElement,"attachEvent","detachEvent")&&t(fabric.window,"attachEvent","detachEvent"),g={},p={};f?(l=function(t,e,i,r){t.addEventListener(e,i,!d&&r)},u=function(t,e,i,r){t.removeEventListener(e,i,!d&&r)}):d?(l=function(t,i,r){var n=c(t);a(n,t),g[n]||(g[n]={}),g[n][i]||(g[n][i]=[]);var s=e(n,r);g[n][i].push(s),t.attachEvent("on"+i,s.wrappedHandler)},u=function(t,e,i){var r,n=c(t);if(g[n]&&g[n][e])for(var s=0,o=g[n][e].length;s<o;s++)r=g[n][e][s],r&&r.handler===i&&(t.detachEvent("on"+e,r.wrappedHandler),g[n][e][s]=null)}):(l=function(t,e,i){var n=c(t);if(p[n]||(p[n]={}),!p[n][e]){p[n][e]=[];var s=t["on"+e];s&&p[n][e].push(s),t["on"+e]=r(n,e)}p[n][e].push(i)},u=function(t,e,i){var r=c(t);if(p[r]&&p[r][e])for(var n=p[r][e],s=0,o=n.length;s<o;s++)n[s]===i&&n.splice(s,1)}),fabric.util.addListener=l,fabric.util.removeListener=u;var v=function(t){return typeof t.clientX!==h?t.clientX:0},b=function(t){return typeof t.clientY!==h?t.clientY:0};fabric.isTouchSupported&&(v=function(t){return s(t,"pageX","clientX")},b=function(t){return s(t,"pageY","clientY")}),fabric.util.getPointer=n,fabric.util.object.extend(fabric.util,fabric.Observable)}(),function(){function t(t,e){var i=t.style;if(!i)return t;if("string"==typeof e)return t.style.cssText+=";"+e,e.indexOf("opacity")>-1?s(t,e.match(/opacity:\s*(\d?\.?\d*)/)[1]):t;for(var r in e)if("opacity"===r)s(t,e[r]);else{var n="float"===r||"cssFloat"===r?"undefined"==typeof i.styleFloat?"cssFloat":"styleFloat":r;i[n]=e[r]}return t}var e=fabric.document.createElement("div"),i="string"==typeof e.style.opacity,r="string"==typeof e.style.filter,n=/alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/,s=function(t){return t};i?s=function(t,e){return t.style.opacity=e,t}:r&&(s=function(t,e){var i=t.style;return t.currentStyle&&!t.currentStyle.hasLayout&&(i.zoom=1),n.test(i.filter)?(e=e>=.9999?"":"alpha(opacity="+100*e+")",i.filter=i.filter.replace(n,e)):i.filter+=" alpha(opacity="+100*e+")",t}),fabric.util.setStyle=t}(),function(){function t(t){return"string"==typeof t?fabric.document.getElementById(t):t}function e(t,e){var i=fabric.document.createElement(t);for(var r in e)"class"===r?i.className=e[r]:"for"===r?i.htmlFor=e[r]:i.setAttribute(r,e[r]);return i}function i(t,e){t&&(" "+t.className+" ").indexOf(" "+e+" ")===-1&&(t.className+=(t.className?" ":"")+e)}function r(t,i,r){return"string"==typeof i&&(i=e(i,r)),t.parentNode&&t.parentNode.replaceChild(i,t),i.appendChild(t),i}function n(t){for(var e=0,i=0,r=fabric.document.documentElement,n=fabric.document.body||{scrollLeft:0,scrollTop:0};t&&(t.parentNode||t.host)&&(t=t.parentNode||t.host,t===fabric.document?(e=n.scrollLeft||r.scrollLeft||0,i=n.scrollTop||r.scrollTop||0):(e+=t.scrollLeft||0,i+=t.scrollTop||0),1!==t.nodeType||"fixed"!==fabric.util.getElementStyle(t,"position")););return{left:e,top:i}}function s(t){var e,i,r=t&&t.ownerDocument,s={left:0,top:0},o={left:0,top:0},a={borderLeftWidth:"left",borderTopWidth:"top",paddingLeft:"left",paddingTop:"top"};if(!r)return o;for(var h in a)o[a[h]]+=parseInt(c(t,h),10)||0;return e=r.documentElement,"undefined"!=typeof t.getBoundingClientRect&&(s=t.getBoundingClientRect()),i=n(t),{left:s.left+i.left-(e.clientLeft||0)+o.left,top:s.top+i.top-(e.clientTop||0)+o.top}}var o,a=Array.prototype.slice,h=function(t){return a.call(t,0)};try{o=h(fabric.document.childNodes)instanceof Array}catch(t){}o||(h=function(t){for(var e=new Array(t.length),i=t.length;i--;)e[i]=t[i];return e});var c;c=fabric.document.defaultView&&fabric.document.defaultView.getComputedStyle?function(t,e){var i=fabric.document.defaultView.getComputedStyle(t,null);return i?i[e]:void 0}:function(t,e){var i=t.style[e];return!i&&t.currentStyle&&(i=t.currentStyle[e]),i},function(){function t(t){return"undefined"!=typeof t.onselectstart&&(t.onselectstart=fabric.util.falseFunction),r?t.style[r]="none":"string"==typeof t.unselectable&&(t.unselectable="on"),t}function e(t){return"undefined"!=typeof t.onselectstart&&(t.onselectstart=null),r?t.style[r]="":"string"==typeof t.unselectable&&(t.unselectable=""),t}var i=fabric.document.documentElement.style,r="userSelect"in i?"userSelect":"MozUserSelect"in i?"MozUserSelect":"WebkitUserSelect"in i?"WebkitUserSelect":"KhtmlUserSelect"in i?"KhtmlUserSelect":"";fabric.util.makeElementUnselectable=t,fabric.util.makeElementSelectable=e}(),function(){function t(t,e){var i=fabric.document.getElementsByTagName("head")[0],r=fabric.document.createElement("script"),n=!0;r.onload=r.onreadystatechange=function(t){if(n){if("string"==typeof this.readyState&&"loaded"!==this.readyState&&"complete"!==this.readyState)return;n=!1,e(t||fabric.window.event),r=r.onload=r.onreadystatechange=null}},r.src=t,i.appendChild(r)}fabric.util.getScript=t}(),fabric.util.getById=t,fabric.util.toArray=h,fabric.util.makeElement=e,fabric.util.addClass=i,fabric.util.wrapElement=r,fabric.util.getScrollLeftTop=n,fabric.util.getElementOffset=s,fabric.util.getElementStyle=c}(),function(){function t(t,e){return t+(/\?/.test(t)?"&":"?")+e}function e(){}function i(i,n){n||(n={});var s=n.method?n.method.toUpperCase():"GET",o=n.onComplete||function(){},a=r(),h=n.body||n.parameters;return a.onreadystatechange=function(){4===a.readyState&&(o(a),a.onreadystatechange=e)},"GET"===s&&(h=null,"string"==typeof n.parameters&&(i=t(i,n.parameters))),a.open(s,i,!0),"POST"!==s&&"PUT"!==s||a.setRequestHeader("Content-Type","application/x-www-form-urlencoded"),a.send(h),a}var r=function(){for(var t=[function(){return new ActiveXObject("Microsoft.XMLHTTP")},function(){return new ActiveXObject("Msxml2.XMLHTTP")},function(){return new ActiveXObject("Msxml2.XMLHTTP.3.0")},function(){return new XMLHttpRequest}],e=t.length;e--;)try{var i=t[e]();if(i)return t[e]}catch(t){}}();fabric.util.request=i}(),fabric.log=function(){},fabric.warn=function(){},"undefined"!=typeof console&&["log","warn"].forEach(function(t){"undefined"!=typeof console[t]&&"function"==typeof console[t].apply&&(fabric[t]=function(){return console[t].apply(console,arguments)})}),function(){function t(t){e(function(i){t||(t={});var r,n=i||+new Date,s=t.duration||500,o=n+s,a=t.onChange||function(){},h=t.abort||function(){return!1},c=t.easing||function(t,e,i,r){return-i*Math.cos(t/r*(Math.PI/2))+i+e},l="startValue"in t?t.startValue:0,u="endValue"in t?t.endValue:100,f=t.byValue||u-l;t.onStart&&t.onStart(),function i(u){r=u||+new Date;var d=r>o?s:r-n;return h()?void(t.onComplete&&t.onComplete()):(a(c(d,l,f,s)),r>o?void(t.onComplete&&t.onComplete()):void e(i))}(n)})}function e(){return i.apply(fabric.window,arguments)}var i=fabric.window.requestAnimationFrame||fabric.window.webkitRequestAnimationFrame||fabric.window.mozRequestAnimationFrame||fabric.window.oRequestAnimationFrame||fabric.window.msRequestAnimationFrame||function(t){fabric.window.setTimeout(t,1e3/60)};fabric.util.animate=t,fabric.util.requestAnimFrame=e}(),function(){function t(t,e,i){var r="rgba("+parseInt(t[0]+i*(e[0]-t[0]),10)+","+parseInt(t[1]+i*(e[1]-t[1]),10)+","+parseInt(t[2]+i*(e[2]-t[2]),10);return r+=","+(t&&e?parseFloat(t[3]+i*(e[3]-t[3])):1),r+=")"}function e(e,i,r,n){var s=new fabric.Color(e).getSource(),o=new fabric.Color(i).getSource();n=n||{},fabric.util.animate(fabric.util.object.extend(n,{duration:r||500,startValue:s,endValue:o,byValue:o,easing:function(e,i,r,s){var o=n.colorEasing?n.colorEasing(e,s):1-Math.cos(e/s*(Math.PI/2));return t(i,r,o)}}))}fabric.util.animateColor=e}(),function(){function t(t,e,i,r){return t<Math.abs(e)?(t=e,r=i/4):r=0===e&&0===t?i/(2*Math.PI)*Math.asin(1):i/(2*Math.PI)*Math.asin(e/t),{a:t,c:e,p:i,s:r}}function e(t,e,i){return t.a*Math.pow(2,10*(e-=1))*Math.sin((e*i-t.s)*(2*Math.PI)/t.p)}function i(t,e,i,r){return i*((t=t/r-1)*t*t+1)+e}function r(t,e,i,r){return t/=r/2,t<1?i/2*t*t*t+e:i/2*((t-=2)*t*t+2)+e}function n(t,e,i,r){return i*(t/=r)*t*t*t+e}function s(t,e,i,r){return-i*((t=t/r-1)*t*t*t-1)+e}function o(t,e,i,r){return t/=r/2,t<1?i/2*t*t*t*t+e:-i/2*((t-=2)*t*t*t-2)+e}function a(t,e,i,r){return i*(t/=r)*t*t*t*t+e}function h(t,e,i,r){return i*((t=t/r-1)*t*t*t*t+1)+e}function c(t,e,i,r){return t/=r/2,t<1?i/2*t*t*t*t*t+e:i/2*((t-=2)*t*t*t*t+2)+e}function l(t,e,i,r){return-i*Math.cos(t/r*(Math.PI/2))+i+e}function u(t,e,i,r){return i*Math.sin(t/r*(Math.PI/2))+e}function f(t,e,i,r){return-i/2*(Math.cos(Math.PI*t/r)-1)+e}function d(t,e,i,r){return 0===t?e:i*Math.pow(2,10*(t/r-1))+e}function g(t,e,i,r){return t===r?e+i:i*(-Math.pow(2,-10*t/r)+1)+e}function p(t,e,i,r){return 0===t?e:t===r?e+i:(t/=r/2,t<1?i/2*Math.pow(2,10*(t-1))+e:i/2*(-Math.pow(2,-10*--t)+2)+e)}function v(t,e,i,r){return-i*(Math.sqrt(1-(t/=r)*t)-1)+e}function b(t,e,i,r){return i*Math.sqrt(1-(t=t/r-1)*t)+e}function m(t,e,i,r){return t/=r/2,t<1?-i/2*(Math.sqrt(1-t*t)-1)+e:i/2*(Math.sqrt(1-(t-=2)*t)+1)+e}function y(i,r,n,s){var o=1.70158,a=0,h=n;if(0===i)return r;if(i/=s,1===i)return r+n;a||(a=.3*s);var c=t(h,n,a,o);return-e(c,i,s)+r}function _(e,i,r,n){var s=1.70158,o=0,a=r;if(0===e)return i;if(e/=n,1===e)return i+r;o||(o=.3*n);var h=t(a,r,o,s);return h.a*Math.pow(2,-10*e)*Math.sin((e*n-h.s)*(2*Math.PI)/h.p)+h.c+i}function x(i,r,n,s){var o=1.70158,a=0,h=n;if(0===i)return r;if(i/=s/2,2===i)return r+n;a||(a=s*(.3*1.5));var c=t(h,n,a,o);return i<1?-.5*e(c,i,s)+r:c.a*Math.pow(2,-10*(i-=1))*Math.sin((i*s-c.s)*(2*Math.PI)/c.p)*.5+c.c+r}function C(t,e,i,r,n){return void 0===n&&(n=1.70158),i*(t/=r)*t*((n+1)*t-n)+e}function S(t,e,i,r,n){return void 0===n&&(n=1.70158),i*((t=t/r-1)*t*((n+1)*t+n)+1)+e}function w(t,e,i,r,n){return void 0===n&&(n=1.70158),t/=r/2,t<1?i/2*(t*t*(((n*=1.525)+1)*t-n))+e:i/2*((t-=2)*t*(((n*=1.525)+1)*t+n)+2)+e}function O(t,e,i,r){return i-T(r-t,0,i,r)+e}function T(t,e,i,r){return(t/=r)<1/2.75?i*(7.5625*t*t)+e:t<2/2.75?i*(7.5625*(t-=1.5/2.75)*t+.75)+e:t<2.5/2.75?i*(7.5625*(t-=2.25/2.75)*t+.9375)+e:i*(7.5625*(t-=2.625/2.75)*t+.984375)+e}function j(t,e,i,r){return t<r/2?.5*O(2*t,0,i,r)+e:.5*T(2*t-r,0,i,r)+.5*i+e}fabric.util.ease={easeInQuad:function(t,e,i,r){return i*(t/=r)*t+e},easeOutQuad:function(t,e,i,r){return-i*(t/=r)*(t-2)+e},easeInOutQuad:function(t,e,i,r){return t/=r/2,t<1?i/2*t*t+e:-i/2*(--t*(t-2)-1)+e},easeInCubic:function(t,e,i,r){return i*(t/=r)*t*t+e},easeOutCubic:i,easeInOutCubic:r,easeInQuart:n,easeOutQuart:s,easeInOutQuart:o,easeInQuint:a,easeOutQuint:h,easeInOutQuint:c,easeInSine:l,easeOutSine:u,easeInOutSine:f,easeInExpo:d,easeOutExpo:g,easeInOutExpo:p,easeInCirc:v,easeOutCirc:b,easeInOutCirc:m,easeInElastic:y,easeOutElastic:_,easeInOutElastic:x,easeInBack:C,easeOutBack:S,easeInOutBack:w,easeInBounce:O,easeOutBounce:T,easeInOutBounce:j}}(),function(t){"use strict";function e(t){return t in O?O[t]:t}function i(t,e,i,r){var n,s="[object Array]"===Object.prototype.toString.call(e);return"fill"!==t&&"stroke"!==t||"none"!==e?"strokeDashArray"===t?e="none"===e?null:e.replace(/,/g," ").split(/\s+/).map(function(t){return parseFloat(t)}):"transformMatrix"===t?e=i&&i.transformMatrix?_(i.transformMatrix,p.parseTransformAttribute(e)):p.parseTransformAttribute(e):"visible"===t?(e="none"!==e&&"hidden"!==e,i&&i.visible===!1&&(e=!1)):"opacity"===t?(e=parseFloat(e),i&&"undefined"!=typeof i.opacity&&(e*=i.opacity)):"originX"===t?e="start"===e?"left":"end"===e?"right":"center":n=s?e.map(y):y(e,r):e="",!s&&isNaN(n)?e:n}function r(t){for(var e in T)if("undefined"!=typeof t[T[e]]&&""!==t[e]){if("undefined"==typeof t[e]){if(!p.Object.prototype[e])continue;t[e]=p.Object.prototype[e]}if(0!==t[e].indexOf("url(")){var i=new p.Color(t[e]);t[e]=i.setAlpha(m(i.getAlpha()*t[T[e]],2)).toRgba()}}return t}function n(t,e){for(var i,r,n=[],s=0;s<e.length;s++)i=e[s],r=t.getElementsByTagName(i),n=n.concat(Array.prototype.slice.call(r));return n}function s(t,e){var i,r;t.replace(/;\s*$/,"").split(";").forEach(function(t){var n=t.split(":");i=n[0].trim().toLowerCase(),r=n[1].trim(),e[i]=r})}function o(t,e){var i,r;for(var n in t)"undefined"!=typeof t[n]&&(i=n.toLowerCase(),r=t[n],e[i]=r)}function a(t,e){var i={};for(var r in p.cssRules[e])if(h(t,r.split(" ")))for(var n in p.cssRules[e][r])i[n]=p.cssRules[e][r][n];return i}function h(t,e){var i,r=!0;return i=l(t,e.pop()),i&&e.length&&(r=c(t,e)),i&&r&&0===e.length}function c(t,e){for(var i,r=!0;t.parentNode&&1===t.parentNode.nodeType&&e.length;)r&&(i=e.pop()),t=t.parentNode,r=l(t,i);return 0===e.length}function l(t,e){var i,r=t.nodeName,n=t.getAttribute("class"),s=t.getAttribute("id");if(i=new RegExp("^"+r,"i"),e=e.replace(i,""),s&&e.length&&(i=new RegExp("#"+s+"(?![a-zA-Z\\-]+)","i"),e=e.replace(i,"")),n&&e.length){n=n.split(" ");for(var o=n.length;o--;)i=new RegExp("\\."+n[o]+"(?![a-zA-Z\\-]+)","i"),e=e.replace(i,"")}return 0===e.length}function u(t,e){var i;if(t.getElementById&&(i=t.getElementById(e)),i)return i;var r,n,s=t.getElementsByTagName("*");for(n=0;n<s.length;n++)if(r=s[n],e===r.getAttribute("id"))return r}function f(t){for(var e=n(t,["use","svg:use"]),i=0;e.length&&i<e.length;){var r,s,o,a,h,c=e[i],l=c.getAttribute("xlink:href").substr(1),f=c.getAttribute("x")||0,g=c.getAttribute("y")||0,p=u(t,l).cloneNode(!0),v=(p.getAttribute("transform")||"")+" translate("+f+", "+g+")",b=e.length;if(d(p),/^svg$/i.test(p.nodeName)){var m=p.ownerDocument.createElement("g");for(o=0,a=p.attributes,h=a.length;o<h;o++)s=a.item(o),m.setAttribute(s.nodeName,s.nodeValue);for(;p.firstChild;)m.appendChild(p.firstChild);p=m}for(o=0,a=c.attributes,h=a.length;o<h;o++)s=a.item(o),"x"!==s.nodeName&&"y"!==s.nodeName&&"xlink:href"!==s.nodeName&&("transform"===s.nodeName?v=s.nodeValue+" "+v:p.setAttribute(s.nodeName,s.nodeValue));p.setAttribute("transform",v),p.setAttribute("instantiated_by_use","1"),p.removeAttribute("id"),r=c.parentNode,r.replaceChild(p,c),e.length===b&&i++}}function d(t){var e,i,r,n,s=t.getAttribute("viewBox"),o=1,a=1,h=0,c=0,l=t.getAttribute("width"),u=t.getAttribute("height"),f=t.getAttribute("x")||0,d=t.getAttribute("y")||0,g=t.getAttribute("preserveAspectRatio")||"",v=!s||!C.test(t.nodeName)||!(s=s.match(j)),b=!l||!u||"100%"===l||"100%"===u,m=v&&b,_={},x="";if(_.width=0,_.height=0,_.toBeParsed=m,m)return _;if(v)return _.width=y(l),_.height=y(u),_;if(h=-parseFloat(s[1]),c=-parseFloat(s[2]),e=parseFloat(s[3]),i=parseFloat(s[4]),b?(_.width=e,_.height=i):(_.width=y(l),_.height=y(u),o=_.width/e,a=_.height/i),g=p.util.parsePreserveAspectRatioAttribute(g),"none"!==g.alignX&&(a=o=o>a?a:o),1===o&&1===a&&0===h&&0===c&&0===f&&0===d)return _;if((f||d)&&(x=" translate("+y(f)+" "+y(d)+") "),r=x+" matrix("+o+" 0 0 "+a+" "+h*o+" "+c*a+") ",
"svg"===t.nodeName){for(n=t.ownerDocument.createElement("g");t.firstChild;)n.appendChild(t.firstChild);t.appendChild(n)}else n=t,r=n.getAttribute("transform")+r;return n.setAttribute("transform",r),_}function g(t,e){for(;t&&(t=t.parentNode);)if(t.nodeName&&e.test(t.nodeName.replace("svg:",""))&&!t.getAttribute("instantiated_by_use"))return!0;return!1}var p=t.fabric||(t.fabric={}),v=p.util.object.extend,b=p.util.object.clone,m=p.util.toFixed,y=p.util.parseUnit,_=p.util.multiplyTransformMatrices,x=/^(path|circle|polygon|polyline|ellipse|rect|line|image|text)$/i,C=/^(symbol|image|marker|pattern|view|svg)$/i,S=/^(?:pattern|defs|symbol|metadata|clipPath|mask)$/i,w=/^(symbol|g|a|svg)$/i,O={cx:"left",x:"left",r:"radius",cy:"top",y:"top",display:"visible",visibility:"visible",transform:"transformMatrix","fill-opacity":"fillOpacity","fill-rule":"fillRule","font-family":"fontFamily","font-size":"fontSize","font-style":"fontStyle","font-weight":"fontWeight","stroke-dasharray":"strokeDashArray","stroke-linecap":"strokeLineCap","stroke-linejoin":"strokeLineJoin","stroke-miterlimit":"strokeMiterLimit","stroke-opacity":"strokeOpacity","stroke-width":"strokeWidth","text-decoration":"textDecoration","text-anchor":"originX",opacity:"opacity"},T={stroke:"strokeOpacity",fill:"fillOpacity"};p.cssRules={},p.gradientDefs={},p.parseTransformAttribute=function(){function t(t,e){var i=Math.cos(e[0]),r=Math.sin(e[0]),n=0,s=0;3===e.length&&(n=e[1],s=e[2]),t[0]=i,t[1]=r,t[2]=-r,t[3]=i,t[4]=n-(i*n-r*s),t[5]=s-(r*n+i*s)}function e(t,e){var i=e[0],r=2===e.length?e[1]:e[0];t[0]=i,t[3]=r}function i(t,e,i){t[i]=Math.tan(p.util.degreesToRadians(e[0]))}function r(t,e){t[4]=e[0],2===e.length&&(t[5]=e[1])}var n=[1,0,0,1,0,0],s=p.reNum,o="(?:\\s+,?\\s*|,\\s*)",a="(?:(skewX)\\s*\\(\\s*("+s+")\\s*\\))",h="(?:(skewY)\\s*\\(\\s*("+s+")\\s*\\))",c="(?:(rotate)\\s*\\(\\s*("+s+")(?:"+o+"("+s+")"+o+"("+s+"))?\\s*\\))",l="(?:(scale)\\s*\\(\\s*("+s+")(?:"+o+"("+s+"))?\\s*\\))",u="(?:(translate)\\s*\\(\\s*("+s+")(?:"+o+"("+s+"))?\\s*\\))",f="(?:(matrix)\\s*\\(\\s*("+s+")"+o+"("+s+")"+o+"("+s+")"+o+"("+s+")"+o+"("+s+")"+o+"("+s+")\\s*\\))",d="(?:"+f+"|"+u+"|"+l+"|"+c+"|"+a+"|"+h+")",g="(?:"+d+"(?:"+o+"*"+d+")*)",v="^\\s*(?:"+g+"?)\\s*$",b=new RegExp(v),m=new RegExp(d,"g");return function(s){var o=n.concat(),a=[];if(!s||s&&!b.test(s))return o;s.replace(m,function(s){var h=new RegExp(d).exec(s).filter(function(t){return!!t}),c=h[1],l=h.slice(2).map(parseFloat);switch(c){case"translate":r(o,l);break;case"rotate":l[0]=p.util.degreesToRadians(l[0]),t(o,l);break;case"scale":e(o,l);break;case"skewX":i(o,l,2);break;case"skewY":i(o,l,1);break;case"matrix":o=l}a.push(o.concat()),o=n.concat()});for(var h=a[0];a.length>1;)a.shift(),h=p.util.multiplyTransformMatrices(h,a[0]);return h}}();var j=new RegExp("^\\s*("+p.reNum+"+)\\s*,?\\s*("+p.reNum+"+)\\s*,?\\s*("+p.reNum+"+)\\s*,?\\s*("+p.reNum+"+)\\s*$");p.parseSVGDocument=function(t,e,i,r){if(t){f(t);var n=p.Object.__uid++,s=d(t),o=p.util.toArray(t.getElementsByTagName("*"));if(s.crossOrigin=r&&r.crossOrigin,s.svgUid=n,0===o.length&&p.isLikelyNode){o=t.selectNodes('//*[name(.)!="svg"]');for(var a=[],h=0,c=o.length;h<c;h++)a[h]=o[h];o=a}var l=o.filter(function(t){return d(t),x.test(t.nodeName.replace("svg:",""))&&!g(t,S)});if(!l||l&&!l.length)return void(e&&e([],{}));p.gradientDefs[n]=p.getGradientDefs(t),p.cssRules[n]=p.getCSSRules(t),p.parseElements(l,function(t){e&&e(t,s)},b(s),i,r)}};var k=new RegExp("(normal|italic)?\\s*(normal|small-caps)?\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*("+p.reNum+"(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|"+p.reNum+"))?\\s+(.*)");v(p,{parseFontDeclaration:function(t,e){var i=t.match(k);if(i){var r=i[1],n=i[3],s=i[4],o=i[5],a=i[6];r&&(e.fontStyle=r),n&&(e.fontWeight=isNaN(parseFloat(n))?n:parseFloat(n)),s&&(e.fontSize=y(s)),a&&(e.fontFamily=a),o&&(e.lineHeight="normal"===o?1:o)}},getGradientDefs:function(t){var e,i,r,s=["linearGradient","radialGradient","svg:linearGradient","svg:radialGradient"],o=n(t,s),a=0,h={},c={};for(a=o.length;a--;)e=o[a],r=e.getAttribute("xlink:href"),i=e.getAttribute("id"),r&&(c[i]=r.substr(1)),h[i]=e;for(i in c){var l=h[c[i]].cloneNode(!0);for(e=h[i];l.firstChild;)e.appendChild(l.firstChild)}return h},parseAttributes:function(t,n,s){if(t){var o,h,c={};"undefined"==typeof s&&(s=t.getAttribute("svgUid")),t.parentNode&&w.test(t.parentNode.nodeName)&&(c=p.parseAttributes(t.parentNode,n,s)),h=c&&c.fontSize||t.getAttribute("font-size")||p.Text.DEFAULT_SVG_FONT_SIZE;var l=n.reduce(function(e,i){return o=t.getAttribute(i),o&&(e[i]=o),e},{});l=v(l,v(a(t,s),p.parseStyleAttribute(t)));var u,f,d={};for(var g in l)u=e(g),f=i(u,l[g],c,h),d[u]=f;d&&d.font&&p.parseFontDeclaration(d.font,d);var b=v(c,d);return w.test(t.nodeName)?b:r(b)}},parseElements:function(t,e,i,r,n){new p.ElementsParser(t,e,i,r,n).parse()},parseStyleAttribute:function(t){var e={},i=t.getAttribute("style");return i?("string"==typeof i?s(i,e):o(i,e),e):e},parsePointsAttribute:function(t){if(!t)return null;t=t.replace(/,/g," ").trim(),t=t.split(/\s+/);var e,i,r=[];for(e=0,i=t.length;e<i;e+=2)r.push({x:parseFloat(t[e]),y:parseFloat(t[e+1])});return r},getCSSRules:function(t){for(var e,i=t.getElementsByTagName("style"),r={},n=0,s=i.length;n<s;n++){var o=i[n].textContent||i[n].text;o=o.replace(/\/\*[\s\S]*?\*\//g,""),""!==o.trim()&&(e=o.match(/[^{]*\{[\s\S]*?\}/g),e=e.map(function(t){return t.trim()}),e.forEach(function(t){for(var e=t.match(/([\s\S]*?)\s*\{([^}]*)\}/),i={},n=e[2].trim(),s=n.replace(/;$/,"").split(/\s*;\s*/),o=0,a=s.length;o<a;o++){var h=s[o].split(/\s*:\s*/),c=h[0],l=h[1];i[c]=l}t=e[1],t.split(",").forEach(function(t){t=t.replace(/^svg/i,"").trim(),""!==t&&(r[t]?p.util.object.extend(r[t],i):r[t]=p.util.object.clone(i))})}))}return r},loadSVGFromURL:function(t,e,i,r){function n(t){var n=t.responseXML;n&&!n.documentElement&&p.window.ActiveXObject&&t.responseText&&(n=new ActiveXObject("Microsoft.XMLDOM"),n.async="false",n.loadXML(t.responseText.replace(/<!DOCTYPE[\s\S]*?(\[[\s\S]*\])*?>/i,""))),n&&n.documentElement||e&&e(null),p.parseSVGDocument(n.documentElement,function(t,i){e&&e(t,i)},i,r)}t=t.replace(/^\n\s*/,"").trim(),new p.util.request(t,{method:"get",onComplete:n})},loadSVGFromString:function(t,e,i,r){t=t.trim();var n;if("undefined"!=typeof DOMParser){var s=new DOMParser;s&&s.parseFromString&&(n=s.parseFromString(t,"text/xml"))}else p.window.ActiveXObject&&(n=new ActiveXObject("Microsoft.XMLDOM"),n.async="false",n.loadXML(t.replace(/<!DOCTYPE[\s\S]*?(\[[\s\S]*\])*?>/i,"")));p.parseSVGDocument(n.documentElement,function(t,i){e(t,i)},i,r)}})}("undefined"!=typeof exports?exports:this),fabric.ElementsParser=function(t,e,i,r,n){this.elements=t,this.callback=e,this.options=i,this.reviver=r,this.svgUid=i&&i.svgUid||0,this.parsingOptions=n},fabric.ElementsParser.prototype.parse=function(){this.instances=new Array(this.elements.length),this.numElements=this.elements.length,this.createObjects()},fabric.ElementsParser.prototype.createObjects=function(){for(var t=0,e=this.elements.length;t<e;t++)this.elements[t].setAttribute("svgUid",this.svgUid),function(t,e){setTimeout(function(){t.createObject(t.elements[e],e)},0)}(this,t)},fabric.ElementsParser.prototype.createObject=function(t,e){var i=fabric[fabric.util.string.capitalize(t.tagName.replace("svg:",""))];if(i&&i.fromElement)try{this._createObject(i,t,e)}catch(t){fabric.log(t)}else this.checkIfDone()},fabric.ElementsParser.prototype._createObject=function(t,e,i){if(t.async)t.fromElement(e,this.createCallback(i,e),this.options);else{var r=t.fromElement(e,this.options);this.resolveGradient(r,"fill"),this.resolveGradient(r,"stroke"),this.reviver&&this.reviver(e,r),this.instances[i]=r,this.checkIfDone()}},fabric.ElementsParser.prototype.createCallback=function(t,e){var i=this;return function(r){i.resolveGradient(r,"fill"),i.resolveGradient(r,"stroke"),i.reviver&&i.reviver(e,r),i.instances[t]=r,i.checkIfDone()}},fabric.ElementsParser.prototype.resolveGradient=function(t,e){var i=t.get(e);if(/^url\(/.test(i)){var r=i.slice(5,i.length-1);fabric.gradientDefs[this.svgUid][r]&&t.set(e,fabric.Gradient.fromElement(fabric.gradientDefs[this.svgUid][r],t))}},fabric.ElementsParser.prototype.checkIfDone=function(){0===--this.numElements&&(this.instances=this.instances.filter(function(t){return null!=t}),this.callback(this.instances))},function(t){"use strict";function e(t,e){this.x=t,this.y=e}var i=t.fabric||(t.fabric={});return i.Point?void i.warn("fabric.Point is already defined"):(i.Point=e,void(e.prototype={type:"point",constructor:e,add:function(t){return new e(this.x+t.x,this.y+t.y)},addEquals:function(t){return this.x+=t.x,this.y+=t.y,this},scalarAdd:function(t){return new e(this.x+t,this.y+t)},scalarAddEquals:function(t){return this.x+=t,this.y+=t,this},subtract:function(t){return new e(this.x-t.x,this.y-t.y)},subtractEquals:function(t){return this.x-=t.x,this.y-=t.y,this},scalarSubtract:function(t){return new e(this.x-t,this.y-t)},scalarSubtractEquals:function(t){return this.x-=t,this.y-=t,this},multiply:function(t){return new e(this.x*t,this.y*t)},multiplyEquals:function(t){return this.x*=t,this.y*=t,this},divide:function(t){return new e(this.x/t,this.y/t)},divideEquals:function(t){return this.x/=t,this.y/=t,this},eq:function(t){return this.x===t.x&&this.y===t.y},lt:function(t){return this.x<t.x&&this.y<t.y},lte:function(t){return this.x<=t.x&&this.y<=t.y},gt:function(t){return this.x>t.x&&this.y>t.y},gte:function(t){return this.x>=t.x&&this.y>=t.y},lerp:function(t,i){return"undefined"==typeof i&&(i=.5),i=Math.max(Math.min(1,i),0),new e(this.x+(t.x-this.x)*i,this.y+(t.y-this.y)*i)},distanceFrom:function(t){var e=this.x-t.x,i=this.y-t.y;return Math.sqrt(e*e+i*i)},midPointFrom:function(t){return this.lerp(t)},min:function(t){return new e(Math.min(this.x,t.x),Math.min(this.y,t.y))},max:function(t){return new e(Math.max(this.x,t.x),Math.max(this.y,t.y))},toString:function(){return this.x+","+this.y},setXY:function(t,e){return this.x=t,this.y=e,this},setX:function(t){return this.x=t,this},setY:function(t){return this.y=t,this},setFromPoint:function(t){return this.x=t.x,this.y=t.y,this},swap:function(t){var e=this.x,i=this.y;this.x=t.x,this.y=t.y,t.x=e,t.y=i},clone:function(){return new e(this.x,this.y)}}))}("undefined"!=typeof exports?exports:this),function(t){"use strict";function e(t){this.status=t,this.points=[]}var i=t.fabric||(t.fabric={});return i.Intersection?void i.warn("fabric.Intersection is already defined"):(i.Intersection=e,i.Intersection.prototype={constructor:e,appendPoint:function(t){return this.points.push(t),this},appendPoints:function(t){return this.points=this.points.concat(t),this}},i.Intersection.intersectLineLine=function(t,r,n,s){var o,a=(s.x-n.x)*(t.y-n.y)-(s.y-n.y)*(t.x-n.x),h=(r.x-t.x)*(t.y-n.y)-(r.y-t.y)*(t.x-n.x),c=(s.y-n.y)*(r.x-t.x)-(s.x-n.x)*(r.y-t.y);if(0!==c){var l=a/c,u=h/c;0<=l&&l<=1&&0<=u&&u<=1?(o=new e("Intersection"),o.appendPoint(new i.Point(t.x+l*(r.x-t.x),t.y+l*(r.y-t.y)))):o=new e}else o=new e(0===a||0===h?"Coincident":"Parallel");return o},i.Intersection.intersectLinePolygon=function(t,i,r){for(var n,s,o,a=new e,h=r.length,c=0;c<h;c++)n=r[c],s=r[(c+1)%h],o=e.intersectLineLine(t,i,n,s),a.appendPoints(o.points);return a.points.length>0&&(a.status="Intersection"),a},i.Intersection.intersectPolygonPolygon=function(t,i){for(var r=new e,n=t.length,s=0;s<n;s++){var o=t[s],a=t[(s+1)%n],h=e.intersectLinePolygon(o,a,i);r.appendPoints(h.points)}return r.points.length>0&&(r.status="Intersection"),r},void(i.Intersection.intersectPolygonRectangle=function(t,r,n){var s=r.min(n),o=r.max(n),a=new i.Point(o.x,s.y),h=new i.Point(s.x,o.y),c=e.intersectLinePolygon(s,a,t),l=e.intersectLinePolygon(a,o,t),u=e.intersectLinePolygon(o,h,t),f=e.intersectLinePolygon(h,s,t),d=new e;return d.appendPoints(c.points),d.appendPoints(l.points),d.appendPoints(u.points),d.appendPoints(f.points),d.points.length>0&&(d.status="Intersection"),d}))}("undefined"!=typeof exports?exports:this),function(t){"use strict";function e(t){t?this._tryParsingColor(t):this.setSource([0,0,0,1])}function i(t,e,i){return i<0&&(i+=1),i>1&&(i-=1),i<1/6?t+6*(e-t)*i:i<.5?e:i<2/3?t+(e-t)*(2/3-i)*6:t}var r=t.fabric||(t.fabric={});return r.Color?void r.warn("fabric.Color is already defined."):(r.Color=e,r.Color.prototype={_tryParsingColor:function(t){var i;t in e.colorNameMap&&(t=e.colorNameMap[t]),"transparent"===t&&(i=[255,255,255,0]),i||(i=e.sourceFromHex(t)),i||(i=e.sourceFromRgb(t)),i||(i=e.sourceFromHsl(t)),i||(i=[0,0,0,1]),i&&this.setSource(i)},_rgbToHsl:function(t,e,i){t/=255,e/=255,i/=255;var n,s,o,a=r.util.array.max([t,e,i]),h=r.util.array.min([t,e,i]);if(o=(a+h)/2,a===h)n=s=0;else{var c=a-h;switch(s=o>.5?c/(2-a-h):c/(a+h),a){case t:n=(e-i)/c+(e<i?6:0);break;case e:n=(i-t)/c+2;break;case i:n=(t-e)/c+4}n/=6}return[Math.round(360*n),Math.round(100*s),Math.round(100*o)]},getSource:function(){return this._source},setSource:function(t){this._source=t},toRgb:function(){var t=this.getSource();return"rgb("+t[0]+","+t[1]+","+t[2]+")"},toRgba:function(){var t=this.getSource();return"rgba("+t[0]+","+t[1]+","+t[2]+","+t[3]+")"},toHsl:function(){var t=this.getSource(),e=this._rgbToHsl(t[0],t[1],t[2]);return"hsl("+e[0]+","+e[1]+"%,"+e[2]+"%)"},toHsla:function(){var t=this.getSource(),e=this._rgbToHsl(t[0],t[1],t[2]);return"hsla("+e[0]+","+e[1]+"%,"+e[2]+"%,"+t[3]+")"},toHex:function(){var t,e,i,r=this.getSource();return t=r[0].toString(16),t=1===t.length?"0"+t:t,e=r[1].toString(16),e=1===e.length?"0"+e:e,i=r[2].toString(16),i=1===i.length?"0"+i:i,t.toUpperCase()+e.toUpperCase()+i.toUpperCase()},toHexa:function(){var t,e=this.getSource();return t=255*e[3],t=t.toString(16),t=1===t.length?"0"+t:t,this.toHex()+t.toUpperCase()},getAlpha:function(){return this.getSource()[3]},setAlpha:function(t){var e=this.getSource();return e[3]=t,this.setSource(e),this},toGrayscale:function(){var t=this.getSource(),e=parseInt((.3*t[0]+.59*t[1]+.11*t[2]).toFixed(0),10),i=t[3];return this.setSource([e,e,e,i]),this},toBlackWhite:function(t){var e=this.getSource(),i=(.3*e[0]+.59*e[1]+.11*e[2]).toFixed(0),r=e[3];return t=t||127,i=Number(i)<Number(t)?0:255,this.setSource([i,i,i,r]),this},overlayWith:function(t){t instanceof e||(t=new e(t));for(var i=[],r=this.getAlpha(),n=.5,s=this.getSource(),o=t.getSource(),a=0;a<3;a++)i.push(Math.round(s[a]*(1-n)+o[a]*n));return i[3]=r,this.setSource(i),this}},r.Color.reRGBa=/^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/,r.Color.reHSLa=/^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/,r.Color.reHex=/^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i,r.Color.colorNameMap={aqua:"#00FFFF",black:"#000000",blue:"#0000FF",fuchsia:"#FF00FF",gray:"#808080",grey:"#808080",green:"#008000",lime:"#00FF00",maroon:"#800000",navy:"#000080",olive:"#808000",orange:"#FFA500",purple:"#800080",red:"#FF0000",silver:"#C0C0C0",teal:"#008080",white:"#FFFFFF",yellow:"#FFFF00"},r.Color.fromRgb=function(t){return e.fromSource(e.sourceFromRgb(t))},r.Color.sourceFromRgb=function(t){var i=t.match(e.reRGBa);if(i){var r=parseInt(i[1],10)/(/%$/.test(i[1])?100:1)*(/%$/.test(i[1])?255:1),n=parseInt(i[2],10)/(/%$/.test(i[2])?100:1)*(/%$/.test(i[2])?255:1),s=parseInt(i[3],10)/(/%$/.test(i[3])?100:1)*(/%$/.test(i[3])?255:1);return[parseInt(r,10),parseInt(n,10),parseInt(s,10),i[4]?parseFloat(i[4]):1]}},r.Color.fromRgba=e.fromRgb,r.Color.fromHsl=function(t){return e.fromSource(e.sourceFromHsl(t))},r.Color.sourceFromHsl=function(t){var r=t.match(e.reHSLa);if(r){var n,s,o,a=(parseFloat(r[1])%360+360)%360/360,h=parseFloat(r[2])/(/%$/.test(r[2])?100:1),c=parseFloat(r[3])/(/%$/.test(r[3])?100:1);if(0===h)n=s=o=c;else{var l=c<=.5?c*(h+1):c+h-c*h,u=2*c-l;n=i(u,l,a+1/3),s=i(u,l,a),o=i(u,l,a-1/3)}return[Math.round(255*n),Math.round(255*s),Math.round(255*o),r[4]?parseFloat(r[4]):1]}},r.Color.fromHsla=e.fromHsl,r.Color.fromHex=function(t){return e.fromSource(e.sourceFromHex(t))},r.Color.sourceFromHex=function(t){if(t.match(e.reHex)){var i=t.slice(t.indexOf("#")+1),r=3===i.length||4===i.length,n=8===i.length||4===i.length,s=r?i.charAt(0)+i.charAt(0):i.substring(0,2),o=r?i.charAt(1)+i.charAt(1):i.substring(2,4),a=r?i.charAt(2)+i.charAt(2):i.substring(4,6),h=n?r?i.charAt(3)+i.charAt(3):i.substring(6,8):"FF";return[parseInt(s,16),parseInt(o,16),parseInt(a,16),parseFloat((parseInt(h,16)/255).toFixed(2))]}},void(r.Color.fromSource=function(t){var i=new e;return i.setSource(t),i}))}("undefined"!=typeof exports?exports:this),function(){function t(t){var e,i,r,n=t.getAttribute("style"),s=t.getAttribute("offset")||0;if(s=parseFloat(s)/(/%$/.test(s)?100:1),s=s<0?0:s>1?1:s,n){var o=n.split(/\s*;\s*/);""===o[o.length-1]&&o.pop();for(var a=o.length;a--;){var h=o[a].split(/\s*:\s*/),c=h[0].trim(),l=h[1].trim();"stop-color"===c?e=l:"stop-opacity"===c&&(r=l)}}return e||(e=t.getAttribute("stop-color")||"rgb(0,0,0)"),r||(r=t.getAttribute("stop-opacity")),e=new fabric.Color(e),i=e.getAlpha(),r=isNaN(parseFloat(r))?1:parseFloat(r),r*=i,{offset:s,color:e.toRgb(),opacity:r}}function e(t){return{x1:t.getAttribute("x1")||0,y1:t.getAttribute("y1")||0,x2:t.getAttribute("x2")||"100%",y2:t.getAttribute("y2")||0}}function i(t){return{x1:t.getAttribute("fx")||t.getAttribute("cx")||"50%",y1:t.getAttribute("fy")||t.getAttribute("cy")||"50%",r1:0,x2:t.getAttribute("cx")||"50%",y2:t.getAttribute("cy")||"50%",r2:t.getAttribute("r")||"50%"}}function r(t,e,i){var r,n=0,s=1,o="";for(var a in e)"Infinity"===e[a]?e[a]=1:"-Infinity"===e[a]&&(e[a]=0),r=parseFloat(e[a],10),s="string"==typeof e[a]&&/^\d+%$/.test(e[a])?.01:1,"x1"===a||"x2"===a||"r2"===a?(s*="objectBoundingBox"===i?t.width:1,n="objectBoundingBox"===i?t.left||0:0):"y1"!==a&&"y2"!==a||(s*="objectBoundingBox"===i?t.height:1,n="objectBoundingBox"===i?t.top||0:0),e[a]=r*s+n;if("ellipse"===t.type&&null!==e.r2&&"objectBoundingBox"===i&&t.rx!==t.ry){var h=t.ry/t.rx;o=" scale(1, "+h+")",e.y1&&(e.y1/=h),e.y2&&(e.y2/=h)}return o}var n=fabric.util.object.clone;fabric.Gradient=fabric.util.createClass({offsetX:0,offsetY:0,initialize:function(t){t||(t={});var e={};this.id=fabric.Object.__uid++,this.type=t.type||"linear",e={x1:t.coords.x1||0,y1:t.coords.y1||0,x2:t.coords.x2||0,y2:t.coords.y2||0},"radial"===this.type&&(e.r1=t.coords.r1||0,e.r2=t.coords.r2||0),this.coords=e,this.colorStops=t.colorStops.slice(),t.gradientTransform&&(this.gradientTransform=t.gradientTransform),this.offsetX=t.offsetX||this.offsetX,this.offsetY=t.offsetY||this.offsetY},addColorStop:function(t){for(var e in t){var i=new fabric.Color(t[e]);this.colorStops.push({offset:parseFloat(e),color:i.toRgb(),opacity:i.getAlpha()})}return this},toObject:function(t){var e={type:this.type,coords:this.coords,colorStops:this.colorStops,offsetX:this.offsetX,offsetY:this.offsetY,gradientTransform:this.gradientTransform?this.gradientTransform.concat():this.gradientTransform};return fabric.util.populateWithProperties(this,e,t),e},toSVG:function(t){var e,i,r=n(this.coords,!0),s=n(this.colorStops,!0),o=r.r1>r.r2;if(s.sort(function(t,e){return t.offset-e.offset}),!t.group||"path-group"!==t.group.type)for(var a in r)"x1"===a||"x2"===a?r[a]+=this.offsetX-t.width/2:"y1"!==a&&"y2"!==a||(r[a]+=this.offsetY-t.height/2);if(i='id="SVGID_'+this.id+'" gradientUnits="userSpaceOnUse"',this.gradientTransform&&(i+=' gradientTransform="matrix('+this.gradientTransform.join(" ")+')" '),"linear"===this.type?e=["<linearGradient ",i,' x1="',r.x1,'" y1="',r.y1,'" x2="',r.x2,'" y2="',r.y2,'">\n']:"radial"===this.type&&(e=["<radialGradient ",i,' cx="',o?r.x1:r.x2,'" cy="',o?r.y1:r.y2,'" r="',o?r.r1:r.r2,'" fx="',o?r.x2:r.x1,'" fy="',o?r.y2:r.y1,'">\n']),"radial"===this.type){if(o){s=s.concat(),s.reverse();for(var h=0;h<s.length;h++)s[h].offset=1-s[h].offset}var c=Math.min(r.r1,r.r2);if(c>0)for(var l=Math.max(r.r1,r.r2),u=c/l,h=0;h<s.length;h++)s[h].offset+=u*(1-s[h].offset)}for(var h=0;h<s.length;h++){var f=s[h];e.push("<stop ",'offset="',100*f.offset+"%",'" style="stop-color:',f.color,null!==f.opacity?";stop-opacity: "+f.opacity:";",'"/>\n')}return e.push("linear"===this.type?"</linearGradient>\n":"</radialGradient>\n"),e.join("")},toLive:function(t,e){var i,r,n=fabric.util.object.clone(this.coords);if(this.type){if(e.group&&"path-group"===e.group.type)for(r in n)"x1"===r||"x2"===r?n[r]+=-this.offsetX+e.width/2:"y1"!==r&&"y2"!==r||(n[r]+=-this.offsetY+e.height/2);"linear"===this.type?i=t.createLinearGradient(n.x1,n.y1,n.x2,n.y2):"radial"===this.type&&(i=t.createRadialGradient(n.x1,n.y1,n.r1,n.x2,n.y2,n.r2));for(var s=0,o=this.colorStops.length;s<o;s++){var a=this.colorStops[s].color,h=this.colorStops[s].opacity,c=this.colorStops[s].offset;"undefined"!=typeof h&&(a=new fabric.Color(a).setAlpha(h).toRgba()),i.addColorStop(c,a)}return i}}}),fabric.util.object.extend(fabric.Gradient,{fromElement:function(n,s){var o,a,h,c=n.getElementsByTagName("stop"),l=n.getAttribute("gradientUnits")||"objectBoundingBox",u=n.getAttribute("gradientTransform"),f=[];o="linearGradient"===n.nodeName||"LINEARGRADIENT"===n.nodeName?"linear":"radial","linear"===o?a=e(n):"radial"===o&&(a=i(n));for(var d=c.length;d--;)f.push(t(c[d]));h=r(s,a,l);var g=new fabric.Gradient({type:o,coords:a,colorStops:f,offsetX:-s.left,offsetY:-s.top});return(u||""!==h)&&(g.gradientTransform=fabric.parseTransformAttribute((u||"")+h)),g},forObject:function(t,e){return e||(e={}),r(t,e.coords,"userSpaceOnUse"),new fabric.Gradient(e)}})}(),function(){"use strict";var t=fabric.util.toFixed;fabric.Pattern=fabric.util.createClass({repeat:"repeat",offsetX:0,offsetY:0,initialize:function(t,e){if(t||(t={}),this.id=fabric.Object.__uid++,this.setOptions(t),!t.source||t.source&&"string"!=typeof t.source)return void(e&&e(this));if("undefined"!=typeof fabric.util.getFunctionBody(t.source))this.source=new Function(fabric.util.getFunctionBody(t.source)),e&&e(this);else{var i=this;this.source=fabric.util.createImage(),fabric.util.loadImage(t.source,function(t){i.source=t,e&&e(i)})}},toObject:function(e){var i,r,n=fabric.Object.NUM_FRACTION_DIGITS;return"function"==typeof this.source?i=String(this.source):"string"==typeof this.source.src?i=this.source.src:"object"==typeof this.source&&this.source.toDataURL&&(i=this.source.toDataURL()),r={type:"pattern",source:i,repeat:this.repeat,offsetX:t(this.offsetX,n),offsetY:t(this.offsetY,n)},fabric.util.populateWithProperties(this,r,e),r},toSVG:function(t){var e="function"==typeof this.source?this.source():this.source,i=e.width/t.width,r=e.height/t.height,n=this.offsetX/t.width,s=this.offsetY/t.height,o="";return"repeat-x"!==this.repeat&&"no-repeat"!==this.repeat||(r=1),"repeat-y"!==this.repeat&&"no-repeat"!==this.repeat||(i=1),e.src?o=e.src:e.toDataURL&&(o=e.toDataURL()),'<pattern id="SVGID_'+this.id+'" x="'+n+'" y="'+s+'" width="'+i+'" height="'+r+'">\n<image x="0" y="0" width="'+e.width+'" height="'+e.height+'" xlink:href="'+o+'"></image>\n</pattern>\n'},setOptions:function(t){for(var e in t)this[e]=t[e]},toLive:function(t){var e="function"==typeof this.source?this.source():this.source;if(!e)return"";if("undefined"!=typeof e.src){if(!e.complete)return"";if(0===e.naturalWidth||0===e.naturalHeight)return""}return t.createPattern(e,this.repeat)}})}(),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.util.toFixed;return e.Shadow?void e.warn("fabric.Shadow is already defined."):(e.Shadow=e.util.createClass({color:"rgb(0,0,0)",blur:0,offsetX:0,offsetY:0,affectStroke:!1,includeDefaultValues:!0,initialize:function(t){"string"==typeof t&&(t=this._parseShadow(t));for(var i in t)this[i]=t[i];this.id=e.Object.__uid++},_parseShadow:function(t){var i=t.trim(),r=e.Shadow.reOffsetsAndBlur.exec(i)||[],n=i.replace(e.Shadow.reOffsetsAndBlur,"")||"rgb(0,0,0)";return{color:n.trim(),offsetX:parseInt(r[1],10)||0,offsetY:parseInt(r[2],10)||0,blur:parseInt(r[3],10)||0}},toString:function(){return[this.offsetX,this.offsetY,this.blur,this.color].join("px ")},toSVG:function(t){var r=40,n=40,s=e.Object.NUM_FRACTION_DIGITS,o=e.util.rotateVector({x:this.offsetX,y:this.offsetY},e.util.degreesToRadians(-t.angle)),a=20;return t.width&&t.height&&(r=100*i((Math.abs(o.x)+this.blur)/t.width,s)+a,n=100*i((Math.abs(o.y)+this.blur)/t.height,s)+a),t.flipX&&(o.x*=-1),t.flipY&&(o.y*=-1),'<filter id="SVGID_'+this.id+'" y="-'+n+'%" height="'+(100+2*n)+'%" x="-'+r+'%" width="'+(100+2*r)+'%" >\n\t<feGaussianBlur in="SourceAlpha" stdDeviation="'+i(this.blur?this.blur/2:0,s)+'"></feGaussianBlur>\n\t<feOffset dx="'+i(o.x,s)+'" dy="'+i(o.y,s)+'" result="oBlur" ></feOffset>\n\t<feFlood flood-color="'+this.color+'"/>\n\t<feComposite in2="oBlur" operator="in" />\n\t<feMerge>\n\t\t<feMergeNode></feMergeNode>\n\t\t<feMergeNode in="SourceGraphic"></feMergeNode>\n\t</feMerge>\n</filter>\n'},toObject:function(){if(this.includeDefaultValues)return{color:this.color,blur:this.blur,offsetX:this.offsetX,offsetY:this.offsetY,affectStroke:this.affectStroke};var t={},i=e.Shadow.prototype;return["color","blur","offsetX","offsetY","affectStroke"].forEach(function(e){this[e]!==i[e]&&(t[e]=this[e])},this),t}}),void(e.Shadow.reOffsetsAndBlur=/(?:\s|^)(-?\d+(?:px)?(?:\s?|$))?(-?\d+(?:px)?(?:\s?|$))?(\d+(?:px)?)?(?:\s?|$)(?:$|\s)/))}("undefined"!=typeof exports?exports:this),function(){"use strict";if(fabric.StaticCanvas)return void fabric.warn("fabric.StaticCanvas is already defined.");var t=fabric.util.object.extend,e=fabric.util.getElementOffset,i=fabric.util.removeFromArray,r=fabric.util.toFixed,n=fabric.util.transformPoint,s=fabric.util.invertTransform,o=new Error("Could not initialize `canvas` element");fabric.StaticCanvas=fabric.util.createClass(fabric.CommonMethods,{initialize:function(t,e){e||(e={}),this._initStatic(t,e)},backgroundColor:"",backgroundImage:null,overlayColor:"",overlayImage:null,includeDefaultValues:!0,stateful:!1,renderOnAddRemove:!0,clipTo:null,controlsAboveOverlay:!1,allowTouchScrolling:!1,imageSmoothingEnabled:!0,viewportTransform:fabric.iMatrix.concat(),backgroundVpt:!0,overlayVpt:!0,onBeforeScaleRotate:function(){},enableRetinaScaling:!0,vptCoords:{},skipOffscreen:!1,_initStatic:function(t,e){var i=fabric.StaticCanvas.prototype.renderAll.bind(this);this._objects=[],this._createLowerCanvas(t),this._initOptions(e),this._setImageSmoothing(),this.interactive||this._initRetinaScaling(),e.overlayImage&&this.setOverlayImage(e.overlayImage,i),e.backgroundImage&&this.setBackgroundImage(e.backgroundImage,i),e.backgroundColor&&this.setBackgroundColor(e.backgroundColor,i),e.overlayColor&&this.setOverlayColor(e.overlayColor,i),this.calcOffset()},_isRetinaScaling:function(){return 1!==fabric.devicePixelRatio&&this.enableRetinaScaling},getRetinaScaling:function(){return this._isRetinaScaling()?fabric.devicePixelRatio:1},_initRetinaScaling:function(){this._isRetinaScaling()&&(this.lowerCanvasEl.setAttribute("width",this.width*fabric.devicePixelRatio),this.lowerCanvasEl.setAttribute("height",this.height*fabric.devicePixelRatio),this.contextContainer.scale(fabric.devicePixelRatio,fabric.devicePixelRatio))},calcOffset:function(){return this._offset=e(this.lowerCanvasEl),this},setOverlayImage:function(t,e,i){return this.__setBgOverlayImage("overlayImage",t,e,i)},setBackgroundImage:function(t,e,i){return this.__setBgOverlayImage("backgroundImage",t,e,i)},setOverlayColor:function(t,e){return this.__setBgOverlayColor("overlayColor",t,e)},setBackgroundColor:function(t,e){return this.__setBgOverlayColor("backgroundColor",t,e)},_setImageSmoothing:function(){var t=this.getContext();t.imageSmoothingEnabled=t.imageSmoothingEnabled||t.webkitImageSmoothingEnabled||t.mozImageSmoothingEnabled||t.msImageSmoothingEnabled||t.oImageSmoothingEnabled,t.imageSmoothingEnabled=this.imageSmoothingEnabled},__setBgOverlayImage:function(t,e,i,r){return"string"==typeof e?fabric.util.loadImage(e,function(e){e&&(this[t]=new fabric.Image(e,r)),i&&i(e)},this,r&&r.crossOrigin):(r&&e.setOptions(r),this[t]=e,i&&i(e)),this},__setBgOverlayColor:function(t,e,i){return this[t]=e,this._initGradient(e,t),this._initPattern(e,t,i),this},_createCanvasElement:function(t){var e=fabric.util.createCanvasElement(t);if(e.style||(e.style={}),!e)throw o;if("undefined"==typeof e.getContext)throw o;return e},_initOptions:function(t){this._setOptions(t),this.width=this.width||parseInt(this.lowerCanvasEl.width,10)||0,this.height=this.height||parseInt(this.lowerCanvasEl.height,10)||0,this.lowerCanvasEl.style&&(this.lowerCanvasEl.width=this.width,this.lowerCanvasEl.height=this.height,this.lowerCanvasEl.style.width=this.width+"px",this.lowerCanvasEl.style.height=this.height+"px",this.viewportTransform=this.viewportTransform.slice())},_createLowerCanvas:function(t){this.lowerCanvasEl=fabric.util.getById(t)||this._createCanvasElement(t),fabric.util.addClass(this.lowerCanvasEl,"lower-canvas"),this.interactive&&this._applyCanvasStyle(this.lowerCanvasEl),this.contextContainer=this.lowerCanvasEl.getContext("2d")},getWidth:function(){return this.width},getHeight:function(){return this.height},setWidth:function(t,e){return this.setDimensions({width:t},e)},setHeight:function(t,e){return this.setDimensions({height:t},e)},setDimensions:function(t,e){var i;e=e||{};for(var r in t)i=t[r],e.cssOnly||(this._setBackstoreDimension(r,t[r]),i+="px"),e.backstoreOnly||this._setCssDimension(r,i);return this._initRetinaScaling(),this._setImageSmoothing(),this.calcOffset(),e.cssOnly||this.renderAll(),this},_setBackstoreDimension:function(t,e){return this.lowerCanvasEl[t]=e,this.upperCanvasEl&&(this.upperCanvasEl[t]=e),this.cacheCanvasEl&&(this.cacheCanvasEl[t]=e),this[t]=e,this},_setCssDimension:function(t,e){return this.lowerCanvasEl.style[t]=e,this.upperCanvasEl&&(this.upperCanvasEl.style[t]=e),this.wrapperEl&&(this.wrapperEl.style[t]=e),this},getZoom:function(){return this.viewportTransform[0]},setViewportTransform:function(t){var e,i=this._activeGroup,r=!1,n=!0;this.viewportTransform=t;for(var s=0,o=this._objects.length;s<o;s++)e=this._objects[s],e.group||e.setCoords(r,n);return i&&i.setCoords(r,n),this.calcViewportBoundaries(),this.renderAll(),this},zoomToPoint:function(t,e){var i=t,r=this.viewportTransform.slice(0);t=n(t,s(this.viewportTransform)),r[0]=e,r[3]=e;var o=n(t,r);return r[4]+=i.x-o.x,r[5]+=i.y-o.y,this.setViewportTransform(r)},setZoom:function(t){return this.zoomToPoint(new fabric.Point(0,0),t),this},absolutePan:function(t){var e=this.viewportTransform.slice(0);return e[4]=-t.x,e[5]=-t.y,this.setViewportTransform(e)},relativePan:function(t){return this.absolutePan(new fabric.Point(-t.x-this.viewportTransform[4],-t.y-this.viewportTransform[5]))},getElement:function(){return this.lowerCanvasEl},_onObjectAdded:function(t){this.stateful&&t.setupState(),t._set("canvas",this),t.setCoords(),this.fire("object:added",{target:t}),t.fire("added")},_onObjectRemoved:function(t){this.fire("object:removed",{target:t}),t.fire("removed"),delete t.canvas},clearContext:function(t){return t.clearRect(0,0,this.width,this.height),this},getContext:function(){return this.contextContainer},clear:function(){return this._objects.length=0,this.backgroundImage=null,this.overlayImage=null,this.backgroundColor="",this.overlayColor="",this._hasITextHandlers&&(this.off("mouse:up",this._mouseUpITextHandler),this._iTextInstances=null,this._hasITextHandlers=!1),this.clearContext(this.contextContainer),this.fire("canvas:cleared"),this.renderAll(),this},renderAll:function(){var t=this.contextContainer;return this.renderCanvas(t,this._objects),this},calcViewportBoundaries:function(){var t={},e=this.getWidth(),i=this.getHeight(),r=s(this.viewportTransform);return t.tl=n({x:0,y:0},r),t.br=n({x:e,y:i},r),t.tr=new fabric.Point(t.br.x,t.tl.y),t.bl=new fabric.Point(t.tl.x,t.br.y),this.vptCoords=t,t},renderCanvas:function(t,e){this.calcViewportBoundaries(),this.clearContext(t),this.fire("before:render"),this.clipTo&&fabric.util.clipContext(this,t),this._renderBackground(t),t.save(),t.transform.apply(t,this.viewportTransform),this._renderObjects(t,e),t.restore(),!this.controlsAboveOverlay&&this.interactive&&this.drawControls(t),
this.clipTo&&t.restore(),this._renderOverlay(t),this.controlsAboveOverlay&&this.interactive&&this.drawControls(t),this.fire("after:render")},_renderObjects:function(t,e){for(var i=0,r=e.length;i<r;++i)e[i]&&e[i].render(t)},_renderBackgroundOrOverlay:function(t,e){var i=this[e+"Color"];i&&(t.fillStyle=i.toLive?i.toLive(t,this):i,t.fillRect(i.offsetX||0,i.offsetY||0,this.width,this.height)),i=this[e+"Image"],i&&(this[e+"Vpt"]&&(t.save(),t.transform.apply(t,this.viewportTransform)),i.render(t),this[e+"Vpt"]&&t.restore())},_renderBackground:function(t){this._renderBackgroundOrOverlay(t,"background")},_renderOverlay:function(t){this._renderBackgroundOrOverlay(t,"overlay")},getCenter:function(){return{top:this.getHeight()/2,left:this.getWidth()/2}},centerObjectH:function(t){return this._centerObject(t,new fabric.Point(this.getCenter().left,t.getCenterPoint().y))},centerObjectV:function(t){return this._centerObject(t,new fabric.Point(t.getCenterPoint().x,this.getCenter().top))},centerObject:function(t){var e=this.getCenter();return this._centerObject(t,new fabric.Point(e.left,e.top))},viewportCenterObject:function(t){var e=this.getVpCenter();return this._centerObject(t,e)},viewportCenterObjectH:function(t){var e=this.getVpCenter();return this._centerObject(t,new fabric.Point(e.x,t.getCenterPoint().y)),this},viewportCenterObjectV:function(t){var e=this.getVpCenter();return this._centerObject(t,new fabric.Point(t.getCenterPoint().x,e.y))},getVpCenter:function(){var t=this.getCenter(),e=s(this.viewportTransform);return n({x:t.left,y:t.top},e)},_centerObject:function(t,e){return t.setPositionByOrigin(e,"center","center"),this.renderAll(),this},toDatalessJSON:function(t){return this.toDatalessObject(t)},toObject:function(t){return this._toObjectMethod("toObject",t)},toDatalessObject:function(t){return this._toObjectMethod("toDatalessObject",t)},_toObjectMethod:function(e,i){var r={objects:this._toObjects(e,i)};return t(r,this.__serializeBgOverlay(e,i)),fabric.util.populateWithProperties(this,r,i),r},_toObjects:function(t,e){return this.getObjects().filter(function(t){return!t.excludeFromExport}).map(function(i){return this._toObject(i,t,e)},this)},_toObject:function(t,e,i){var r;this.includeDefaultValues||(r=t.includeDefaultValues,t.includeDefaultValues=!1);var n=t[e](i);return this.includeDefaultValues||(t.includeDefaultValues=r),n},__serializeBgOverlay:function(t,e){var i={};return this.backgroundColor&&(i.background=this.backgroundColor.toObject?this.backgroundColor.toObject(e):this.backgroundColor),this.overlayColor&&(i.overlay=this.overlayColor.toObject?this.overlayColor.toObject(e):this.overlayColor),this.backgroundImage&&(i.backgroundImage=this._toObject(this.backgroundImage,t,e)),this.overlayImage&&(i.overlayImage=this._toObject(this.overlayImage,t,e)),i},svgViewportTransformation:!0,toSVG:function(t,e){t||(t={});var i=[];return this._setSVGPreamble(i,t),this._setSVGHeader(i,t),this._setSVGBgOverlayColor(i,"backgroundColor"),this._setSVGBgOverlayImage(i,"backgroundImage",e),this._setSVGObjects(i,e),this._setSVGBgOverlayColor(i,"overlayColor"),this._setSVGBgOverlayImage(i,"overlayImage",e),i.push("</svg>"),i.join("")},_setSVGPreamble:function(t,e){e.suppressPreamble||t.push('<?xml version="1.0" encoding="',e.encoding||"UTF-8",'" standalone="no" ?>\n','<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ','"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n')},_setSVGHeader:function(t,e){var i,n=e.width||this.width,s=e.height||this.height,o='viewBox="0 0 '+this.width+" "+this.height+'" ',a=fabric.Object.NUM_FRACTION_DIGITS;e.viewBox?o='viewBox="'+e.viewBox.x+" "+e.viewBox.y+" "+e.viewBox.width+" "+e.viewBox.height+'" ':this.svgViewportTransformation&&(i=this.viewportTransform,o='viewBox="'+r(-i[4]/i[0],a)+" "+r(-i[5]/i[3],a)+" "+r(this.width/i[0],a)+" "+r(this.height/i[3],a)+'" '),t.push("<svg ",'xmlns="http://www.w3.org/2000/svg" ','xmlns:xlink="http://www.w3.org/1999/xlink" ','version="1.1" ','width="',n,'" ','height="',s,'" ',o,'xml:space="preserve">\n',"<desc>Created with Fabric.js ",fabric.version,"</desc>\n","<defs>\n",this.createSVGFontFacesMarkup(),this.createSVGRefElementsMarkup(),"</defs>\n")},createSVGRefElementsMarkup:function(){var t=this,e=["backgroundColor","overlayColor"].map(function(e){var i=t[e];if(i&&i.toLive)return i.toSVG(t,!1)});return e.join("")},createSVGFontFacesMarkup:function(){for(var t,e,i,r,n,s,o,a="",h={},c=fabric.fontPaths,l=this.getObjects(),u=0,f=l.length;u<f;u++)if(t=l[u],e=t.fontFamily,t.type.indexOf("text")!==-1&&!h[e]&&c[e]&&(h[e]=!0,t.styles)){i=t.styles;for(n in i){r=i[n];for(o in r)s=r[o],e=s.fontFamily,!h[e]&&c[e]&&(h[e]=!0)}}for(var d in h)a+=["\t\t@font-face {\n","\t\t\tfont-family: '",d,"';\n","\t\t\tsrc: url('",c[d],"');\n","\t\t}\n"].join("");return a&&(a=['\t<style type="text/css">',"<![CDATA[\n",a,"]]>","</style>\n"].join("")),a},_setSVGObjects:function(t,e){for(var i,r=0,n=this.getObjects(),s=n.length;r<s;r++)i=n[r],i.excludeFromExport||this._setSVGObject(t,i,e)},_setSVGObject:function(t,e,i){t.push(e.toSVG(i))},_setSVGBgOverlayImage:function(t,e,i){this[e]&&this[e].toSVG&&t.push(this[e].toSVG(i))},_setSVGBgOverlayColor:function(t,e){var i=this[e];if(i)if(i.toLive){var r=i.repeat;t.push('<rect transform="translate(',this.width/2,",",this.height/2,')"',' x="',i.offsetX-this.width/2,'" y="',i.offsetY-this.height/2,'" ','width="',"repeat-y"===r||"no-repeat"===r?i.source.width:this.width,'" height="',"repeat-x"===r||"no-repeat"===r?i.source.height:this.height,'" fill="url(#SVGID_'+i.id+')"',"></rect>\n")}else t.push('<rect x="0" y="0" ','width="',this.width,'" height="',this.height,'" fill="',this[e],'"',"></rect>\n")},sendToBack:function(t){if(!t)return this;var e,r,n,s=this._activeGroup;if(t===s)for(n=s._objects,e=n.length;e--;)r=n[e],i(this._objects,r),this._objects.unshift(r);else i(this._objects,t),this._objects.unshift(t);return this.renderAll&&this.renderAll()},bringToFront:function(t){if(!t)return this;var e,r,n,s=this._activeGroup;if(t===s)for(n=s._objects,e=0;e<n.length;e++)r=n[e],i(this._objects,r),this._objects.push(r);else i(this._objects,t),this._objects.push(t);return this.renderAll&&this.renderAll()},sendBackwards:function(t,e){if(!t)return this;var r,n,s,o,a,h=this._activeGroup;if(t===h)for(a=h._objects,r=0;r<a.length;r++)n=a[r],s=this._objects.indexOf(n),0!==s&&(o=s-1,i(this._objects,n),this._objects.splice(o,0,n));else s=this._objects.indexOf(t),0!==s&&(o=this._findNewLowerIndex(t,s,e),i(this._objects,t),this._objects.splice(o,0,t));return this.renderAll&&this.renderAll(),this},_findNewLowerIndex:function(t,e,i){var r;if(i){r=e;for(var n=e-1;n>=0;--n){var s=t.intersectsWithObject(this._objects[n])||t.isContainedWithinObject(this._objects[n])||this._objects[n].isContainedWithinObject(t);if(s){r=n;break}}}else r=e-1;return r},bringForward:function(t,e){if(!t)return this;var r,n,s,o,a,h=this._activeGroup;if(t===h)for(a=h._objects,r=a.length;r--;)n=a[r],s=this._objects.indexOf(n),s!==this._objects.length-1&&(o=s+1,i(this._objects,n),this._objects.splice(o,0,n));else s=this._objects.indexOf(t),s!==this._objects.length-1&&(o=this._findNewUpperIndex(t,s,e),i(this._objects,t),this._objects.splice(o,0,t));return this.renderAll&&this.renderAll(),this},_findNewUpperIndex:function(t,e,i){var r;if(i){r=e;for(var n=e+1;n<this._objects.length;++n){var s=t.intersectsWithObject(this._objects[n])||t.isContainedWithinObject(this._objects[n])||this._objects[n].isContainedWithinObject(t);if(s){r=n;break}}}else r=e+1;return r},moveTo:function(t,e){return i(this._objects,t),this._objects.splice(e,0,t),this.renderAll&&this.renderAll()},dispose:function(){return this.clear(),this},toString:function(){return"#<fabric.Canvas ("+this.complexity()+"): { objects: "+this.getObjects().length+" }>"}}),t(fabric.StaticCanvas.prototype,fabric.Observable),t(fabric.StaticCanvas.prototype,fabric.Collection),t(fabric.StaticCanvas.prototype,fabric.DataURLExporter),t(fabric.StaticCanvas,{EMPTY_JSON:'{"objects": [], "background": "white"}',supports:function(t){var e=fabric.util.createCanvasElement();if(!e||!e.getContext)return null;var i=e.getContext("2d");if(!i)return null;switch(t){case"getImageData":return"undefined"!=typeof i.getImageData;case"setLineDash":return"undefined"!=typeof i.setLineDash;case"toDataURL":return"undefined"!=typeof e.toDataURL;case"toDataURLWithQuality":try{return e.toDataURL("image/jpeg",0),!0}catch(t){}return!1;default:return null}}}),fabric.StaticCanvas.prototype.toJSON=fabric.StaticCanvas.prototype.toObject}(),fabric.BaseBrush=fabric.util.createClass({color:"rgb(0, 0, 0)",width:1,shadow:null,strokeLineCap:"round",strokeLineJoin:"round",strokeDashArray:null,setShadow:function(t){return this.shadow=new fabric.Shadow(t),this},_setBrushStyles:function(){var t=this.canvas.contextTop;t.strokeStyle=this.color,t.lineWidth=this.width,t.lineCap=this.strokeLineCap,t.lineJoin=this.strokeLineJoin,this.strokeDashArray&&fabric.StaticCanvas.supports("setLineDash")&&t.setLineDash(this.strokeDashArray)},_setShadow:function(){if(this.shadow){var t=this.canvas.contextTop,e=this.canvas.getZoom();t.shadowColor=this.shadow.color,t.shadowBlur=this.shadow.blur*e,t.shadowOffsetX=this.shadow.offsetX*e,t.shadowOffsetY=this.shadow.offsetY*e}},_resetShadow:function(){var t=this.canvas.contextTop;t.shadowColor="",t.shadowBlur=t.shadowOffsetX=t.shadowOffsetY=0}}),function(){fabric.PencilBrush=fabric.util.createClass(fabric.BaseBrush,{initialize:function(t){this.canvas=t,this._points=[]},onMouseDown:function(t){this._prepareForDrawing(t),this._captureDrawingPath(t),this._render()},onMouseMove:function(t){this._captureDrawingPath(t),this.canvas.clearContext(this.canvas.contextTop),this._render()},onMouseUp:function(){this._finalizeAndAddPath()},_prepareForDrawing:function(t){var e=new fabric.Point(t.x,t.y);this._reset(),this._addPoint(e),this.canvas.contextTop.moveTo(e.x,e.y)},_addPoint:function(t){this._points.push(t)},_reset:function(){this._points.length=0,this._setBrushStyles(),this._setShadow()},_captureDrawingPath:function(t){var e=new fabric.Point(t.x,t.y);this._addPoint(e)},_render:function(){var t=this.canvas.contextTop,e=this.canvas.viewportTransform,i=this._points[0],r=this._points[1];t.save(),t.transform(e[0],e[1],e[2],e[3],e[4],e[5]),t.beginPath(),2===this._points.length&&i.x===r.x&&i.y===r.y&&(i.x-=.5,r.x+=.5),t.moveTo(i.x,i.y);for(var n=1,s=this._points.length;n<s;n++){var o=i.midPointFrom(r);t.quadraticCurveTo(i.x,i.y,o.x,o.y),i=this._points[n],r=this._points[n+1]}t.lineTo(i.x,i.y),t.stroke(),t.restore()},convertPointsToSVGPath:function(t){var e=[],i=new fabric.Point(t[0].x,t[0].y),r=new fabric.Point(t[1].x,t[1].y);e.push("M ",t[0].x," ",t[0].y," ");for(var n=1,s=t.length;n<s;n++){var o=i.midPointFrom(r);e.push("Q ",i.x," ",i.y," ",o.x," ",o.y," "),i=new fabric.Point(t[n].x,t[n].y),n+1<t.length&&(r=new fabric.Point(t[n+1].x,t[n+1].y))}return e.push("L ",i.x," ",i.y," "),e},createPath:function(t){var e=new fabric.Path(t,{fill:null,stroke:this.color,strokeWidth:this.width,strokeLineCap:this.strokeLineCap,strokeLineJoin:this.strokeLineJoin,strokeDashArray:this.strokeDashArray,originX:"center",originY:"center"});return this.shadow&&(this.shadow.affectStroke=!0,e.setShadow(this.shadow)),e},_finalizeAndAddPath:function(){var t=this.canvas.contextTop;t.closePath();var e=this.convertPointsToSVGPath(this._points).join("");if("M 0 0 Q 0 0 0 0 L 0 0"===e)return void this.canvas.renderAll();var i=this.createPath(e);this.canvas.add(i),i.setCoords(),this.canvas.clearContext(this.canvas.contextTop),this._resetShadow(),this.canvas.renderAll(),this.canvas.fire("path:created",{path:i})}})}(),fabric.CircleBrush=fabric.util.createClass(fabric.BaseBrush,{width:10,initialize:function(t){this.canvas=t,this.points=[]},drawDot:function(t){var e=this.addPoint(t),i=this.canvas.contextTop,r=this.canvas.viewportTransform;i.save(),i.transform(r[0],r[1],r[2],r[3],r[4],r[5]),i.fillStyle=e.fill,i.beginPath(),i.arc(e.x,e.y,e.radius,0,2*Math.PI,!1),i.closePath(),i.fill(),i.restore()},onMouseDown:function(t){this.points.length=0,this.canvas.clearContext(this.canvas.contextTop),this._setShadow(),this.drawDot(t)},onMouseMove:function(t){this.drawDot(t)},onMouseUp:function(){var t=this.canvas.renderOnAddRemove;this.canvas.renderOnAddRemove=!1;for(var e=[],i=0,r=this.points.length;i<r;i++){var n=this.points[i],s=new fabric.Circle({radius:n.radius,left:n.x,top:n.y,originX:"center",originY:"center",fill:n.fill});this.shadow&&s.setShadow(this.shadow),e.push(s)}var o=new fabric.Group(e,{originX:"center",originY:"center"});o.canvas=this.canvas,this.canvas.add(o),this.canvas.fire("path:created",{path:o}),this.canvas.clearContext(this.canvas.contextTop),this._resetShadow(),this.canvas.renderOnAddRemove=t,this.canvas.renderAll()},addPoint:function(t){var e=new fabric.Point(t.x,t.y),i=fabric.util.getRandomInt(Math.max(0,this.width-20),this.width+20)/2,r=new fabric.Color(this.color).setAlpha(fabric.util.getRandomInt(0,100)/100).toRgba();return e.radius=i,e.fill=r,this.points.push(e),e}}),fabric.SprayBrush=fabric.util.createClass(fabric.BaseBrush,{width:10,density:20,dotWidth:1,dotWidthVariance:1,randomOpacity:!1,optimizeOverlapping:!0,initialize:function(t){this.canvas=t,this.sprayChunks=[]},onMouseDown:function(t){this.sprayChunks.length=0,this.canvas.clearContext(this.canvas.contextTop),this._setShadow(),this.addSprayChunk(t),this.render()},onMouseMove:function(t){this.addSprayChunk(t),this.render()},onMouseUp:function(){var t=this.canvas.renderOnAddRemove;this.canvas.renderOnAddRemove=!1;for(var e=[],i=0,r=this.sprayChunks.length;i<r;i++)for(var n=this.sprayChunks[i],s=0,o=n.length;s<o;s++){var a=new fabric.Rect({width:n[s].width,height:n[s].width,left:n[s].x+1,top:n[s].y+1,originX:"center",originY:"center",fill:this.color});this.shadow&&a.setShadow(this.shadow),e.push(a)}this.optimizeOverlapping&&(e=this._getOptimizedRects(e));var h=new fabric.Group(e,{originX:"center",originY:"center"});h.canvas=this.canvas,this.canvas.add(h),this.canvas.fire("path:created",{path:h}),this.canvas.clearContext(this.canvas.contextTop),this._resetShadow(),this.canvas.renderOnAddRemove=t,this.canvas.renderAll()},_getOptimizedRects:function(t){for(var e,i={},r=0,n=t.length;r<n;r++)e=t[r].left+""+t[r].top,i[e]||(i[e]=t[r]);var s=[];for(e in i)s.push(i[e]);return s},render:function(){var t=this.canvas.contextTop;t.fillStyle=this.color;var e=this.canvas.viewportTransform;t.save(),t.transform(e[0],e[1],e[2],e[3],e[4],e[5]);for(var i=0,r=this.sprayChunkPoints.length;i<r;i++){var n=this.sprayChunkPoints[i];"undefined"!=typeof n.opacity&&(t.globalAlpha=n.opacity),t.fillRect(n.x,n.y,n.width,n.width)}t.restore()},addSprayChunk:function(t){this.sprayChunkPoints=[];for(var e,i,r,n=this.width/2,s=0;s<this.density;s++){e=fabric.util.getRandomInt(t.x-n,t.x+n),i=fabric.util.getRandomInt(t.y-n,t.y+n),r=this.dotWidthVariance?fabric.util.getRandomInt(Math.max(1,this.dotWidth-this.dotWidthVariance),this.dotWidth+this.dotWidthVariance):this.dotWidth;var o=new fabric.Point(e,i);o.width=r,this.randomOpacity&&(o.opacity=fabric.util.getRandomInt(0,100)/100),this.sprayChunkPoints.push(o)}this.sprayChunks.push(this.sprayChunkPoints)}}),fabric.PatternBrush=fabric.util.createClass(fabric.PencilBrush,{getPatternSrc:function(){var t=20,e=5,i=fabric.document.createElement("canvas"),r=i.getContext("2d");return i.width=i.height=t+e,r.fillStyle=this.color,r.beginPath(),r.arc(t/2,t/2,t/2,0,2*Math.PI,!1),r.closePath(),r.fill(),i},getPatternSrcFunction:function(){return String(this.getPatternSrc).replace("this.color",'"'+this.color+'"')},getPattern:function(){return this.canvas.contextTop.createPattern(this.source||this.getPatternSrc(),"repeat")},_setBrushStyles:function(){this.callSuper("_setBrushStyles"),this.canvas.contextTop.strokeStyle=this.getPattern()},createPath:function(t){var e=this.callSuper("createPath",t),i=e._getLeftTopCoords().scalarAdd(e.strokeWidth/2);return e.stroke=new fabric.Pattern({source:this.source||this.getPatternSrcFunction(),offsetX:-i.x,offsetY:-i.y}),e}}),function(){var t=fabric.util.getPointer,e=fabric.util.degreesToRadians,i=fabric.util.radiansToDegrees,r=Math.atan2,n=Math.abs,s=fabric.StaticCanvas.supports("setLineDash"),o=.5;fabric.Canvas=fabric.util.createClass(fabric.StaticCanvas,{initialize:function(t,e){e||(e={}),this._initStatic(t,e),this._initInteractive(),this._createCacheCanvas()},uniScaleTransform:!1,uniScaleKey:"shiftKey",centeredScaling:!1,centeredRotation:!1,centeredKey:"altKey",altActionKey:"shiftKey",interactive:!0,selection:!0,selectionKey:"shiftKey",altSelectionKey:null,selectionColor:"rgba(100, 100, 255, 0.3)",selectionDashArray:[],selectionBorderColor:"rgba(255, 255, 255, 0.3)",selectionLineWidth:1,hoverCursor:"move",moveCursor:"move",defaultCursor:"default",freeDrawingCursor:"crosshair",rotationCursor:"crosshair",containerClass:"canvas-container",perPixelTargetFind:!1,targetFindTolerance:0,skipTargetFind:!1,isDrawingMode:!1,preserveObjectStacking:!1,snapAngle:0,snapThreshold:null,stopContextMenu:!1,fireRightClick:!1,fireMiddleClick:!1,_initInteractive:function(){this._currentTransform=null,this._groupSelector=null,this._initWrapperElement(),this._createUpperCanvas(),this._initEventListeners(),this._initRetinaScaling(),this.freeDrawingBrush=fabric.PencilBrush&&new fabric.PencilBrush(this),this.calcOffset()},_chooseObjectsToRender:function(){var t,e=this.getActiveGroup(),i=this.getActiveObject(),r=[],n=[];if(!e&&!i||this.preserveObjectStacking)r=this._objects;else{for(var s=0,o=this._objects.length;s<o;s++)t=this._objects[s],e&&e.contains(t)||t===i?n.push(t):r.push(t);e&&(e._set("_objects",n),r.push(e)),i&&r.push(i)}return r},renderAll:function(){!this.contextTopDirty||this._groupSelector||this.isDrawingMode||(this.clearContext(this.contextTop),this.contextTopDirty=!1);var t=this.contextContainer;return this.renderCanvas(t,this._chooseObjectsToRender()),this},renderTop:function(){var t=this.contextTop;return this.clearContext(t),this.selection&&this._groupSelector&&this._drawSelection(t),this.fire("after:render"),this.contextTopDirty=!0,this},_resetCurrentTransform:function(){var t=this._currentTransform;t.target.set({scaleX:t.original.scaleX,scaleY:t.original.scaleY,skewX:t.original.skewX,skewY:t.original.skewY,left:t.original.left,top:t.original.top}),this._shouldCenterTransform(t.target)?"rotate"===t.action?this._setOriginToCenter(t.target):("center"!==t.originX&&("right"===t.originX?t.mouseXSign=-1:t.mouseXSign=1),"center"!==t.originY&&("bottom"===t.originY?t.mouseYSign=-1:t.mouseYSign=1),t.originX="center",t.originY="center"):(t.originX=t.original.originX,t.originY=t.original.originY)},containsPoint:function(t,e,i){var r,n=!0,s=i||this.getPointer(t,n);return r=e.group&&e.group===this.getActiveGroup()?this._normalizePointer(e.group,s):{x:s.x,y:s.y},e.containsPoint(r)||e._findTargetCorner(s)},_normalizePointer:function(t,e){var i=t.calcTransformMatrix(),r=fabric.util.invertTransform(i),n=this.restorePointerVpt(e);return fabric.util.transformPoint(n,r)},isTargetTransparent:function(t,e,i){var r=t.hasBorders,n=t.transparentCorners,s=this.contextCache,o=t.selectionBackgroundColor;t.hasBorders=t.transparentCorners=!1,t.selectionBackgroundColor="",s.save(),s.transform.apply(s,this.viewportTransform),t.render(s),s.restore(),t.active&&t._renderControls(s),t.hasBorders=r,t.transparentCorners=n,t.selectionBackgroundColor=o;var a=fabric.util.isTransparent(s,e,i,this.targetFindTolerance);return this.clearContext(s),a},_shouldClearSelection:function(t,e){var i=this.getActiveGroup(),r=this.getActiveObject();return!e||e&&i&&!i.contains(e)&&i!==e&&!t[this.selectionKey]||e&&!e.evented||e&&!e.selectable&&r&&r!==e},_shouldCenterTransform:function(t){if(t){var e,i=this._currentTransform;return"scale"===i.action||"scaleX"===i.action||"scaleY"===i.action?e=this.centeredScaling||t.centeredScaling:"rotate"===i.action&&(e=this.centeredRotation||t.centeredRotation),e?!i.altKey:i.altKey}},_getOriginFromCorner:function(t,e){var i={x:t.originX,y:t.originY};return"ml"===e||"tl"===e||"bl"===e?i.x="right":"mr"!==e&&"tr"!==e&&"br"!==e||(i.x="left"),"tl"===e||"mt"===e||"tr"===e?i.y="bottom":"bl"!==e&&"mb"!==e&&"br"!==e||(i.y="top"),i},_getActionFromCorner:function(t,e,i){if(!e)return"drag";switch(e){case"mtr":return"rotate";case"ml":case"mr":return i[this.altActionKey]?"skewY":"scaleX";case"mt":case"mb":return i[this.altActionKey]?"skewX":"scaleY";default:return"scale"}},_setupCurrentTransform:function(t,i){if(i){var r=this.getPointer(t),n=i._findTargetCorner(this.getPointer(t,!0)),s=this._getActionFromCorner(i,n,t),o=this._getOriginFromCorner(i,n);this._currentTransform={target:i,action:s,corner:n,scaleX:i.scaleX,scaleY:i.scaleY,skewX:i.skewX,skewY:i.skewY,offsetX:r.x-i.left,offsetY:r.y-i.top,originX:o.x,originY:o.y,ex:r.x,ey:r.y,lastX:r.x,lastY:r.y,left:i.left,top:i.top,theta:e(i.angle),width:i.width*i.scaleX,mouseXSign:1,mouseYSign:1,shiftKey:t.shiftKey,altKey:t[this.centeredKey]},this._currentTransform.original={left:i.left,top:i.top,scaleX:i.scaleX,scaleY:i.scaleY,skewX:i.skewX,skewY:i.skewY,originX:o.x,originY:o.y},this._resetCurrentTransform()}},_translateObject:function(t,e){var i=this._currentTransform,r=i.target,n=t-i.offsetX,s=e-i.offsetY,o=!r.get("lockMovementX")&&r.left!==n,a=!r.get("lockMovementY")&&r.top!==s;return o&&r.set("left",n),a&&r.set("top",s),o||a},_changeSkewTransformOrigin:function(t,e,i){var r="originX",n={0:"center"},s=e.target.skewX,o="left",a="right",h="mt"===e.corner||"ml"===e.corner?1:-1,c=1;t=t>0?1:-1,"y"===i&&(s=e.target.skewY,o="top",a="bottom",r="originY"),n[-1]=o,n[1]=a,e.target.flipX&&(c*=-1),e.target.flipY&&(c*=-1),0===s?(e.skewSign=-h*t*c,e[r]=n[-t]):(s=s>0?1:-1,e.skewSign=s,e[r]=n[s*h*c])},_skewObject:function(t,e,i){var r=this._currentTransform,n=r.target,s=!1,o=n.get("lockSkewingX"),a=n.get("lockSkewingY");if(o&&"x"===i||a&&"y"===i)return!1;var h,c,l=n.getCenterPoint(),u=n.toLocalPoint(new fabric.Point(t,e),"center","center")[i],f=n.toLocalPoint(new fabric.Point(r.lastX,r.lastY),"center","center")[i],d=n._getTransformedDimensions();return this._changeSkewTransformOrigin(u-f,r,i),h=n.toLocalPoint(new fabric.Point(t,e),r.originX,r.originY)[i],c=n.translateToOriginPoint(l,r.originX,r.originY),s=this._setObjectSkew(h,r,i,d),r.lastX=t,r.lastY=e,n.setPositionByOrigin(c,r.originX,r.originY),s},_setObjectSkew:function(t,e,i,r){var n,s,o,a,h,c,l,u,f,d=e.target,g=!1,p=e.skewSign;return"x"===i?(a="y",h="Y",c="X",u=0,f=d.skewY):(a="x",h="X",c="Y",u=d.skewX,f=0),o=d._getTransformedDimensions(u,f),l=2*Math.abs(t)-o[i],l<=2?n=0:(n=p*Math.atan(l/d["scale"+c]/(o[a]/d["scale"+h])),n=fabric.util.radiansToDegrees(n)),g=d["skew"+c]!==n,d.set("skew"+c,n),0!==d["skew"+h]&&(s=d._getTransformedDimensions(),n=r[a]/s[a]*d["scale"+h],d.set("scale"+h,n)),g},_scaleObject:function(t,e,i){var r=this._currentTransform,n=r.target,s=n.get("lockScalingX"),o=n.get("lockScalingY"),a=n.get("lockScalingFlip");if(s&&o)return!1;var h=n.translateToOriginPoint(n.getCenterPoint(),r.originX,r.originY),c=n.toLocalPoint(new fabric.Point(t,e),r.originX,r.originY),l=n._getTransformedDimensions(),u=!1;return this._setLocalMouse(c,r),u=this._setObjectScale(c,r,s,o,i,a,l),n.setPositionByOrigin(h,r.originX,r.originY),u},_setObjectScale:function(t,e,i,r,n,s,o){var a,h,c,l,u=e.target,f=!1,d=!1,g=!1;return c=t.x*u.scaleX/o.x,l=t.y*u.scaleY/o.y,a=u.scaleX!==c,h=u.scaleY!==l,s&&c<=0&&c<u.scaleX&&(f=!0),s&&l<=0&&l<u.scaleY&&(d=!0),"equally"!==n||i||r?n?"x"!==n||u.get("lockUniScaling")?"y"!==n||u.get("lockUniScaling")||d||r||u.set("scaleY",l)&&(g=g||h):f||i||u.set("scaleX",c)&&(g=g||a):(f||i||u.set("scaleX",c)&&(g=g||a),d||r||u.set("scaleY",l)&&(g=g||h)):f||d||(g=this._scaleObjectEqually(t,u,e,o)),e.newScaleX=c,e.newScaleY=l,f||d||this._flipObject(e,n),g},_scaleObjectEqually:function(t,e,i,r){var n,s=t.y+t.x,o=r.y*i.original.scaleY/e.scaleY+r.x*i.original.scaleX/e.scaleX;return i.newScaleX=i.original.scaleX*s/o,i.newScaleY=i.original.scaleY*s/o,n=i.newScaleX!==e.scaleX||i.newScaleY!==e.scaleY,e.set("scaleX",i.newScaleX),e.set("scaleY",i.newScaleY),n},_flipObject:function(t,e){t.newScaleX<0&&"y"!==e&&("left"===t.originX?t.originX="right":"right"===t.originX&&(t.originX="left")),t.newScaleY<0&&"x"!==e&&("top"===t.originY?t.originY="bottom":"bottom"===t.originY&&(t.originY="top"))},_setLocalMouse:function(t,e){var i=e.target,r=this.getZoom(),s=i.padding/r;"right"===e.originX?t.x*=-1:"center"===e.originX&&(t.x*=2*e.mouseXSign,t.x<0&&(e.mouseXSign=-e.mouseXSign)),"bottom"===e.originY?t.y*=-1:"center"===e.originY&&(t.y*=2*e.mouseYSign,t.y<0&&(e.mouseYSign=-e.mouseYSign)),n(t.x)>s?t.x<0?t.x+=s:t.x-=s:t.x=0,n(t.y)>s?t.y<0?t.y+=s:t.y-=s:t.y=0},_rotateObject:function(t,e){var n=this._currentTransform;if(n.target.get("lockRotation"))return!1;var s=r(n.ey-n.top,n.ex-n.left),o=r(e-n.top,t-n.left),a=i(o-s+n.theta),h=!0;if(n.target.snapAngle>0){var c=n.target.snapAngle,l=n.target.snapThreshold||c,u=Math.ceil(a/c)*c,f=Math.floor(a/c)*c;Math.abs(a-f)<l?a=f:Math.abs(a-u)<l&&(a=u)}return a<0&&(a=360+a),a%=360,n.target.angle===a?h=!1:n.target.angle=a,h},setCursor:function(t){this.upperCanvasEl.style.cursor=t},_resetObjectTransform:function(t){t.scaleX=1,t.scaleY=1,t.skewX=0,t.skewY=0,t.setAngle(0)},_drawSelection:function(t){var e=this._groupSelector,i=e.left,r=e.top,a=n(i),h=n(r);if(this.selectionColor&&(t.fillStyle=this.selectionColor,t.fillRect(e.ex-(i>0?0:-i),e.ey-(r>0?0:-r),a,h)),this.selectionLineWidth&&this.selectionBorderColor)if(t.lineWidth=this.selectionLineWidth,t.strokeStyle=this.selectionBorderColor,this.selectionDashArray.length>1&&!s){var c=e.ex+o-(i>0?0:a),l=e.ey+o-(r>0?0:h);t.beginPath(),fabric.util.drawDashedLine(t,c,l,c+a,l,this.selectionDashArray),fabric.util.drawDashedLine(t,c,l+h-1,c+a,l+h-1,this.selectionDashArray),fabric.util.drawDashedLine(t,c,l,c,l+h,this.selectionDashArray),fabric.util.drawDashedLine(t,c+a-1,l,c+a-1,l+h,this.selectionDashArray),t.closePath(),t.stroke()}else fabric.Object.prototype._setLineDash.call(this,t,this.selectionDashArray),t.strokeRect(e.ex+o-(i>0?0:a),e.ey+o-(r>0?0:h),a,h)},findTarget:function(t,e){if(!this.skipTargetFind){var i,r=!0,n=this.getPointer(t,r),s=this.getActiveGroup(),o=this.getActiveObject();if(s&&!e&&s===this._searchPossibleTargets([s],n))return this._fireOverOutEvents(s,t),s;if(o&&o._findTargetCorner(n))return this._fireOverOutEvents(o,t),o;if(o&&o===this._searchPossibleTargets([o],n)){if(!this.preserveObjectStacking)return this._fireOverOutEvents(o,t),o;i=o}this.targets=[];var a=this._searchPossibleTargets(this._objects,n);return t[this.altSelectionKey]&&a&&i&&a!==i&&(a=i),this._fireOverOutEvents(a,t),a}},_fireOverOutEvents:function(t,e){t?this._hoveredTarget!==t&&(this._hoveredTarget&&(this.fire("mouse:out",{target:this._hoveredTarget,e:e}),this._hoveredTarget.fire("mouseout",{e:e})),this.fire("mouse:over",{target:t,e:e}),t.fire("mouseover",{e:e}),this._hoveredTarget=t):this._hoveredTarget&&(this.fire("mouse:out",{target:this._hoveredTarget,e:e}),this._hoveredTarget.fire("mouseout",{e:e}),this._hoveredTarget=null)},_checkTarget:function(t,e){if(e&&e.visible&&e.evented&&this.containsPoint(null,e,t)){if(!this.perPixelTargetFind&&!e.perPixelTargetFind||e.isEditing)return!0;var i=this.isTargetTransparent(e,t.x,t.y);if(!i)return!0}},_searchPossibleTargets:function(t,e){for(var i,r,n,s=t.length;s--;)if(this._checkTarget(e,t[s])){i=t[s],"group"===i.type&&i.subTargetCheck&&(r=this._normalizePointer(i,e),n=this._searchPossibleTargets(i._objects,r),n&&this.targets.push(n));break}return i},restorePointerVpt:function(t){return fabric.util.transformPoint(t,fabric.util.invertTransform(this.viewportTransform))},getPointer:function(e,i,r){r||(r=this.upperCanvasEl);var n,s=t(e),o=r.getBoundingClientRect(),a=o.width||0,h=o.height||0;return a&&h||("top"in o&&"bottom"in o&&(h=Math.abs(o.top-o.bottom)),"right"in o&&"left"in o&&(a=Math.abs(o.right-o.left))),this.calcOffset(),s.x=s.x-this._offset.left,s.y=s.y-this._offset.top,i||(s=this.restorePointerVpt(s)),n=0===a||0===h?{width:1,height:1}:{width:r.width/a,height:r.height/h},{x:s.x*n.width,y:s.y*n.height}},_createUpperCanvas:function(){var t=this.lowerCanvasEl.className.replace(/\s*lower-canvas\s*/,"");this.upperCanvasEl=this._createCanvasElement(),fabric.util.addClass(this.upperCanvasEl,"upper-canvas "+t),this.wrapperEl.appendChild(this.upperCanvasEl),this._copyCanvasStyle(this.lowerCanvasEl,this.upperCanvasEl),this._applyCanvasStyle(this.upperCanvasEl),this.contextTop=this.upperCanvasEl.getContext("2d")},_createCacheCanvas:function(){this.cacheCanvasEl=this._createCanvasElement(),this.cacheCanvasEl.setAttribute("width",this.width),this.cacheCanvasEl.setAttribute("height",this.height),this.contextCache=this.cacheCanvasEl.getContext("2d")},_initWrapperElement:function(){this.wrapperEl=fabric.util.wrapElement(this.lowerCanvasEl,"div",{class:this.containerClass}),fabric.util.setStyle(this.wrapperEl,{width:this.getWidth()+"px",height:this.getHeight()+"px",position:"relative"}),fabric.util.makeElementUnselectable(this.wrapperEl)},_applyCanvasStyle:function(t){var e=this.getWidth()||t.width,i=this.getHeight()||t.height;fabric.util.setStyle(t,{position:"absolute",width:e+"px",height:i+"px",left:0,top:0,"touch-action":"none"}),t.width=e,t.height=i,fabric.util.makeElementUnselectable(t)},_copyCanvasStyle:function(t,e){e.style.cssText=t.style.cssText},getSelectionContext:function(){return this.contextTop},getSelectionElement:function(){return this.upperCanvasEl},_setActiveObject:function(t){var e=this._activeObject;e&&(e.set("active",!1),t!==e&&e.onDeselect&&"function"==typeof e.onDeselect&&e.onDeselect()),this._activeObject=t,t.set("active",!0)},setActiveObject:function(t,e){var i=this.getActiveObject();return i&&i!==t&&i.fire("deselected",{e:e}),this._setActiveObject(t),this.renderAll(),this.fire("object:selected",{target:t,e:e}),t.fire("selected",{e:e}),this},getActiveObject:function(){return this._activeObject},_onObjectRemoved:function(t){this.getActiveObject()===t&&(this.fire("before:selection:cleared",{target:t}),this._discardActiveObject(),this.fire("selection:cleared",{target:t}),t.fire("deselected")),this._hoveredTarget===t&&(this._hoveredTarget=null),this.callSuper("_onObjectRemoved",t)},_discardActiveObject:function(){var t=this._activeObject;t&&(t.set("active",!1),t.onDeselect&&"function"==typeof t.onDeselect&&t.onDeselect()),this._activeObject=null},discardActiveObject:function(t){var e=this._activeObject;return e&&(this.fire("before:selection:cleared",{target:e,e:t}),this._discardActiveObject(),this.fire("selection:cleared",{e:t}),e.fire("deselected",{e:t})),this},_setActiveGroup:function(t){this._activeGroup=t,t&&t.set("active",!0)},setActiveGroup:function(t,e){return this._setActiveGroup(t),t&&(this.fire("object:selected",{target:t,e:e}),t.fire("selected",{e:e})),this},getActiveGroup:function(){return this._activeGroup},_discardActiveGroup:function(){var t=this.getActiveGroup();t&&t.destroy(),this.setActiveGroup(null)},discardActiveGroup:function(t){var e=this.getActiveGroup();return e&&(this.fire("before:selection:cleared",{e:t,target:e}),this._discardActiveGroup(),this.fire("selection:cleared",{e:t})),this},deactivateAll:function(){for(var t,e=this.getObjects(),i=0,r=e.length;i<r;i++)t=e[i],t&&t.set("active",!1);return this._discardActiveGroup(),this._discardActiveObject(),this},deactivateAllWithDispatch:function(t){return this.discardActiveGroup(t),this.discardActiveObject(t),this.deactivateAll(),this},dispose:function(){this.callSuper("dispose");var t=this.wrapperEl;return this.removeListeners(),t.removeChild(this.upperCanvasEl),t.removeChild(this.lowerCanvasEl),delete this.upperCanvasEl,t.parentNode&&t.parentNode.replaceChild(this.lowerCanvasEl,this.wrapperEl),delete this.wrapperEl,this},clear:function(){return this.discardActiveGroup(),this.discardActiveObject(),this.clearContext(this.contextTop),this.callSuper("clear")},drawControls:function(t){var e=this.getActiveGroup();e?e._renderControls(t):this._drawObjectsControls(t)},_drawObjectsControls:function(t){for(var e=0,i=this._objects.length;e<i;++e)this._objects[e]&&this._objects[e].active&&this._objects[e]._renderControls(t);
},_toObject:function(t,e,i){var r=this._realizeGroupTransformOnObject(t),n=this.callSuper("_toObject",t,e,i);return this._unwindGroupTransformOnObject(t,r),n},_realizeGroupTransformOnObject:function(t){var e=["angle","flipX","flipY","height","left","scaleX","scaleY","top","width"];if(t.group&&t.group===this.getActiveGroup()){var i={};return e.forEach(function(e){i[e]=t[e]}),this.getActiveGroup().realizeTransform(t),i}return null},_unwindGroupTransformOnObject:function(t,e){e&&t.set(e)},_setSVGObject:function(t,e,i){var r;r=this._realizeGroupTransformOnObject(e),this.callSuper("_setSVGObject",t,e,i),this._unwindGroupTransformOnObject(e,r)}});for(var a in fabric.StaticCanvas)"prototype"!==a&&(fabric.Canvas[a]=fabric.StaticCanvas[a]);fabric.isTouchSupported&&(fabric.Canvas.prototype._setCursorFromEvent=function(){}),fabric.Element=fabric.Canvas}(),function(){var t={mt:0,tr:1,mr:2,br:3,mb:4,bl:5,ml:6,tl:7},e=fabric.util.addListener,i=fabric.util.removeListener;fabric.util.object.extend(fabric.Canvas.prototype,{cursorMap:["n-resize","ne-resize","e-resize","se-resize","s-resize","sw-resize","w-resize","nw-resize"],_initEventListeners:function(){this._bindEvents(),e(fabric.window,"resize",this._onResize),e(this.upperCanvasEl,"mousedown",this._onMouseDown),e(this.upperCanvasEl,"mousemove",this._onMouseMove),e(this.upperCanvasEl,"mouseout",this._onMouseOut),e(this.upperCanvasEl,"mouseenter",this._onMouseEnter),e(this.upperCanvasEl,"wheel",this._onMouseWheel),e(this.upperCanvasEl,"contextmenu",this._onContextMenu),e(this.upperCanvasEl,"touchstart",this._onMouseDown,{passive:!1}),e(this.upperCanvasEl,"touchmove",this._onMouseMove,{passive:!1}),"undefined"!=typeof eventjs&&"add"in eventjs&&(eventjs.add(this.upperCanvasEl,"gesture",this._onGesture),eventjs.add(this.upperCanvasEl,"drag",this._onDrag),eventjs.add(this.upperCanvasEl,"orientation",this._onOrientationChange),eventjs.add(this.upperCanvasEl,"shake",this._onShake),eventjs.add(this.upperCanvasEl,"longpress",this._onLongPress))},_bindEvents:function(){this._onMouseDown=this._onMouseDown.bind(this),this._onMouseMove=this._onMouseMove.bind(this),this._onMouseUp=this._onMouseUp.bind(this),this._onResize=this._onResize.bind(this),this._onGesture=this._onGesture.bind(this),this._onDrag=this._onDrag.bind(this),this._onShake=this._onShake.bind(this),this._onLongPress=this._onLongPress.bind(this),this._onOrientationChange=this._onOrientationChange.bind(this),this._onMouseWheel=this._onMouseWheel.bind(this),this._onMouseOut=this._onMouseOut.bind(this),this._onMouseEnter=this._onMouseEnter.bind(this),this._onContextMenu=this._onContextMenu.bind(this)},removeListeners:function(){i(fabric.window,"resize",this._onResize),i(this.upperCanvasEl,"mousedown",this._onMouseDown),i(this.upperCanvasEl,"mousemove",this._onMouseMove),i(this.upperCanvasEl,"mouseout",this._onMouseOut),i(this.upperCanvasEl,"mouseenter",this._onMouseEnter),i(this.upperCanvasEl,"wheel",this._onMouseWheel),i(this.upperCanvasEl,"contextmenu",this._onContextMenu),i(this.upperCanvasEl,"touchstart",this._onMouseDown),i(this.upperCanvasEl,"touchmove",this._onMouseMove),"undefined"!=typeof eventjs&&"remove"in eventjs&&(eventjs.remove(this.upperCanvasEl,"gesture",this._onGesture),eventjs.remove(this.upperCanvasEl,"drag",this._onDrag),eventjs.remove(this.upperCanvasEl,"orientation",this._onOrientationChange),eventjs.remove(this.upperCanvasEl,"shake",this._onShake),eventjs.remove(this.upperCanvasEl,"longpress",this._onLongPress))},_onGesture:function(t,e){this.__onTransformGesture&&this.__onTransformGesture(t,e)},_onDrag:function(t,e){this.__onDrag&&this.__onDrag(t,e)},_onMouseWheel:function(t){this.__onMouseWheel(t)},_onMouseOut:function(t){var e=this._hoveredTarget;this.fire("mouse:out",{target:e,e:t}),this._hoveredTarget=null,e&&e.fire("mouseout",{e:t}),this._iTextInstances&&this._iTextInstances.forEach(function(t){t.isEditing&&t.hiddenTextarea.focus()})},_onMouseEnter:function(t){this.findTarget(t)||(this.fire("mouse:over",{target:null,e:t}),this._hoveredTarget=null)},_onOrientationChange:function(t,e){this.__onOrientationChange&&this.__onOrientationChange(t,e)},_onShake:function(t,e){this.__onShake&&this.__onShake(t,e)},_onLongPress:function(t,e){this.__onLongPress&&this.__onLongPress(t,e)},_onContextMenu:function(t){return this.stopContextMenu&&(t.stopPropagation(),t.preventDefault()),!1},_onMouseDown:function(t){this.__onMouseDown(t),e(fabric.document,"touchend",this._onMouseUp,{passive:!1}),e(fabric.document,"touchmove",this._onMouseMove,{passive:!1}),i(this.upperCanvasEl,"mousemove",this._onMouseMove),i(this.upperCanvasEl,"touchmove",this._onMouseMove),"touchstart"===t.type?i(this.upperCanvasEl,"mousedown",this._onMouseDown):(e(fabric.document,"mouseup",this._onMouseUp),e(fabric.document,"mousemove",this._onMouseMove))},_onMouseUp:function(t){if(this.__onMouseUp(t),i(fabric.document,"mouseup",this._onMouseUp),i(fabric.document,"touchend",this._onMouseUp),i(fabric.document,"mousemove",this._onMouseMove),i(fabric.document,"touchmove",this._onMouseMove),e(this.upperCanvasEl,"mousemove",this._onMouseMove),e(this.upperCanvasEl,"touchmove",this._onMouseMove,{passive:!1}),"touchend"===t.type){var r=this;setTimeout(function(){e(r.upperCanvasEl,"mousedown",r._onMouseDown)},400)}},_onMouseMove:function(t){!this.allowTouchScrolling&&t.preventDefault&&t.preventDefault(),this.__onMouseMove(t)},_onResize:function(){this.calcOffset()},_shouldRender:function(t,e){var i=this.getActiveGroup()||this.getActiveObject();return(!i||!i.isEditing||t!==i)&&!!(t&&(t.isMoving||t!==i)||!t&&i||!t&&!i&&!this._groupSelector||e&&this._previousPointer&&this.selection&&(e.x!==this._previousPointer.x||e.y!==this._previousPointer.y))},__onMouseUp:function(t){var e,i=!0,r=this._currentTransform,n=this._groupSelector,s=!n||0===n.left&&0===n.top;if(this.isDrawingMode&&this._isCurrentlyDrawing)return void this._onMouseUpInDrawingMode(t);r&&(this._finalizeCurrentTransform(),i=!r.actionPerformed),e=i?this.findTarget(t,!0):r.target;var o=this._shouldRender(e,this.getPointer(t));e||!s?this._maybeGroupObjects(t):(this._groupSelector=null,this._currentTransform=null),e&&(e.isMoving=!1),this._handleCursorAndEvent(t,e,"up"),e&&(e.__corner=0),o&&this.renderAll()},_handleCursorAndEvent:function(t,e,i){this._setCursorFromEvent(t,e),this._handleEvent(t,i,e?e:null)},_handleEvent:function(t,e,i){var r="undefined"==typeof i?this.findTarget(t):i,n=this.targets||[],s={e:t,target:r,subTargets:n};this.fire("mouse:"+e,s),r&&r.fire("mouse"+e,s);for(var o=0;o<n.length;o++)n[o].fire("mouse"+e,s)},_finalizeCurrentTransform:function(){var t=this._currentTransform,e=t.target;e._scaling&&(e._scaling=!1),e.setCoords(),this._restoreOriginXY(e),(t.actionPerformed||this.stateful&&e.hasStateChanged())&&(this.fire("object:modified",{target:e}),e.fire("modified"))},_restoreOriginXY:function(t){if(this._previousOriginX&&this._previousOriginY){var e=t.translateToOriginPoint(t.getCenterPoint(),this._previousOriginX,this._previousOriginY);t.originX=this._previousOriginX,t.originY=this._previousOriginY,t.left=e.x,t.top=e.y,this._previousOriginX=null,this._previousOriginY=null}},_onMouseDownInDrawingMode:function(t){this._isCurrentlyDrawing=!0,this.discardActiveObject(t).renderAll(),this.clipTo&&fabric.util.clipContext(this,this.contextTop);var e=this.getPointer(t);this.freeDrawingBrush.onMouseDown(e),this._handleEvent(t,"down")},_onMouseMoveInDrawingMode:function(t){if(this._isCurrentlyDrawing){var e=this.getPointer(t);this.freeDrawingBrush.onMouseMove(e)}this.setCursor(this.freeDrawingCursor),this._handleEvent(t,"move")},_onMouseUpInDrawingMode:function(t){this._isCurrentlyDrawing=!1,this.clipTo&&this.contextTop.restore(),this.freeDrawingBrush.onMouseUp(),this._handleEvent(t,"up")},__onMouseDown:function(t){var e=this.findTarget(t),i="which"in t?3===t.which:2===t.button;if(i)return void(this.fireRightClick&&this._handleEvent(t,"down",e?e:null));var r="which"in t?2===t.which:1===t.button;if(r)return void(this.fireMiddleClick&&this._handleEvent(t,"down",e?e:null));if(this.isDrawingMode)return void this._onMouseDownInDrawingMode(t);if(!this._currentTransform){var n=this.getPointer(t,!0);this._previousPointer=n;var s=this._shouldRender(e,n),o=this._shouldGroup(t,e);if(this._shouldClearSelection(t,e)?this._clearSelection(t,e,n):o&&(this._handleGrouping(t,e),e=this.getActiveGroup()),e){!e.selectable||!e.__corner&&o||(this._beforeTransform(t,e),this._setupCurrentTransform(t,e));var a=this.getActiveObject();e!==this.getActiveGroup()&&e!==a&&(this.deactivateAll(),e.selectable&&(a&&a.fire("deselected",{e:t}),this.setActiveObject(e,t)))}this._handleEvent(t,"down",e?e:null),s&&this.renderAll()}},_beforeTransform:function(t,e){this.stateful&&e.saveState(),e._findTargetCorner(this.getPointer(t))&&this.onBeforeScaleRotate(e)},_clearSelection:function(t,e,i){this.deactivateAllWithDispatch(t),e&&e.selectable?this.setActiveObject(e,t):this.selection&&(this._groupSelector={ex:i.x,ey:i.y,top:0,left:0})},_setOriginToCenter:function(t){this._previousOriginX=this._currentTransform.target.originX,this._previousOriginY=this._currentTransform.target.originY;var e=t.getCenterPoint();t.originX="center",t.originY="center",t.left=e.x,t.top=e.y,this._currentTransform.left=t.left,this._currentTransform.top=t.top},_setCenterToOrigin:function(t){var e=t.translateToOriginPoint(t.getCenterPoint(),this._previousOriginX,this._previousOriginY);t.originX=this._previousOriginX,t.originY=this._previousOriginY,t.left=e.x,t.top=e.y,this._previousOriginX=null,this._previousOriginY=null},__onMouseMove:function(t){var e,i;if(this.isDrawingMode)return void this._onMouseMoveInDrawingMode(t);if(!("undefined"!=typeof t.touches&&t.touches.length>1)){var r=this._groupSelector;r?(i=this.getPointer(t,!0),r.left=i.x-r.ex,r.top=i.y-r.ey,this.renderTop()):this._currentTransform?this._transformObject(t):(e=this.findTarget(t),this._setCursorFromEvent(t,e)),this._handleEvent(t,"move",e?e:null)}},__onMouseWheel:function(t){this._handleEvent(t,"wheel")},_transformObject:function(t){var e=this.getPointer(t),i=this._currentTransform;i.reset=!1,i.target.isMoving=!0,i.shiftKey=t.shiftKey,i.altKey=t[this.centeredKey],this._beforeScaleTransform(t,i),this._performTransformAction(t,i,e),i.actionPerformed&&this.renderAll()},_performTransformAction:function(t,e,i){var r=i.x,n=i.y,s=e.target,o=e.action,a=!1;"rotate"===o?(a=this._rotateObject(r,n))&&this._fire("rotating",s,t):"scale"===o?(a=this._onScale(t,e,r,n))&&this._fire("scaling",s,t):"scaleX"===o?(a=this._scaleObject(r,n,"x"))&&this._fire("scaling",s,t):"scaleY"===o?(a=this._scaleObject(r,n,"y"))&&this._fire("scaling",s,t):"skewX"===o?(a=this._skewObject(r,n,"x"))&&this._fire("skewing",s,t):"skewY"===o?(a=this._skewObject(r,n,"y"))&&this._fire("skewing",s,t):(a=this._translateObject(r,n),a&&(this._fire("moving",s,t),this.setCursor(s.moveCursor||this.moveCursor))),e.actionPerformed=e.actionPerformed||a},_fire:function(t,e,i){this.fire("object:"+t,{target:e,e:i}),e.fire(t,{e:i})},_beforeScaleTransform:function(t,e){if("scale"===e.action||"scaleX"===e.action||"scaleY"===e.action){var i=this._shouldCenterTransform(e.target);(i&&("center"!==e.originX||"center"!==e.originY)||!i&&"center"===e.originX&&"center"===e.originY)&&(this._resetCurrentTransform(),e.reset=!0)}},_onScale:function(t,e,i,r){return!t[this.uniScaleKey]&&!this.uniScaleTransform||e.target.get("lockUniScaling")?(e.reset||"scale"!==e.currentAction||this._resetCurrentTransform(),e.currentAction="scaleEqually",this._scaleObject(i,r,"equally")):(e.currentAction="scale",this._scaleObject(i,r))},_setCursorFromEvent:function(t,e){if(!e||!e.selectable)return this.setCursor(this.defaultCursor),!1;var i=e.hoverCursor||this.hoverCursor,r=this.getActiveGroup(),n=e._findTargetCorner&&(!r||!r.contains(e))&&e._findTargetCorner(this.getPointer(t,!0));return n?this._setCornerCursor(n,e,t):this.setCursor(i),!0},_setCornerCursor:function(e,i,r){if(e in t)this.setCursor(this._getRotatedCornerCursor(e,i,r));else{if("mtr"!==e||!i.hasRotatingPoint)return this.setCursor(this.defaultCursor),!1;this.setCursor(this.rotationCursor)}},_getRotatedCornerCursor:function(e,i,r){var n=Math.round(i.getAngle()%360/45);return n<0&&(n+=8),n+=t[e],r[this.altActionKey]&&t[e]%2===0&&(n+=2),n%=8,this.cursorMap[n]}})}(),function(){var t=Math.min,e=Math.max;fabric.util.object.extend(fabric.Canvas.prototype,{_shouldGroup:function(t,e){var i=this.getActiveObject();return t[this.selectionKey]&&e&&e.selectable&&(this.getActiveGroup()||i&&i!==e)&&this.selection},_handleGrouping:function(t,e){var i=this.getActiveGroup();(e!==i||(e=this.findTarget(t,!0)))&&(i?this._updateActiveGroup(e,t):this._createActiveGroup(e,t),this._activeGroup&&this._activeGroup.saveCoords())},_updateActiveGroup:function(t,e){var i=this.getActiveGroup();if(i.contains(t)){if(i.removeWithUpdate(t),t.set("active",!1),1===i.size())return this.discardActiveGroup(e),void this.setActiveObject(i.item(0),e)}else i.addWithUpdate(t);this.fire("selection:created",{target:i,e:e}),i.set("active",!0)},_createActiveGroup:function(t,e){if(this._activeObject&&t!==this._activeObject){var i=this._createGroup(t);i.addWithUpdate(),this.setActiveGroup(i,e),this._activeObject=null,this.fire("selection:created",{target:i,e:e})}t.set("active",!0)},_createGroup:function(t){var e=this.getObjects(),i=e.indexOf(this._activeObject)<e.indexOf(t),r=i?[this._activeObject,t]:[t,this._activeObject];return this._activeObject.isEditing&&this._activeObject.exitEditing(),new fabric.Group(r,{canvas:this})},_groupSelectedObjects:function(t){var e=this._collectObjects();1===e.length?this.setActiveObject(e[0],t):e.length>1&&(e=new fabric.Group(e.reverse(),{canvas:this}),e.addWithUpdate(),this.setActiveGroup(e,t),e.saveCoords(),this.fire("selection:created",{target:e,e:t}),this.renderAll())},_collectObjects:function(){for(var i,r=[],n=this._groupSelector.ex,s=this._groupSelector.ey,o=n+this._groupSelector.left,a=s+this._groupSelector.top,h=new fabric.Point(t(n,o),t(s,a)),c=new fabric.Point(e(n,o),e(s,a)),l=n===o&&s===a,u=this._objects.length;u--&&(i=this._objects[u],!(i&&i.selectable&&i.visible&&(i.intersectsWithRect(h,c)||i.isContainedWithinRect(h,c)||i.containsPoint(h)||i.containsPoint(c))&&(i.set("active",!0),r.push(i),l))););return r},_maybeGroupObjects:function(t){this.selection&&this._groupSelector&&this._groupSelectedObjects(t);var e=this.getActiveGroup();e&&(e.setObjectsCoords().setCoords(),e.isMoving=!1,this.setCursor(this.defaultCursor)),this._groupSelector=null,this._currentTransform=null}})}(),function(){var t=fabric.StaticCanvas.supports("toDataURLWithQuality");fabric.util.object.extend(fabric.StaticCanvas.prototype,{toDataURL:function(t){t||(t={});var e=t.format||"png",i=t.quality||1,r=t.multiplier||1,n={left:t.left||0,top:t.top||0,width:t.width||0,height:t.height||0};return this.__toDataURLWithMultiplier(e,i,n,r)},__toDataURLWithMultiplier:function(t,e,i,r){var n=this.getWidth(),s=this.getHeight(),o=(i.width||this.getWidth())*r,a=(i.height||this.getHeight())*r,h=this.getZoom(),c=h*r,l=this.viewportTransform,u=(l[4]-i.left)*r,f=(l[5]-i.top)*r,d=[c,0,0,c,u,f],g=this.interactive;this.viewportTransform=d,this.interactive&&(this.interactive=!1),n!==o||s!==a?this.setDimensions({width:o,height:a}):this.renderAll();var p=this.__toDataURL(t,e,i);return g&&(this.interactive=g),this.viewportTransform=l,this.setDimensions({width:n,height:s}),p},__toDataURL:function(e,i){var r=this.contextContainer.canvas;"jpg"===e&&(e="jpeg");var n=t?r.toDataURL("image/"+e,i):r.toDataURL("image/"+e);return n},toDataURLWithMultiplier:function(t,e,i){return this.toDataURL({format:t,multiplier:e,quality:i})}})}(),fabric.util.object.extend(fabric.StaticCanvas.prototype,{loadFromDatalessJSON:function(t,e,i){return this.loadFromJSON(t,e,i)},loadFromJSON:function(t,e,i){if(t){var r="string"==typeof t?JSON.parse(t):fabric.util.object.clone(t);this.clear();var n=this;return this._enlivenObjects(r.objects,function(){n._setBgOverlay(r,function(){delete r.objects,delete r.backgroundImage,delete r.overlayImage,delete r.background,delete r.overlay,n._setOptions(r),e&&e()})},i),this}},_setBgOverlay:function(t,e){var i=this,r={backgroundColor:!1,overlayColor:!1,backgroundImage:!1,overlayImage:!1};if(!(t.backgroundImage||t.overlayImage||t.background||t.overlay))return void(e&&e());var n=function(){r.backgroundImage&&r.overlayImage&&r.backgroundColor&&r.overlayColor&&(i.renderAll(),e&&e())};this.__setBgOverlay("backgroundImage",t.backgroundImage,r,n),this.__setBgOverlay("overlayImage",t.overlayImage,r,n),this.__setBgOverlay("backgroundColor",t.background,r,n),this.__setBgOverlay("overlayColor",t.overlay,r,n)},__setBgOverlay:function(t,e,i,r){var n=this;return e?void("backgroundImage"===t||"overlayImage"===t?fabric.util.enlivenObjects([e],function(e){n[t]=e[0],i[t]=!0,r&&r()}):this["set"+fabric.util.string.capitalize(t,!0)](e,function(){i[t]=!0,r&&r()})):(i[t]=!0,void(r&&r()))},_enlivenObjects:function(t,e,i){var r=this;if(!t||0===t.length)return void(e&&e());var n=this.renderOnAddRemove;this.renderOnAddRemove=!1,fabric.util.enlivenObjects(t,function(t){t.forEach(function(t,e){r.insertAt(t,e)}),r.renderOnAddRemove=n,e&&e()},null,i)},_toDataURL:function(t,e){this.clone(function(i){e(i.toDataURL(t))})},_toDataURLWithMultiplier:function(t,e,i){this.clone(function(r){i(r.toDataURLWithMultiplier(t,e))})},clone:function(t,e){var i=JSON.stringify(this.toJSON(e));this.cloneWithoutData(function(e){e.loadFromJSON(i,function(){t&&t(e)})})},cloneWithoutData:function(t){var e=fabric.document.createElement("canvas");e.width=this.getWidth(),e.height=this.getHeight();var i=new fabric.Canvas(e);i.clipTo=this.clipTo,this.backgroundImage?(i.setBackgroundImage(this.backgroundImage.src,function(){i.renderAll(),t&&t(i)}),i.backgroundImageOpacity=this.backgroundImageOpacity,i.backgroundImageStretch=this.backgroundImageStretch):t&&t(i)}}),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.util.object.extend,r=e.util.object.clone,n=e.util.toFixed,s=e.util.string.capitalize,o=e.util.degreesToRadians,a=e.StaticCanvas.supports("setLineDash"),h=!e.isLikelyNode;e.Object||(e.Object=e.util.createClass(e.CommonMethods,{type:"object",originX:"left",originY:"top",top:0,left:0,width:0,height:0,scaleX:1,scaleY:1,flipX:!1,flipY:!1,opacity:1,angle:0,skewX:0,skewY:0,cornerSize:13,transparentCorners:!0,hoverCursor:null,moveCursor:null,padding:0,borderColor:"rgba(102,153,255,0.75)",borderDashArray:null,cornerColor:"rgba(102,153,255,0.5)",cornerStrokeColor:null,cornerStyle:"rect",cornerDashArray:null,centeredScaling:!1,centeredRotation:!0,fill:"rgb(0,0,0)",fillRule:"nonzero",globalCompositeOperation:"source-over",backgroundColor:"",selectionBackgroundColor:"",stroke:null,strokeWidth:1,strokeDashArray:null,strokeLineCap:"butt",strokeLineJoin:"miter",strokeMiterLimit:10,shadow:null,borderOpacityWhenMoving:.4,borderScaleFactor:1,transformMatrix:null,minScaleLimit:.01,selectable:!0,evented:!0,visible:!0,hasControls:!0,hasBorders:!0,hasRotatingPoint:!0,rotatingPointOffset:40,perPixelTargetFind:!1,includeDefaultValues:!0,clipTo:null,lockMovementX:!1,lockMovementY:!1,lockRotation:!1,lockScalingX:!1,lockScalingY:!1,lockUniScaling:!1,lockSkewingX:!1,lockSkewingY:!1,lockScalingFlip:!1,excludeFromExport:!1,objectCaching:h,statefullCache:!1,noScaleCache:!0,dirty:!0,needsItsOwnCache:!1,stateProperties:"top left width height scaleX scaleY flipX flipY originX originY transformMatrix stroke strokeWidth strokeDashArray strokeLineCap strokeLineJoin strokeMiterLimit angle opacity fill fillRule globalCompositeOperation shadow clipTo visible backgroundColor skewX skewY".split(" "),cacheProperties:"fill stroke strokeWidth strokeDashArray width height stroke strokeWidth strokeDashArray strokeLineCap strokeLineJoin strokeMiterLimit fillRule backgroundColor".split(" "),initialize:function(t){t=t||{},t&&this.setOptions(t),this.objectCaching&&this._createCacheCanvas()},_createCacheCanvas:function(){this._cacheProperties={},this._cacheCanvas=e.document.createElement("canvas"),this._cacheContext=this._cacheCanvas.getContext("2d"),this._updateCacheCanvas()},_getCacheCanvasDimensions:function(){var t=this.canvas&&this.canvas.getZoom()||1,i=this.getObjectScaling(),r=this._getNonTransformedDimensions(),n=this.canvas&&this.canvas._isRetinaScaling()?e.devicePixelRatio:1,s=i.scaleX*t*n,o=i.scaleY*t*n,a=r.x*s,h=r.y*o;return{width:a+2,height:h+2,zoomX:s,zoomY:o}},_updateCacheCanvas:function(){if(this.noScaleCache&&this.canvas&&this.canvas._currentTransform){var t=this.canvas._currentTransform.action;if("scale"===t.slice(0,5))return!1}var e=this._getCacheCanvasDimensions(),i=e.width,r=e.height,n=e.zoomX,s=e.zoomY;return(i!==this.cacheWidth||r!==this.cacheHeight)&&(this._cacheCanvas.width=Math.ceil(i),this._cacheCanvas.height=Math.ceil(r),this._cacheContext.translate(i/2,r/2),this._cacheContext.scale(n,s),this.cacheWidth=i,this.cacheHeight=r,this.zoomX=n,this.zoomY=s,!0)},setOptions:function(t){this._setOptions(t),this._initGradient(t.fill,"fill"),this._initGradient(t.stroke,"stroke"),this._initClipping(t),this._initPattern(t.fill,"fill"),this._initPattern(t.stroke,"stroke")},transform:function(t,e){this.group&&!this.group._transformDone&&this.group===this.canvas._activeGroup&&this.group.transform(t);var i=e?this._getLeftTopCoords():this.getCenterPoint();t.translate(i.x,i.y),this.angle&&t.rotate(o(this.angle)),t.scale(this.scaleX*(this.flipX?-1:1),this.scaleY*(this.flipY?-1:1)),this.skewX&&t.transform(1,0,Math.tan(o(this.skewX)),1,0,0),this.skewY&&t.transform(1,Math.tan(o(this.skewY)),0,1,0,0)},toObject:function(t){var i=e.Object.NUM_FRACTION_DIGITS,r={type:this.type,originX:this.originX,originY:this.originY,left:n(this.left,i),top:n(this.top,i),width:n(this.width,i),height:n(this.height,i),fill:this.fill&&this.fill.toObject?this.fill.toObject():this.fill,stroke:this.stroke&&this.stroke.toObject?this.stroke.toObject():this.stroke,strokeWidth:n(this.strokeWidth,i),strokeDashArray:this.strokeDashArray?this.strokeDashArray.concat():this.strokeDashArray,strokeLineCap:this.strokeLineCap,strokeLineJoin:this.strokeLineJoin,strokeMiterLimit:n(this.strokeMiterLimit,i),scaleX:n(this.scaleX,i),scaleY:n(this.scaleY,i),angle:n(this.getAngle(),i),flipX:this.flipX,flipY:this.flipY,opacity:n(this.opacity,i),shadow:this.shadow&&this.shadow.toObject?this.shadow.toObject():this.shadow,visible:this.visible,clipTo:this.clipTo&&String(this.clipTo),backgroundColor:this.backgroundColor,fillRule:this.fillRule,globalCompositeOperation:this.globalCompositeOperation,transformMatrix:this.transformMatrix?this.transformMatrix.concat():null,skewX:n(this.skewX,i),skewY:n(this.skewY,i)};return e.util.populateWithProperties(this,r,t),this.includeDefaultValues||(r=this._removeDefaultValues(r)),r},toDatalessObject:function(t){return this.toObject(t)},_removeDefaultValues:function(t){var i=e.util.getKlass(t.type).prototype,r=i.stateProperties;return r.forEach(function(e){t[e]===i[e]&&delete t[e];var r="[object Array]"===Object.prototype.toString.call(t[e])&&"[object Array]"===Object.prototype.toString.call(i[e]);r&&0===t[e].length&&0===i[e].length&&delete t[e]}),t},toString:function(){return"#<fabric."+s(this.type)+">"},getObjectScaling:function(){var t=this.scaleX,e=this.scaleY;if(this.group){var i=this.group.getObjectScaling();t*=i.scaleX,e*=i.scaleY}return{scaleX:t,scaleY:e}},_set:function(t,i){var r="scaleX"===t||"scaleY"===t;return r&&(i=this._constrainScale(i)),"scaleX"===t&&i<0?(this.flipX=!this.flipX,i*=-1):"scaleY"===t&&i<0?(this.flipY=!this.flipY,i*=-1):"shadow"!==t||!i||i instanceof e.Shadow?"dirty"===t&&this.group&&this.group.set("dirty",i):i=new e.Shadow(i),this[t]=i,this.cacheProperties.indexOf(t)>-1&&(this.group&&this.group.set("dirty",!0),this.dirty=!0),this.group&&this.stateProperties.indexOf(t)>-1&&this.group.set("dirty",!0),"width"!==t&&"height"!==t||(this.minScaleLimit=Math.min(.1,1/Math.max(this.width,this.height))),this},setOnGroup:function(){},setSourcePath:function(t){return this.sourcePath=t,this},getViewportTransform:function(){return this.canvas&&this.canvas.viewportTransform?this.canvas.viewportTransform:e.iMatrix.concat()},render:function(t,i){0===this.width&&0===this.height||!this.visible||this.canvas&&this.canvas.skipOffscreen&&!this.group&&!this.isOnScreen()||(t.save(),this._setupCompositeOperation(t),this.drawSelectionBackground(t),i||this.transform(t),this._setOpacity(t),this._setShadow(t),this.transformMatrix&&t.transform.apply(t,this.transformMatrix),this.clipTo&&e.util.clipContext(this,t),this.shouldCache()?(this._cacheCanvas||this._createCacheCanvas(),this.isCacheDirty(i)&&(this.statefullCache&&this.saveState({propertySet:"cacheProperties"}),this.drawObject(this._cacheContext,i),this.dirty=!1),this.drawCacheOnCanvas(t)):(this.drawObject(t,i),i&&this.objectCaching&&this.statefullCache&&this.saveState({propertySet:"cacheProperties"})),this.clipTo&&t.restore(),t.restore())},shouldCache:function(){return this.objectCaching&&(!this.group||this.needsItsOwnCache||!this.group.isCaching())},willDrawShadow:function(){return!!this.shadow},drawObject:function(t,e){this._renderBackground(t),this._setStrokeStyles(t),this._setFillStyles(t),this._render(t,e)},drawCacheOnCanvas:function(t){t.scale(1/this.zoomX,1/this.zoomY),t.drawImage(this._cacheCanvas,-this.cacheWidth/2,-this.cacheHeight/2)},isCacheDirty:function(t){if(!t&&this._updateCacheCanvas())return!0;if(this.dirty||this.statefullCache&&this.hasStateChanged("cacheProperties")){if(!t){var e=this.cacheWidth/this.zoomX,i=this.cacheHeight/this.zoomY;this._cacheContext.clearRect(-e/2,-i/2,e,i)}return!0}return!1},_renderBackground:function(t){if(this.backgroundColor){var e=this._getNonTransformedDimensions();t.fillStyle=this.backgroundColor,t.fillRect(-e.x/2,-e.y/2,e.x,e.y),this._removeShadow(t)}},_setOpacity:function(t){t.globalAlpha*=this.opacity},_setStrokeStyles:function(t){this.stroke&&(t.lineWidth=this.strokeWidth,t.lineCap=this.strokeLineCap,t.lineJoin=this.strokeLineJoin,t.miterLimit=this.strokeMiterLimit,t.strokeStyle=this.stroke.toLive?this.stroke.toLive(t,this):this.stroke)},_setFillStyles:function(t){this.fill&&(t.fillStyle=this.fill.toLive?this.fill.toLive(t,this):this.fill)},_setLineDash:function(t,e,i){e&&(1&e.length&&e.push.apply(e,e),a?t.setLineDash(e):i&&i(t))},_renderControls:function(t){if(this.active&&(!this.group||this.group===this.canvas.getActiveGroup())){var i,r=this.getViewportTransform(),n=this.calcTransformMatrix();n=e.util.multiplyTransformMatrices(r,n),i=e.util.qrDecompose(n),t.save(),t.translate(i.translateX,i.translateY),t.lineWidth=1*this.borderScaleFactor,this.group||(t.globalAlpha=this.isMoving?this.borderOpacityWhenMoving:1),this.group&&this.group===this.canvas.getActiveGroup()?(t.rotate(o(i.angle)),this.drawBordersInGroup(t,i)):(t.rotate(o(this.angle)),this.drawBorders(t)),this.drawControls(t),t.restore()}},_setShadow:function(t){if(this.shadow){var i=this.canvas&&this.canvas.viewportTransform[0]||1,r=this.canvas&&this.canvas.viewportTransform[3]||1,n=this.getObjectScaling();this.canvas&&this.canvas._isRetinaScaling()&&(i*=e.devicePixelRatio,r*=e.devicePixelRatio),t.shadowColor=this.shadow.color,t.shadowBlur=this.shadow.blur*(i+r)*(n.scaleX+n.scaleY)/4,t.shadowOffsetX=this.shadow.offsetX*i*n.scaleX,t.shadowOffsetY=this.shadow.offsetY*r*n.scaleY}},_removeShadow:function(t){this.shadow&&(t.shadowColor="",t.shadowBlur=t.shadowOffsetX=t.shadowOffsetY=0)},_applyPatternGradientTransform:function(t,e){if(e.toLive){var i=e.gradientTransform||e.patternTransform;i&&t.transform.apply(t,i);var r=-this.width/2+e.offsetX||0,n=-this.height/2+e.offsetY||0;t.translate(r,n)}},_renderFill:function(t){this.fill&&(t.save(),this._applyPatternGradientTransform(t,this.fill),"evenodd"===this.fillRule?t.fill("evenodd"):t.fill(),t.restore())},_renderStroke:function(t){this.stroke&&0!==this.strokeWidth&&(this.shadow&&!this.shadow.affectStroke&&this._removeShadow(t),t.save(),this._setLineDash(t,this.strokeDashArray,this._renderDashedStroke),this._applyPatternGradientTransform(t,this.stroke),t.stroke(),t.restore())},clone:function(t,i){return this.constructor.fromObject?this.constructor.fromObject(this.toObject(i),t):new e.Object(this.toObject(i))},cloneAsImage:function(t,i){var r=this.toDataURL(i);return e.util.loadImage(r,function(i){t&&t(new e.Image(i))}),this},toDataURL:function(t){t||(t={});var i=e.util.createCanvasElement(),r=this.getBoundingRect();i.width=r.width,i.height=r.height,e.util.wrapElement(i,"div");var n=new e.StaticCanvas(i,{enableRetinaScaling:t.enableRetinaScaling});"jpg"===t.format&&(t.format="jpeg"),"jpeg"===t.format&&(n.backgroundColor="#fff");var s={active:this.get("active"),left:this.getLeft(),top:this.getTop()};this.set("active",!1),this.setPositionByOrigin(new e.Point(n.getWidth()/2,n.getHeight()/2),"center","center");var o=this.canvas;n.add(this);var a=n.toDataURL(t);return this.set(s).setCoords(),this.canvas=o,n.dispose(),n=null,a},isType:function(t){return this.type===t},complexity:function(){return 1},toJSON:function(t){return this.toObject(t)},setGradient:function(t,i){i||(i={});var r={colorStops:[]};return r.type=i.type||(i.r1||i.r2?"radial":"linear"),r.coords={x1:i.x1,y1:i.y1,x2:i.x2,y2:i.y2},(i.r1||i.r2)&&(r.coords.r1=i.r1,r.coords.r2=i.r2),r.gradientTransform=i.gradientTransform,e.Gradient.prototype.addColorStop.call(r,i.colorStops),this.set(t,e.Gradient.forObject(this,r))},setPatternFill:function(t){return this.set("fill",new e.Pattern(t))},setShadow:function(t){return this.set("shadow",t?new e.Shadow(t):null)},setColor:function(t){return this.set("fill",t),this},setAngle:function(t){var e=("center"!==this.originX||"center"!==this.originY)&&this.centeredRotation;return e&&this._setOriginToCenter(),this.set("angle",t),e&&this._resetOrigin(),this},centerH:function(){return this.canvas&&this.canvas.centerObjectH(this),this},viewportCenterH:function(){return this.canvas&&this.canvas.viewportCenterObjectH(this),this},centerV:function(){return this.canvas&&this.canvas.centerObjectV(this),this},viewportCenterV:function(){return this.canvas&&this.canvas.viewportCenterObjectV(this),this},center:function(){return this.canvas&&this.canvas.centerObject(this),this},viewportCenter:function(){return this.canvas&&this.canvas.viewportCenterObject(this),this},remove:function(){return this.canvas&&this.canvas.remove(this),this},getLocalPointer:function(t,i){i=i||this.canvas.getPointer(t);var r=new e.Point(i.x,i.y),n=this._getLeftTopCoords();return this.angle&&(r=e.util.rotatePoint(r,n,o(-this.angle))),{x:r.x-n.x,y:r.y-n.y}},_setupCompositeOperation:function(t){this.globalCompositeOperation&&(t.globalCompositeOperation=this.globalCompositeOperation)}}),e.util.createAccessors(e.Object),e.Object.prototype.rotate=e.Object.prototype.setAngle,i(e.Object.prototype,e.Observable),e.Object.NUM_FRACTION_DIGITS=2,e.Object._fromObject=function(t,i,n,s,o){var a=e[t];if(i=r(i,!0),!s){var h=o?new a(i[o],i):new a(i);return n&&n(h),h}e.util.enlivenPatterns([i.fill,i.stroke],function(t){"undefined"!=typeof t[0]&&(i.fill=t[0]),"undefined"!=typeof t[1]&&(i.stroke=t[1]);var e=o?new a(i[o],i):new a(i);n&&n(e)})},e.Object.__uid=0)}("undefined"!=typeof exports?exports:this),function(){var t=fabric.util.degreesToRadians,e={left:-.5,center:0,right:.5},i={top:-.5,center:0,bottom:.5};fabric.util.object.extend(fabric.Object.prototype,{translateToGivenOrigin:function(t,r,n,s,o){var a,h,c,l=t.x,u=t.y;return"string"==typeof r?r=e[r]:r-=.5,"string"==typeof s?s=e[s]:s-=.5,a=s-r,"string"==typeof n?n=i[n]:n-=.5,"string"==typeof o?o=i[o]:o-=.5,h=o-n,(a||h)&&(c=this._getTransformedDimensions(),l=t.x+a*c.x,u=t.y+h*c.y),new fabric.Point(l,u)},translateToCenterPoint:function(e,i,r){var n=this.translateToGivenOrigin(e,i,r,"center","center");return this.angle?fabric.util.rotatePoint(n,e,t(this.angle)):n},translateToOriginPoint:function(e,i,r){var n=this.translateToGivenOrigin(e,"center","center",i,r);return this.angle?fabric.util.rotatePoint(n,e,t(this.angle)):n},getCenterPoint:function(){var t=new fabric.Point(this.left,this.top);
return this.translateToCenterPoint(t,this.originX,this.originY)},getPointByOrigin:function(t,e){var i=this.getCenterPoint();return this.translateToOriginPoint(i,t,e)},toLocalPoint:function(e,i,r){var n,s,o=this.getCenterPoint();return n="undefined"!=typeof i&&"undefined"!=typeof r?this.translateToGivenOrigin(o,"center","center",i,r):new fabric.Point(this.left,this.top),s=new fabric.Point(e.x,e.y),this.angle&&(s=fabric.util.rotatePoint(s,o,-t(this.angle))),s.subtractEquals(n)},setPositionByOrigin:function(t,e,i){var r=this.translateToCenterPoint(t,e,i),n=this.translateToOriginPoint(r,this.originX,this.originY);this.set("left",n.x),this.set("top",n.y)},adjustPosition:function(i){var r,n,s=t(this.angle),o=this.getWidth(),a=Math.cos(s)*o,h=Math.sin(s)*o;r="string"==typeof this.originX?e[this.originX]:this.originX-.5,n="string"==typeof i?e[i]:i-.5,this.left+=a*(n-r),this.top+=h*(n-r),this.setCoords(),this.originX=i},_setOriginToCenter:function(){this._originalOriginX=this.originX,this._originalOriginY=this.originY;var t=this.getCenterPoint();this.originX="center",this.originY="center",this.left=t.x,this.top=t.y},_resetOrigin:function(){var t=this.translateToOriginPoint(this.getCenterPoint(),this._originalOriginX,this._originalOriginY);this.originX=this._originalOriginX,this.originY=this._originalOriginY,this.left=t.x,this.top=t.y,this._originalOriginX=null,this._originalOriginY=null},_getLeftTopCoords:function(){return this.translateToOriginPoint(this.getCenterPoint(),"left","top")},onDeselect:function(){}})}(),function(){function t(t){return[new fabric.Point(t.tl.x,t.tl.y),new fabric.Point(t.tr.x,t.tr.y),new fabric.Point(t.br.x,t.br.y),new fabric.Point(t.bl.x,t.bl.y)]}var e=fabric.util.degreesToRadians,i=fabric.util.multiplyTransformMatrices;fabric.util.object.extend(fabric.Object.prototype,{oCoords:null,aCoords:null,getCoords:function(e,i){this.oCoords||this.setCoords();var r=e?this.aCoords:this.oCoords;return t(i?this.calcCoords(e):r)},intersectsWithRect:function(t,e,i,r){var n=this.getCoords(i,r),s=fabric.Intersection.intersectPolygonRectangle(n,t,e);return"Intersection"===s.status},intersectsWithObject:function(t,e,i){var r=fabric.Intersection.intersectPolygonPolygon(this.getCoords(e,i),t.getCoords(e,i));return"Intersection"===r.status||t.isContainedWithinObject(this,e,i)||this.isContainedWithinObject(t,e,i)},isContainedWithinObject:function(t,e,i){for(var r=this.getCoords(e,i),n=0,s=t._getImageLines(i?t.calcCoords(e):e?t.aCoords:t.oCoords);n<4;n++)if(!t.containsPoint(r[n],s))return!1;return!0},isContainedWithinRect:function(t,e,i,r){var n=this.getBoundingRect(i,r);return n.left>=t.x&&n.left+n.width<=e.x&&n.top>=t.y&&n.top+n.height<=e.y},containsPoint:function(t,e,i,r){var e=e||this._getImageLines(r?this.calcCoords(i):i?this.aCoords:this.oCoords),n=this._findCrossPoints(t,e);return 0!==n&&n%2===1},isOnScreen:function(t){if(!this.canvas)return!1;for(var e,i=this.canvas.vptCoords.tl,r=this.canvas.vptCoords.br,n=this.getCoords(!0,t),s=0;s<4;s++)if(e=n[s],e.x<=r.x&&e.x>=i.x&&e.y<=r.y&&e.y>=i.y)return!0;if(this.intersectsWithRect(i,r,!0))return!0;var o={x:(i.x+r.x)/2,y:(i.y+r.y)/2};return!!this.containsPoint(o,null,!0)},_getImageLines:function(t){return{topline:{o:t.tl,d:t.tr},rightline:{o:t.tr,d:t.br},bottomline:{o:t.br,d:t.bl},leftline:{o:t.bl,d:t.tl}}},_findCrossPoints:function(t,e){var i,r,n,s,o,a,h=0;for(var c in e)if(a=e[c],!(a.o.y<t.y&&a.d.y<t.y||a.o.y>=t.y&&a.d.y>=t.y||(a.o.x===a.d.x&&a.o.x>=t.x?o=a.o.x:(i=0,r=(a.d.y-a.o.y)/(a.d.x-a.o.x),n=t.y-i*t.x,s=a.o.y-r*a.o.x,o=-(n-s)/(i-r)),o>=t.x&&(h+=1),2!==h)))break;return h},getBoundingRectWidth:function(){return this.getBoundingRect().width},getBoundingRectHeight:function(){return this.getBoundingRect().height},getBoundingRect:function(t,e){var i=this.getCoords(t,e);return fabric.util.makeBoundingBoxFromPoints(i)},getWidth:function(){return this._getTransformedDimensions().x},getHeight:function(){return this._getTransformedDimensions().y},_constrainScale:function(t){return Math.abs(t)<this.minScaleLimit?t<0?-this.minScaleLimit:this.minScaleLimit:t},scale:function(t){return t=this._constrainScale(t),t<0&&(this.flipX=!this.flipX,this.flipY=!this.flipY,t*=-1),this.scaleX=t,this.scaleY=t,this.setCoords()},scaleToWidth:function(t){var e=this.getBoundingRect().width/this.getWidth();return this.scale(t/this.width/e)},scaleToHeight:function(t){var e=this.getBoundingRect().height/this.getHeight();return this.scale(t/this.height/e)},calcCoords:function(t){var i=e(this.angle),r=this.getViewportTransform(),n=t?this._getTransformedDimensions():this._calculateCurrentDimensions(),s=n.x,o=n.y,a=Math.sin(i),h=Math.cos(i),c=s>0?Math.atan(o/s):0,l=s/Math.cos(c)/2,u=Math.cos(c+i)*l,f=Math.sin(c+i)*l,d=this.getCenterPoint(),g=t?d:fabric.util.transformPoint(d,r),p=new fabric.Point(g.x-u,g.y-f),v=new fabric.Point(p.x+s*h,p.y+s*a),b=new fabric.Point(p.x-o*a,p.y+o*h),m=new fabric.Point(g.x+u,g.y+f);if(!t)var y=new fabric.Point((p.x+b.x)/2,(p.y+b.y)/2),_=new fabric.Point((v.x+p.x)/2,(v.y+p.y)/2),x=new fabric.Point((m.x+v.x)/2,(m.y+v.y)/2),C=new fabric.Point((m.x+b.x)/2,(m.y+b.y)/2),S=new fabric.Point(_.x+a*this.rotatingPointOffset,_.y-h*this.rotatingPointOffset);var g={tl:p,tr:v,br:m,bl:b};return t||(g.ml=y,g.mt=_,g.mr=x,g.mb=C,g.mtr=S),g},setCoords:function(t,e){return this.oCoords=this.calcCoords(t),e||(this.aCoords=this.calcCoords(!0)),t||this._setCornerCoords&&this._setCornerCoords(),this},_calcRotateMatrix:function(){if(this.angle){var t=e(this.angle),i=Math.cos(t),r=Math.sin(t);return 6.123233995736766e-17!==i&&i!==-1.8369701987210297e-16||(i=0),[i,r,-r,i,0,0]}return fabric.iMatrix.concat()},calcTransformMatrix:function(t){var e=this.getCenterPoint(),r=[1,0,0,1,e.x,e.y],n=this._calcRotateMatrix(),s=this._calcDimensionsTransformMatrix(this.skewX,this.skewY,!0),o=this.group&&!t?this.group.calcTransformMatrix():fabric.iMatrix.concat();return o=i(o,r),o=i(o,n),o=i(o,s)},_calcDimensionsTransformMatrix:function(t,r,n){var s=[1,0,Math.tan(e(t)),1],o=[1,Math.tan(e(r)),0,1],a=this.scaleX*(n&&this.flipX?-1:1),h=this.scaleY*(n&&this.flipY?-1:1),c=[a,0,0,h],l=i(c,s,!0);return i(l,o,!0)},_getNonTransformedDimensions:function(){var t=this.strokeWidth,e=this.width+t,i=this.height+t;return{x:e,y:i}},_getTransformedDimensions:function(t,e){"undefined"==typeof t&&(t=this.skewX),"undefined"==typeof e&&(e=this.skewY);var i,r,n=this._getNonTransformedDimensions(),s=n.x/2,o=n.y/2,a=[{x:-s,y:-o},{x:s,y:-o},{x:-s,y:o},{x:s,y:o}],h=this._calcDimensionsTransformMatrix(t,e,!1);for(i=0;i<a.length;i++)a[i]=fabric.util.transformPoint(a[i],h);return r=fabric.util.makeBoundingBoxFromPoints(a),{x:r.width,y:r.height}},_calculateCurrentDimensions:function(){var t=this.getViewportTransform(),e=this._getTransformedDimensions(),i=fabric.util.transformPoint(e,t,!0);return i.scalarAdd(2*this.padding)}})}(),fabric.util.object.extend(fabric.Object.prototype,{sendToBack:function(){return this.group?fabric.StaticCanvas.prototype.sendToBack.call(this.group,this):this.canvas.sendToBack(this),this},bringToFront:function(){return this.group?fabric.StaticCanvas.prototype.bringToFront.call(this.group,this):this.canvas.bringToFront(this),this},sendBackwards:function(t){return this.group?fabric.StaticCanvas.prototype.sendBackwards.call(this.group,this,t):this.canvas.sendBackwards(this,t),this},bringForward:function(t){return this.group?fabric.StaticCanvas.prototype.bringForward.call(this.group,this,t):this.canvas.bringForward(this,t),this},moveTo:function(t){return this.group?fabric.StaticCanvas.prototype.moveTo.call(this.group,this,t):this.canvas.moveTo(this,t),this}}),function(){function t(t,e){if(e){if(e.toLive)return t+": url(#SVGID_"+e.id+"); ";var i=new fabric.Color(e),r=t+": "+i.toRgb()+"; ",n=i.getAlpha();return 1!==n&&(r+=t+"-opacity: "+n.toString()+"; "),r}return t+": none; "}fabric.util.object.extend(fabric.Object.prototype,{getSvgStyles:function(e){var i=this.fillRule,r=this.strokeWidth?this.strokeWidth:"0",n=this.strokeDashArray?this.strokeDashArray.join(" "):"none",s=this.strokeLineCap?this.strokeLineCap:"butt",o=this.strokeLineJoin?this.strokeLineJoin:"miter",a=this.strokeMiterLimit?this.strokeMiterLimit:"4",h="undefined"!=typeof this.opacity?this.opacity:"1",c=this.visible?"":" visibility: hidden;",l=e?"":this.getSvgFilter(),u=t("fill",this.fill),f=t("stroke",this.stroke);return[f,"stroke-width: ",r,"; ","stroke-dasharray: ",n,"; ","stroke-linecap: ",s,"; ","stroke-linejoin: ",o,"; ","stroke-miterlimit: ",a,"; ",u,"fill-rule: ",i,"; ","opacity: ",h,";",l,c].join("")},getSvgFilter:function(){return this.shadow?"filter: url(#SVGID_"+this.shadow.id+");":""},getSvgId:function(){return this.id?'id="'+this.id+'" ':""},getSvgTransform:function(){if(this.group&&"path-group"===this.group.type)return"";var t=fabric.util.toFixed,e=this.getAngle(),i=this.getSkewX()%360,r=this.getSkewY()%360,n=this.getCenterPoint(),s=fabric.Object.NUM_FRACTION_DIGITS,o="path-group"===this.type?"":"translate("+t(n.x,s)+" "+t(n.y,s)+")",a=0!==e?" rotate("+t(e,s)+")":"",h=1===this.scaleX&&1===this.scaleY?"":" scale("+t(this.scaleX,s)+" "+t(this.scaleY,s)+")",c=0!==i?" skewX("+t(i,s)+")":"",l=0!==r?" skewY("+t(r,s)+")":"",u="path-group"===this.type?this.width:0,f=this.flipX?" matrix(-1 0 0 1 "+u+" 0) ":"",d="path-group"===this.type?this.height:0,g=this.flipY?" matrix(1 0 0 -1 0 "+d+")":"";return[o,a,h,f,g,c,l].join("")},getSvgTransformMatrix:function(){return this.transformMatrix?" matrix("+this.transformMatrix.join(" ")+") ":""},_createBaseSVGMarkup:function(){var t=[];return this.fill&&this.fill.toLive&&t.push(this.fill.toSVG(this,!1)),this.stroke&&this.stroke.toLive&&t.push(this.stroke.toSVG(this,!1)),this.shadow&&t.push(this.shadow.toSVG(this)),t}})}(),function(){function t(t,e,r){var n={},s=!0;r.forEach(function(e){n[e]=t[e]}),i(t[e],n,s)}function e(t,i,r){if(!fabric.isLikelyNode&&t instanceof Element)return t===i;if(t instanceof Array){if(t.length!==i.length)return!1;for(var n=0,s=t.length;n<s;n++)if(t[n]!==i[n])return!1;return!0}if(t&&"object"==typeof t){if(!r&&Object.keys(t).length!==Object.keys(i).length)return!1;for(var o in t)if(!e(t[o],i[o]))return!1;return!0}return t===i}var i=fabric.util.object.extend,r="stateProperties";fabric.util.object.extend(fabric.Object.prototype,{hasStateChanged:function(t){return t=t||r,t="_"+t,!Object.keys(this[t]).length||!e(this[t],this,!0)},saveState:function(e){var i=e&&e.propertySet||r,n="_"+i;return this[n]?(t(this,n,this[i]),e&&e.stateProperties&&t(this,n,e.stateProperties),this):this.setupState(e)},setupState:function(t){t=t||{};var e=t.propertySet||r;return t.propertySet=e,this["_"+e]={},this.saveState(t),this}})}(),function(){var t=fabric.util.degreesToRadians,e=function(){return"undefined"!=typeof G_vmlCanvasManager};fabric.util.object.extend(fabric.Object.prototype,{_controlsVisibility:null,_findTargetCorner:function(t){if(!this.hasControls||!this.active)return!1;var e,i,r=t.x,n=t.y;this.__corner=0;for(var s in this.oCoords)if(this.isControlVisible(s)&&("mtr"!==s||this.hasRotatingPoint)&&(!this.get("lockUniScaling")||"mt"!==s&&"mr"!==s&&"mb"!==s&&"ml"!==s)&&(i=this._getImageLines(this.oCoords[s].corner),e=this._findCrossPoints({x:r,y:n},i),0!==e&&e%2===1))return this.__corner=s,s;return!1},_setCornerCoords:function(){var e,i,r=this.oCoords,n=t(45-this.angle),s=.707106*this.cornerSize,o=s*Math.cos(n),a=s*Math.sin(n);for(var h in r)e=r[h].x,i=r[h].y,r[h].corner={tl:{x:e-a,y:i-o},tr:{x:e+o,y:i-a},bl:{x:e-o,y:i+a},br:{x:e+a,y:i+o}}},drawSelectionBackground:function(e){if(!this.selectionBackgroundColor||this.group||!this.active||this.canvas&&!this.canvas.interactive)return this;e.save();var i=this.getCenterPoint(),r=this._calculateCurrentDimensions(),n=this.canvas.viewportTransform;return e.translate(i.x,i.y),e.scale(1/n[0],1/n[3]),e.rotate(t(this.angle)),e.fillStyle=this.selectionBackgroundColor,e.fillRect(-r.x/2,-r.y/2,r.x,r.y),e.restore(),this},drawBorders:function(t){if(!this.hasBorders)return this;var e=this._calculateCurrentDimensions(),i=1/this.borderScaleFactor,r=e.x+i,n=e.y+i;if(t.save(),t.strokeStyle=this.borderColor,this._setLineDash(t,this.borderDashArray,null),t.strokeRect(-r/2,-n/2,r,n),this.hasRotatingPoint&&this.isControlVisible("mtr")&&!this.get("lockRotation")&&this.hasControls){var s=-n/2;t.beginPath(),t.moveTo(0,s),t.lineTo(0,s-this.rotatingPointOffset),t.closePath(),t.stroke()}return t.restore(),this},drawBordersInGroup:function(t,e){if(!this.hasBorders)return this;var i=this._getNonTransformedDimensions(),r=fabric.util.customTransformMatrix(e.scaleX,e.scaleY,e.skewX),n=fabric.util.transformPoint(i,r),s=1/this.borderScaleFactor,o=n.x+s,a=n.y+s;return t.save(),this._setLineDash(t,this.borderDashArray,null),t.strokeStyle=this.borderColor,t.strokeRect(-o/2,-a/2,o,a),t.restore(),this},drawControls:function(t){if(!this.hasControls)return this;var e=this._calculateCurrentDimensions(),i=e.x,r=e.y,n=this.cornerSize,s=-(i+n)/2,o=-(r+n)/2,a=this.transparentCorners?"stroke":"fill";return t.save(),t.strokeStyle=t.fillStyle=this.cornerColor,this.transparentCorners||(t.strokeStyle=this.cornerStrokeColor),this._setLineDash(t,this.cornerDashArray,null),this._drawControl("tl",t,a,s,o),this._drawControl("tr",t,a,s+i,o),this._drawControl("bl",t,a,s,o+r),this._drawControl("br",t,a,s+i,o+r),this.get("lockUniScaling")||(this._drawControl("mt",t,a,s+i/2,o),this._drawControl("mb",t,a,s+i/2,o+r),this._drawControl("mr",t,a,s+i,o+r/2),this._drawControl("ml",t,a,s,o+r/2)),this.hasRotatingPoint&&this._drawControl("mtr",t,a,s+i/2,o-this.rotatingPointOffset),t.restore(),this},_drawControl:function(t,i,r,n,s){if(this.isControlVisible(t)){var o=this.cornerSize,a=!this.transparentCorners&&this.cornerStrokeColor;switch(this.cornerStyle){case"circle":i.beginPath(),i.arc(n+o/2,s+o/2,o/2,0,2*Math.PI,!1),i[r](),a&&i.stroke();break;default:e()||this.transparentCorners||i.clearRect(n,s,o,o),i[r+"Rect"](n,s,o,o),a&&i.strokeRect(n,s,o,o)}}},isControlVisible:function(t){return this._getControlsVisibility()[t]},setControlVisible:function(t,e){return this._getControlsVisibility()[t]=e,this},setControlsVisibility:function(t){t||(t={});for(var e in t)this.setControlVisible(e,t[e]);return this},_getControlsVisibility:function(){return this._controlsVisibility||(this._controlsVisibility={tl:!0,tr:!0,br:!0,bl:!0,ml:!0,mt:!0,mr:!0,mb:!0,mtr:!0}),this._controlsVisibility}})}(),fabric.util.object.extend(fabric.StaticCanvas.prototype,{FX_DURATION:500,fxCenterObjectH:function(t,e){e=e||{};var i=function(){},r=e.onComplete||i,n=e.onChange||i,s=this;return fabric.util.animate({startValue:t.get("left"),endValue:this.getCenter().left,duration:this.FX_DURATION,onChange:function(e){t.set("left",e),s.renderAll(),n()},onComplete:function(){t.setCoords(),r()}}),this},fxCenterObjectV:function(t,e){e=e||{};var i=function(){},r=e.onComplete||i,n=e.onChange||i,s=this;return fabric.util.animate({startValue:t.get("top"),endValue:this.getCenter().top,duration:this.FX_DURATION,onChange:function(e){t.set("top",e),s.renderAll(),n()},onComplete:function(){t.setCoords(),r()}}),this},fxRemove:function(t,e){e=e||{};var i=function(){},r=e.onComplete||i,n=e.onChange||i,s=this;return fabric.util.animate({startValue:t.get("opacity"),endValue:0,duration:this.FX_DURATION,onStart:function(){t.set("active",!1)},onChange:function(e){t.set("opacity",e),s.renderAll(),n()},onComplete:function(){s.remove(t),r()}}),this}}),fabric.util.object.extend(fabric.Object.prototype,{animate:function(){if(arguments[0]&&"object"==typeof arguments[0]){var t,e,i=[];for(t in arguments[0])i.push(t);for(var r=0,n=i.length;r<n;r++)t=i[r],e=r!==n-1,this._animate(t,arguments[0][t],arguments[1],e)}else this._animate.apply(this,arguments);return this},_animate:function(t,e,i,r){var n,s=this;e=e.toString(),i=i?fabric.util.object.clone(i):{},~t.indexOf(".")&&(n=t.split("."));var o=n?this.get(n[0])[n[1]]:this.get(t);"from"in i||(i.from=o),e=~e.indexOf("=")?o+parseFloat(e.replace("=","")):parseFloat(e),fabric.util.animate({startValue:i.from,endValue:e,byValue:i.by,easing:i.easing,duration:i.duration,abort:i.abort&&function(){return i.abort.call(s)},onChange:function(e){n?s[n[0]][n[1]]=e:s.set(t,e),r||i.onChange&&i.onChange()},onComplete:function(){r||(s.setCoords(),i.onComplete&&i.onComplete())}})}}),function(t){"use strict";function e(t,e){var i=t.origin,r=t.axis1,n=t.axis2,s=t.dimension,o=e.nearest,a=e.center,h=e.farthest;return function(){switch(this.get(i)){case o:return Math.min(this.get(r),this.get(n));case a:return Math.min(this.get(r),this.get(n))+.5*this.get(s);case h:return Math.max(this.get(r),this.get(n))}}}var i=t.fabric||(t.fabric={}),r=i.util.object.extend,n=i.util.object.clone,s={x1:1,x2:1,y1:1,y2:1},o=i.StaticCanvas.supports("setLineDash");if(i.Line)return void i.warn("fabric.Line is already defined");var a=i.Object.prototype.cacheProperties.concat();a.push("x1","x2","y1","y2"),i.Line=i.util.createClass(i.Object,{type:"line",x1:0,y1:0,x2:0,y2:0,cacheProperties:a,initialize:function(t,e){t||(t=[0,0,0,0]),this.callSuper("initialize",e),this.set("x1",t[0]),this.set("y1",t[1]),this.set("x2",t[2]),this.set("y2",t[3]),this._setWidthHeight(e)},_setWidthHeight:function(t){t||(t={}),this.width=Math.abs(this.x2-this.x1),this.height=Math.abs(this.y2-this.y1),this.left="left"in t?t.left:this._getLeftToOriginX(),this.top="top"in t?t.top:this._getTopToOriginY()},_set:function(t,e){return this.callSuper("_set",t,e),"undefined"!=typeof s[t]&&this._setWidthHeight(),this},_getLeftToOriginX:e({origin:"originX",axis1:"x1",axis2:"x2",dimension:"width"},{nearest:"left",center:"center",farthest:"right"}),_getTopToOriginY:e({origin:"originY",axis1:"y1",axis2:"y2",dimension:"height"},{nearest:"top",center:"center",farthest:"bottom"}),_render:function(t,e){if(t.beginPath(),e){var i=this.getCenterPoint(),r=this.strokeWidth/2;t.translate(i.x-("butt"===this.strokeLineCap&&0===this.height?0:r),i.y-("butt"===this.strokeLineCap&&0===this.width?0:r))}if(!this.strokeDashArray||this.strokeDashArray&&o){var n=this.calcLinePoints();t.moveTo(n.x1,n.y1),t.lineTo(n.x2,n.y2)}t.lineWidth=this.strokeWidth;var s=t.strokeStyle;t.strokeStyle=this.stroke||t.fillStyle,this.stroke&&this._renderStroke(t),t.strokeStyle=s},_renderDashedStroke:function(t){var e=this.calcLinePoints();t.beginPath(),i.util.drawDashedLine(t,e.x1,e.y1,e.x2,e.y2,this.strokeDashArray),t.closePath()},toObject:function(t){return r(this.callSuper("toObject",t),this.calcLinePoints())},_getNonTransformedDimensions:function(){var t=this.callSuper("_getNonTransformedDimensions");return"butt"===this.strokeLineCap&&(0===this.width&&(t.y-=this.strokeWidth),0===this.height&&(t.x-=this.strokeWidth)),t},calcLinePoints:function(){var t=this.x1<=this.x2?-1:1,e=this.y1<=this.y2?-1:1,i=t*this.width*.5,r=e*this.height*.5,n=t*this.width*-.5,s=e*this.height*-.5;return{x1:i,x2:n,y1:r,y2:s}},toSVG:function(t){var e=this._createBaseSVGMarkup(),i={x1:this.x1,x2:this.x2,y1:this.y1,y2:this.y2};return this.group&&"path-group"===this.group.type||(i=this.calcLinePoints()),e.push("<line ",this.getSvgId(),'x1="',i.x1,'" y1="',i.y1,'" x2="',i.x2,'" y2="',i.y2,'" style="',this.getSvgStyles(),'" transform="',this.getSvgTransform(),this.getSvgTransformMatrix(),'"/>\n'),t?t(e.join("")):e.join("")}}),i.Line.ATTRIBUTE_NAMES=i.SHARED_ATTRIBUTES.concat("x1 y1 x2 y2".split(" ")),i.Line.fromElement=function(t,e){e=e||{};var n=i.parseAttributes(t,i.Line.ATTRIBUTE_NAMES),s=[n.x1||0,n.y1||0,n.x2||0,n.y2||0];return e.originX="left",e.originY="top",new i.Line(s,r(n,e))},i.Line.fromObject=function(t,e,r){function s(t){delete t.points,e&&e(t)}var o=n(t,!0);o.points=[t.x1,t.y1,t.x2,t.y2];var a=i.Object._fromObject("Line",o,s,r,"points");return a&&delete a.points,a}}("undefined"!=typeof exports?exports:this),function(t){"use strict";function e(t){return"radius"in t&&t.radius>=0}var i=t.fabric||(t.fabric={}),r=Math.PI,n=i.util.object.extend;if(i.Circle)return void i.warn("fabric.Circle is already defined.");var s=i.Object.prototype.cacheProperties.concat();s.push("radius"),i.Circle=i.util.createClass(i.Object,{type:"circle",radius:0,startAngle:0,endAngle:2*r,cacheProperties:s,initialize:function(t){this.callSuper("initialize",t),this.set("radius",t&&t.radius||0)},_set:function(t,e){return this.callSuper("_set",t,e),"radius"===t&&this.setRadius(e),this},toObject:function(t){return this.callSuper("toObject",["radius","startAngle","endAngle"].concat(t))},toSVG:function(t){var e=this._createBaseSVGMarkup(),i=0,n=0,s=(this.endAngle-this.startAngle)%(2*r);if(0===s)this.group&&"path-group"===this.group.type&&(i=this.left+this.radius,n=this.top+this.radius),e.push("<circle ",this.getSvgId(),'cx="'+i+'" cy="'+n+'" ','r="',this.radius,'" style="',this.getSvgStyles(),'" transform="',this.getSvgTransform()," ",this.getSvgTransformMatrix(),'"/>\n');else{var o=Math.cos(this.startAngle)*this.radius,a=Math.sin(this.startAngle)*this.radius,h=Math.cos(this.endAngle)*this.radius,c=Math.sin(this.endAngle)*this.radius,l=s>r?"1":"0";e.push('<path d="M '+o+" "+a," A "+this.radius+" "+this.radius," 0 ",+l+" 1"," "+h+" "+c,'" style="',this.getSvgStyles(),'" transform="',this.getSvgTransform()," ",this.getSvgTransformMatrix(),'"/>\n')}return t?t(e.join("")):e.join("")},_render:function(t,e){t.beginPath(),t.arc(e?this.left+this.radius:0,e?this.top+this.radius:0,this.radius,this.startAngle,this.endAngle,!1),this._renderFill(t),this._renderStroke(t)},getRadiusX:function(){return this.get("radius")*this.get("scaleX")},getRadiusY:function(){return this.get("radius")*this.get("scaleY")},setRadius:function(t){return this.radius=t,this.set("width",2*t).set("height",2*t)}}),i.Circle.ATTRIBUTE_NAMES=i.SHARED_ATTRIBUTES.concat("cx cy r".split(" ")),i.Circle.fromElement=function(t,r){r||(r={});var s=i.parseAttributes(t,i.Circle.ATTRIBUTE_NAMES);if(!e(s))throw new Error("value of `r` attribute is required and can not be negative");s.left=s.left||0,s.top=s.top||0;var o=new i.Circle(n(s,r));return o.left-=o.radius,o.top-=o.radius,o},i.Circle.fromObject=function(t,e,r){return i.Object._fromObject("Circle",t,e,r)}}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={});return e.Triangle?void e.warn("fabric.Triangle is already defined"):(e.Triangle=e.util.createClass(e.Object,{type:"triangle",initialize:function(t){this.callSuper("initialize",t),this.set("width",t&&t.width||100).set("height",t&&t.height||100)},_render:function(t){var e=this.width/2,i=this.height/2;t.beginPath(),t.moveTo(-e,i),t.lineTo(0,-i),t.lineTo(e,i),t.closePath(),this._renderFill(t),this._renderStroke(t)},_renderDashedStroke:function(t){var i=this.width/2,r=this.height/2;t.beginPath(),e.util.drawDashedLine(t,-i,r,0,-r,this.strokeDashArray),e.util.drawDashedLine(t,0,-r,i,r,this.strokeDashArray),e.util.drawDashedLine(t,i,r,-i,r,this.strokeDashArray),t.closePath()},toSVG:function(t){var e=this._createBaseSVGMarkup(),i=this.width/2,r=this.height/2,n=[-i+" "+r,"0 "+-r,i+" "+r].join(",");return e.push("<polygon ",this.getSvgId(),'points="',n,'" style="',this.getSvgStyles(),'" transform="',this.getSvgTransform(),'"/>'),t?t(e.join("")):e.join("")}}),void(e.Triangle.fromObject=function(t,i,r){return e.Object._fromObject("Triangle",t,i,r)}))}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=2*Math.PI,r=e.util.object.extend;if(e.Ellipse)return void e.warn("fabric.Ellipse is already defined.");var n=e.Object.prototype.cacheProperties.concat();n.push("rx","ry"),e.Ellipse=e.util.createClass(e.Object,{type:"ellipse",rx:0,ry:0,cacheProperties:n,initialize:function(t){this.callSuper("initialize",t),this.set("rx",t&&t.rx||0),this.set("ry",t&&t.ry||0)},_set:function(t,e){switch(this.callSuper("_set",t,e),t){case"rx":this.rx=e,this.set("width",2*e);break;case"ry":this.ry=e,this.set("height",2*e)}return this},getRx:function(){return this.get("rx")*this.get("scaleX")},getRy:function(){return this.get("ry")*this.get("scaleY")},toObject:function(t){return this.callSuper("toObject",["rx","ry"].concat(t))},toSVG:function(t){var e=this._createBaseSVGMarkup(),i=0,r=0;return this.group&&"path-group"===this.group.type&&(i=this.left+this.rx,r=this.top+this.ry),e.push("<ellipse ",this.getSvgId(),'cx="',i,'" cy="',r,'" ','rx="',this.rx,'" ry="',this.ry,'" style="',this.getSvgStyles(),'" transform="',this.getSvgTransform(),this.getSvgTransformMatrix(),'"/>\n'),t?t(e.join("")):e.join("")},_render:function(t,e){t.beginPath(),t.save(),t.transform(1,0,0,this.ry/this.rx,0,0),t.arc(e?this.left+this.rx:0,e?(this.top+this.ry)*this.rx/this.ry:0,this.rx,0,i,!1),t.restore(),this._renderFill(t),this._renderStroke(t)}}),e.Ellipse.ATTRIBUTE_NAMES=e.SHARED_ATTRIBUTES.concat("cx cy rx ry".split(" ")),e.Ellipse.fromElement=function(t,i){i||(i={});var n=e.parseAttributes(t,e.Ellipse.ATTRIBUTE_NAMES);n.left=n.left||0,n.top=n.top||0;var s=new e.Ellipse(r(n,i));return s.top-=s.ry,s.left-=s.rx,s},e.Ellipse.fromObject=function(t,i,r){return e.Object._fromObject("Ellipse",t,i,r)}}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.util.object.extend;if(e.Rect)return void e.warn("fabric.Rect is already defined");var r=e.Object.prototype.stateProperties.concat();r.push("rx","ry");var n=e.Object.prototype.cacheProperties.concat();n.push("rx","ry"),e.Rect=e.util.createClass(e.Object,{stateProperties:r,type:"rect",rx:0,ry:0,cacheProperties:n,initialize:function(t){this.callSuper("initialize",t),this._initRxRy()},_initRxRy:function(){this.rx&&!this.ry?this.ry=this.rx:this.ry&&!this.rx&&(this.rx=this.ry)},_render:function(t,e){if(1===this.width&&1===this.height)return void t.fillRect(-.5,-.5,1,1);var i=this.rx?Math.min(this.rx,this.width/2):0,r=this.ry?Math.min(this.ry,this.height/2):0,n=this.width,s=this.height,o=e?this.left:-this.width/2,a=e?this.top:-this.height/2,h=0!==i||0!==r,c=.4477152502;t.beginPath(),t.moveTo(o+i,a),t.lineTo(o+n-i,a),h&&t.bezierCurveTo(o+n-c*i,a,o+n,a+c*r,o+n,a+r),t.lineTo(o+n,a+s-r),h&&t.bezierCurveTo(o+n,a+s-c*r,o+n-c*i,a+s,o+n-i,a+s),t.lineTo(o+i,a+s),h&&t.bezierCurveTo(o+c*i,a+s,o,a+s-c*r,o,a+s-r),t.lineTo(o,a+r),h&&t.bezierCurveTo(o,a+c*r,o+c*i,a,o+i,a),t.closePath(),this._renderFill(t),this._renderStroke(t)},_renderDashedStroke:function(t){var i=-this.width/2,r=-this.height/2,n=this.width,s=this.height;t.beginPath(),e.util.drawDashedLine(t,i,r,i+n,r,this.strokeDashArray),e.util.drawDashedLine(t,i+n,r,i+n,r+s,this.strokeDashArray),e.util.drawDashedLine(t,i+n,r+s,i,r+s,this.strokeDashArray),e.util.drawDashedLine(t,i,r+s,i,r,this.strokeDashArray),t.closePath()},toObject:function(t){return this.callSuper("toObject",["rx","ry"].concat(t))},toSVG:function(t){var e=this._createBaseSVGMarkup(),i=this.left,r=this.top;return this.group&&"path-group"===this.group.type||(i=-this.width/2,r=-this.height/2),e.push("<rect ",this.getSvgId(),'x="',i,'" y="',r,'" rx="',this.get("rx"),'" ry="',this.get("ry"),'" width="',this.width,'" height="',this.height,'" style="',this.getSvgStyles(),'" transform="',this.getSvgTransform(),this.getSvgTransformMatrix(),'"/>\n'),t?t(e.join("")):e.join("")}}),e.Rect.ATTRIBUTE_NAMES=e.SHARED_ATTRIBUTES.concat("x y rx ry width height".split(" ")),e.Rect.fromElement=function(t,r){if(!t)return null;r=r||{};var n=e.parseAttributes(t,e.Rect.ATTRIBUTE_NAMES);n.left=n.left||0,n.top=n.top||0;var s=new e.Rect(i(r?e.util.object.clone(r):{},n));return s.visible=s.visible&&s.width>0&&s.height>0,s},e.Rect.fromObject=function(t,i,r){return e.Object._fromObject("Rect",t,i,r)}}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.util.object.extend,r=e.util.array.min,n=e.util.array.max,s=e.util.toFixed,o=e.Object.NUM_FRACTION_DIGITS;if(e.Polyline)return void e.warn("fabric.Polyline is already defined");var a=e.Object.prototype.cacheProperties.concat();a.push("points"),e.Polyline=e.util.createClass(e.Object,{type:"polyline",points:null,minX:0,minY:0,cacheProperties:a,initialize:function(t,e){e=e||{},this.points=t||[],this.callSuper("initialize",e),this._calcDimensions(),"top"in e||(this.top=this.minY),"left"in e||(this.left=this.minX),this.pathOffset={x:this.minX+this.width/2,y:this.minY+this.height/2}},_calcDimensions:function(){var t=this.points,e=r(t,"x"),i=r(t,"y"),s=n(t,"x"),o=n(t,"y");this.width=s-e||0,this.height=o-i||0,this.minX=e||0,this.minY=i||0},toObject:function(t){return i(this.callSuper("toObject",t),{points:this.points.concat()})},toSVG:function(t){var e,i,r=[],n=this._createBaseSVGMarkup();this.group&&"path-group"===this.group.type||(e=this.pathOffset.x,i=this.pathOffset.y);for(var a=0,h=this.points.length;a<h;a++)r.push(s(this.points[a].x-e,o),",",s(this.points[a].y-i,o)," ");return n.push("<",this.type," ",this.getSvgId(),'points="',r.join(""),'" style="',this.getSvgStyles(),'" transform="',this.getSvgTransform()," ",this.getSvgTransformMatrix(),'"/>\n'),t?t(n.join("")):n.join("")},commonRender:function(t,e){var i,r=this.points.length,n=e?0:this.pathOffset.x,s=e?0:this.pathOffset.y;if(!r||isNaN(this.points[r-1].y))return!1;t.beginPath(),t.moveTo(this.points[0].x-n,this.points[0].y-s);for(var o=0;o<r;o++)i=this.points[o],t.lineTo(i.x-n,i.y-s);return!0},_render:function(t,e){this.commonRender(t,e)&&(this._renderFill(t),this._renderStroke(t))},_renderDashedStroke:function(t){var i,r;t.beginPath();for(var n=0,s=this.points.length;n<s;n++)i=this.points[n],r=this.points[n+1]||i,e.util.drawDashedLine(t,i.x,i.y,r.x,r.y,this.strokeDashArray)},complexity:function(){return this.get("points").length}}),e.Polyline.ATTRIBUTE_NAMES=e.SHARED_ATTRIBUTES.concat(),e.Polyline.fromElement=function(t,i){if(!t)return null;i||(i={});var r=e.parsePointsAttribute(t.getAttribute("points")),n=e.parseAttributes(t,e.Polyline.ATTRIBUTE_NAMES);return new e.Polyline(r,e.util.object.extend(n,i))},e.Polyline.fromObject=function(t,i,r){return e.Object._fromObject("Polyline",t,i,r,"points")}}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.util.object.extend;return e.Polygon?void e.warn("fabric.Polygon is already defined"):(e.Polygon=e.util.createClass(e.Polyline,{type:"polygon",_render:function(t,e){this.commonRender(t,e)&&(t.closePath(),this._renderFill(t),this._renderStroke(t))},_renderDashedStroke:function(t){this.callSuper("_renderDashedStroke",t),t.closePath()}}),e.Polygon.ATTRIBUTE_NAMES=e.SHARED_ATTRIBUTES.concat(),e.Polygon.fromElement=function(t,r){if(!t)return null;r||(r={});var n=e.parsePointsAttribute(t.getAttribute("points")),s=e.parseAttributes(t,e.Polygon.ATTRIBUTE_NAMES);return new e.Polygon(n,i(s,r))},void(e.Polygon.fromObject=function(t,i,r){return e.Object._fromObject("Polygon",t,i,r,"points")}))}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.util.array.min,r=e.util.array.max,n=e.util.object.extend,s=Object.prototype.toString,o=e.util.drawArc,a={m:2,l:2,h:1,v:1,c:6,s:4,q:4,t:2,a:7},h={m:"l",M:"L"};if(e.Path)return void e.warn("fabric.Path is already defined");var c=e.Object.prototype.cacheProperties.concat();c.push("path"),e.Path=e.util.createClass(e.Object,{type:"path",path:null,minX:0,minY:0,cacheProperties:c,initialize:function(t,e){e=e||{},e&&this.setOptions(e),t||(t=[]);var i="[object Array]"===s.call(t);this.path=i?t:t.match&&t.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi),this.path&&(i||(this.path=this._parsePath()),this._setPositionDimensions(e),this.objectCaching&&this._createCacheCanvas())},_setPositionDimensions:function(t){var e=this._parseDimensions();this.minX=e.left,this.minY=e.top,this.width=e.width,this.height=e.height,"undefined"==typeof t.left&&(this.left=e.left+("center"===this.originX?this.width/2:"right"===this.originX?this.width:0)),"undefined"==typeof t.top&&(this.top=e.top+("center"===this.originY?this.height/2:"bottom"===this.originY?this.height:0)),this.pathOffset=this.pathOffset||{x:this.minX+this.width/2,y:this.minY+this.height/2}},_renderPathCommands:function(t){var e,i,r,n=null,s=0,a=0,h=0,c=0,l=0,u=0,f=-this.pathOffset.x,d=-this.pathOffset.y;this.group&&"path-group"===this.group.type&&(f=0,
d=0),t.beginPath();for(var g=0,p=this.path.length;g<p;++g){switch(e=this.path[g],e[0]){case"l":h+=e[1],c+=e[2],t.lineTo(h+f,c+d);break;case"L":h=e[1],c=e[2],t.lineTo(h+f,c+d);break;case"h":h+=e[1],t.lineTo(h+f,c+d);break;case"H":h=e[1],t.lineTo(h+f,c+d);break;case"v":c+=e[1],t.lineTo(h+f,c+d);break;case"V":c=e[1],t.lineTo(h+f,c+d);break;case"m":h+=e[1],c+=e[2],s=h,a=c,t.moveTo(h+f,c+d);break;case"M":h=e[1],c=e[2],s=h,a=c,t.moveTo(h+f,c+d);break;case"c":i=h+e[5],r=c+e[6],l=h+e[3],u=c+e[4],t.bezierCurveTo(h+e[1]+f,c+e[2]+d,l+f,u+d,i+f,r+d),h=i,c=r;break;case"C":h=e[5],c=e[6],l=e[3],u=e[4],t.bezierCurveTo(e[1]+f,e[2]+d,l+f,u+d,h+f,c+d);break;case"s":i=h+e[3],r=c+e[4],null===n[0].match(/[CcSs]/)?(l=h,u=c):(l=2*h-l,u=2*c-u),t.bezierCurveTo(l+f,u+d,h+e[1]+f,c+e[2]+d,i+f,r+d),l=h+e[1],u=c+e[2],h=i,c=r;break;case"S":i=e[3],r=e[4],null===n[0].match(/[CcSs]/)?(l=h,u=c):(l=2*h-l,u=2*c-u),t.bezierCurveTo(l+f,u+d,e[1]+f,e[2]+d,i+f,r+d),h=i,c=r,l=e[1],u=e[2];break;case"q":i=h+e[3],r=c+e[4],l=h+e[1],u=c+e[2],t.quadraticCurveTo(l+f,u+d,i+f,r+d),h=i,c=r;break;case"Q":i=e[3],r=e[4],t.quadraticCurveTo(e[1]+f,e[2]+d,i+f,r+d),h=i,c=r,l=e[1],u=e[2];break;case"t":i=h+e[1],r=c+e[2],null===n[0].match(/[QqTt]/)?(l=h,u=c):(l=2*h-l,u=2*c-u),t.quadraticCurveTo(l+f,u+d,i+f,r+d),h=i,c=r;break;case"T":i=e[1],r=e[2],null===n[0].match(/[QqTt]/)?(l=h,u=c):(l=2*h-l,u=2*c-u),t.quadraticCurveTo(l+f,u+d,i+f,r+d),h=i,c=r;break;case"a":o(t,h+f,c+d,[e[1],e[2],e[3],e[4],e[5],e[6]+h+f,e[7]+c+d]),h+=e[6],c+=e[7];break;case"A":o(t,h+f,c+d,[e[1],e[2],e[3],e[4],e[5],e[6]+f,e[7]+d]),h=e[6],c=e[7];break;case"z":case"Z":h=s,c=a,t.closePath()}n=e}},_render:function(t){this._renderPathCommands(t),this._renderFill(t),this._renderStroke(t)},toString:function(){return"#<fabric.Path ("+this.complexity()+'): { "top": '+this.top+', "left": '+this.left+" }>"},toObject:function(t){var e=n(this.callSuper("toObject",["sourcePath","pathOffset"].concat(t)),{path:this.path.map(function(t){return t.slice()}),top:this.top,left:this.left});return e},toDatalessObject:function(t){var e=this.toObject(t);return this.sourcePath&&(e.path=this.sourcePath),delete e.sourcePath,e},toSVG:function(t){for(var e=[],i=this._createBaseSVGMarkup(),r="",n=0,s=this.path.length;n<s;n++)e.push(this.path[n].join(" "));var o=e.join(" ");return this.group&&"path-group"===this.group.type||(r=" translate("+-this.pathOffset.x+", "+-this.pathOffset.y+") "),i.push("<path ",this.getSvgId(),'d="',o,'" style="',this.getSvgStyles(),'" transform="',this.getSvgTransform(),r,this.getSvgTransformMatrix(),'" stroke-linecap="round" ',"/>\n"),t?t(i.join("")):i.join("")},complexity:function(){return this.path.length},_parsePath:function(){for(var t,e,i,r,n,s=[],o=[],c=/([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/gi,l=0,u=this.path.length;l<u;l++){for(t=this.path[l],r=t.slice(1).trim(),o.length=0;i=c.exec(r);)o.push(i[0]);n=[t.charAt(0)];for(var f=0,d=o.length;f<d;f++)e=parseFloat(o[f]),isNaN(e)||n.push(e);var g=n[0],p=a[g.toLowerCase()],v=h[g]||g;if(n.length-1>p)for(var b=1,m=n.length;b<m;b+=p)s.push([g].concat(n.slice(b,b+p))),g=v;else s.push(n)}return s},_parseDimensions:function(){for(var t,n,s,o,a=[],h=[],c=null,l=0,u=0,f=0,d=0,g=0,p=0,v=0,b=this.path.length;v<b;++v){switch(t=this.path[v],t[0]){case"l":f+=t[1],d+=t[2],o=[];break;case"L":f=t[1],d=t[2],o=[];break;case"h":f+=t[1],o=[];break;case"H":f=t[1],o=[];break;case"v":d+=t[1],o=[];break;case"V":d=t[1],o=[];break;case"m":f+=t[1],d+=t[2],l=f,u=d,o=[];break;case"M":f=t[1],d=t[2],l=f,u=d,o=[];break;case"c":n=f+t[5],s=d+t[6],g=f+t[3],p=d+t[4],o=e.util.getBoundsOfCurve(f,d,f+t[1],d+t[2],g,p,n,s),f=n,d=s;break;case"C":g=t[3],p=t[4],o=e.util.getBoundsOfCurve(f,d,t[1],t[2],g,p,t[5],t[6]),f=t[5],d=t[6];break;case"s":n=f+t[3],s=d+t[4],null===c[0].match(/[CcSs]/)?(g=f,p=d):(g=2*f-g,p=2*d-p),o=e.util.getBoundsOfCurve(f,d,g,p,f+t[1],d+t[2],n,s),g=f+t[1],p=d+t[2],f=n,d=s;break;case"S":n=t[3],s=t[4],null===c[0].match(/[CcSs]/)?(g=f,p=d):(g=2*f-g,p=2*d-p),o=e.util.getBoundsOfCurve(f,d,g,p,t[1],t[2],n,s),f=n,d=s,g=t[1],p=t[2];break;case"q":n=f+t[3],s=d+t[4],g=f+t[1],p=d+t[2],o=e.util.getBoundsOfCurve(f,d,g,p,g,p,n,s),f=n,d=s;break;case"Q":g=t[1],p=t[2],o=e.util.getBoundsOfCurve(f,d,g,p,g,p,t[3],t[4]),f=t[3],d=t[4];break;case"t":n=f+t[1],s=d+t[2],null===c[0].match(/[QqTt]/)?(g=f,p=d):(g=2*f-g,p=2*d-p),o=e.util.getBoundsOfCurve(f,d,g,p,g,p,n,s),f=n,d=s;break;case"T":n=t[1],s=t[2],null===c[0].match(/[QqTt]/)?(g=f,p=d):(g=2*f-g,p=2*d-p),o=e.util.getBoundsOfCurve(f,d,g,p,g,p,n,s),f=n,d=s;break;case"a":o=e.util.getBoundsOfArc(f,d,t[1],t[2],t[3],t[4],t[5],t[6]+f,t[7]+d),f+=t[6],d+=t[7];break;case"A":o=e.util.getBoundsOfArc(f,d,t[1],t[2],t[3],t[4],t[5],t[6],t[7]),f=t[6],d=t[7];break;case"z":case"Z":f=l,d=u}c=t,o.forEach(function(t){a.push(t.x),h.push(t.y)}),a.push(f),h.push(d)}var m=i(a)||0,y=i(h)||0,_=r(a)||0,x=r(h)||0,C=_-m,S=x-y,w={left:m,top:y,width:C,height:S};return w}}),e.Path.fromObject=function(t,i,r){var n;return"string"!=typeof t.path?e.Object._fromObject("Path",t,i,r,"path"):void e.loadSVGFromURL(t.path,function(r){var s=t.path;n=r[0],delete t.path,e.util.object.extend(n,t),n.setSourcePath(s),i&&i(n)})},e.Path.ATTRIBUTE_NAMES=e.SHARED_ATTRIBUTES.concat(["d"]),e.Path.fromElement=function(t,i,r){var s=e.parseAttributes(t,e.Path.ATTRIBUTE_NAMES);i&&i(new e.Path(s.d,n(s,r)))},e.Path.async=!0}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.util.object.extend;return e.PathGroup?void e.warn("fabric.PathGroup is already defined"):(e.PathGroup=e.util.createClass(e.Object,{type:"path-group",fill:"",initialize:function(t,e){e=e||{},this.paths=t||[];for(var i=this.paths.length;i--;)this.paths[i].group=this;e.toBeParsed&&(this.parseDimensionsFromPaths(e),delete e.toBeParsed),this.setOptions(e),this.setCoords(),this.objectCaching&&this._createCacheCanvas()},parseDimensionsFromPaths:function(t){for(var i,r,n,s,o,a,h=[],c=[],l=this.paths.length;l--;){n=this.paths[l],s=n.height+n.strokeWidth,o=n.width+n.strokeWidth,i=[{x:n.left,y:n.top},{x:n.left+o,y:n.top},{x:n.left,y:n.top+s},{x:n.left+o,y:n.top+s}],a=this.paths[l].transformMatrix;for(var u=0;u<i.length;u++)r=i[u],a&&(r=e.util.transformPoint(r,a,!1)),h.push(r.x),c.push(r.y)}t.width=Math.max.apply(null,h),t.height=Math.max.apply(null,c)},drawObject:function(t){t.save(),t.translate(-this.width/2,-this.height/2);for(var e=0,i=this.paths.length;e<i;++e)this.paths[e].render(t,!0);t.restore()},shouldCache:function(){var t=this.objectCaching&&(!this.group||this.needsItsOwnCache||!this.group.isCaching());if(this.caching=t,t)for(var e=0,i=this.paths.length;e<i;e++)if(this.paths[e].willDrawShadow())return this.caching=!1,!1;return t},willDrawShadow:function(){if(this.shadow)return!0;for(var t=0,e=this.paths.length;t<e;t++)if(this.paths[t].willDrawShadow())return!0;return!1},isCaching:function(){return this.caching||this.group&&this.group.isCaching()},isCacheDirty:function(){if(this.callSuper("isCacheDirty"))return!0;if(!this.statefullCache)return!1;for(var t=0,e=this.paths.length;t<e;t++)if(this.paths[t].isCacheDirty(!0)){var i=this._getNonTransformedDimensions();return this._cacheContext.clearRect(-i.x/2,-i.y/2,i.x,i.y),!0}return!1},_set:function(t,e){if("fill"===t&&e&&this.isSameColor())for(var i=this.paths.length;i--;)this.paths[i]._set(t,e);return this.callSuper("_set",t,e)},toObject:function(t){var e=this.paths.map(function(e){var i=e.includeDefaultValues;e.includeDefaultValues=e.group.includeDefaultValues;var r=e.toObject(t);return e.includeDefaultValues=i,r}),r=i(this.callSuper("toObject",["sourcePath"].concat(t)),{paths:e});return r},toDatalessObject:function(t){var e=this.toObject(t);return this.sourcePath&&(e.paths=this.sourcePath),e},toSVG:function(t){var e=this.getObjects(),i=this.getPointByOrigin("left","top"),r="translate("+i.x+" "+i.y+")",n=this._createBaseSVGMarkup();n.push("<g ",this.getSvgId(),'style="',this.getSvgStyles(),'" ','transform="',this.getSvgTransformMatrix(),r,this.getSvgTransform(),'" ',">\n");for(var s=0,o=e.length;s<o;s++)n.push("\t",e[s].toSVG(t));return n.push("</g>\n"),t?t(n.join("")):n.join("")},toString:function(){return"#<fabric.PathGroup ("+this.complexity()+"): { top: "+this.top+", left: "+this.left+" }>"},isSameColor:function(){var t=this.getObjects()[0].get("fill")||"";return"string"==typeof t&&(t=t.toLowerCase(),this.getObjects().every(function(e){var i=e.get("fill")||"";return"string"==typeof i&&i.toLowerCase()===t}))},complexity:function(){return this.paths.reduce(function(t,e){return t+(e&&e.complexity?e.complexity():0)},0)},getObjects:function(){return this.paths}}),e.PathGroup.fromObject=function(t,i){var r=t.paths;delete t.paths,"string"==typeof r?e.loadSVGFromURL(r,function(n){var s=r,o=e.util.groupSVGElements(n,t,s);t.paths=r,i(o)}):e.util.enlivenObjects(r,function(n){var s=new e.PathGroup(n,t);t.paths=r,i(s)})},void(e.PathGroup.async=!0))}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.util.object.extend,r=e.util.array.min,n=e.util.array.max;if(!e.Group){var s={lockMovementX:!0,lockMovementY:!0,lockRotation:!0,lockScalingX:!0,lockScalingY:!0,lockUniScaling:!0};e.Group=e.util.createClass(e.Object,e.Collection,{type:"group",strokeWidth:0,subTargetCheck:!1,initialize:function(t,e,i){e=e||{},this._objects=[],i&&this.callSuper("initialize",e),this._objects=t||[];for(var r=this._objects.length;r--;)this._objects[r].group=this;e.originX&&(this.originX=e.originX),e.originY&&(this.originY=e.originY),i?this._updateObjectsCoords(!0):(this._calcBounds(),this._updateObjectsCoords(),this.callSuper("initialize",e)),this.setCoords(),this.saveCoords()},_updateObjectsCoords:function(t){for(var e=this.getCenterPoint(),i=this._objects.length;i--;)this._updateObjectCoords(this._objects[i],e,t)},_updateObjectCoords:function(t,e,i){if(t.__origHasControls=t.hasControls,t.hasControls=!1,!i){var r=t.getLeft(),n=t.getTop(),s=!0,o=!0;t.set({left:r-e.x,top:n-e.y}),t.setCoords(s,o)}},toString:function(){return"#<fabric.Group: ("+this.complexity()+")>"},addWithUpdate:function(t){return this._restoreObjectsState(),e.util.resetObjectTransform(this),t&&(this._objects.push(t),t.group=this,t._set("canvas",this.canvas)),this.forEachObject(this._setObjectActive,this),this._calcBounds(),this._updateObjectsCoords(),this.dirty=!0,this},_setObjectActive:function(t){t.set("active",!0),t.group=this},removeWithUpdate:function(t){return this._restoreObjectsState(),e.util.resetObjectTransform(this),this.forEachObject(this._setObjectActive,this),this.remove(t),this._calcBounds(),this._updateObjectsCoords(),this.dirty=!0,this},_onObjectAdded:function(t){this.dirty=!0,t.group=this,t._set("canvas",this.canvas)},_onObjectRemoved:function(t){this.dirty=!0,delete t.group,t.set("active",!1)},delegatedProperties:{fill:!0,stroke:!0,strokeWidth:!0,fontFamily:!0,fontWeight:!0,fontSize:!0,fontStyle:!0,lineHeight:!0,textDecoration:!0,textAlign:!0,backgroundColor:!0},_set:function(t,e){var i=this._objects.length;if(this.delegatedProperties[t]||"canvas"===t)for(;i--;)this._objects[i].set(t,e);else for(;i--;)this._objects[i].setOnGroup(t,e);this.callSuper("_set",t,e)},toObject:function(t){var e=this.getObjects().map(function(e){var i=e.includeDefaultValues;e.includeDefaultValues=e.group.includeDefaultValues;var r=e.toObject(t);return e.includeDefaultValues=i,r});return i(this.callSuper("toObject",t),{objects:e})},toDatalessObject:function(t){var e=this.getObjects().map(function(e){var i=e.includeDefaultValues;e.includeDefaultValues=e.group.includeDefaultValues;var r=e.toDatalessObject(t);return e.includeDefaultValues=i,r});return i(this.callSuper("toDatalessObject",t),{objects:e})},render:function(t){this._transformDone=!0,this.callSuper("render",t),this._transformDone=!1},shouldCache:function(){var t=this.objectCaching&&(!this.group||this.needsItsOwnCache||!this.group.isCaching());if(this.caching=t,t)for(var e=0,i=this._objects.length;e<i;e++)if(this._objects[e].willDrawShadow())return this.caching=!1,!1;return t},willDrawShadow:function(){if(this.shadow)return!0;for(var t=0,e=this._objects.length;t<e;t++)if(this._objects[t].willDrawShadow())return!0;return!1},isCaching:function(){return this.caching||this.group&&this.group.isCaching()},drawObject:function(t){for(var e=0,i=this._objects.length;e<i;e++)this._renderObject(this._objects[e],t)},isCacheDirty:function(){if(this.callSuper("isCacheDirty"))return!0;if(!this.statefullCache)return!1;for(var t=0,e=this._objects.length;t<e;t++)if(this._objects[t].isCacheDirty(!0)){var i=this._getNonTransformedDimensions();return this._cacheContext.clearRect(-i.x/2,-i.y/2,i.x,i.y),!0}return!1},_renderControls:function(t,e){t.save(),t.globalAlpha=this.isMoving?this.borderOpacityWhenMoving:1,this.callSuper("_renderControls",t,e);for(var i=0,r=this._objects.length;i<r;i++)this._objects[i]._renderControls(t);t.restore()},_renderObject:function(t,e){if(t.visible){var i=t.hasRotatingPoint;t.hasRotatingPoint=!1,t.render(e),t.hasRotatingPoint=i}},_restoreObjectsState:function(){return this._objects.forEach(this._restoreObjectState,this),this},realizeTransform:function(t){var i=t.calcTransformMatrix(),r=e.util.qrDecompose(i),n=new e.Point(r.translateX,r.translateY);return t.flipX=!1,t.flipY=!1,t.set("scaleX",r.scaleX),t.set("scaleY",r.scaleY),t.skewX=r.skewX,t.skewY=r.skewY,t.angle=r.angle,t.setPositionByOrigin(n,"center","center"),t},_restoreObjectState:function(t){return this.realizeTransform(t),t.setCoords(),t.hasControls=t.__origHasControls,delete t.__origHasControls,t.set("active",!1),delete t.group,this},destroy:function(){return this._restoreObjectsState()},saveCoords:function(){return this._originalLeft=this.get("left"),this._originalTop=this.get("top"),this},hasMoved:function(){return this._originalLeft!==this.get("left")||this._originalTop!==this.get("top")},setObjectsCoords:function(){var t=!0,e=!0;return this.forEachObject(function(i){i.setCoords(t,e)}),this},_calcBounds:function(t){for(var e,i,r,n=[],s=[],o=["tr","br","bl","tl"],a=0,h=this._objects.length,c=o.length,l=!0;a<h;++a)for(e=this._objects[a],e.setCoords(l),r=0;r<c;r++)i=o[r],n.push(e.oCoords[i].x),s.push(e.oCoords[i].y);this.set(this._getBounds(n,s,t))},_getBounds:function(t,i,s){var o=new e.Point(r(t),r(i)),a=new e.Point(n(t),n(i)),h={width:a.x-o.x||0,height:a.y-o.y||0};return s||(h.left=o.x||0,h.top=o.y||0,"center"===this.originX&&(h.left+=h.width/2),"right"===this.originX&&(h.left+=h.width),"center"===this.originY&&(h.top+=h.height/2),"bottom"===this.originY&&(h.top+=h.height)),h},toSVG:function(t){var e=this._createBaseSVGMarkup();e.push("<g ",this.getSvgId(),'transform="',this.getSvgTransform(),this.getSvgTransformMatrix(),'" style="',this.getSvgFilter(),'">\n');for(var i=0,r=this._objects.length;i<r;i++)e.push("\t",this._objects[i].toSVG(t));return e.push("</g>\n"),t?t(e.join("")):e.join("")},get:function(t){if(t in s){if(this[t])return this[t];for(var e=0,i=this._objects.length;e<i;e++)if(this._objects[e][t])return!0;return!1}return t in this.delegatedProperties?this._objects[0]&&this._objects[0].get(t):this[t]}}),e.Group.fromObject=function(t,i){e.util.enlivenObjects(t.objects,function(r){delete t.objects,i&&i(new e.Group(r,t,!0))})},e.Group.async=!0}}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=fabric.util.object.extend;if(t.fabric||(t.fabric={}),t.fabric.Image)return void fabric.warn("fabric.Image is already defined.");var i=fabric.Object.prototype.stateProperties.concat();i.push("alignX","alignY","meetOrSlice"),fabric.Image=fabric.util.createClass(fabric.Object,{type:"image",crossOrigin:"",alignX:"none",alignY:"none",meetOrSlice:"meet",strokeWidth:0,_lastScaleX:1,_lastScaleY:1,minimumScaleTrigger:.5,stateProperties:i,objectCaching:!1,initialize:function(t,e,i){e||(e={}),this.filters=[],this.resizeFilters=[],this.callSuper("initialize",e),this._initElement(t,e,i)},getElement:function(){return this._element},setElement:function(t,e,i){var r,n;return this._element=t,this._originalElement=t,this._initConfig(i),0===this.resizeFilters.length?r=e:(n=this,r=function(){n.applyFilters(e,n.resizeFilters,n._filteredEl||n._originalElement,!0)}),0!==this.filters.length?this.applyFilters(r):r&&r(this),this},setCrossOrigin:function(t){return this.crossOrigin=t,this._element.crossOrigin=t,this},getOriginalSize:function(){var t=this.getElement();return{width:t.width,height:t.height}},_stroke:function(t){if(this.stroke&&0!==this.strokeWidth){var e=this.width/2,i=this.height/2;t.beginPath(),t.moveTo(-e,-i),t.lineTo(e,-i),t.lineTo(e,i),t.lineTo(-e,i),t.lineTo(-e,-i),t.closePath()}},_renderDashedStroke:function(t){var e=-this.width/2,i=-this.height/2,r=this.width,n=this.height;t.save(),this._setStrokeStyles(t),t.beginPath(),fabric.util.drawDashedLine(t,e,i,e+r,i,this.strokeDashArray),fabric.util.drawDashedLine(t,e+r,i,e+r,i+n,this.strokeDashArray),fabric.util.drawDashedLine(t,e+r,i+n,e,i+n,this.strokeDashArray),fabric.util.drawDashedLine(t,e,i+n,e,i,this.strokeDashArray),t.closePath(),t.restore()},toObject:function(t){var i=[],r=[],n=1,s=1;this.filters.forEach(function(t){t&&("Resize"===t.type&&(n*=t.scaleX,s*=t.scaleY),i.push(t.toObject()))}),this.resizeFilters.forEach(function(t){t&&r.push(t.toObject())});var o=e(this.callSuper("toObject",["crossOrigin","alignX","alignY","meetOrSlice"].concat(t)),{src:this.getSrc(),filters:i,resizeFilters:r});return o.width/=n,o.height/=s,o},toSVG:function(t){var e=this._createBaseSVGMarkup(),i=-this.width/2,r=-this.height/2,n="none",s=!0;if(this.group&&"path-group"===this.group.type&&(i=this.left,r=this.top),"none"!==this.alignX&&"none"!==this.alignY&&(n="x"+this.alignX+"Y"+this.alignY+" "+this.meetOrSlice),e.push('<g transform="',this.getSvgTransform(),this.getSvgTransformMatrix(),'">\n',"<image ",this.getSvgId(),'xlink:href="',this.getSvgSrc(s),'" x="',i,'" y="',r,'" style="',this.getSvgStyles(),'" width="',this.width,'" height="',this.height,'" preserveAspectRatio="',n,'"',"></image>\n"),this.stroke||this.strokeDashArray){var o=this.fill;this.fill=null,e.push("<rect ",'x="',i,'" y="',r,'" width="',this.width,'" height="',this.height,'" style="',this.getSvgStyles(),'"/>\n'),this.fill=o}return e.push("</g>\n"),t?t(e.join("")):e.join("")},getSrc:function(t){var e=t?this._element:this._originalElement;return e?fabric.isLikelyNode?e._src:e.src:this.src||""},setSrc:function(t,e,i){fabric.util.loadImage(t,function(t){return this.setElement(t,e,i)},this,i&&i.crossOrigin)},toString:function(){return'#<fabric.Image: { src: "'+this.getSrc()+'" }>'},applyFilters:function(t,e,i,r){if(e=e||this.filters,i=i||this._originalElement){var n,s,o=fabric.util.createImage(),a=this.canvas?this.canvas.getRetinaScaling():fabric.devicePixelRatio,h=this.minimumScaleTrigger/a,c=this;if(0===e.length)return this._element=i,t&&t(this),i;var l=fabric.util.createCanvasElement();return l.width=i.width,l.height=i.height,l.getContext("2d").drawImage(i,0,0,i.width,i.height),e.forEach(function(t){t&&(r?(n=c.scaleX<h?c.scaleX:1,s=c.scaleY<h?c.scaleY:1,n*a<1&&(n*=a),s*a<1&&(s*=a)):(n=t.scaleX,s=t.scaleY),t.applyTo(l,n,s),r||"Resize"!==t.type||(c.width*=t.scaleX,c.height*=t.scaleY))}),o.width=l.width,o.height=l.height,fabric.isLikelyNode?(o.src=l.toBuffer(void 0,fabric.Image.pngCompression),c._element=o,!r&&(c._filteredEl=o),t&&t(c)):(o.onload=function(){c._element=o,!r&&(c._filteredEl=o),t&&t(c),o.onload=l=null},o.src=l.toDataURL("image/png")),l}},_render:function(t,e){var i,r,n,s=this._findMargins();i=e?this.left:-this.width/2,r=e?this.top:-this.height/2,"slice"===this.meetOrSlice&&(t.beginPath(),t.rect(i,r,this.width,this.height),t.clip()),this.isMoving===!1&&this.resizeFilters.length&&this._needsResize()?(this._lastScaleX=this.scaleX,this._lastScaleY=this.scaleY,n=this.applyFilters(null,this.resizeFilters,this._filteredEl||this._originalElement,!0)):n=this._element,n&&t.drawImage(n,i+s.marginX,r+s.marginY,s.width,s.height),this._stroke(t),this._renderStroke(t)},_needsResize:function(){return this.scaleX!==this._lastScaleX||this.scaleY!==this._lastScaleY},_findMargins:function(){var t,e,i=this.width,r=this.height,n=0,s=0;return"none"===this.alignX&&"none"===this.alignY||(t=[this.width/this._element.width,this.height/this._element.height],e="meet"===this.meetOrSlice?Math.min.apply(null,t):Math.max.apply(null,t),i=this._element.width*e,r=this._element.height*e,"Mid"===this.alignX&&(n=(this.width-i)/2),"Max"===this.alignX&&(n=this.width-i),"Mid"===this.alignY&&(s=(this.height-r)/2),"Max"===this.alignY&&(s=this.height-r)),{width:i,height:r,marginX:n,marginY:s}},_resetWidthHeight:function(){var t=this.getElement();this.set("width",t.width),this.set("height",t.height)},_initElement:function(t,e,i){this.setElement(fabric.util.getById(t),i,e),fabric.util.addClass(this.getElement(),fabric.Image.CSS_CANVAS)},_initConfig:function(t){t||(t={}),this.setOptions(t),this._setWidthHeight(t),this._element&&this.crossOrigin&&(this._element.crossOrigin=this.crossOrigin)},_initFilters:function(t,e){t&&t.length?fabric.util.enlivenObjects(t,function(t){e&&e(t)},"fabric.Image.filters"):e&&e()},_setWidthHeight:function(t){this.width="width"in t?t.width:this.getElement()?this.getElement().width||0:0,this.height="height"in t?t.height:this.getElement()?this.getElement().height||0:0}}),fabric.Image.CSS_CANVAS="canvas-img",fabric.Image.prototype.getSvgSrc=fabric.Image.prototype.getSrc,fabric.Image.fromObject=function(t,e){fabric.util.loadImage(t.src,function(i,r){return r?void(e&&e(null,r)):void fabric.Image.prototype._initFilters.call(t,t.filters,function(r){t.filters=r||[],fabric.Image.prototype._initFilters.call(t,t.resizeFilters,function(r){return t.resizeFilters=r||[],new fabric.Image(i,t,e)})})},null,t.crossOrigin)},fabric.Image.fromURL=function(t,e,i){fabric.util.loadImage(t,function(t){e&&e(new fabric.Image(t,i))},null,i&&i.crossOrigin)},fabric.Image.ATTRIBUTE_NAMES=fabric.SHARED_ATTRIBUTES.concat("x y width height preserveAspectRatio xlink:href crossOrigin".split(" ")),fabric.Image.fromElement=function(t,i,r){var n,s=fabric.parseAttributes(t,fabric.Image.ATTRIBUTE_NAMES);s.preserveAspectRatio&&(n=fabric.util.parsePreserveAspectRatioAttribute(s.preserveAspectRatio),e(s,n)),fabric.Image.fromURL(s["xlink:href"],i,e(r?fabric.util.object.clone(r):{},s))},fabric.Image.async=!0,fabric.Image.pngCompression=1}("undefined"!=typeof exports?exports:this),fabric.util.object.extend(fabric.Object.prototype,{_getAngleValueForStraighten:function(){var t=this.getAngle()%360;return t>0?90*Math.round((t-1)/90):90*Math.round(t/90)},straighten:function(){return this.setAngle(this._getAngleValueForStraighten()),this},fxStraighten:function(t){t=t||{};var e=function(){},i=t.onComplete||e,r=t.onChange||e,n=this;return fabric.util.animate({startValue:this.get("angle"),endValue:this._getAngleValueForStraighten(),duration:this.FX_DURATION,onChange:function(t){n.setAngle(t),r()},onComplete:function(){n.setCoords(),i()},onStart:function(){n.set("active",!1)}}),this}}),fabric.util.object.extend(fabric.StaticCanvas.prototype,{straightenObject:function(t){return t.straighten(),this.renderAll(),this},fxStraightenObject:function(t){return t.fxStraighten({onChange:this.renderAll.bind(this)}),this}}),fabric.Image.filters=fabric.Image.filters||{},fabric.Image.filters.BaseFilter=fabric.util.createClass({type:"BaseFilter",initialize:function(t){t&&this.setOptions(t)},setOptions:function(t){for(var e in t)this[e]=t[e]},toObject:function(){return{type:this.type}},toJSON:function(){return this.toObject()}}),fabric.Image.filters.BaseFilter.fromObject=function(t,e){var i=new fabric.Image.filters[t.type](t);return e&&e(i),i},function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.util.object.extend,r=e.Image.filters,n=e.util.createClass;r.Brightness=n(r.BaseFilter,{type:"Brightness",initialize:function(t){t=t||{},this.brightness=t.brightness||0},applyTo:function(t){for(var e=t.getContext("2d"),i=e.getImageData(0,0,t.width,t.height),r=i.data,n=this.brightness,s=0,o=r.length;s<o;s+=4)r[s]+=n,r[s+1]+=n,r[s+2]+=n;e.putImageData(i,0,0)},toObject:function(){return i(this.callSuper("toObject"),{brightness:this.brightness})}}),e.Image.filters.Brightness.fromObject=e.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.util.object.extend,r=e.Image.filters,n=e.util.createClass;r.Convolute=n(r.BaseFilter,{type:"Convolute",initialize:function(t){t=t||{},this.opaque=t.opaque,this.matrix=t.matrix||[0,0,0,0,1,0,0,0,0]},applyTo:function(t){for(var e,i,r,n,s,o,a,h,c,l=this.matrix,u=t.getContext("2d"),f=u.getImageData(0,0,t.width,t.height),d=Math.round(Math.sqrt(l.length)),g=Math.floor(d/2),p=f.data,v=f.width,b=f.height,m=u.createImageData(v,b),y=m.data,_=this.opaque?1:0,x=0;x<b;x++)for(var C=0;C<v;C++){s=4*(x*v+C),e=0,i=0,r=0,n=0;for(var S=0;S<d;S++)for(var w=0;w<d;w++)a=x+S-g,o=C+w-g,a<0||a>b||o<0||o>v||(h=4*(a*v+o),c=l[S*d+w],e+=p[h]*c,i+=p[h+1]*c,r+=p[h+2]*c,n+=p[h+3]*c);y[s]=e,y[s+1]=i,y[s+2]=r,y[s+3]=n+_*(255-n)}u.putImageData(m,0,0)},toObject:function(){return i(this.callSuper("toObject"),{opaque:this.opaque,matrix:this.matrix})}}),e.Image.filters.Convolute.fromObject=e.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.util.object.extend,r=e.Image.filters,n=e.util.createClass;r.GradientTransparency=n(r.BaseFilter,{type:"GradientTransparency",initialize:function(t){t=t||{},this.threshold=t.threshold||100},applyTo:function(t){for(var e=t.getContext("2d"),i=e.getImageData(0,0,t.width,t.height),r=i.data,n=this.threshold,s=r.length,o=0,a=r.length;o<a;o+=4)r[o+3]=n+255*(s-o)/s;e.putImageData(i,0,0)},toObject:function(){return i(this.callSuper("toObject"),{threshold:this.threshold})}}),e.Image.filters.GradientTransparency.fromObject=e.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.Image.filters,r=e.util.createClass;i.Grayscale=r(i.BaseFilter,{type:"Grayscale",applyTo:function(t){for(var e,i=t.getContext("2d"),r=i.getImageData(0,0,t.width,t.height),n=r.data,s=r.width*r.height*4,o=0;o<s;)e=(n[o]+n[o+1]+n[o+2])/3,n[o]=e,n[o+1]=e,n[o+2]=e,o+=4;i.putImageData(r,0,0)}}),e.Image.filters.Grayscale.fromObject=function(t,i){return t=t||{},t.type="Grayscale",e.Image.filters.BaseFilter.fromObject(t,i)}}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.Image.filters,r=e.util.createClass;i.Invert=r(i.BaseFilter,{type:"Invert",applyTo:function(t){var e,i=t.getContext("2d"),r=i.getImageData(0,0,t.width,t.height),n=r.data,s=n.length;for(e=0;e<s;e+=4)n[e]=255-n[e],n[e+1]=255-n[e+1],n[e+2]=255-n[e+2];i.putImageData(r,0,0)}}),e.Image.filters.Invert.fromObject=function(t,i){return t=t||{},t.type="Invert",e.Image.filters.BaseFilter.fromObject(t,i)}}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.util.object.extend,r=e.Image.filters,n=e.util.createClass;r.Mask=n(r.BaseFilter,{type:"Mask",initialize:function(t){t=t||{},this.mask=t.mask,this.channel=[0,1,2,3].indexOf(t.channel)>-1?t.channel:0},applyTo:function(t){if(this.mask){var i,r=t.getContext("2d"),n=r.getImageData(0,0,t.width,t.height),s=n.data,o=this.mask.getElement(),a=e.util.createCanvasElement(),h=this.channel,c=n.width*n.height*4;a.width=t.width,a.height=t.height,a.getContext("2d").drawImage(o,0,0,t.width,t.height);var l=a.getContext("2d").getImageData(0,0,t.width,t.height),u=l.data;for(i=0;i<c;i+=4)s[i+3]=u[i+h];r.putImageData(n,0,0)}},toObject:function(){return i(this.callSuper("toObject"),{mask:this.mask.toObject(),channel:this.channel})}}),e.Image.filters.Mask.fromObject=function(t,i){e.util.loadImage(t.mask.src,function(r){return t.mask=new e.Image(r,t.mask),e.Image.filters.BaseFilter.fromObject(t,i)})},e.Image.filters.Mask.async=!0}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.util.object.extend,r=e.Image.filters,n=e.util.createClass;r.Noise=n(r.BaseFilter,{type:"Noise",initialize:function(t){t=t||{},this.noise=t.noise||0},applyTo:function(t){for(var e,i=t.getContext("2d"),r=i.getImageData(0,0,t.width,t.height),n=r.data,s=this.noise,o=0,a=n.length;o<a;o+=4)e=(.5-Math.random())*s,n[o]+=e,n[o+1]+=e,n[o+2]+=e;i.putImageData(r,0,0)},toObject:function(){return i(this.callSuper("toObject"),{noise:this.noise})}}),e.Image.filters.Noise.fromObject=e.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.util.object.extend,r=e.Image.filters,n=e.util.createClass;r.Pixelate=n(r.BaseFilter,{type:"Pixelate",initialize:function(t){t=t||{},this.blocksize=t.blocksize||4},applyTo:function(t){var e,i,r,n,s,o,a,h=t.getContext("2d"),c=h.getImageData(0,0,t.width,t.height),l=c.data,u=c.height,f=c.width;for(i=0;i<u;i+=this.blocksize)for(r=0;r<f;r+=this.blocksize){e=4*i*f+4*r,n=l[e],s=l[e+1],o=l[e+2],a=l[e+3];for(var d=i,g=i+this.blocksize;d<g;d++)for(var p=r,v=r+this.blocksize;p<v;p++)e=4*d*f+4*p,l[e]=n,l[e+1]=s,l[e+2]=o,l[e+3]=a}h.putImageData(c,0,0)},toObject:function(){return i(this.callSuper("toObject"),{blocksize:this.blocksize})}}),e.Image.filters.Pixelate.fromObject=e.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.util.object.extend,r=e.Image.filters,n=e.util.createClass;r.RemoveWhite=n(r.BaseFilter,{type:"RemoveWhite",initialize:function(t){t=t||{},this.threshold=t.threshold||30,this.distance=t.distance||20},applyTo:function(t){for(var e,i,r,n=t.getContext("2d"),s=n.getImageData(0,0,t.width,t.height),o=s.data,a=this.threshold,h=this.distance,c=255-a,l=Math.abs,u=0,f=o.length;u<f;u+=4)e=o[u],i=o[u+1],r=o[u+2],e>c&&i>c&&r>c&&l(e-i)<h&&l(e-r)<h&&l(i-r)<h&&(o[u+3]=0);n.putImageData(s,0,0)},toObject:function(){return i(this.callSuper("toObject"),{threshold:this.threshold,distance:this.distance})}}),e.Image.filters.RemoveWhite.fromObject=e.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.Image.filters,r=e.util.createClass;i.Sepia=r(i.BaseFilter,{type:"Sepia",applyTo:function(t){var e,i,r=t.getContext("2d"),n=r.getImageData(0,0,t.width,t.height),s=n.data,o=s.length;for(e=0;e<o;e+=4)i=.3*s[e]+.59*s[e+1]+.11*s[e+2],s[e]=i+100,s[e+1]=i+50,s[e+2]=i+255;r.putImageData(n,0,0)}}),e.Image.filters.Sepia.fromObject=function(t,i){return t=t||{},t.type="Sepia",new e.Image.filters.BaseFilter.fromObject(t,i)}}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.Image.filters,r=e.util.createClass;i.Sepia2=r(i.BaseFilter,{type:"Sepia2",applyTo:function(t){var e,i,r,n,s=t.getContext("2d"),o=s.getImageData(0,0,t.width,t.height),a=o.data,h=a.length;for(e=0;e<h;e+=4)i=a[e],r=a[e+1],n=a[e+2],a[e]=(.393*i+.769*r+.189*n)/1.351,a[e+1]=(.349*i+.686*r+.168*n)/1.203,a[e+2]=(.272*i+.534*r+.131*n)/2.14;s.putImageData(o,0,0)}}),e.Image.filters.Sepia2.fromObject=function(t,i){return t=t||{},t.type="Sepia2",new e.Image.filters.BaseFilter.fromObject(t,i)}}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.util.object.extend,r=e.Image.filters,n=e.util.createClass;r.Tint=n(r.BaseFilter,{type:"Tint",initialize:function(t){t=t||{},this.color=t.color||"#000000",this.opacity="undefined"!=typeof t.opacity?t.opacity:new e.Color(this.color).getAlpha()},applyTo:function(t){var i,r,n,s,o,a,h,c,l,u=t.getContext("2d"),f=u.getImageData(0,0,t.width,t.height),d=f.data,g=d.length;for(l=new e.Color(this.color).getSource(),r=l[0]*this.opacity,n=l[1]*this.opacity,s=l[2]*this.opacity,c=1-this.opacity,i=0;i<g;i+=4)o=d[i],a=d[i+1],h=d[i+2],d[i]=r+o*c,d[i+1]=n+a*c,d[i+2]=s+h*c;u.putImageData(f,0,0)},toObject:function(){return i(this.callSuper("toObject"),{color:this.color,opacity:this.opacity})}}),e.Image.filters.Tint.fromObject=e.Image.filters.BaseFilter.fromObject;
}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.util.object.extend,r=e.Image.filters,n=e.util.createClass;r.Multiply=n(r.BaseFilter,{type:"Multiply",initialize:function(t){t=t||{},this.color=t.color||"#000000"},applyTo:function(t){var i,r,n=t.getContext("2d"),s=n.getImageData(0,0,t.width,t.height),o=s.data,a=o.length;for(r=new e.Color(this.color).getSource(),i=0;i<a;i+=4)o[i]*=r[0]/255,o[i+1]*=r[1]/255,o[i+2]*=r[2]/255;n.putImageData(s,0,0)},toObject:function(){return i(this.callSuper("toObject"),{color:this.color})}}),e.Image.filters.Multiply.fromObject=e.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric,i=e.Image.filters,r=e.util.createClass;i.Blend=r(i.BaseFilter,{type:"Blend",initialize:function(t){t=t||{},this.color=t.color||"#000",this.image=t.image||!1,this.mode=t.mode||"multiply",this.alpha=t.alpha||1},applyTo:function(t){var i,r,n,s,o,a,h,c,l,u,f=t.getContext("2d"),d=f.getImageData(0,0,t.width,t.height),g=d.data,p=!1;if(this.image){p=!0;var v=e.util.createCanvasElement();v.width=this.image.width,v.height=this.image.height;var b=new e.StaticCanvas(v);b.add(this.image);var m=b.getContext("2d");u=m.getImageData(0,0,b.width,b.height).data}else u=new e.Color(this.color).getSource(),i=u[0]*this.alpha,r=u[1]*this.alpha,n=u[2]*this.alpha;for(var y=0,_=g.length;y<_;y+=4)switch(s=g[y],o=g[y+1],a=g[y+2],p&&(i=u[y]*this.alpha,r=u[y+1]*this.alpha,n=u[y+2]*this.alpha),this.mode){case"multiply":g[y]=s*i/255,g[y+1]=o*r/255,g[y+2]=a*n/255;break;case"screen":g[y]=1-(1-s)*(1-i),g[y+1]=1-(1-o)*(1-r),g[y+2]=1-(1-a)*(1-n);break;case"add":g[y]=Math.min(255,s+i),g[y+1]=Math.min(255,o+r),g[y+2]=Math.min(255,a+n);break;case"diff":case"difference":g[y]=Math.abs(s-i),g[y+1]=Math.abs(o-r),g[y+2]=Math.abs(a-n);break;case"subtract":h=s-i,c=o-r,l=a-n,g[y]=h<0?0:h,g[y+1]=c<0?0:c,g[y+2]=l<0?0:l;break;case"darken":g[y]=Math.min(s,i),g[y+1]=Math.min(o,r),g[y+2]=Math.min(a,n);break;case"lighten":g[y]=Math.max(s,i),g[y+1]=Math.max(o,r),g[y+2]=Math.max(a,n)}f.putImageData(d,0,0)},toObject:function(){return{color:this.color,image:this.image,mode:this.mode,alpha:this.alpha}}}),e.Image.filters.Blend.fromObject=e.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=Math.pow,r=Math.floor,n=Math.sqrt,s=Math.abs,o=Math.max,a=Math.round,h=Math.sin,c=Math.ceil,l=e.Image.filters,u=e.util.createClass;l.Resize=u(l.BaseFilter,{type:"Resize",resizeType:"hermite",scaleX:0,scaleY:0,lanczosLobes:3,applyTo:function(t,e,i){if(1!==e||1!==i){this.rcpScaleX=1/e,this.rcpScaleY=1/i;var r,n=t.width,s=t.height,o=a(n*e),h=a(s*i);"sliceHack"===this.resizeType&&(r=this.sliceByTwo(t,n,s,o,h)),"hermite"===this.resizeType&&(r=this.hermiteFastResize(t,n,s,o,h)),"bilinear"===this.resizeType&&(r=this.bilinearFiltering(t,n,s,o,h)),"lanczos"===this.resizeType&&(r=this.lanczosResize(t,n,s,o,h)),t.width=o,t.height=h,t.getContext("2d").putImageData(r,0,0)}},sliceByTwo:function(t,i,n,s,a){var h,c=t.getContext("2d"),l=.5,u=.5,f=1,d=1,g=!1,p=!1,v=i,b=n,m=e.util.createCanvasElement(),y=m.getContext("2d");for(s=r(s),a=r(a),m.width=o(s,i),m.height=o(a,n),s>i&&(l=2,f=-1),a>n&&(u=2,d=-1),h=c.getImageData(0,0,i,n),t.width=o(s,i),t.height=o(a,n),c.putImageData(h,0,0);!g||!p;)i=v,n=b,s*f<r(v*l*f)?v=r(v*l):(v=s,g=!0),a*d<r(b*u*d)?b=r(b*u):(b=a,p=!0),h=c.getImageData(0,0,i,n),y.putImageData(h,0,0),c.clearRect(0,0,v,b),c.drawImage(m,0,0,i,n,0,0,v,b);return c.getImageData(0,0,s,a)},lanczosResize:function(t,e,o,a,l){function u(t){return function(e){if(e>t)return 0;if(e*=Math.PI,s(e)<1e-16)return 1;var i=e/t;return h(e)*h(i)/e/i}}function f(t){var h,c,u,d,g,k,M,D,A,P,I;for(T.x=(t+.5)*y,j.x=r(T.x),h=0;h<l;h++){for(T.y=(h+.5)*_,j.y=r(T.y),g=0,k=0,M=0,D=0,A=0,c=j.x-S;c<=j.x+S;c++)if(!(c<0||c>=e)){P=r(1e3*s(c-T.x)),O[P]||(O[P]={});for(var E=j.y-w;E<=j.y+w;E++)E<0||E>=o||(I=r(1e3*s(E-T.y)),O[P][I]||(O[P][I]=m(n(i(P*x,2)+i(I*C,2))/1e3)),u=O[P][I],u>0&&(d=4*(E*e+c),g+=u,k+=u*v[d],M+=u*v[d+1],D+=u*v[d+2],A+=u*v[d+3]))}d=4*(h*a+t),b[d]=k/g,b[d+1]=M/g,b[d+2]=D/g,b[d+3]=A/g}return++t<a?f(t):p}var d=t.getContext("2d"),g=d.getImageData(0,0,e,o),p=d.getImageData(0,0,a,l),v=g.data,b=p.data,m=u(this.lanczosLobes),y=this.rcpScaleX,_=this.rcpScaleY,x=2/this.rcpScaleX,C=2/this.rcpScaleY,S=c(y*this.lanczosLobes/2),w=c(_*this.lanczosLobes/2),O={},T={},j={};return f(0)},bilinearFiltering:function(t,e,i,n,s){var o,a,h,c,l,u,f,d,g,p,v,b,m,y=0,_=this.rcpScaleX,x=this.rcpScaleY,C=t.getContext("2d"),S=4*(e-1),w=C.getImageData(0,0,e,i),O=w.data,T=C.getImageData(0,0,n,s),j=T.data;for(f=0;f<s;f++)for(d=0;d<n;d++)for(l=r(_*d),u=r(x*f),g=_*d-l,p=x*f-u,m=4*(u*e+l),v=0;v<4;v++)o=O[m+v],a=O[m+4+v],h=O[m+S+v],c=O[m+S+4+v],b=o*(1-g)*(1-p)+a*g*(1-p)+h*p*(1-g)+c*g*p,j[y++]=b;return T},hermiteFastResize:function(t,e,i,o,a){for(var h=this.rcpScaleX,l=this.rcpScaleY,u=c(h/2),f=c(l/2),d=t.getContext("2d"),g=d.getImageData(0,0,e,i),p=g.data,v=d.getImageData(0,0,o,a),b=v.data,m=0;m<a;m++)for(var y=0;y<o;y++){for(var _=4*(y+m*o),x=0,C=0,S=0,w=0,O=0,T=0,j=0,k=(m+.5)*l,M=r(m*l);M<(m+1)*l;M++)for(var D=s(k-(M+.5))/f,A=(y+.5)*h,P=D*D,I=r(y*h);I<(y+1)*h;I++){var E=s(A-(I+.5))/u,L=n(P+E*E);L>1&&L<-1||(x=2*L*L*L-3*L*L+1,x>0&&(E=4*(I+M*e),j+=x*p[E+3],S+=x,p[E+3]<255&&(x=x*p[E+3]/250),w+=x*p[E],O+=x*p[E+1],T+=x*p[E+2],C+=x))}b[_]=w/C,b[_+1]=O/C,b[_+2]=T/C,b[_+3]=j/S}return v},toObject:function(){return{type:this.type,scaleX:this.scaleX,scaleY:this.scaleY,resizeType:this.resizeType,lanczosLobes:this.lanczosLobes}}}),e.Image.filters.Resize.fromObject=e.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.util.object.extend,r=e.Image.filters,n=e.util.createClass;r.ColorMatrix=n(r.BaseFilter,{type:"ColorMatrix",initialize:function(t){t||(t={}),this.matrix=t.matrix||[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0]},applyTo:function(t){var e,i,r,n,s,o=t.getContext("2d"),a=o.getImageData(0,0,t.width,t.height),h=a.data,c=h.length,l=this.matrix;for(e=0;e<c;e+=4)i=h[e],r=h[e+1],n=h[e+2],s=h[e+3],h[e]=i*l[0]+r*l[1]+n*l[2]+s*l[3]+l[4],h[e+1]=i*l[5]+r*l[6]+n*l[7]+s*l[8]+l[9],h[e+2]=i*l[10]+r*l[11]+n*l[12]+s*l[13]+l[14],h[e+3]=i*l[15]+r*l[16]+n*l[17]+s*l[18]+l[19];o.putImageData(a,0,0)},toObject:function(){return i(this.callSuper("toObject"),{type:this.type,matrix:this.matrix})}}),e.Image.filters.ColorMatrix.fromObject=e.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.util.object.extend,r=e.Image.filters,n=e.util.createClass;r.Contrast=n(r.BaseFilter,{type:"Contrast",initialize:function(t){t=t||{},this.contrast=t.contrast||0},applyTo:function(t){for(var e=t.getContext("2d"),i=e.getImageData(0,0,t.width,t.height),r=i.data,n=259*(this.contrast+255)/(255*(259-this.contrast)),s=0,o=r.length;s<o;s+=4)r[s]=n*(r[s]-128)+128,r[s+1]=n*(r[s+1]-128)+128,r[s+2]=n*(r[s+2]-128)+128;e.putImageData(i,0,0)},toObject:function(){return i(this.callSuper("toObject"),{contrast:this.contrast})}}),e.Image.filters.Contrast.fromObject=e.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.util.object.extend,r=e.Image.filters,n=e.util.createClass;r.Saturate=n(r.BaseFilter,{type:"Saturate",initialize:function(t){t=t||{},this.saturate=t.saturate||0},applyTo:function(t){for(var e,i=t.getContext("2d"),r=i.getImageData(0,0,t.width,t.height),n=r.data,s=.01*-this.saturate,o=0,a=n.length;o<a;o+=4)e=Math.max(n[o],n[o+1],n[o+2]),n[o]+=e!==n[o]?(e-n[o])*s:0,n[o+1]+=e!==n[o+1]?(e-n[o+1])*s:0,n[o+2]+=e!==n[o+2]?(e-n[o+2])*s:0;i.putImageData(r,0,0)},toObject:function(){return i(this.callSuper("toObject"),{saturate:this.saturate})}}),e.Image.filters.Saturate.fromObject=e.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.util.toFixed,r=e.Object.NUM_FRACTION_DIGITS,n=2;if(e.Text)return void e.warn("fabric.Text is already defined");var s=e.Object.prototype.stateProperties.concat();s.push("fontFamily","fontWeight","fontSize","text","textDecoration","textAlign","fontStyle","lineHeight","textBackgroundColor","charSpacing");var o=e.Object.prototype.cacheProperties.concat();o.push("fontFamily","fontWeight","fontSize","text","textDecoration","textAlign","fontStyle","lineHeight","textBackgroundColor","charSpacing","styles"),e.Text=e.util.createClass(e.Object,{_dimensionAffectingProps:["fontSize","fontWeight","fontFamily","fontStyle","lineHeight","text","charSpacing","textAlign"],_reNewline:/\r?\n/,_reSpacesAndTabs:/[ \t\r]+/g,type:"text",fontSize:40,fontWeight:"normal",fontFamily:"Times New Roman",textDecoration:"",textAlign:"left",fontStyle:"",lineHeight:1.16,textBackgroundColor:"",stateProperties:s,cacheProperties:o,stroke:null,shadow:null,_fontSizeFraction:.25,_fontSizeMult:1.13,charSpacing:0,initialize:function(t,e){e=e||{},this.text=t,this.__skipDimension=!0,this.callSuper("initialize",e),this.__skipDimension=!1,this._initDimensions(),this.setCoords(),this.setupState({propertySet:"_dimensionAffectingProps"})},_initDimensions:function(t){this.__skipDimension||(t||(t=e.util.createCanvasElement().getContext("2d"),this._setTextStyles(t)),this._textLines=this._splitTextIntoLines(),this._clearCache(),this.width=this._getTextWidth(t)||this.cursorWidth||n,this.height=this._getTextHeight(t))},toString:function(){return"#<fabric.Text ("+this.complexity()+'): { "text": "'+this.text+'", "fontFamily": "'+this.fontFamily+'" }>'},_getCacheCanvasDimensions:function(){var t=this.callSuper("_getCacheCanvasDimensions"),e=2*this.fontSize;return t.width+=e*t.zoomX,t.height+=e*t.zoomY,t},_render:function(t){this._setTextStyles(t),this.group&&"path-group"===this.group.type&&t.translate(this.left,this.top),this._renderTextLinesBackground(t),this._renderText(t),this._renderTextDecoration(t)},_renderText:function(t){this._renderTextFill(t),this._renderTextStroke(t)},_setTextStyles:function(t){t.textBaseline="alphabetic",t.font=this._getFontDeclaration()},_getTextHeight:function(){return this._getHeightOfSingleLine()+(this._textLines.length-1)*this._getHeightOfLine()},_getTextWidth:function(t){for(var e=this._getLineWidth(t,0),i=1,r=this._textLines.length;i<r;i++){var n=this._getLineWidth(t,i);n>e&&(e=n)}return e},_renderChars:function(t,e,i,r,n){var s,o,a=t.slice(0,-4);if(this[a].toLive){var h=-this.width/2+this[a].offsetX||0,c=-this.height/2+this[a].offsetY||0;e.save(),e.translate(h,c),r-=h,n-=c}if(0!==this.charSpacing){var l=this._getWidthOfCharSpacing();i=i.split("");for(var u=0,f=i.length;u<f;u++)s=i[u],o=e.measureText(s).width+l,e[t](s,r,n),r+=o>0?o:0}else e[t](i,r,n);this[a].toLive&&e.restore()},_renderTextLine:function(t,e,i,r,n,s){n-=this.fontSize*this._fontSizeFraction;var o=this._getLineWidth(e,s);if("justify"!==this.textAlign||this.width<o)return void this._renderChars(t,e,i,r,n,s);for(var a,h=i.split(/\s+/),c=0,l=this._getWidthOfWords(e,h.join(" "),s,0),u=this.width-l,f=h.length-1,d=f>0?u/f:0,g=0,p=0,v=h.length;p<v;p++){for(;" "===i[c]&&c<i.length;)c++;a=h[p],this._renderChars(t,e,a,r+g,n,s,c),g+=this._getWidthOfWords(e,a,s,c)+d,c+=a.length}},_getWidthOfWords:function(t,e){var i,r,n=t.measureText(e).width;return 0!==this.charSpacing&&(i=e.split("").length,r=i*this._getWidthOfCharSpacing(),n+=r),n>0?n:0},_getLeftOffset:function(){return-this.width/2},_getTopOffset:function(){return-this.height/2},isEmptyStyles:function(){return!0},_renderTextCommon:function(t,e){for(var i=0,r=this._getLeftOffset(),n=this._getTopOffset(),s=0,o=this._textLines.length;s<o;s++){var a=this._getHeightOfLine(t,s),h=a/this.lineHeight,c=this._getLineWidth(t,s),l=this._getLineLeftOffset(c);this._renderTextLine(e,t,this._textLines[s],r+l,n+i+h,s),i+=a}},_renderTextFill:function(t){!this.fill&&this.isEmptyStyles()||this._renderTextCommon(t,"fillText")},_renderTextStroke:function(t){(this.stroke&&0!==this.strokeWidth||!this.isEmptyStyles())&&(this.shadow&&!this.shadow.affectStroke&&this._removeShadow(t),t.save(),this._setLineDash(t,this.strokeDashArray),t.beginPath(),this._renderTextCommon(t,"strokeText"),t.closePath(),t.restore())},_getHeightOfLine:function(){return this._getHeightOfSingleLine()*this.lineHeight},_getHeightOfSingleLine:function(){return this.fontSize*this._fontSizeMult},_renderTextLinesBackground:function(t){if(this.textBackgroundColor){var e,i,r,n=0,s=t.fillStyle;t.fillStyle=this.textBackgroundColor;for(var o=0,a=this._textLines.length;o<a;o++)e=this._getHeightOfLine(t,o),i=this._getLineWidth(t,o),i>0&&(r=this._getLineLeftOffset(i),t.fillRect(this._getLeftOffset()+r,this._getTopOffset()+n,i,e/this.lineHeight)),n+=e;t.fillStyle=s,this._removeShadow(t)}},_getLineLeftOffset:function(t){return"center"===this.textAlign?(this.width-t)/2:"right"===this.textAlign?this.width-t:0},_clearCache:function(){this.__lineWidths=[],this.__lineHeights=[]},_shouldClearDimensionCache:function(){var t=this._forceClearCache;return t||(t=this.hasStateChanged("_dimensionAffectingProps")),t&&(this.saveState({propertySet:"_dimensionAffectingProps"}),this.dirty=!0),t},_getLineWidth:function(t,e){if(this.__lineWidths[e])return this.__lineWidths[e]===-1?this.width:this.__lineWidths[e];var i,r,n=this._textLines[e];return i=""===n?0:this._measureLine(t,e),this.__lineWidths[e]=i,i&&"justify"===this.textAlign&&(r=n.split(/\s+/),r.length>1&&(this.__lineWidths[e]=-1)),i},_getWidthOfCharSpacing:function(){return 0!==this.charSpacing?this.fontSize*this.charSpacing/1e3:0},_measureLine:function(t,e){var i,r,n=this._textLines[e],s=t.measureText(n).width,o=0;return 0!==this.charSpacing&&(i=n.split("").length,o=(i-1)*this._getWidthOfCharSpacing()),r=s+o,r>0?r:0},_renderTextDecoration:function(t){function e(e){var n,s,o,a,h,c,l,u=0;for(n=0,s=r._textLines.length;n<s;n++){for(h=r._getLineWidth(t,n),c=r._getLineLeftOffset(h),l=r._getHeightOfLine(t,n),o=0,a=e.length;o<a;o++)t.fillRect(r._getLeftOffset()+c,u+(r._fontSizeMult-1+e[o])*r.fontSize-i,h,r.fontSize/15);u+=l}}if(this.textDecoration){var i=this.height/2,r=this,n=[];this.textDecoration.indexOf("underline")>-1&&n.push(.85),this.textDecoration.indexOf("line-through")>-1&&n.push(.43),this.textDecoration.indexOf("overline")>-1&&n.push(-.12),n.length>0&&e(n)}},_getFontDeclaration:function(){return[e.isLikelyNode?this.fontWeight:this.fontStyle,e.isLikelyNode?this.fontStyle:this.fontWeight,this.fontSize+"px",e.isLikelyNode?'"'+this.fontFamily+'"':this.fontFamily].join(" ")},render:function(t,e){this.visible&&(this.canvas&&this.canvas.skipOffscreen&&!this.group&&!this.isOnScreen()||(this._shouldClearDimensionCache()&&(this._setTextStyles(t),this._initDimensions(t)),this.callSuper("render",t,e)))},_splitTextIntoLines:function(){return this.text.split(this._reNewline)},toObject:function(t){var e=["text","fontSize","fontWeight","fontFamily","fontStyle","lineHeight","textDecoration","textAlign","textBackgroundColor","charSpacing"].concat(t);return this.callSuper("toObject",e)},toSVG:function(t){this.ctx||(this.ctx=e.util.createCanvasElement().getContext("2d"));var i=this._createBaseSVGMarkup(),r=this._getSVGLeftTopOffsets(this.ctx),n=this._getSVGTextAndBg(r.textTop,r.textLeft);return this._wrapSVGTextAndBg(i,n),t?t(i.join("")):i.join("")},_getSVGLeftTopOffsets:function(t){var e=this._getHeightOfLine(t,0),i=-this.width/2,r=0;return{textLeft:i+(this.group&&"path-group"===this.group.type?this.left:0),textTop:r+(this.group&&"path-group"===this.group.type?-this.top:0),lineTop:e}},_wrapSVGTextAndBg:function(t,e){var i=!0,r=this.getSvgFilter(),n=""===r?"":' style="'+r+'"';t.push("\t<g ",this.getSvgId(),'transform="',this.getSvgTransform(),this.getSvgTransformMatrix(),'"',n,">\n",e.textBgRects.join(""),"\t\t<text ",this.fontFamily?'font-family="'+this.fontFamily.replace(/"/g,"'")+'" ':"",this.fontSize?'font-size="'+this.fontSize+'" ':"",this.fontStyle?'font-style="'+this.fontStyle+'" ':"",this.fontWeight?'font-weight="'+this.fontWeight+'" ':"",this.textDecoration?'text-decoration="'+this.textDecoration+'" ':"",'style="',this.getSvgStyles(i),'" >\n',e.textSpans.join(""),"\t\t</text>\n","\t</g>\n")},_getSVGTextAndBg:function(t,e){var i=[],r=[],n=0;this._setSVGBg(r);for(var s=0,o=this._textLines.length;s<o;s++)this.textBackgroundColor&&this._setSVGTextLineBg(r,s,e,t,n),this._setSVGTextLineText(s,i,n,e,t,r),n+=this._getHeightOfLine(this.ctx,s);return{textSpans:i,textBgRects:r}},_setSVGTextLineText:function(t,n,s,o,a){var h=this.fontSize*(this._fontSizeMult-this._fontSizeFraction)-a+s-this.height/2;return"justify"===this.textAlign?void this._setSVGTextLineJustifed(t,n,h,o):void n.push('\t\t\t<tspan x="',i(o+this._getLineLeftOffset(this._getLineWidth(this.ctx,t)),r),'" ','y="',i(h,r),'" ',this._getFillAttributes(this.fill),">",e.util.string.escapeXml(this._textLines[t]),"</tspan>\n")},_setSVGTextLineJustifed:function(t,n,s,o){var a=e.util.createCanvasElement().getContext("2d");this._setTextStyles(a);var h,c,l=this._textLines[t],u=l.split(/\s+/),f=this._getWidthOfWords(a,u.join("")),d=this.width-f,g=u.length-1,p=g>0?d/g:0,v=this._getFillAttributes(this.fill);for(o+=this._getLineLeftOffset(this._getLineWidth(a,t)),t=0,c=u.length;t<c;t++)h=u[t],n.push('\t\t\t<tspan x="',i(o,r),'" ','y="',i(s,r),'" ',v,">",e.util.string.escapeXml(h),"</tspan>\n"),o+=this._getWidthOfWords(a,h)+p},_setSVGTextLineBg:function(t,e,n,s,o){t.push("\t\t<rect ",this._getFillAttributes(this.textBackgroundColor),' x="',i(n+this._getLineLeftOffset(this._getLineWidth(this.ctx,e)),r),'" y="',i(o-this.height/2,r),'" width="',i(this._getLineWidth(this.ctx,e),r),'" height="',i(this._getHeightOfLine(this.ctx,e)/this.lineHeight,r),'"></rect>\n')},_setSVGBg:function(t){this.backgroundColor&&t.push("\t\t<rect ",this._getFillAttributes(this.backgroundColor),' x="',i(-this.width/2,r),'" y="',i(-this.height/2,r),'" width="',i(this.width,r),'" height="',i(this.height,r),'"></rect>\n')},_getFillAttributes:function(t){var i=t&&"string"==typeof t?new e.Color(t):"";return i&&i.getSource()&&1!==i.getAlpha()?'opacity="'+i.getAlpha()+'" fill="'+i.setAlpha(1).toRgb()+'"':'fill="'+t+'"'},_set:function(t,e){this.callSuper("_set",t,e),this._dimensionAffectingProps.indexOf(t)>-1&&(this._initDimensions(),this.setCoords())},complexity:function(){return 1}}),e.Text.ATTRIBUTE_NAMES=e.SHARED_ATTRIBUTES.concat("x y dx dy font-family font-style font-weight font-size text-decoration text-anchor".split(" ")),e.Text.DEFAULT_SVG_FONT_SIZE=16,e.Text.fromElement=function(t,i){if(!t)return null;var r=e.parseAttributes(t,e.Text.ATTRIBUTE_NAMES);i=e.util.object.extend(i?e.util.object.clone(i):{},r),i.top=i.top||0,i.left=i.left||0,"dx"in r&&(i.left+=r.dx),"dy"in r&&(i.top+=r.dy),"fontSize"in i||(i.fontSize=e.Text.DEFAULT_SVG_FONT_SIZE),i.originX||(i.originX="left");var n="";"textContent"in t?n=t.textContent:"firstChild"in t&&null!==t.firstChild&&"data"in t.firstChild&&null!==t.firstChild.data&&(n=t.firstChild.data),n=n.replace(/^\s+|\s+$|\n+/g,"").replace(/\s+/g," ");var s=new e.Text(n,i),o=s.getHeight()/s.height,a=(s.height+s.strokeWidth)*s.lineHeight-s.height,h=a*o,c=s.getHeight()+h,l=0;return"left"===s.originX&&(l=s.getWidth()/2),"right"===s.originX&&(l=-s.getWidth()/2),s.set({left:s.getLeft()+l,top:s.getTop()-c/2+s.fontSize*(.18+s._fontSizeFraction)/s.lineHeight}),s},e.Text.fromObject=function(t,i,r){return e.Object._fromObject("Text",t,i,r,"text")},e.util.createAccessors(e.Text)}("undefined"!=typeof exports?exports:this),function(){var t=fabric.util.object.clone;fabric.IText=fabric.util.createClass(fabric.Text,fabric.Observable,{type:"i-text",selectionStart:0,selectionEnd:0,selectionColor:"rgba(17,119,255,0.3)",isEditing:!1,editable:!0,editingBorderColor:"rgba(102,153,255,0.25)",cursorWidth:2,cursorColor:"#333",cursorDelay:1e3,cursorDuration:600,styles:null,caching:!0,_reSpace:/\s|\n/,_currentCursorOpacity:0,_selectionDirection:null,_abortCursorAnimation:!1,__widthOfSpace:[],initialize:function(t,e){this.styles=e?e.styles||{}:{},this.callSuper("initialize",t,e),this.initBehavior()},_clearCache:function(){this.callSuper("_clearCache"),this.__widthOfSpace=[]},isEmptyStyles:function(){if(!this.styles)return!0;var t=this.styles;for(var e in t)for(var i in t[e])for(var r in t[e][i])return!1;return!0},setSelectionStart:function(t){t=Math.max(t,0),this._updateAndFire("selectionStart",t)},setSelectionEnd:function(t){t=Math.min(t,this.text.length),this._updateAndFire("selectionEnd",t)},_updateAndFire:function(t,e){this[t]!==e&&(this._fireSelectionChanged(),this[t]=e),this._updateTextarea()},_fireSelectionChanged:function(){this.fire("selection:changed"),this.canvas&&this.canvas.fire("text:selection:changed",{target:this})},getSelectionStyles:function(t,e){if(2===arguments.length){for(var i=[],r=t;r<e;r++)i.push(this.getSelectionStyles(r));return i}var n=this.get2DCursorLocation(t),s=this._getStyleDeclaration(n.lineIndex,n.charIndex);return s||{}},setSelectionStyles:function(t){if(this.selectionStart===this.selectionEnd)this._extendStyles(this.selectionStart,t);else for(var e=this.selectionStart;e<this.selectionEnd;e++)this._extendStyles(e,t);return this._forceClearCache=!0,this},_extendStyles:function(t,e){var i=this.get2DCursorLocation(t);this._getLineStyle(i.lineIndex)||this._setLineStyle(i.lineIndex,{}),this._getStyleDeclaration(i.lineIndex,i.charIndex)||this._setStyleDeclaration(i.lineIndex,i.charIndex,{}),fabric.util.object.extend(this._getStyleDeclaration(i.lineIndex,i.charIndex),e)},_initDimensions:function(t){t||this.clearContextTop(),this.callSuper("_initDimensions",t)},render:function(t,e){this.clearContextTop(),this.callSuper("render",t,e),this.cursorOffsetCache={},this.renderCursorOrSelection()},_render:function(t){this.callSuper("_render",t),this.ctx=t},clearContextTop:function(){if(this.active&&this.isEditing&&this.canvas&&this.canvas.contextTop){var t=this.canvas.contextTop;t.save(),t.transform.apply(t,this.canvas.viewportTransform),this.transform(t),this.transformMatrix&&t.transform.apply(t,this.transformMatrix),this._clearTextArea(t),t.restore()}},renderCursorOrSelection:function(){if(this.active&&this.isEditing){var t,e,i=this.text.split("");this.canvas&&this.canvas.contextTop?(e=this.canvas.contextTop,e.save(),e.transform.apply(e,this.canvas.viewportTransform),this.transform(e),this.transformMatrix&&e.transform.apply(e,this.transformMatrix),this._clearTextArea(e)):(e=this.ctx,e.save()),this.selectionStart===this.selectionEnd?(t=this._getCursorBoundaries(i,"cursor"),this.renderCursor(t,e)):(t=this._getCursorBoundaries(i,"selection"),this.renderSelection(i,t,e)),e.restore()}},_clearTextArea:function(t){var e=this.width+4,i=this.height+4;t.clearRect(-e/2,-i/2,e,i)},get2DCursorLocation:function(t){"undefined"==typeof t&&(t=this.selectionStart);for(var e=this._textLines.length,i=0;i<e;i++){if(t<=this._textLines[i].length)return{lineIndex:i,charIndex:t};t-=this._textLines[i].length+1}return{lineIndex:i-1,charIndex:this._textLines[i-1].length<t?this._textLines[i-1].length:t}},getCurrentCharStyle:function(t,e){var i=this._getStyleDeclaration(t,0===e?0:e-1);return{fontSize:i&&i.fontSize||this.fontSize,fill:i&&i.fill||this.fill,textBackgroundColor:i&&i.textBackgroundColor||this.textBackgroundColor,textDecoration:i&&i.textDecoration||this.textDecoration,fontFamily:i&&i.fontFamily||this.fontFamily,fontWeight:i&&i.fontWeight||this.fontWeight,fontStyle:i&&i.fontStyle||this.fontStyle,stroke:i&&i.stroke||this.stroke,strokeWidth:i&&i.strokeWidth||this.strokeWidth}},getCurrentCharFontSize:function(t,e){var i=this._getStyleDeclaration(t,0===e?0:e-1);return i&&i.fontSize?i.fontSize:this.fontSize},getCurrentCharColor:function(t,e){var i=this._getStyleDeclaration(t,0===e?0:e-1);return i&&i.fill?i.fill:this.cursorColor},_getCursorBoundaries:function(t,e){var i=Math.round(this._getLeftOffset()),r=this._getTopOffset(),n=this._getCursorBoundariesOffsets(t,e);return{left:i,top:r,leftOffset:n.left+n.lineLeft,topOffset:n.top}},_getCursorBoundariesOffsets:function(t,e){if(this.cursorOffsetCache&&"top"in this.cursorOffsetCache)return this.cursorOffsetCache;for(var i,r=0,n=0,s=0,o=0,a=0,h=0;h<this.selectionStart;h++)"\n"===t[h]?(a=0,o+=this._getHeightOfLine(this.ctx,n),n++,s=0):(a+=this._getWidthOfChar(this.ctx,t[h],n,s),s++),r=this._getLineLeftOffset(this._getLineWidth(this.ctx,n));return"cursor"===e&&(o+=(1-this._fontSizeFraction)*this._getHeightOfLine(this.ctx,n)/this.lineHeight-this.getCurrentCharFontSize(n,s)*(1-this._fontSizeFraction)),0!==this.charSpacing&&s===this._textLines[n].length&&(a-=this._getWidthOfCharSpacing()),i={top:o,left:a>0?a:0,lineLeft:r},this.cursorOffsetCache=i,this.cursorOffsetCache},renderCursor:function(t,e){var i=this.get2DCursorLocation(),r=i.lineIndex,n=i.charIndex,s=this.getCurrentCharFontSize(r,n),o=t.leftOffset,a=this.scaleX*this.canvas.getZoom(),h=this.cursorWidth/a;e.fillStyle=this.getCurrentCharColor(r,n),e.globalAlpha=this.__isMousedown?1:this._currentCursorOpacity,e.fillRect(t.left+o-h/2,t.top+t.topOffset,h,s)},renderSelection:function(t,e,i){i.fillStyle=this.selectionColor;for(var r=this.get2DCursorLocation(this.selectionStart),n=this.get2DCursorLocation(this.selectionEnd),s=r.lineIndex,o=n.lineIndex,a=s;a<=o;a++){var h=this._getLineLeftOffset(this._getLineWidth(i,a))||0,c=this._getHeightOfLine(this.ctx,a),l=0,u=0,f=this._textLines[a];if(a===s){for(var d=0,g=f.length;d<g;d++)d>=r.charIndex&&(a!==o||d<n.charIndex)&&(u+=this._getWidthOfChar(i,f[d],a,d)),d<r.charIndex&&(h+=this._getWidthOfChar(i,f[d],a,d));d===f.length&&(u-=this._getWidthOfCharSpacing())}else if(a>s&&a<o)u+=this._getLineWidth(i,a)||5;else if(a===o){for(var p=0,v=n.charIndex;p<v;p++)u+=this._getWidthOfChar(i,f[p],a,p);n.charIndex===f.length&&(u-=this._getWidthOfCharSpacing())}l=c,(this.lineHeight<1||a===o&&this.lineHeight>1)&&(c/=this.lineHeight),i.fillRect(e.left+h,e.top+e.topOffset,u>0?u:0,c),e.topOffset+=l}},_renderChars:function(t,e,i,r,n,s,o){if(this.isEmptyStyles())return this._renderCharsFast(t,e,i,r,n);o=o||0;var a,h,c=this._getHeightOfLine(e,s),l="";e.save(),n-=c/this.lineHeight*this._fontSizeFraction;for(var u=o,f=i.length+o;u<=f;u++)a=a||this.getCurrentCharStyle(s,u),h=this.getCurrentCharStyle(s,u+1),(this._hasStyleChanged(a,h)||u===f)&&(this._renderChar(t,e,s,u-1,l,r,n,c),l="",a=h),l+=i[u-o];e.restore()},_renderCharsFast:function(t,e,i,r,n){"fillText"===t&&this.fill&&this.callSuper("_renderChars",t,e,i,r,n),"strokeText"===t&&(this.stroke&&this.strokeWidth>0||this.skipFillStrokeCheck)&&this.callSuper("_renderChars",t,e,i,r,n)},_renderChar:function(t,e,i,r,n,s,o,a){var h,c,l,u,f,d,g,p,v,b=this._getStyleDeclaration(i,r);if(b?(c=this._getHeightOfChar(e,n,i,r),u=b.stroke,l=b.fill,d=b.textDecoration):c=this.fontSize,u=(u||this.stroke)&&"strokeText"===t,l=(l||this.fill)&&"fillText"===t,b&&e.save(),h=this._applyCharStylesGetWidth(e,n,i,r,b||null),d=d||this.textDecoration,b&&b.textBackgroundColor&&this._removeShadow(e),0!==this.charSpacing){p=this._getWidthOfCharSpacing(),g=n.split(""),h=0;for(var m,y=0,_=g.length;y<_;y++)m=g[y],l&&e.fillText(m,s+h,o),u&&e.strokeText(m,s+h,o),v=e.measureText(m).width+p,h+=v>0?v:0}else l&&e.fillText(n,s,o),u&&e.strokeText(n,s,o);(d||""!==d)&&(f=this._fontSizeFraction*a/this.lineHeight,this._renderCharDecoration(e,d,s,o,f,h,c)),b&&e.restore(),e.translate(h,0)},_hasStyleChanged:function(t,e){return t.fill!==e.fill||t.fontSize!==e.fontSize||t.textBackgroundColor!==e.textBackgroundColor||t.textDecoration!==e.textDecoration||t.fontFamily!==e.fontFamily||t.fontWeight!==e.fontWeight||t.fontStyle!==e.fontStyle||t.stroke!==e.stroke||t.strokeWidth!==e.strokeWidth},_renderCharDecoration:function(t,e,i,r,n,s,o){if(e){var a,h,c=o/15,l={underline:r+o/10,"line-through":r-o*(this._fontSizeFraction+this._fontSizeMult-1)+c,overline:r-(this._fontSizeMult-this._fontSizeFraction)*o},u=["underline","line-through","overline"];for(a=0;a<u.length;a++)h=u[a],e.indexOf(h)>-1&&t.fillRect(i,l[h],s,c)}},_renderTextLine:function(t,e,i,r,n,s){this.isEmptyStyles()||(n+=this.fontSize*(this._fontSizeFraction+.03)),this.callSuper("_renderTextLine",t,e,i,r,n,s)},_renderTextDecoration:function(t){if(this.isEmptyStyles())return this.callSuper("_renderTextDecoration",t)},_renderTextLinesBackground:function(t){this.callSuper("_renderTextLinesBackground",t);var e,i,r,n,s,o,a,h,c,l,u=0,f=this._getLeftOffset(),d=this._getTopOffset(),g="";t.save();for(var p=0,v=this._textLines.length;p<v;p++)if(e=this._getHeightOfLine(t,p),n=this._textLines[p],""!==n&&this.styles&&this._getLineStyle(p)){i=this._getLineWidth(t,p),r=this._getLineLeftOffset(i),a=h=c=l=0;for(var b=0,m=n.length;b<m;b++)o=this._getStyleDeclaration(p,b)||{},g!==o.textBackgroundColor&&(l&&c&&(t.fillStyle=g,t.fillRect(a,h,c,l)),a=h=c=l=0,g=o.textBackgroundColor||""),o.textBackgroundColor?(s=n[b],g===o.textBackgroundColor&&(g=o.textBackgroundColor,a||(a=f+r+this._getWidthOfCharsAt(t,p,b)),h=d+u,c+=this._getWidthOfChar(t,s,p,b),l=e/this.lineHeight)):g="";l&&c&&(t.fillStyle=g,t.fillRect(a,h,c,l),a=h=c=l=0),u+=e}else u+=e;t.restore()},_getCacheProp:function(t,e){return t+e.fontSize+e.fontWeight+e.fontStyle},_getFontCache:function(t){return fabric.charWidthsCache[t]||(fabric.charWidthsCache[t]={}),fabric.charWidthsCache[t]},_applyCharStylesGetWidth:function(e,i,r,n,s){var o,a,h,c=s||this._getStyleDeclaration(r,n),l=t(c);if(this._applyFontStyles(l),h=this._getFontCache(l.fontFamily),a=this._getCacheProp(i,l),!c&&h[a]&&this.caching)return h[a];"string"==typeof l.shadow&&(l.shadow=new fabric.Shadow(l.shadow));var u=l.fill||this.fill;return e.fillStyle=u.toLive?u.toLive(e,this):u,l.stroke&&(e.strokeStyle=l.stroke&&l.stroke.toLive?l.stroke.toLive(e,this):l.stroke),e.lineWidth=l.strokeWidth||this.strokeWidth,e.font=this._getFontDeclaration.call(l),l.shadow&&(l.scaleX=this.scaleX,l.scaleY=this.scaleY,l.canvas=this.canvas,l.getObjectScaling=this.getObjectScaling,this._setShadow.call(l,e)),this.caching&&h[a]?h[a]:(o=e.measureText(i).width,this.caching&&(h[a]=o),o)},_applyFontStyles:function(t){t.fontFamily||(t.fontFamily=this.fontFamily),t.fontSize||(t.fontSize=this.fontSize),t.fontWeight||(t.fontWeight=this.fontWeight),t.fontStyle||(t.fontStyle=this.fontStyle)},_getStyleDeclaration:function(e,i,r){return r?this.styles[e]&&this.styles[e][i]?t(this.styles[e][i]):{}:this.styles[e]&&this.styles[e][i]?this.styles[e][i]:null},_setStyleDeclaration:function(t,e,i){this.styles[t][e]=i},_deleteStyleDeclaration:function(t,e){delete this.styles[t][e]},_getLineStyle:function(t){return this.styles[t]},_setLineStyle:function(t,e){this.styles[t]=e},_deleteLineStyle:function(t){delete this.styles[t]},_getWidthOfChar:function(t,e,i,r){if(!this._isMeasuring&&"justify"===this.textAlign&&this._reSpacesAndTabs.test(e))return this._getWidthOfSpace(t,i);t.save();var n=this._applyCharStylesGetWidth(t,e,i,r);return 0!==this.charSpacing&&(n+=this._getWidthOfCharSpacing()),t.restore(),n>0?n:0},_getHeightOfChar:function(t,e,i){var r=this._getStyleDeclaration(e,i);return r&&r.fontSize?r.fontSize:this.fontSize},_getWidthOfCharsAt:function(t,e,i){var r,n,s=0;for(r=0;r<i;r++)n=this._textLines[e][r],s+=this._getWidthOfChar(t,n,e,r);return s},_measureLine:function(t,e){this._isMeasuring=!0;var i=this._getWidthOfCharsAt(t,e,this._textLines[e].length);return 0!==this.charSpacing&&(i-=this._getWidthOfCharSpacing()),this._isMeasuring=!1,i>0?i:0},_getWidthOfSpace:function(t,e){if(this.__widthOfSpace[e])return this.__widthOfSpace[e];var i=this._textLines[e],r=this._getWidthOfWords(t,i,e,0),n=this.width-r,s=i.length-i.replace(this._reSpacesAndTabs,"").length,o=Math.max(n/s,t.measureText(" ").width);return this.__widthOfSpace[e]=o,o},_getWidthOfWords:function(t,e,i,r){for(var n=0,s=0;s<e.length;s++){var o=e[s];o.match(/\s/)||(n+=this._getWidthOfChar(t,o,i,s+r))}return n},_getHeightOfLine:function(t,e){if(this.__lineHeights[e])return this.__lineHeights[e];for(var i=this._textLines[e],r=this._getHeightOfChar(t,e,0),n=1,s=i.length;n<s;n++){var o=this._getHeightOfChar(t,e,n);o>r&&(r=o);
}return this.__lineHeights[e]=r*this.lineHeight*this._fontSizeMult,this.__lineHeights[e]},_getTextHeight:function(t){for(var e,i=0,r=0,n=this._textLines.length;r<n;r++)e=this._getHeightOfLine(t,r),i+=r===n-1?e/this.lineHeight:e;return i},toObject:function(e){return fabric.util.object.extend(this.callSuper("toObject",e),{styles:t(this.styles,!0)})}}),fabric.IText.fromObject=function(t,e,i){return fabric.Object._fromObject("IText",t,e,i,"text")}}(),function(){var t=fabric.util.object.clone;fabric.util.object.extend(fabric.IText.prototype,{initBehavior:function(){this.initAddedHandler(),this.initRemovedHandler(),this.initCursorSelectionHandlers(),this.initDoubleClickSimulation(),this.mouseMoveHandler=this.mouseMoveHandler.bind(this)},onDeselect:function(){this.isEditing&&this.exitEditing(),this.selected=!1,this.callSuper("onDeselect")},initAddedHandler:function(){var t=this;this.on("added",function(){var e=t.canvas;e&&(e._hasITextHandlers||(e._hasITextHandlers=!0,t._initCanvasHandlers(e)),e._iTextInstances=e._iTextInstances||[],e._iTextInstances.push(t))})},initRemovedHandler:function(){var t=this;this.on("removed",function(){var e=t.canvas;e&&(e._iTextInstances=e._iTextInstances||[],fabric.util.removeFromArray(e._iTextInstances,t),0===e._iTextInstances.length&&(e._hasITextHandlers=!1,t._removeCanvasHandlers(e)))})},_initCanvasHandlers:function(t){t._mouseUpITextHandler=function(){t._iTextInstances&&t._iTextInstances.forEach(function(t){t.__isMousedown=!1})}.bind(this),t.on("mouse:up",t._mouseUpITextHandler)},_removeCanvasHandlers:function(t){t.off("mouse:up",t._mouseUpITextHandler)},_tick:function(){this._currentTickState=this._animateCursor(this,1,this.cursorDuration,"_onTickComplete")},_animateCursor:function(t,e,i,r){var n;return n={isAborted:!1,abort:function(){this.isAborted=!0}},t.animate("_currentCursorOpacity",e,{duration:i,onComplete:function(){n.isAborted||t[r]()},onChange:function(){t.canvas&&t.selectionStart===t.selectionEnd&&t.renderCursorOrSelection()},abort:function(){return n.isAborted}}),n},_onTickComplete:function(){var t=this;this._cursorTimeout1&&clearTimeout(this._cursorTimeout1),this._cursorTimeout1=setTimeout(function(){t._currentTickCompleteState=t._animateCursor(t,0,this.cursorDuration/2,"_tick")},100)},initDelayedCursor:function(t){var e=this,i=t?0:this.cursorDelay;this.abortCursorAnimation(),this._currentCursorOpacity=1,this._cursorTimeout2=setTimeout(function(){e._tick()},i)},abortCursorAnimation:function(){var t=this._currentTickState||this._currentTickCompleteState;this._currentTickState&&this._currentTickState.abort(),this._currentTickCompleteState&&this._currentTickCompleteState.abort(),clearTimeout(this._cursorTimeout1),clearTimeout(this._cursorTimeout2),this._currentCursorOpacity=0,t&&this.canvas&&this.canvas.clearContext(this.canvas.contextTop||this.ctx)},selectAll:function(){this.selectionStart=0,this.selectionEnd=this.text.length,this._fireSelectionChanged(),this._updateTextarea()},getSelectedText:function(){return this.text.slice(this.selectionStart,this.selectionEnd)},findWordBoundaryLeft:function(t){var e=0,i=t-1;if(this._reSpace.test(this.text.charAt(i)))for(;this._reSpace.test(this.text.charAt(i));)e++,i--;for(;/\S/.test(this.text.charAt(i))&&i>-1;)e++,i--;return t-e},findWordBoundaryRight:function(t){var e=0,i=t;if(this._reSpace.test(this.text.charAt(i)))for(;this._reSpace.test(this.text.charAt(i));)e++,i++;for(;/\S/.test(this.text.charAt(i))&&i<this.text.length;)e++,i++;return t+e},findLineBoundaryLeft:function(t){for(var e=0,i=t-1;!/\n/.test(this.text.charAt(i))&&i>-1;)e++,i--;return t-e},findLineBoundaryRight:function(t){for(var e=0,i=t;!/\n/.test(this.text.charAt(i))&&i<this.text.length;)e++,i++;return t+e},getNumNewLinesInSelectedText:function(){for(var t=this.getSelectedText(),e=0,i=0,r=t.length;i<r;i++)"\n"===t[i]&&e++;return e},searchWordBoundary:function(t,e){for(var i=this._reSpace.test(this.text.charAt(t))?t-1:t,r=this.text.charAt(i),n=/[ \n\.,;!\?\-]/;!n.test(r)&&i>0&&i<this.text.length;)i+=e,r=this.text.charAt(i);return n.test(r)&&"\n"!==r&&(i+=1===e?0:1),i},selectWord:function(t){t=t||this.selectionStart;var e=this.searchWordBoundary(t,-1),i=this.searchWordBoundary(t,1);this.selectionStart=e,this.selectionEnd=i,this._fireSelectionChanged(),this._updateTextarea(),this.renderCursorOrSelection()},selectLine:function(t){t=t||this.selectionStart;var e=this.findLineBoundaryLeft(t),i=this.findLineBoundaryRight(t);this.selectionStart=e,this.selectionEnd=i,this._fireSelectionChanged(),this._updateTextarea()},enterEditing:function(t){if(!this.isEditing&&this.editable)return this.canvas&&this.exitEditingOnOthers(this.canvas),this.isEditing=!0,this.selected=!0,this.initHiddenTextarea(t),this.hiddenTextarea.focus(),this._updateTextarea(),this._saveEditingProps(),this._setEditingProps(),this._textBeforeEdit=this.text,this._tick(),this.fire("editing:entered"),this._fireSelectionChanged(),this.canvas?(this.canvas.fire("text:editing:entered",{target:this}),this.initMouseMoveHandler(),this.canvas.renderAll(),this):this},exitEditingOnOthers:function(t){t._iTextInstances&&t._iTextInstances.forEach(function(t){t.selected=!1,t.isEditing&&t.exitEditing()})},initMouseMoveHandler:function(){this.canvas.on("mouse:move",this.mouseMoveHandler)},mouseMoveHandler:function(t){if(this.__isMousedown&&this.isEditing){var e=this.getSelectionStartFromPointer(t.e),i=this.selectionStart,r=this.selectionEnd;(e===this.__selectionStartOnMouseDown&&i!==r||i!==e&&r!==e)&&(e>this.__selectionStartOnMouseDown?(this.selectionStart=this.__selectionStartOnMouseDown,this.selectionEnd=e):(this.selectionStart=e,this.selectionEnd=this.__selectionStartOnMouseDown),this.selectionStart===i&&this.selectionEnd===r||(this.restartCursorIfNeeded(),this._fireSelectionChanged(),this._updateTextarea(),this.renderCursorOrSelection()))}},_setEditingProps:function(){this.hoverCursor="text",this.canvas&&(this.canvas.defaultCursor=this.canvas.moveCursor="text"),this.borderColor=this.editingBorderColor,this.hasControls=this.selectable=!1,this.lockMovementX=this.lockMovementY=!0},_updateTextarea:function(){if(this.hiddenTextarea&&!this.inCompositionMode&&(this.cursorOffsetCache={},this.hiddenTextarea.value=this.text,this.hiddenTextarea.selectionStart=this.selectionStart,this.hiddenTextarea.selectionEnd=this.selectionEnd,this.selectionStart===this.selectionEnd)){var t=this._calcTextareaPosition();this.hiddenTextarea.style.left=t.left,this.hiddenTextarea.style.top=t.top,this.hiddenTextarea.style.fontSize=t.fontSize}},_calcTextareaPosition:function(){if(!this.canvas)return{x:1,y:1};var t=this.text.split(""),e=this._getCursorBoundaries(t,"cursor"),i=this.get2DCursorLocation(),r=i.lineIndex,n=i.charIndex,s=this.getCurrentCharFontSize(r,n),o=e.leftOffset,a=this.calcTransformMatrix(),h={x:e.left+o,y:e.top+e.topOffset+s},c=this.canvas.upperCanvasEl,l=c.width-s,u=c.height-s;return h=fabric.util.transformPoint(h,a),h=fabric.util.transformPoint(h,this.canvas.viewportTransform),h.x<0&&(h.x=0),h.x>l&&(h.x=l),h.y<0&&(h.y=0),h.y>u&&(h.y=u),h.x+=this.canvas._offset.left,h.y+=this.canvas._offset.top,{left:h.x+"px",top:h.y+"px",fontSize:s}},_saveEditingProps:function(){this._savedProps={hasControls:this.hasControls,borderColor:this.borderColor,lockMovementX:this.lockMovementX,lockMovementY:this.lockMovementY,hoverCursor:this.hoverCursor,defaultCursor:this.canvas&&this.canvas.defaultCursor,moveCursor:this.canvas&&this.canvas.moveCursor}},_restoreEditingProps:function(){this._savedProps&&(this.hoverCursor=this._savedProps.overCursor,this.hasControls=this._savedProps.hasControls,this.borderColor=this._savedProps.borderColor,this.lockMovementX=this._savedProps.lockMovementX,this.lockMovementY=this._savedProps.lockMovementY,this.canvas&&(this.canvas.defaultCursor=this._savedProps.defaultCursor,this.canvas.moveCursor=this._savedProps.moveCursor))},exitEditing:function(){var t=this._textBeforeEdit!==this.text;return this.selected=!1,this.isEditing=!1,this.selectable=!0,this.selectionEnd=this.selectionStart,this.hiddenTextarea&&(this.hiddenTextarea.blur&&this.hiddenTextarea.blur(),this.canvas&&this.hiddenTextarea.parentNode.removeChild(this.hiddenTextarea),this.hiddenTextarea=null),this.abortCursorAnimation(),this._restoreEditingProps(),this._currentCursorOpacity=0,this.fire("editing:exited"),t&&this.fire("modified"),this.canvas&&(this.canvas.off("mouse:move",this.mouseMoveHandler),this.canvas.fire("text:editing:exited",{target:this}),t&&this.canvas.fire("object:modified",{target:this})),this},_removeExtraneousStyles:function(){for(var t in this.styles)this._textLines[t]||delete this.styles[t]},_removeCharsFromTo:function(t,e){for(;e!==t;)this._removeSingleCharAndStyle(t+1),e--;this.selectionStart=t,this.selectionEnd=t},_removeSingleCharAndStyle:function(t){var e="\n"===this.text[t-1],i=e?t:t-1;this.removeStyleObject(e,i),this.text=this.text.slice(0,t-1)+this.text.slice(t),this._textLines=this._splitTextIntoLines()},insertChars:function(t,e){var i;if(this.selectionEnd-this.selectionStart>1&&this._removeCharsFromTo(this.selectionStart,this.selectionEnd),!e&&this.isEmptyStyles())return void this.insertChar(t,!1);for(var r=0,n=t.length;r<n;r++)e&&(i=fabric.util.object.clone(fabric.copiedTextStyle[r],!0)),this.insertChar(t[r],r<n-1,i)},insertChar:function(t,e,i){var r="\n"===this.text[this.selectionStart];this.text=this.text.slice(0,this.selectionStart)+t+this.text.slice(this.selectionEnd),this._textLines=this._splitTextIntoLines(),this.insertStyleObjects(t,r,i),this.selectionStart+=t.length,this.selectionEnd=this.selectionStart,e||(this._updateTextarea(),this.setCoords(),this._fireSelectionChanged(),this.fire("changed"),this.restartCursorIfNeeded(),this.canvas&&(this.canvas.fire("text:changed",{target:this}),this.canvas.renderAll()))},restartCursorIfNeeded:function(){this._currentTickState&&!this._currentTickState.isAborted&&this._currentTickCompleteState&&!this._currentTickCompleteState.isAborted||this.initDelayedCursor()},insertNewlineStyleObject:function(e,i,r){this.shiftLineStyles(e,1);var n={},s={};if(this.styles[e]&&this.styles[e][i-1]&&(n=this.styles[e][i-1]),r&&n)s[0]=t(n),this.styles[e+1]=s;else{var o=!1;for(var a in this.styles[e]){var h=parseInt(a,10);h>=i&&(o=!0,s[h-i]=this.styles[e][a],delete this.styles[e][a])}o&&(this.styles[e+1]=s)}this._forceClearCache=!0},insertCharStyleObject:function(e,i,r){var n=this.styles[e],s=t(n);0!==i||r||(i=1);for(var o in s){var a=parseInt(o,10);a>=i&&(n[a+1]=s[a],s[a-1]||delete n[a])}var h=r||t(n[i-1]);h&&(this.styles[e][i]=h),this._forceClearCache=!0},insertStyleObjects:function(t,e,i){var r=this.get2DCursorLocation(),n=r.lineIndex,s=r.charIndex;this._getLineStyle(n)||this._setLineStyle(n,{}),"\n"===t?this.insertNewlineStyleObject(n,s,e):this.insertCharStyleObject(n,s,i)},shiftLineStyles:function(e,i){var r=t(this.styles);for(var n in r){var s=parseInt(n,10);s<=e&&delete r[s]}for(var n in this.styles){var s=parseInt(n,10);s>e&&(this.styles[s+i]=r[s],r[s-i]||delete this.styles[s])}},removeStyleObject:function(t,e){var i=this.get2DCursorLocation(e),r=i.lineIndex,n=i.charIndex;this._removeStyleObject(t,i,r,n)},_getTextOnPreviousLine:function(t){return this._textLines[t-1]},_removeStyleObject:function(e,i,r,n){if(e){var s=this._getTextOnPreviousLine(i.lineIndex),o=s?s.length:0;this.styles[r-1]||(this.styles[r-1]={});for(n in this.styles[r])this.styles[r-1][parseInt(n,10)+o]=this.styles[r][n];this.shiftLineStyles(i.lineIndex,-1)}else{var a=this.styles[r];a&&delete a[n];var h=t(a);for(var c in h){var l=parseInt(c,10);l>=n&&0!==l&&(a[l-1]=h[l],delete a[l])}}},insertNewline:function(){this.insertChars("\n")},setSelectionStartEndWithShift:function(t,e,i){i<=t?(e===t?this._selectionDirection="left":"right"===this._selectionDirection&&(this._selectionDirection="left",this.selectionEnd=t),this.selectionStart=i):i>t&&i<e?"right"===this._selectionDirection?this.selectionEnd=i:this.selectionStart=i:(e===t?this._selectionDirection="right":"left"===this._selectionDirection&&(this._selectionDirection="right",this.selectionStart=e),this.selectionEnd=i)},setSelectionInBoundaries:function(){var t=this.text.length;this.selectionStart>t?this.selectionStart=t:this.selectionStart<0&&(this.selectionStart=0),this.selectionEnd>t?this.selectionEnd=t:this.selectionEnd<0&&(this.selectionEnd=0)}})}(),fabric.util.object.extend(fabric.IText.prototype,{initDoubleClickSimulation:function(){this.__lastClickTime=+new Date,this.__lastLastClickTime=+new Date,this.__lastPointer={},this.on("mousedown",this.onMouseDown.bind(this))},onMouseDown:function(t){this.__newClickTime=+new Date;var e=this.canvas.getPointer(t.e);this.isTripleClick(e)?(this.fire("tripleclick",t),this._stopEvent(t.e)):this.isDoubleClick(e)&&(this.fire("dblclick",t),this._stopEvent(t.e)),this.__lastLastClickTime=this.__lastClickTime,this.__lastClickTime=this.__newClickTime,this.__lastPointer=e,this.__lastIsEditing=this.isEditing,this.__lastSelected=this.selected},isDoubleClick:function(t){return this.__newClickTime-this.__lastClickTime<500&&this.__lastPointer.x===t.x&&this.__lastPointer.y===t.y&&this.__lastIsEditing},isTripleClick:function(t){return this.__newClickTime-this.__lastClickTime<500&&this.__lastClickTime-this.__lastLastClickTime<500&&this.__lastPointer.x===t.x&&this.__lastPointer.y===t.y},_stopEvent:function(t){t.preventDefault&&t.preventDefault(),t.stopPropagation&&t.stopPropagation()},initCursorSelectionHandlers:function(){this.initMousedownHandler(),this.initMouseupHandler(),this.initClicks()},initClicks:function(){this.on("dblclick",function(t){this.selectWord(this.getSelectionStartFromPointer(t.e))}),this.on("tripleclick",function(t){this.selectLine(this.getSelectionStartFromPointer(t.e))})},initMousedownHandler:function(){this.on("mousedown",function(t){if(this.editable){var e=this.canvas.getPointer(t.e);this.__mousedownX=e.x,this.__mousedownY=e.y,this.__isMousedown=!0,this.selected&&this.setCursorByClick(t.e),this.isEditing&&(this.__selectionStartOnMouseDown=this.selectionStart,this.selectionStart===this.selectionEnd&&this.abortCursorAnimation(),this.renderCursorOrSelection())}})},_isObjectMoved:function(t){var e=this.canvas.getPointer(t);return this.__mousedownX!==e.x||this.__mousedownY!==e.y},initMouseupHandler:function(){this.on("mouseup",function(t){this.__isMousedown=!1,this.editable&&!this._isObjectMoved(t.e)&&(this.__lastSelected&&!this.__corner&&(this.enterEditing(t.e),this.selectionStart===this.selectionEnd?this.initDelayedCursor(!0):this.renderCursorOrSelection()),this.selected=!0)})},setCursorByClick:function(t){var e=this.getSelectionStartFromPointer(t),i=this.selectionStart,r=this.selectionEnd;t.shiftKey?this.setSelectionStartEndWithShift(i,r,e):(this.selectionStart=e,this.selectionEnd=e),this.isEditing&&(this._fireSelectionChanged(),this._updateTextarea())},getSelectionStartFromPointer:function(t){for(var e,i,r=this.getLocalPointer(t),n=0,s=0,o=0,a=0,h=0,c=this._textLines.length;h<c;h++){i=this._textLines[h],o+=this._getHeightOfLine(this.ctx,h)*this.scaleY;var l=this._getLineWidth(this.ctx,h),u=this._getLineLeftOffset(l);s=u*this.scaleX;for(var f=0,d=i.length;f<d;f++){if(n=s,s+=this._getWidthOfChar(this.ctx,i[f],h,this.flipX?d-f:f)*this.scaleX,!(o<=r.y||s<=r.x))return this._getNewSelectionStartFromOffset(r,n,s,a+h,d);a++}if(r.y<o)return this._getNewSelectionStartFromOffset(r,n,s,a+h-1,d)}if("undefined"==typeof e)return this.text.length},_getNewSelectionStartFromOffset:function(t,e,i,r,n){var s=t.x-e,o=i-t.x,a=o>s?0:1,h=r+a;return this.flipX&&(h=n-h),h>this.text.length&&(h=this.text.length),h}}),fabric.util.object.extend(fabric.IText.prototype,{initHiddenTextarea:function(){this.hiddenTextarea=fabric.document.createElement("textarea"),this.hiddenTextarea.setAttribute("autocapitalize","off");var t=this._calcTextareaPosition();this.hiddenTextarea.style.cssText="white-space: nowrap; position: absolute; top: "+t.top+"; left: "+t.left+"; opacity: 0; width: 1px; height: 1px; z-index: -999;",fabric.document.body.appendChild(this.hiddenTextarea),fabric.util.addListener(this.hiddenTextarea,"keydown",this.onKeyDown.bind(this)),fabric.util.addListener(this.hiddenTextarea,"keyup",this.onKeyUp.bind(this)),fabric.util.addListener(this.hiddenTextarea,"input",this.onInput.bind(this)),fabric.util.addListener(this.hiddenTextarea,"copy",this.copy.bind(this)),fabric.util.addListener(this.hiddenTextarea,"cut",this.cut.bind(this)),fabric.util.addListener(this.hiddenTextarea,"paste",this.paste.bind(this)),fabric.util.addListener(this.hiddenTextarea,"compositionstart",this.onCompositionStart.bind(this)),fabric.util.addListener(this.hiddenTextarea,"compositionupdate",this.onCompositionUpdate.bind(this)),fabric.util.addListener(this.hiddenTextarea,"compositionend",this.onCompositionEnd.bind(this)),!this._clickHandlerInitialized&&this.canvas&&(fabric.util.addListener(this.canvas.upperCanvasEl,"click",this.onClick.bind(this)),this._clickHandlerInitialized=!0)},_keysMap:{8:"removeChars",9:"exitEditing",27:"exitEditing",13:"insertNewline",33:"moveCursorUp",34:"moveCursorDown",35:"moveCursorRight",36:"moveCursorLeft",37:"moveCursorLeft",38:"moveCursorUp",39:"moveCursorRight",40:"moveCursorDown",46:"forwardDelete"},_ctrlKeysMapUp:{67:"copy",88:"cut"},_ctrlKeysMapDown:{65:"selectAll"},onClick:function(){this.hiddenTextarea&&this.hiddenTextarea.focus()},onKeyDown:function(t){if(this.isEditing){if(t.keyCode in this._keysMap)this[this._keysMap[t.keyCode]](t);else{if(!(t.keyCode in this._ctrlKeysMapDown&&(t.ctrlKey||t.metaKey)))return;this[this._ctrlKeysMapDown[t.keyCode]](t)}t.stopImmediatePropagation(),t.preventDefault(),t.keyCode>=33&&t.keyCode<=40?(this.clearContextTop(),this.renderCursorOrSelection()):this.canvas&&this.canvas.renderAll()}},onKeyUp:function(t){return!this.isEditing||this._copyDone?void(this._copyDone=!1):void(t.keyCode in this._ctrlKeysMapUp&&(t.ctrlKey||t.metaKey)&&(this[this._ctrlKeysMapUp[t.keyCode]](t),t.stopImmediatePropagation(),t.preventDefault(),this.canvas&&this.canvas.renderAll()))},onInput:function(t){if(this.isEditing&&!this.inCompositionMode){var e,i,r,n=this.selectionStart||0,s=this.selectionEnd||0,o=this.text.length,a=this.hiddenTextarea.value.length;a>o?(r="left"===this._selectionDirection?s:n,e=a-o,i=this.hiddenTextarea.value.slice(r,r+e)):(e=a-o+s-n,i=this.hiddenTextarea.value.slice(n,n+e)),this.insertChars(i),t.stopPropagation()}},onCompositionStart:function(){this.inCompositionMode=!0,this.prevCompositionLength=0,this.compositionStart=this.selectionStart},onCompositionEnd:function(){this.inCompositionMode=!1},onCompositionUpdate:function(t){var e=t.data;this.selectionStart=this.compositionStart,this.selectionEnd=this.selectionEnd===this.selectionStart?this.compositionStart+this.prevCompositionLength:this.selectionEnd,this.insertChars(e,!1),this.prevCompositionLength=e.length},forwardDelete:function(t){if(this.selectionStart===this.selectionEnd){if(this.selectionStart===this.text.length)return;this.moveCursorRight(t)}this.removeChars(t)},copy:function(t){if(this.selectionStart!==this.selectionEnd){var e=this.getSelectedText(),i=this._getClipboardData(t);i&&i.setData("text",e),fabric.copiedText=e,fabric.copiedTextStyle=this.getSelectionStyles(this.selectionStart,this.selectionEnd),t.stopImmediatePropagation(),t.preventDefault(),this._copyDone=!0}},paste:function(t){var e=null,i=this._getClipboardData(t),r=!0;i?(e=i.getData("text").replace(/\r/g,""),fabric.copiedTextStyle&&fabric.copiedText===e||(r=!1)):e=fabric.copiedText,e&&this.insertChars(e,r),t.stopImmediatePropagation(),t.preventDefault()},cut:function(t){this.selectionStart!==this.selectionEnd&&(this.copy(t),this.removeChars(t))},_getClipboardData:function(t){return t&&t.clipboardData||fabric.window.clipboardData},_getWidthBeforeCursor:function(t,e){for(var i,r=this._textLines[t].slice(0,e),n=this._getLineWidth(this.ctx,t),s=this._getLineLeftOffset(n),o=0,a=r.length;o<a;o++)i=r[o],s+=this._getWidthOfChar(this.ctx,i,t,o);return s},getDownCursorOffset:function(t,e){var i=this._getSelectionForOffset(t,e),r=this.get2DCursorLocation(i),n=r.lineIndex;if(n===this._textLines.length-1||t.metaKey||34===t.keyCode)return this.text.length-i;var s=r.charIndex,o=this._getWidthBeforeCursor(n,s),a=this._getIndexOnLine(n+1,o),h=this._textLines[n].slice(s);return h.length+a+2},_getSelectionForOffset:function(t,e){return t.shiftKey&&this.selectionStart!==this.selectionEnd&&e?this.selectionEnd:this.selectionStart},getUpCursorOffset:function(t,e){var i=this._getSelectionForOffset(t,e),r=this.get2DCursorLocation(i),n=r.lineIndex;if(0===n||t.metaKey||33===t.keyCode)return-i;var s=r.charIndex,o=this._getWidthBeforeCursor(n,s),a=this._getIndexOnLine(n-1,o),h=this._textLines[n].slice(0,s);return-this._textLines[n-1].length+a-h.length},_getIndexOnLine:function(t,e){for(var i,r=this._getLineWidth(this.ctx,t),n=this._textLines[t],s=this._getLineLeftOffset(r),o=s,a=0,h=0,c=n.length;h<c;h++){var l=n[h],u=this._getWidthOfChar(this.ctx,l,t,h);if(o+=u,o>e){i=!0;var f=o-u,d=o,g=Math.abs(f-e),p=Math.abs(d-e);a=p<g?h:h-1;break}}return i||(a=n.length-1),a},moveCursorDown:function(t){this.selectionStart>=this.text.length&&this.selectionEnd>=this.text.length||this._moveCursorUpOrDown("Down",t)},moveCursorUp:function(t){0===this.selectionStart&&0===this.selectionEnd||this._moveCursorUpOrDown("Up",t)},_moveCursorUpOrDown:function(t,e){var i="get"+t+"CursorOffset",r=this[i](e,"right"===this._selectionDirection);e.shiftKey?this.moveCursorWithShift(r):this.moveCursorWithoutShift(r),0!==r&&(this.setSelectionInBoundaries(),this.abortCursorAnimation(),this._currentCursorOpacity=1,this.initDelayedCursor(),this._fireSelectionChanged(),this._updateTextarea())},moveCursorWithShift:function(t){var e="left"===this._selectionDirection?this.selectionStart+t:this.selectionEnd+t;return this.setSelectionStartEndWithShift(this.selectionStart,this.selectionEnd,e),0!==t},moveCursorWithoutShift:function(t){return t<0?(this.selectionStart+=t,this.selectionEnd=this.selectionStart):(this.selectionEnd+=t,this.selectionStart=this.selectionEnd),0!==t},moveCursorLeft:function(t){0===this.selectionStart&&0===this.selectionEnd||this._moveCursorLeftOrRight("Left",t)},_move:function(t,e,i){var r;if(t.altKey)r=this["findWordBoundary"+i](this[e]);else{if(!t.metaKey&&35!==t.keyCode&&36!==t.keyCode)return this[e]+="Left"===i?-1:1,!0;r=this["findLineBoundary"+i](this[e])}if(void 0!==typeof r&&this[e]!==r)return this[e]=r,!0},_moveLeft:function(t,e){return this._move(t,e,"Left")},_moveRight:function(t,e){return this._move(t,e,"Right")},moveCursorLeftWithoutShift:function(t){var e=!0;return this._selectionDirection="left",this.selectionEnd===this.selectionStart&&0!==this.selectionStart&&(e=this._moveLeft(t,"selectionStart")),this.selectionEnd=this.selectionStart,e},moveCursorLeftWithShift:function(t){return"right"===this._selectionDirection&&this.selectionStart!==this.selectionEnd?this._moveLeft(t,"selectionEnd"):0!==this.selectionStart?(this._selectionDirection="left",this._moveLeft(t,"selectionStart")):void 0},moveCursorRight:function(t){this.selectionStart>=this.text.length&&this.selectionEnd>=this.text.length||this._moveCursorLeftOrRight("Right",t)},_moveCursorLeftOrRight:function(t,e){var i="moveCursor"+t+"With";this._currentCursorOpacity=1,i+=e.shiftKey?"Shift":"outShift",this[i](e)&&(this.abortCursorAnimation(),this.initDelayedCursor(),this._fireSelectionChanged(),this._updateTextarea())},moveCursorRightWithShift:function(t){return"left"===this._selectionDirection&&this.selectionStart!==this.selectionEnd?this._moveRight(t,"selectionStart"):this.selectionEnd!==this.text.length?(this._selectionDirection="right",this._moveRight(t,"selectionEnd")):void 0},moveCursorRightWithoutShift:function(t){var e=!0;return this._selectionDirection="right",this.selectionStart===this.selectionEnd?(e=this._moveRight(t,"selectionStart"),this.selectionEnd=this.selectionStart):this.selectionStart=this.selectionEnd,e},removeChars:function(t){this.selectionStart===this.selectionEnd?this._removeCharsNearCursor(t):this._removeCharsFromTo(this.selectionStart,this.selectionEnd),this.set("dirty",!0),this.setSelectionEnd(this.selectionStart),this._removeExtraneousStyles(),this.canvas&&this.canvas.renderAll(),this.setCoords(),this.fire("changed"),this.canvas&&this.canvas.fire("text:changed",{target:this})},_removeCharsNearCursor:function(t){if(0!==this.selectionStart)if(t.metaKey){var e=this.findLineBoundaryLeft(this.selectionStart);this._removeCharsFromTo(e,this.selectionStart),this.setSelectionStart(e)}else if(t.altKey){var i=this.findWordBoundaryLeft(this.selectionStart);this._removeCharsFromTo(i,this.selectionStart),this.setSelectionStart(i)}else this._removeSingleCharAndStyle(this.selectionStart),this.setSelectionStart(this.selectionStart-1)}}),function(){var t=fabric.util.toFixed,e=fabric.Object.NUM_FRACTION_DIGITS;fabric.util.object.extend(fabric.IText.prototype,{_setSVGTextLineText:function(t,e,i,r,n,s){this._getLineStyle(t)?this._setSVGTextLineChars(t,e,i,r,s):fabric.Text.prototype._setSVGTextLineText.call(this,t,e,i,r,n)},_setSVGTextLineChars:function(t,e,i,r,n){for(var s=this._textLines[t],o=0,a=this._getLineLeftOffset(this._getLineWidth(this.ctx,t))-this.width/2,h=this._getSVGLineTopOffset(t),c=this._getHeightOfLine(this.ctx,t),l=0,u=s.length;l<u;l++){var f=this._getStyleDeclaration(t,l)||{};e.push(this._createTextCharSpan(s[l],f,a,h.lineTop+h.offset,o));var d=this._getWidthOfChar(this.ctx,s[l],t,l);f.textBackgroundColor&&n.push(this._createTextCharBg(f,a,h.lineTop,c,d,o)),o+=d}},_getSVGLineTopOffset:function(t){for(var e=0,i=0,r=0;r<t;r++)e+=this._getHeightOfLine(this.ctx,r);return i=this._getHeightOfLine(this.ctx,r),{lineTop:e,offset:(this._fontSizeMult-this._fontSizeFraction)*i/(this.lineHeight*this._fontSizeMult)}},_createTextCharBg:function(i,r,n,s,o,a){return['\t\t<rect fill="',i.textBackgroundColor,'" x="',t(r+a,e),'" y="',t(n-this.height/2,e),'" width="',t(o,e),'" height="',t(s/this.lineHeight,e),'"></rect>\n'].join("")},_createTextCharSpan:function(i,r,n,s,o){var a=this.getSvgStyles.call(fabric.util.object.extend({visible:!0,fill:this.fill,stroke:this.stroke,type:"text",getSvgFilter:fabric.Object.prototype.getSvgFilter},r));return['\t\t\t<tspan x="',t(n+o,e),'" y="',t(s-this.height/2,e),'" ',r.fontFamily?'font-family="'+r.fontFamily.replace(/"/g,"'")+'" ':"",r.fontSize?'font-size="'+r.fontSize+'" ':"",r.fontStyle?'font-style="'+r.fontStyle+'" ':"",r.fontWeight?'font-weight="'+r.fontWeight+'" ':"",r.textDecoration?'text-decoration="'+r.textDecoration+'" ':"",'style="',a,'">',fabric.util.string.escapeXml(i),"</tspan>\n"].join("")}})}(),function(t){"use strict";var e=t.fabric||(t.fabric={});e.Textbox=e.util.createClass(e.IText,e.Observable,{type:"textbox",minWidth:20,dynamicMinWidth:2,__cachedLines:null,lockScalingY:!0,lockScalingFlip:!0,noScaleCache:!1,initialize:function(t,i){this.callSuper("initialize",t,i),this.setControlsVisibility(e.Textbox.getTextboxControlVisibility()),this.ctx=this.objectCaching?this._cacheContext:e.util.createCanvasElement().getContext("2d"),this._dimensionAffectingProps.push("width")},_initDimensions:function(t){this.__skipDimension||(t||(t=e.util.createCanvasElement().getContext("2d"),this._setTextStyles(t),this.clearContextTop()),this.dynamicMinWidth=0,this._textLines=this._splitTextIntoLines(t),this.dynamicMinWidth>this.width&&this._set("width",this.dynamicMinWidth),this._clearCache(),this.height=this._getTextHeight(t))},_generateStyleMap:function(){for(var t=0,e=0,i=0,r={},n=0;n<this._textLines.length;n++)"\n"===this.text[i]&&n>0?(e=0,i++,t++):" "===this.text[i]&&n>0&&(e++,i++),r[n]={line:t,offset:e},i+=this._textLines[n].length,e+=this._textLines[n].length;return r},_getStyleDeclaration:function(t,e,i){if(this._styleMap){var r=this._styleMap[t];if(!r)return i?{}:null;t=r.line,e=r.offset+e}return this.callSuper("_getStyleDeclaration",t,e,i)},_setStyleDeclaration:function(t,e,i){var r=this._styleMap[t];t=r.line,e=r.offset+e,this.styles[t][e]=i},_deleteStyleDeclaration:function(t,e){var i=this._styleMap[t];t=i.line,e=i.offset+e,delete this.styles[t][e]},_getLineStyle:function(t){var e=this._styleMap[t];return this.styles[e.line]},_setLineStyle:function(t,e){var i=this._styleMap[t];this.styles[i.line]=e},_deleteLineStyle:function(t){var e=this._styleMap[t];delete this.styles[e.line]},_wrapText:function(t,e){var i,r=e.split(this._reNewline),n=[];for(i=0;i<r.length;i++)n=n.concat(this._wrapLine(t,r[i],i));return n},_measureText:function(t,e,i,r){var n=0;r=r||0;for(var s=0,o=e.length;s<o;s++)n+=this._getWidthOfChar(t,e[s],i,s+r);return n},_wrapLine:function(t,e,i){for(var r=0,n=[],s="",o=e.split(" "),a="",h=0,c=" ",l=0,u=0,f=0,d=!0,g=this._getWidthOfCharSpacing(),p=0;p<o.length;p++)a=o[p],l=this._measureText(t,a,i,h),h+=a.length,r+=u+l-g,r>=this.width&&!d?(n.push(s),s="",r=l,d=!0):r+=g,d||(s+=c),s+=a,u=this._measureText(t,c,i,h),h++,d=!1,l>f&&(f=l);return p&&n.push(s),f>this.dynamicMinWidth&&(this.dynamicMinWidth=f-g),n},_splitTextIntoLines:function(t){t=t||this.ctx;var e=this.textAlign;this._styleMap=null,t.save(),this._setTextStyles(t),this.textAlign="left";var i=this._wrapText(t,this.text);return this.textAlign=e,t.restore(),this._textLines=i,this._styleMap=this._generateStyleMap(),i},setOnGroup:function(t,e){"scaleX"===t&&(this.set("scaleX",Math.abs(1/e)),this.set("width",this.get("width")*e/("undefined"==typeof this.__oldScaleX?1:this.__oldScaleX)),this.__oldScaleX=e)},get2DCursorLocation:function(t){"undefined"==typeof t&&(t=this.selectionStart);for(var e=this._textLines.length,i=0,r=0;r<e;r++){var n=this._textLines[r],s=n.length;if(t<=i+s)return{lineIndex:r,charIndex:t-i};i+=s,"\n"!==this.text[i]&&" "!==this.text[i]||i++}return{lineIndex:e-1,charIndex:this._textLines[e-1].length}},_getCursorBoundariesOffsets:function(t,e){for(var i=0,r=0,n=this.get2DCursorLocation(),s=this._textLines[n.lineIndex].split(""),o=this._getLineLeftOffset(this._getLineWidth(this.ctx,n.lineIndex)),a=0;a<n.charIndex;a++)r+=this._getWidthOfChar(this.ctx,s[a],n.lineIndex,a);for(a=0;a<n.lineIndex;a++)i+=this._getHeightOfLine(this.ctx,a);return"cursor"===e&&(i+=(1-this._fontSizeFraction)*this._getHeightOfLine(this.ctx,n.lineIndex)/this.lineHeight-this.getCurrentCharFontSize(n.lineIndex,n.charIndex)*(1-this._fontSizeFraction)),{top:i,left:r,lineLeft:o}},getMinWidth:function(){return Math.max(this.minWidth,this.dynamicMinWidth)},toObject:function(t){return this.callSuper("toObject",["minWidth"].concat(t))}}),e.Textbox.fromObject=function(t,i,r){return e.Object._fromObject("Textbox",t,i,r,"text")},e.Textbox.getTextboxControlVisibility=function(){return{tl:!1,tr:!1,br:!1,bl:!1,ml:!0,mt:!1,mr:!0,mb:!1,mtr:!0}}}("undefined"!=typeof exports?exports:this),function(){var t=fabric.Canvas.prototype._setObjectScale;fabric.Canvas.prototype._setObjectScale=function(e,i,r,n,s,o,a){var h=i.target;if(!(h instanceof fabric.Textbox))return t.call(fabric.Canvas.prototype,e,i,r,n,s,o,a);var c=h.width*(e.x/i.scaleX/(h.width+h.strokeWidth));return c>=h.getMinWidth()?(h.set("width",c),!0):void 0},fabric.Group.prototype._refreshControlsVisibility=function(){if("undefined"!=typeof fabric.Textbox)for(var t=this._objects.length;t--;)if(this._objects[t]instanceof fabric.Textbox)return void this.setControlsVisibility(fabric.Textbox.getTextboxControlVisibility())},fabric.util.object.extend(fabric.Textbox.prototype,{_removeExtraneousStyles:function(){for(var t in this._styleMap)this._textLines[t]||delete this.styles[this._styleMap[t].line]},insertCharStyleObject:function(t,e,i){var r=this._styleMap[t];t=r.line,e=r.offset+e,fabric.IText.prototype.insertCharStyleObject.apply(this,[t,e,i])},insertNewlineStyleObject:function(t,e,i){var r=this._styleMap[t];t=r.line,e=r.offset+e,fabric.IText.prototype.insertNewlineStyleObject.apply(this,[t,e,i])},shiftLineStyles:function(t,e){var i=this._styleMap[t];t=i.line,fabric.IText.prototype.shiftLineStyles.call(this,t,e)},_getTextOnPreviousLine:function(t){for(var e=this._textLines[t-1];this._styleMap[t-2]&&this._styleMap[t-2].line===this._styleMap[t-1].line;)e=this._textLines[t-2]+e,
t--;return e},removeStyleObject:function(t,e){var i=this.get2DCursorLocation(e),r=this._styleMap[i.lineIndex],n=r.line,s=r.offset+i.charIndex;this._removeStyleObject(t,i,n,s)}})}(),function(){var t=fabric.IText.prototype._getNewSelectionStartFromOffset;fabric.IText.prototype._getNewSelectionStartFromOffset=function(e,i,r,n,s){n=t.call(this,e,i,r,n,s);for(var o=0,a=0,h=0;h<this._textLines.length&&(o+=this._textLines[h].length,!(o+a>=n));h++)"\n"!==this.text[o+a]&&" "!==this.text[o+a]||a++;return n-h+a}}(),function(){function request(t,e,i){var r=URL.parse(t);r.port||(r.port=0===r.protocol.indexOf("https:")?443:80);var n=0===r.protocol.indexOf("https:")?HTTPS:HTTP,s=n.request({hostname:r.hostname,port:r.port,path:r.path,method:"GET"},function(t){var r="";e&&t.setEncoding(e),t.on("end",function(){i(r)}),t.on("data",function(e){200===t.statusCode&&(r+=e)})});s.on("error",function(t){t.errno===process.ECONNREFUSED?fabric.log("ECONNREFUSED: connection refused to "+r.hostname+":"+r.port):fabric.log(t.message),i(null)}),s.end()}function requestFs(t,e){var i=require("fs");i.readFile(t,function(t,i){if(t)throw fabric.log(t),t;e(i)})}if("undefined"==typeof document||"undefined"==typeof window){var DOMParser=require("xmldom").DOMParser,URL=require("url"),HTTP=require("http"),HTTPS=require("https"),Canvas=require("canvas"),Image=require("canvas").Image;fabric.util.loadImage=function(t,e,i){function r(r){r?(n.src=new Buffer(r,"binary"),n._src=t,e&&e.call(i,n)):(n=null,e&&e.call(i,null,!0))}var n=new Image;t&&(t instanceof Buffer||0===t.indexOf("data"))?(n.src=n._src=t,e&&e.call(i,n)):t&&0!==t.indexOf("http")?requestFs(t,r):t?request(t,"binary",r):e&&e.call(i,t)},fabric.loadSVGFromURL=function(t,e,i){t=t.replace(/^\n\s*/,"").replace(/\?.*$/,"").trim(),0!==t.indexOf("http")?requestFs(t,function(t){fabric.loadSVGFromString(t.toString(),e,i)}):request(t,"",function(t){fabric.loadSVGFromString(t,e,i)})},fabric.loadSVGFromString=function(t,e,i){var r=(new DOMParser).parseFromString(t);fabric.parseSVGDocument(r.documentElement,function(t,i){e&&e(t,i)},i)},fabric.util.getScript=function(url,callback){request(url,"",function(body){eval(body),callback&&callback()})},fabric.createCanvasForNode=function(t,e,i,r){r=r||i;var n=fabric.document.createElement("canvas"),s=new Canvas(t||600,e||600,r),o=new Canvas(t||600,e||600,r);n.style={},n.width=s.width,n.height=s.height,i=i||{},i.nodeCanvas=s,i.nodeCacheCanvas=o;var a=fabric.Canvas||fabric.StaticCanvas,h=new a(n,i);return h.nodeCanvas=s,h.nodeCacheCanvas=o,h.contextContainer=s.getContext("2d"),h.contextCache=o.getContext("2d"),h.Font=Canvas.Font,h};var originaInitStatic=fabric.StaticCanvas.prototype._initStatic;fabric.StaticCanvas.prototype._initStatic=function(t,e){t=t||fabric.document.createElement("canvas"),this.nodeCanvas=new Canvas(t.width,t.height),this.nodeCacheCanvas=new Canvas(t.width,t.height),originaInitStatic.call(this,t,e),this.contextContainer=this.nodeCanvas.getContext("2d"),this.contextCache=this.nodeCacheCanvas.getContext("2d"),this.Font=Canvas.Font},fabric.StaticCanvas.prototype.createPNGStream=function(){return this.nodeCanvas.createPNGStream()},fabric.StaticCanvas.prototype.createJPEGStream=function(t){return this.nodeCanvas.createJPEGStream(t)},fabric.StaticCanvas.prototype._initRetinaScaling=function(){if(this._isRetinaScaling())return this.lowerCanvasEl.setAttribute("width",this.width*fabric.devicePixelRatio),this.lowerCanvasEl.setAttribute("height",this.height*fabric.devicePixelRatio),this.nodeCanvas.width=this.width*fabric.devicePixelRatio,this.nodeCanvas.height=this.height*fabric.devicePixelRatio,this.contextContainer.scale(fabric.devicePixelRatio,fabric.devicePixelRatio),this},fabric.Canvas&&(fabric.Canvas.prototype._initRetinaScaling=fabric.StaticCanvas.prototype._initRetinaScaling);var origSetBackstoreDimension=fabric.StaticCanvas.prototype._setBackstoreDimension;fabric.StaticCanvas.prototype._setBackstoreDimension=function(t,e){return origSetBackstoreDimension.call(this,t,e),this.nodeCanvas[t]=e,this},fabric.Canvas&&(fabric.Canvas.prototype._setBackstoreDimension=fabric.StaticCanvas.prototype._setBackstoreDimension)}}();
/*! jQuery UI - v1.12.1 - 2017-04-21
* http://jqueryui.com
* Includes: widget.js, data.js, disable-selection.js, scroll-parent.js, widgets/draggable.js, widgets/droppable.js, widgets/mouse.js
* Copyright jQuery Foundation and other contributors; Licensed MIT */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([ "jquery" ], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

$.ui = $.ui || {};

var version = $.ui.version = "1.12.1";


/*!
 * jQuery UI Widget 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Widget
//>>group: Core
//>>description: Provides a factory for creating stateful widgets with a common API.
//>>docs: http://api.jqueryui.com/jQuery.widget/
//>>demos: http://jqueryui.com/widget/



var widgetUuid = 0;
var widgetSlice = Array.prototype.slice;

$.cleanData = ( function( orig ) {
	return function( elems ) {
		var events, elem, i;
		for ( i = 0; ( elem = elems[ i ] ) != null; i++ ) {
			try {

				// Only trigger remove when necessary to save time
				events = $._data( elem, "events" );
				if ( events && events.remove ) {
					$( elem ).triggerHandler( "remove" );
				}

			// Http://bugs.jquery.com/ticket/8235
			} catch ( e ) {}
		}
		orig( elems );
	};
} )( $.cleanData );

$.widget = function( name, base, prototype ) {
	var existingConstructor, constructor, basePrototype;

	// ProxiedPrototype allows the provided prototype to remain unmodified
	// so that it can be used as a mixin for multiple widgets (#8876)
	var proxiedPrototype = {};

	var namespace = name.split( "." )[ 0 ];
	name = name.split( "." )[ 1 ];
	var fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	if ( $.isArray( prototype ) ) {
		prototype = $.extend.apply( null, [ {} ].concat( prototype ) );
	}

	// Create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {

		// Allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// Allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};

	// Extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,

		// Copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),

		// Track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	} );

	basePrototype = new base();

	// We need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = ( function() {
			function _super() {
				return base.prototype[ prop ].apply( this, arguments );
			}

			function _superApply( args ) {
				return base.prototype[ prop ].apply( this, args );
			}

			return function() {
				var __super = this._super;
				var __superApply = this._superApply;
				var returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		} )();
	} );
	constructor.prototype = $.widget.extend( basePrototype, {

		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	} );

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// Redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor,
				child._proto );
		} );

		// Remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );

	return constructor;
};

$.widget.extend = function( target ) {
	var input = widgetSlice.call( arguments, 1 );
	var inputIndex = 0;
	var inputLength = input.length;
	var key;
	var value;

	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {

				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :

						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );

				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string";
		var args = widgetSlice.call( arguments, 1 );
		var returnValue = this;

		if ( isMethodCall ) {

			// If this is an empty collection, we need to have the instance method
			// return undefined instead of the jQuery instance
			if ( !this.length && options === "instance" ) {
				returnValue = undefined;
			} else {
				this.each( function() {
					var methodValue;
					var instance = $.data( this, fullName );

					if ( options === "instance" ) {
						returnValue = instance;
						return false;
					}

					if ( !instance ) {
						return $.error( "cannot call methods on " + name +
							" prior to initialization; " +
							"attempted to call method '" + options + "'" );
					}

					if ( !$.isFunction( instance[ options ] ) || options.charAt( 0 ) === "_" ) {
						return $.error( "no such method '" + options + "' for " + name +
							" widget instance" );
					}

					methodValue = instance[ options ].apply( instance, args );

					if ( methodValue !== instance && methodValue !== undefined ) {
						returnValue = methodValue && methodValue.jquery ?
							returnValue.pushStack( methodValue.get() ) :
							methodValue;
						return false;
					}
				} );
			}
		} else {

			// Allow multiple hashes to be passed on init
			if ( args.length ) {
				options = $.widget.extend.apply( null, [ options ].concat( args ) );
			}

			this.each( function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} );
					if ( instance._init ) {
						instance._init();
					}
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			} );
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",

	options: {
		classes: {},
		disabled: false,

		// Callbacks
		create: null
	},

	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = widgetUuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();
		this.classesElementLookup = {};

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			} );
			this.document = $( element.style ?

				// Element within the document
				element.ownerDocument :

				// Element is window or document
				element.document || element );
			this.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );
		}

		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this._create();

		if ( this.options.disabled ) {
			this._setOptionDisabled( this.options.disabled );
		}

		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},

	_getCreateOptions: function() {
		return {};
	},

	_getCreateEventData: $.noop,

	_create: $.noop,

	_init: $.noop,

	destroy: function() {
		var that = this;

		this._destroy();
		$.each( this.classesElementLookup, function( key, value ) {
			that._removeClass( value, key );
		} );

		// We can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.off( this.eventNamespace )
			.removeData( this.widgetFullName );
		this.widget()
			.off( this.eventNamespace )
			.removeAttr( "aria-disabled" );

		// Clean up events and states
		this.bindings.off( this.eventNamespace );
	},

	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key;
		var parts;
		var curOption;
		var i;

		if ( arguments.length === 0 ) {

			// Don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {

			// Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},

	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},

	_setOption: function( key, value ) {
		if ( key === "classes" ) {
			this._setOptionClasses( value );
		}

		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this._setOptionDisabled( value );
		}

		return this;
	},

	_setOptionClasses: function( value ) {
		var classKey, elements, currentElements;

		for ( classKey in value ) {
			currentElements = this.classesElementLookup[ classKey ];
			if ( value[ classKey ] === this.options.classes[ classKey ] ||
					!currentElements ||
					!currentElements.length ) {
				continue;
			}

			// We are doing this to create a new jQuery object because the _removeClass() call
			// on the next line is going to destroy the reference to the current elements being
			// tracked. We need to save a copy of this collection so that we can add the new classes
			// below.
			elements = $( currentElements.get() );
			this._removeClass( currentElements, classKey );

			// We don't use _addClass() here, because that uses this.options.classes
			// for generating the string of classes. We want to use the value passed in from
			// _setOption(), this is the new value of the classes option which was passed to
			// _setOption(). We pass this value directly to _classes().
			elements.addClass( this._classes( {
				element: elements,
				keys: classKey,
				classes: value,
				add: true
			} ) );
		}
	},

	_setOptionDisabled: function( value ) {
		this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null, !!value );

		// If the widget is becoming disabled, then nothing is interactive
		if ( value ) {
			this._removeClass( this.hoverable, null, "ui-state-hover" );
			this._removeClass( this.focusable, null, "ui-state-focus" );
		}
	},

	enable: function() {
		return this._setOptions( { disabled: false } );
	},

	disable: function() {
		return this._setOptions( { disabled: true } );
	},

	_classes: function( options ) {
		var full = [];
		var that = this;

		options = $.extend( {
			element: this.element,
			classes: this.options.classes || {}
		}, options );

		function processClassString( classes, checkOption ) {
			var current, i;
			for ( i = 0; i < classes.length; i++ ) {
				current = that.classesElementLookup[ classes[ i ] ] || $();
				if ( options.add ) {
					current = $( $.unique( current.get().concat( options.element.get() ) ) );
				} else {
					current = $( current.not( options.element ).get() );
				}
				that.classesElementLookup[ classes[ i ] ] = current;
				full.push( classes[ i ] );
				if ( checkOption && options.classes[ classes[ i ] ] ) {
					full.push( options.classes[ classes[ i ] ] );
				}
			}
		}

		this._on( options.element, {
			"remove": "_untrackClassesElement"
		} );

		if ( options.keys ) {
			processClassString( options.keys.match( /\S+/g ) || [], true );
		}
		if ( options.extra ) {
			processClassString( options.extra.match( /\S+/g ) || [] );
		}

		return full.join( " " );
	},

	_untrackClassesElement: function( event ) {
		var that = this;
		$.each( that.classesElementLookup, function( key, value ) {
			if ( $.inArray( event.target, value ) !== -1 ) {
				that.classesElementLookup[ key ] = $( value.not( event.target ).get() );
			}
		} );
	},

	_removeClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, false );
	},

	_addClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, true );
	},

	_toggleClass: function( element, keys, extra, add ) {
		add = ( typeof add === "boolean" ) ? add : extra;
		var shift = ( typeof element === "string" || element === null ),
			options = {
				extra: shift ? keys : extra,
				keys: shift ? element : keys,
				element: shift ? this.element : element,
				add: add
			};
		options.element.toggleClass( this._classes( options ), add );
		return this;
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement;
		var instance = this;

		// No suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// No element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {

				// Allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
						$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// Copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^([\w:-]*)\s*(.*)$/ );
			var eventName = match[ 1 ] + instance.eventNamespace;
			var selector = match[ 2 ];

			if ( selector ) {
				delegateElement.on( eventName, selector, handlerProxy );
			} else {
				element.on( eventName, handlerProxy );
			}
		} );
	},

	_off: function( element, eventName ) {
		eventName = ( eventName || "" ).split( " " ).join( this.eventNamespace + " " ) +
			this.eventNamespace;
		element.off( eventName ).off( eventName );

		// Clear the stack to avoid memory leaks (#10056)
		this.bindings = $( this.bindings.not( element ).get() );
		this.focusable = $( this.focusable.not( element ).get() );
		this.hoverable = $( this.hoverable.not( element ).get() );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-hover" );
			},
			mouseleave: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-hover" );
			}
		} );
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-focus" );
			},
			focusout: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-focus" );
			}
		} );
	},

	_trigger: function( type, event, data ) {
		var prop, orig;
		var callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();

		// The original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// Copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}

		var hasOptions;
		var effectName = !options ?
			method :
			options === true || typeof options === "number" ?
				defaultEffect :
				options.effect || defaultEffect;

		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}

		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;

		if ( options.delay ) {
			element.delay( options.delay );
		}

		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue( function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			} );
		}
	};
} );

var widget = $.widget;


/*!
 * jQuery UI :data 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: :data Selector
//>>group: Core
//>>description: Selects elements which have data stored under the specified key.
//>>docs: http://api.jqueryui.com/data-selector/


var data = $.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo( function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		} ) :

		// Support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		}
} );

/*!
 * jQuery UI Disable Selection 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: disableSelection
//>>group: Core
//>>description: Disable selection of text content within the set of matched elements.
//>>docs: http://api.jqueryui.com/disableSelection/

// This file is deprecated


var disableSelection = $.fn.extend( {
	disableSelection: ( function() {
		var eventType = "onselectstart" in document.createElement( "div" ) ?
			"selectstart" :
			"mousedown";

		return function() {
			return this.on( eventType + ".ui-disableSelection", function( event ) {
				event.preventDefault();
			} );
		};
	} )(),

	enableSelection: function() {
		return this.off( ".ui-disableSelection" );
	}
} );


/*!
 * jQuery UI Scroll Parent 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: scrollParent
//>>group: Core
//>>description: Get the closest ancestor element that is scrollable.
//>>docs: http://api.jqueryui.com/scrollParent/



var scrollParent = $.fn.scrollParent = function( includeHidden ) {
	var position = this.css( "position" ),
		excludeStaticParent = position === "absolute",
		overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
		scrollParent = this.parents().filter( function() {
			var parent = $( this );
			if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
				return false;
			}
			return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) +
				parent.css( "overflow-x" ) );
		} ).eq( 0 );

	return position === "fixed" || !scrollParent.length ?
		$( this[ 0 ].ownerDocument || document ) :
		scrollParent;
};




// This file is deprecated
var ie = $.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

/*!
 * jQuery UI Mouse 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Mouse
//>>group: Widgets
//>>description: Abstracts mouse-based interactions to assist in creating certain widgets.
//>>docs: http://api.jqueryui.com/mouse/



var mouseHandled = false;
$( document ).on( "mouseup", function() {
	mouseHandled = false;
} );

var widgetsMouse = $.widget( "ui.mouse", {
	version: "1.12.1",
	options: {
		cancel: "input, textarea, button, select, option",
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.on( "mousedown." + this.widgetName, function( event ) {
				return that._mouseDown( event );
			} )
			.on( "click." + this.widgetName, function( event ) {
				if ( true === $.data( event.target, that.widgetName + ".preventClickEvent" ) ) {
					$.removeData( event.target, that.widgetName + ".preventClickEvent" );
					event.stopImmediatePropagation();
					return false;
				}
			} );

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.off( "." + this.widgetName );
		if ( this._mouseMoveDelegate ) {
			this.document
				.off( "mousemove." + this.widgetName, this._mouseMoveDelegate )
				.off( "mouseup." + this.widgetName, this._mouseUpDelegate );
		}
	},

	_mouseDown: function( event ) {

		// don't let more than one widget handle mouseStart
		if ( mouseHandled ) {
			return;
		}

		this._mouseMoved = false;

		// We may have missed mouseup (out of window)
		( this._mouseStarted && this._mouseUp( event ) );

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = ( event.which === 1 ),

			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = ( typeof this.options.cancel === "string" && event.target.nodeName ?
				$( event.target ).closest( this.options.cancel ).length : false );
		if ( !btnIsLeft || elIsCancel || !this._mouseCapture( event ) ) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if ( !this.mouseDelayMet ) {
			this._mouseDelayTimer = setTimeout( function() {
				that.mouseDelayMet = true;
			}, this.options.delay );
		}

		if ( this._mouseDistanceMet( event ) && this._mouseDelayMet( event ) ) {
			this._mouseStarted = ( this._mouseStart( event ) !== false );
			if ( !this._mouseStarted ) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if ( true === $.data( event.target, this.widgetName + ".preventClickEvent" ) ) {
			$.removeData( event.target, this.widgetName + ".preventClickEvent" );
		}

		// These delegates are required to keep context
		this._mouseMoveDelegate = function( event ) {
			return that._mouseMove( event );
		};
		this._mouseUpDelegate = function( event ) {
			return that._mouseUp( event );
		};

		this.document
			.on( "mousemove." + this.widgetName, this._mouseMoveDelegate )
			.on( "mouseup." + this.widgetName, this._mouseUpDelegate );

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function( event ) {

		// Only check for mouseups outside the document if you've moved inside the document
		// at least once. This prevents the firing of mouseup in the case of IE<9, which will
		// fire a mousemove event if content is placed under the cursor. See #7778
		// Support: IE <9
		if ( this._mouseMoved ) {

			// IE mouseup check - mouseup happened when mouse was out of window
			if ( $.ui.ie && ( !document.documentMode || document.documentMode < 9 ) &&
					!event.button ) {
				return this._mouseUp( event );

			// Iframe mouseup check - mouseup occurred in another document
			} else if ( !event.which ) {

				// Support: Safari <=8 - 9
				// Safari sets which to 0 if you press any of the following keys
				// during a drag (#14461)
				if ( event.originalEvent.altKey || event.originalEvent.ctrlKey ||
						event.originalEvent.metaKey || event.originalEvent.shiftKey ) {
					this.ignoreMissingWhich = true;
				} else if ( !this.ignoreMissingWhich ) {
					return this._mouseUp( event );
				}
			}
		}

		if ( event.which || event.button ) {
			this._mouseMoved = true;
		}

		if ( this._mouseStarted ) {
			this._mouseDrag( event );
			return event.preventDefault();
		}

		if ( this._mouseDistanceMet( event ) && this._mouseDelayMet( event ) ) {
			this._mouseStarted =
				( this._mouseStart( this._mouseDownEvent, event ) !== false );
			( this._mouseStarted ? this._mouseDrag( event ) : this._mouseUp( event ) );
		}

		return !this._mouseStarted;
	},

	_mouseUp: function( event ) {
		this.document
			.off( "mousemove." + this.widgetName, this._mouseMoveDelegate )
			.off( "mouseup." + this.widgetName, this._mouseUpDelegate );

		if ( this._mouseStarted ) {
			this._mouseStarted = false;

			if ( event.target === this._mouseDownEvent.target ) {
				$.data( event.target, this.widgetName + ".preventClickEvent", true );
			}

			this._mouseStop( event );
		}

		if ( this._mouseDelayTimer ) {
			clearTimeout( this._mouseDelayTimer );
			delete this._mouseDelayTimer;
		}

		this.ignoreMissingWhich = false;
		mouseHandled = false;
		event.preventDefault();
	},

	_mouseDistanceMet: function( event ) {
		return ( Math.max(
				Math.abs( this._mouseDownEvent.pageX - event.pageX ),
				Math.abs( this._mouseDownEvent.pageY - event.pageY )
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function( /* event */ ) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function( /* event */ ) {},
	_mouseDrag: function( /* event */ ) {},
	_mouseStop: function( /* event */ ) {},
	_mouseCapture: function( /* event */ ) { return true; }
} );




// $.ui.plugin is deprecated. Use $.widget() extensions instead.
var plugin = $.ui.plugin = {
	add: function( module, option, set ) {
		var i,
			proto = $.ui[ module ].prototype;
		for ( i in set ) {
			proto.plugins[ i ] = proto.plugins[ i ] || [];
			proto.plugins[ i ].push( [ option, set[ i ] ] );
		}
	},
	call: function( instance, name, args, allowDisconnected ) {
		var i,
			set = instance.plugins[ name ];

		if ( !set ) {
			return;
		}

		if ( !allowDisconnected && ( !instance.element[ 0 ].parentNode ||
				instance.element[ 0 ].parentNode.nodeType === 11 ) ) {
			return;
		}

		for ( i = 0; i < set.length; i++ ) {
			if ( instance.options[ set[ i ][ 0 ] ] ) {
				set[ i ][ 1 ].apply( instance.element, args );
			}
		}
	}
};



var safeActiveElement = $.ui.safeActiveElement = function( document ) {
	var activeElement;

	// Support: IE 9 only
	// IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
	try {
		activeElement = document.activeElement;
	} catch ( error ) {
		activeElement = document.body;
	}

	// Support: IE 9 - 11 only
	// IE may return null instead of an element
	// Interestingly, this only seems to occur when NOT in an iframe
	if ( !activeElement ) {
		activeElement = document.body;
	}

	// Support: IE 11 only
	// IE11 returns a seemingly empty object in some cases when accessing
	// document.activeElement from an <iframe>
	if ( !activeElement.nodeName ) {
		activeElement = document.body;
	}

	return activeElement;
};



var safeBlur = $.ui.safeBlur = function( element ) {

	// Support: IE9 - 10 only
	// If the <body> is blurred, IE will switch windows, see #9420
	if ( element && element.nodeName.toLowerCase() !== "body" ) {
		$( element ).trigger( "blur" );
	}
};


/*!
 * jQuery UI Draggable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Draggable
//>>group: Interactions
//>>description: Enables dragging functionality for any element.
//>>docs: http://api.jqueryui.com/draggable/
//>>demos: http://jqueryui.com/draggable/
//>>css.structure: ../../themes/base/draggable.css



$.widget( "ui.draggable", $.ui.mouse, {
	version: "1.12.1",
	widgetEventPrefix: "drag",
	options: {
		addClasses: true,
		appendTo: "parent",
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		grid: false,
		handle: false,
		helper: "original",
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: "default",
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: "both",
		snapTolerance: 20,
		stack: false,
		zIndex: false,

		// Callbacks
		drag: null,
		start: null,
		stop: null
	},
	_create: function() {

		if ( this.options.helper === "original" ) {
			this._setPositionRelative();
		}
		if ( this.options.addClasses ) {
			this._addClass( "ui-draggable" );
		}
		this._setHandleClassName();

		this._mouseInit();
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "handle" ) {
			this._removeHandleClassName();
			this._setHandleClassName();
		}
	},

	_destroy: function() {
		if ( ( this.helper || this.element ).is( ".ui-draggable-dragging" ) ) {
			this.destroyOnClear = true;
			return;
		}
		this._removeHandleClassName();
		this._mouseDestroy();
	},

	_mouseCapture: function( event ) {
		var o = this.options;

		// Among others, prevent a drag on a resizable-handle
		if ( this.helper || o.disabled ||
				$( event.target ).closest( ".ui-resizable-handle" ).length > 0 ) {
			return false;
		}

		//Quit if we're not on a valid handle
		this.handle = this._getHandle( event );
		if ( !this.handle ) {
			return false;
		}

		this._blurActiveElement( event );

		this._blockFrames( o.iframeFix === true ? "iframe" : o.iframeFix );

		return true;

	},

	_blockFrames: function( selector ) {
		this.iframeBlocks = this.document.find( selector ).map( function() {
			var iframe = $( this );

			return $( "<div>" )
				.css( "position", "absolute" )
				.appendTo( iframe.parent() )
				.outerWidth( iframe.outerWidth() )
				.outerHeight( iframe.outerHeight() )
				.offset( iframe.offset() )[ 0 ];
		} );
	},

	_unblockFrames: function() {
		if ( this.iframeBlocks ) {
			this.iframeBlocks.remove();
			delete this.iframeBlocks;
		}
	},

	_blurActiveElement: function( event ) {
		var activeElement = $.ui.safeActiveElement( this.document[ 0 ] ),
			target = $( event.target );

		// Don't blur if the event occurred on an element that is within
		// the currently focused element
		// See #10527, #12472
		if ( target.closest( activeElement ).length ) {
			return;
		}

		// Blur any element that currently has focus, see #4261
		$.ui.safeBlur( activeElement );
	},

	_mouseStart: function( event ) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper( event );

		this._addClass( this.helper, "ui-draggable-dragging" );

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.current = this;
		}

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper's css position
		this.cssPosition = this.helper.css( "position" );
		this.scrollParent = this.helper.scrollParent( true );
		this.offsetParent = this.helper.offsetParent();
		this.hasFixedAncestor = this.helper.parents().filter( function() {
				return $( this ).css( "position" ) === "fixed";
			} ).length > 0;

		//The element's absolute position on the page minus margins
		this.positionAbs = this.element.offset();
		this._refreshOffsets( event );

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition( event, false );
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
		( o.cursorAt && this._adjustOffsetFromHelper( o.cursorAt ) );

		//Set a containment if given in the options
		this._setContainment();

		//Trigger event + callbacks
		if ( this._trigger( "start", event ) === false ) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ( $.ui.ddmanager && !o.dropBehaviour ) {
			$.ui.ddmanager.prepareOffsets( this, event );
		}

		// Execute the drag once - this causes the helper not to be visible before getting its
		// correct position
		this._mouseDrag( event, true );

		// If the ddmanager is used for droppables, inform the manager that dragging has started
		// (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStart( this, event );
		}

		return true;
	},

	_refreshOffsets: function( event ) {
		this.offset = {
			top: this.positionAbs.top - this.margins.top,
			left: this.positionAbs.left - this.margins.left,
			scroll: false,
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset()
		};

		this.offset.click = {
			left: event.pageX - this.offset.left,
			top: event.pageY - this.offset.top
		};
	},

	_mouseDrag: function( event, noPropagation ) {

		// reset any necessary cached properties (see #5009)
		if ( this.hasFixedAncestor ) {
			this.offset.parent = this._getParentOffset();
		}

		//Compute the helpers position
		this.position = this._generatePosition( event, true );
		this.positionAbs = this._convertPositionTo( "absolute" );

		//Call plugins and callbacks and use the resulting position if something is returned
		if ( !noPropagation ) {
			var ui = this._uiHash();
			if ( this._trigger( "drag", event, ui ) === false ) {
				this._mouseUp( new $.Event( "mouseup", event ) );
				return false;
			}
			this.position = ui.position;
		}

		this.helper[ 0 ].style.left = this.position.left + "px";
		this.helper[ 0 ].style.top = this.position.top + "px";

		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.drag( this, event );
		}

		return false;
	},

	_mouseStop: function( event ) {

		//If we are using droppables, inform the manager about the drop
		var that = this,
			dropped = false;
		if ( $.ui.ddmanager && !this.options.dropBehaviour ) {
			dropped = $.ui.ddmanager.drop( this, event );
		}

		//if a drop comes from outside (a sortable)
		if ( this.dropped ) {
			dropped = this.dropped;
			this.dropped = false;
		}

		if ( ( this.options.revert === "invalid" && !dropped ) ||
				( this.options.revert === "valid" && dropped ) ||
				this.options.revert === true || ( $.isFunction( this.options.revert ) &&
				this.options.revert.call( this.element, dropped ) )
		) {
			$( this.helper ).animate(
				this.originalPosition,
				parseInt( this.options.revertDuration, 10 ),
				function() {
					if ( that._trigger( "stop", event ) !== false ) {
						that._clear();
					}
				}
			);
		} else {
			if ( this._trigger( "stop", event ) !== false ) {
				this._clear();
			}
		}

		return false;
	},

	_mouseUp: function( event ) {
		this._unblockFrames();

		// If the ddmanager is used for droppables, inform the manager that dragging has stopped
		// (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStop( this, event );
		}

		// Only need to focus if the event occurred on the draggable itself, see #10527
		if ( this.handleElement.is( event.target ) ) {

			// The interaction is over; whether or not the click resulted in a drag,
			// focus the element
			this.element.trigger( "focus" );
		}

		return $.ui.mouse.prototype._mouseUp.call( this, event );
	},

	cancel: function() {

		if ( this.helper.is( ".ui-draggable-dragging" ) ) {
			this._mouseUp( new $.Event( "mouseup", { target: this.element[ 0 ] } ) );
		} else {
			this._clear();
		}

		return this;

	},

	_getHandle: function( event ) {
		return this.options.handle ?
			!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
			true;
	},

	_setHandleClassName: function() {
		this.handleElement = this.options.handle ?
			this.element.find( this.options.handle ) : this.element;
		this._addClass( this.handleElement, "ui-draggable-handle" );
	},

	_removeHandleClassName: function() {
		this._removeClass( this.handleElement, "ui-draggable-handle" );
	},

	_createHelper: function( event ) {

		var o = this.options,
			helperIsFunction = $.isFunction( o.helper ),
			helper = helperIsFunction ?
				$( o.helper.apply( this.element[ 0 ], [ event ] ) ) :
				( o.helper === "clone" ?
					this.element.clone().removeAttr( "id" ) :
					this.element );

		if ( !helper.parents( "body" ).length ) {
			helper.appendTo( ( o.appendTo === "parent" ?
				this.element[ 0 ].parentNode :
				o.appendTo ) );
		}

		// Http://bugs.jqueryui.com/ticket/9446
		// a helper function can return the original element
		// which wouldn't have been set to relative in _create
		if ( helperIsFunction && helper[ 0 ] === this.element[ 0 ] ) {
			this._setPositionRelative();
		}

		if ( helper[ 0 ] !== this.element[ 0 ] &&
				!( /(fixed|absolute)/ ).test( helper.css( "position" ) ) ) {
			helper.css( "position", "absolute" );
		}

		return helper;

	},

	_setPositionRelative: function() {
		if ( !( /^(?:r|a|f)/ ).test( this.element.css( "position" ) ) ) {
			this.element[ 0 ].style.position = "relative";
		}
	},

	_adjustOffsetFromHelper: function( obj ) {
		if ( typeof obj === "string" ) {
			obj = obj.split( " " );
		}
		if ( $.isArray( obj ) ) {
			obj = { left: +obj[ 0 ], top: +obj[ 1 ] || 0 };
		}
		if ( "left" in obj ) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ( "right" in obj ) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ( "top" in obj ) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ( "bottom" in obj ) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_isRootNode: function( element ) {
		return ( /(html|body)/i ).test( element.tagName ) || element === this.document[ 0 ];
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		var po = this.offsetParent.offset(),
			document = this.document[ 0 ];

		// This is a special case where we need to modify a offset calculated on start, since the
		// following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the
		// next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't
		// the document, which means that the scroll is included in the initial calculation of the
		// offset of the parent, and never recalculated upon drag
		if ( this.cssPosition === "absolute" && this.scrollParent[ 0 ] !== document &&
				$.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if ( this._isRootNode( this.offsetParent[ 0 ] ) ) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + ( parseInt( this.offsetParent.css( "borderTopWidth" ), 10 ) || 0 ),
			left: po.left + ( parseInt( this.offsetParent.css( "borderLeftWidth" ), 10 ) || 0 )
		};

	},

	_getRelativeOffset: function() {
		if ( this.cssPosition !== "relative" ) {
			return { top: 0, left: 0 };
		}

		var p = this.element.position(),
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

		return {
			top: p.top - ( parseInt( this.helper.css( "top" ), 10 ) || 0 ) +
				( !scrollIsRootNode ? this.scrollParent.scrollTop() : 0 ),
			left: p.left - ( parseInt( this.helper.css( "left" ), 10 ) || 0 ) +
				( !scrollIsRootNode ? this.scrollParent.scrollLeft() : 0 )
		};

	},

	_cacheMargins: function() {
		this.margins = {
			left: ( parseInt( this.element.css( "marginLeft" ), 10 ) || 0 ),
			top: ( parseInt( this.element.css( "marginTop" ), 10 ) || 0 ),
			right: ( parseInt( this.element.css( "marginRight" ), 10 ) || 0 ),
			bottom: ( parseInt( this.element.css( "marginBottom" ), 10 ) || 0 )
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var isUserScrollable, c, ce,
			o = this.options,
			document = this.document[ 0 ];

		this.relativeContainer = null;

		if ( !o.containment ) {
			this.containment = null;
			return;
		}

		if ( o.containment === "window" ) {
			this.containment = [
				$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
				$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
				$( window ).scrollLeft() + $( window ).width() -
					this.helperProportions.width - this.margins.left,
				$( window ).scrollTop() +
					( $( window ).height() || document.body.parentNode.scrollHeight ) -
					this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment === "document" ) {
			this.containment = [
				0,
				0,
				$( document ).width() - this.helperProportions.width - this.margins.left,
				( $( document ).height() || document.body.parentNode.scrollHeight ) -
					this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment.constructor === Array ) {
			this.containment = o.containment;
			return;
		}

		if ( o.containment === "parent" ) {
			o.containment = this.helper[ 0 ].parentNode;
		}

		c = $( o.containment );
		ce = c[ 0 ];

		if ( !ce ) {
			return;
		}

		isUserScrollable = /(scroll|auto)/.test( c.css( "overflow" ) );

		this.containment = [
			( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) +
				( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
			( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) +
				( parseInt( c.css( "paddingTop" ), 10 ) || 0 ),
			( isUserScrollable ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -
				( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) -
				( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) -
				this.helperProportions.width -
				this.margins.left -
				this.margins.right,
			( isUserScrollable ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -
				( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) -
				( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) -
				this.helperProportions.height -
				this.margins.top -
				this.margins.bottom
		];
		this.relativeContainer = c;
	},

	_convertPositionTo: function( d, pos ) {

		if ( !pos ) {
			pos = this.position;
		}

		var mod = d === "absolute" ? 1 : -1,
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

		return {
			top: (

				// The absolute mouse position
				pos.top	+

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.top * mod +

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.top * mod -
				( ( this.cssPosition === "fixed" ?
					-this.offset.scroll.top :
					( scrollIsRootNode ? 0 : this.offset.scroll.top ) ) * mod )
			),
			left: (

				// The absolute mouse position
				pos.left +

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.left * mod +

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.left * mod	-
				( ( this.cssPosition === "fixed" ?
					-this.offset.scroll.left :
					( scrollIsRootNode ? 0 : this.offset.scroll.left ) ) * mod )
			)
		};

	},

	_generatePosition: function( event, constrainPosition ) {

		var containment, co, top, left,
			o = this.options,
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] ),
			pageX = event.pageX,
			pageY = event.pageY;

		// Cache the scroll
		if ( !scrollIsRootNode || !this.offset.scroll ) {
			this.offset.scroll = {
				top: this.scrollParent.scrollTop(),
				left: this.scrollParent.scrollLeft()
			};
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		// If we are not dragging yet, we won't check for options
		if ( constrainPosition ) {
			if ( this.containment ) {
				if ( this.relativeContainer ) {
					co = this.relativeContainer.offset();
					containment = [
						this.containment[ 0 ] + co.left,
						this.containment[ 1 ] + co.top,
						this.containment[ 2 ] + co.left,
						this.containment[ 3 ] + co.top
					];
				} else {
					containment = this.containment;
				}

				if ( event.pageX - this.offset.click.left < containment[ 0 ] ) {
					pageX = containment[ 0 ] + this.offset.click.left;
				}
				if ( event.pageY - this.offset.click.top < containment[ 1 ] ) {
					pageY = containment[ 1 ] + this.offset.click.top;
				}
				if ( event.pageX - this.offset.click.left > containment[ 2 ] ) {
					pageX = containment[ 2 ] + this.offset.click.left;
				}
				if ( event.pageY - this.offset.click.top > containment[ 3 ] ) {
					pageY = containment[ 3 ] + this.offset.click.top;
				}
			}

			if ( o.grid ) {

				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid
				// argument errors in IE (see ticket #6950)
				top = o.grid[ 1 ] ? this.originalPageY + Math.round( ( pageY -
					this.originalPageY ) / o.grid[ 1 ] ) * o.grid[ 1 ] : this.originalPageY;
				pageY = containment ? ( ( top - this.offset.click.top >= containment[ 1 ] ||
					top - this.offset.click.top > containment[ 3 ] ) ?
						top :
						( ( top - this.offset.click.top >= containment[ 1 ] ) ?
							top - o.grid[ 1 ] : top + o.grid[ 1 ] ) ) : top;

				left = o.grid[ 0 ] ? this.originalPageX +
					Math.round( ( pageX - this.originalPageX ) / o.grid[ 0 ] ) * o.grid[ 0 ] :
					this.originalPageX;
				pageX = containment ? ( ( left - this.offset.click.left >= containment[ 0 ] ||
					left - this.offset.click.left > containment[ 2 ] ) ?
						left :
						( ( left - this.offset.click.left >= containment[ 0 ] ) ?
							left - o.grid[ 0 ] : left + o.grid[ 0 ] ) ) : left;
			}

			if ( o.axis === "y" ) {
				pageX = this.originalPageX;
			}

			if ( o.axis === "x" ) {
				pageY = this.originalPageY;
			}
		}

		return {
			top: (

				// The absolute mouse position
				pageY -

				// Click offset (relative to the element)
				this.offset.click.top -

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.top -

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.top +
				( this.cssPosition === "fixed" ?
					-this.offset.scroll.top :
					( scrollIsRootNode ? 0 : this.offset.scroll.top ) )
			),
			left: (

				// The absolute mouse position
				pageX -

				// Click offset (relative to the element)
				this.offset.click.left -

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.left -

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.left +
				( this.cssPosition === "fixed" ?
					-this.offset.scroll.left :
					( scrollIsRootNode ? 0 : this.offset.scroll.left ) )
			)
		};

	},

	_clear: function() {
		this._removeClass( this.helper, "ui-draggable-dragging" );
		if ( this.helper[ 0 ] !== this.element[ 0 ] && !this.cancelHelperRemoval ) {
			this.helper.remove();
		}
		this.helper = null;
		this.cancelHelperRemoval = false;
		if ( this.destroyOnClear ) {
			this.destroy();
		}
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function( type, event, ui ) {
		ui = ui || this._uiHash();
		$.ui.plugin.call( this, type, [ event, ui, this ], true );

		// Absolute position and offset (see #6884 ) have to be recalculated after plugins
		if ( /^(drag|start|stop)/.test( type ) ) {
			this.positionAbs = this._convertPositionTo( "absolute" );
			ui.offset = this.positionAbs;
		}
		return $.Widget.prototype._trigger.call( this, type, event, ui );
	},

	plugins: {},

	_uiHash: function() {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

} );

$.ui.plugin.add( "draggable", "connectToSortable", {
	start: function( event, ui, draggable ) {
		var uiSortable = $.extend( {}, ui, {
			item: draggable.element
		} );

		draggable.sortables = [];
		$( draggable.options.connectToSortable ).each( function() {
			var sortable = $( this ).sortable( "instance" );

			if ( sortable && !sortable.options.disabled ) {
				draggable.sortables.push( sortable );

				// RefreshPositions is called at drag start to refresh the containerCache
				// which is used in drag. This ensures it's initialized and synchronized
				// with any changes that might have happened on the page since initialization.
				sortable.refreshPositions();
				sortable._trigger( "activate", event, uiSortable );
			}
		} );
	},
	stop: function( event, ui, draggable ) {
		var uiSortable = $.extend( {}, ui, {
			item: draggable.element
		} );

		draggable.cancelHelperRemoval = false;

		$.each( draggable.sortables, function() {
			var sortable = this;

			if ( sortable.isOver ) {
				sortable.isOver = 0;

				// Allow this sortable to handle removing the helper
				draggable.cancelHelperRemoval = true;
				sortable.cancelHelperRemoval = false;

				// Use _storedCSS To restore properties in the sortable,
				// as this also handles revert (#9675) since the draggable
				// may have modified them in unexpected ways (#8809)
				sortable._storedCSS = {
					position: sortable.placeholder.css( "position" ),
					top: sortable.placeholder.css( "top" ),
					left: sortable.placeholder.css( "left" )
				};

				sortable._mouseStop( event );

				// Once drag has ended, the sortable should return to using
				// its original helper, not the shared helper from draggable
				sortable.options.helper = sortable.options._helper;
			} else {

				// Prevent this Sortable from removing the helper.
				// However, don't set the draggable to remove the helper
				// either as another connected Sortable may yet handle the removal.
				sortable.cancelHelperRemoval = true;

				sortable._trigger( "deactivate", event, uiSortable );
			}
		} );
	},
	drag: function( event, ui, draggable ) {
		$.each( draggable.sortables, function() {
			var innermostIntersecting = false,
				sortable = this;

			// Copy over variables that sortable's _intersectsWith uses
			sortable.positionAbs = draggable.positionAbs;
			sortable.helperProportions = draggable.helperProportions;
			sortable.offset.click = draggable.offset.click;

			if ( sortable._intersectsWith( sortable.containerCache ) ) {
				innermostIntersecting = true;

				$.each( draggable.sortables, function() {

					// Copy over variables that sortable's _intersectsWith uses
					this.positionAbs = draggable.positionAbs;
					this.helperProportions = draggable.helperProportions;
					this.offset.click = draggable.offset.click;

					if ( this !== sortable &&
							this._intersectsWith( this.containerCache ) &&
							$.contains( sortable.element[ 0 ], this.element[ 0 ] ) ) {
						innermostIntersecting = false;
					}

					return innermostIntersecting;
				} );
			}

			if ( innermostIntersecting ) {

				// If it intersects, we use a little isOver variable and set it once,
				// so that the move-in stuff gets fired only once.
				if ( !sortable.isOver ) {
					sortable.isOver = 1;

					// Store draggable's parent in case we need to reappend to it later.
					draggable._parent = ui.helper.parent();

					sortable.currentItem = ui.helper
						.appendTo( sortable.element )
						.data( "ui-sortable-item", true );

					// Store helper option to later restore it
					sortable.options._helper = sortable.options.helper;

					sortable.options.helper = function() {
						return ui.helper[ 0 ];
					};

					// Fire the start events of the sortable with our passed browser event,
					// and our own helper (so it doesn't create a new one)
					event.target = sortable.currentItem[ 0 ];
					sortable._mouseCapture( event, true );
					sortable._mouseStart( event, true, true );

					// Because the browser event is way off the new appended portlet,
					// modify necessary variables to reflect the changes
					sortable.offset.click.top = draggable.offset.click.top;
					sortable.offset.click.left = draggable.offset.click.left;
					sortable.offset.parent.left -= draggable.offset.parent.left -
						sortable.offset.parent.left;
					sortable.offset.parent.top -= draggable.offset.parent.top -
						sortable.offset.parent.top;

					draggable._trigger( "toSortable", event );

					// Inform draggable that the helper is in a valid drop zone,
					// used solely in the revert option to handle "valid/invalid".
					draggable.dropped = sortable.element;

					// Need to refreshPositions of all sortables in the case that
					// adding to one sortable changes the location of the other sortables (#9675)
					$.each( draggable.sortables, function() {
						this.refreshPositions();
					} );

					// Hack so receive/update callbacks work (mostly)
					draggable.currentItem = draggable.element;
					sortable.fromOutside = draggable;
				}

				if ( sortable.currentItem ) {
					sortable._mouseDrag( event );

					// Copy the sortable's position because the draggable's can potentially reflect
					// a relative position, while sortable is always absolute, which the dragged
					// element has now become. (#8809)
					ui.position = sortable.position;
				}
			} else {

				// If it doesn't intersect with the sortable, and it intersected before,
				// we fake the drag stop of the sortable, but make sure it doesn't remove
				// the helper by using cancelHelperRemoval.
				if ( sortable.isOver ) {

					sortable.isOver = 0;
					sortable.cancelHelperRemoval = true;

					// Calling sortable's mouseStop would trigger a revert,
					// so revert must be temporarily false until after mouseStop is called.
					sortable.options._revert = sortable.options.revert;
					sortable.options.revert = false;

					sortable._trigger( "out", event, sortable._uiHash( sortable ) );
					sortable._mouseStop( event, true );

					// Restore sortable behaviors that were modfied
					// when the draggable entered the sortable area (#9481)
					sortable.options.revert = sortable.options._revert;
					sortable.options.helper = sortable.options._helper;

					if ( sortable.placeholder ) {
						sortable.placeholder.remove();
					}

					// Restore and recalculate the draggable's offset considering the sortable
					// may have modified them in unexpected ways. (#8809, #10669)
					ui.helper.appendTo( draggable._parent );
					draggable._refreshOffsets( event );
					ui.position = draggable._generatePosition( event, true );

					draggable._trigger( "fromSortable", event );

					// Inform draggable that the helper is no longer in a valid drop zone
					draggable.dropped = false;

					// Need to refreshPositions of all sortables just in case removing
					// from one sortable changes the location of other sortables (#9675)
					$.each( draggable.sortables, function() {
						this.refreshPositions();
					} );
				}
			}
		} );
	}
} );

$.ui.plugin.add( "draggable", "cursor", {
	start: function( event, ui, instance ) {
		var t = $( "body" ),
			o = instance.options;

		if ( t.css( "cursor" ) ) {
			o._cursor = t.css( "cursor" );
		}
		t.css( "cursor", o.cursor );
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;
		if ( o._cursor ) {
			$( "body" ).css( "cursor", o._cursor );
		}
	}
} );

$.ui.plugin.add( "draggable", "opacity", {
	start: function( event, ui, instance ) {
		var t = $( ui.helper ),
			o = instance.options;
		if ( t.css( "opacity" ) ) {
			o._opacity = t.css( "opacity" );
		}
		t.css( "opacity", o.opacity );
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;
		if ( o._opacity ) {
			$( ui.helper ).css( "opacity", o._opacity );
		}
	}
} );

$.ui.plugin.add( "draggable", "scroll", {
	start: function( event, ui, i ) {
		if ( !i.scrollParentNotHidden ) {
			i.scrollParentNotHidden = i.helper.scrollParent( false );
		}

		if ( i.scrollParentNotHidden[ 0 ] !== i.document[ 0 ] &&
				i.scrollParentNotHidden[ 0 ].tagName !== "HTML" ) {
			i.overflowOffset = i.scrollParentNotHidden.offset();
		}
	},
	drag: function( event, ui, i  ) {

		var o = i.options,
			scrolled = false,
			scrollParent = i.scrollParentNotHidden[ 0 ],
			document = i.document[ 0 ];

		if ( scrollParent !== document && scrollParent.tagName !== "HTML" ) {
			if ( !o.axis || o.axis !== "x" ) {
				if ( ( i.overflowOffset.top + scrollParent.offsetHeight ) - event.pageY <
						o.scrollSensitivity ) {
					scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
				} else if ( event.pageY - i.overflowOffset.top < o.scrollSensitivity ) {
					scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
				}
			}

			if ( !o.axis || o.axis !== "y" ) {
				if ( ( i.overflowOffset.left + scrollParent.offsetWidth ) - event.pageX <
						o.scrollSensitivity ) {
					scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
				} else if ( event.pageX - i.overflowOffset.left < o.scrollSensitivity ) {
					scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;
				}
			}

		} else {

			if ( !o.axis || o.axis !== "x" ) {
				if ( event.pageY - $( document ).scrollTop() < o.scrollSensitivity ) {
					scrolled = $( document ).scrollTop( $( document ).scrollTop() - o.scrollSpeed );
				} else if ( $( window ).height() - ( event.pageY - $( document ).scrollTop() ) <
						o.scrollSensitivity ) {
					scrolled = $( document ).scrollTop( $( document ).scrollTop() + o.scrollSpeed );
				}
			}

			if ( !o.axis || o.axis !== "y" ) {
				if ( event.pageX - $( document ).scrollLeft() < o.scrollSensitivity ) {
					scrolled = $( document ).scrollLeft(
						$( document ).scrollLeft() - o.scrollSpeed
					);
				} else if ( $( window ).width() - ( event.pageX - $( document ).scrollLeft() ) <
						o.scrollSensitivity ) {
					scrolled = $( document ).scrollLeft(
						$( document ).scrollLeft() + o.scrollSpeed
					);
				}
			}

		}

		if ( scrolled !== false && $.ui.ddmanager && !o.dropBehaviour ) {
			$.ui.ddmanager.prepareOffsets( i, event );
		}

	}
} );

$.ui.plugin.add( "draggable", "snap", {
	start: function( event, ui, i ) {

		var o = i.options;

		i.snapElements = [];

		$( o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap )
			.each( function() {
				var $t = $( this ),
					$o = $t.offset();
				if ( this !== i.element[ 0 ] ) {
					i.snapElements.push( {
						item: this,
						width: $t.outerWidth(), height: $t.outerHeight(),
						top: $o.top, left: $o.left
					} );
				}
			} );

	},
	drag: function( event, ui, inst ) {

		var ts, bs, ls, rs, l, r, t, b, i, first,
			o = inst.options,
			d = o.snapTolerance,
			x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for ( i = inst.snapElements.length - 1; i >= 0; i-- ) {

			l = inst.snapElements[ i ].left - inst.margins.left;
			r = l + inst.snapElements[ i ].width;
			t = inst.snapElements[ i ].top - inst.margins.top;
			b = t + inst.snapElements[ i ].height;

			if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d ||
					!$.contains( inst.snapElements[ i ].item.ownerDocument,
					inst.snapElements[ i ].item ) ) {
				if ( inst.snapElements[ i ].snapping ) {
					( inst.options.snap.release &&
						inst.options.snap.release.call(
							inst.element,
							event,
							$.extend( inst._uiHash(), { snapItem: inst.snapElements[ i ].item } )
						) );
				}
				inst.snapElements[ i ].snapping = false;
				continue;
			}

			if ( o.snapMode !== "inner" ) {
				ts = Math.abs( t - y2 ) <= d;
				bs = Math.abs( b - y1 ) <= d;
				ls = Math.abs( l - x2 ) <= d;
				rs = Math.abs( r - x1 ) <= d;
				if ( ts ) {
					ui.position.top = inst._convertPositionTo( "relative", {
						top: t - inst.helperProportions.height,
						left: 0
					} ).top;
				}
				if ( bs ) {
					ui.position.top = inst._convertPositionTo( "relative", {
						top: b,
						left: 0
					} ).top;
				}
				if ( ls ) {
					ui.position.left = inst._convertPositionTo( "relative", {
						top: 0,
						left: l - inst.helperProportions.width
					} ).left;
				}
				if ( rs ) {
					ui.position.left = inst._convertPositionTo( "relative", {
						top: 0,
						left: r
					} ).left;
				}
			}

			first = ( ts || bs || ls || rs );

			if ( o.snapMode !== "outer" ) {
				ts = Math.abs( t - y1 ) <= d;
				bs = Math.abs( b - y2 ) <= d;
				ls = Math.abs( l - x1 ) <= d;
				rs = Math.abs( r - x2 ) <= d;
				if ( ts ) {
					ui.position.top = inst._convertPositionTo( "relative", {
						top: t,
						left: 0
					} ).top;
				}
				if ( bs ) {
					ui.position.top = inst._convertPositionTo( "relative", {
						top: b - inst.helperProportions.height,
						left: 0
					} ).top;
				}
				if ( ls ) {
					ui.position.left = inst._convertPositionTo( "relative", {
						top: 0,
						left: l
					} ).left;
				}
				if ( rs ) {
					ui.position.left = inst._convertPositionTo( "relative", {
						top: 0,
						left: r - inst.helperProportions.width
					} ).left;
				}
			}

			if ( !inst.snapElements[ i ].snapping && ( ts || bs || ls || rs || first ) ) {
				( inst.options.snap.snap &&
					inst.options.snap.snap.call(
						inst.element,
						event,
						$.extend( inst._uiHash(), {
							snapItem: inst.snapElements[ i ].item
						} ) ) );
			}
			inst.snapElements[ i ].snapping = ( ts || bs || ls || rs || first );

		}

	}
} );

$.ui.plugin.add( "draggable", "stack", {
	start: function( event, ui, instance ) {
		var min,
			o = instance.options,
			group = $.makeArray( $( o.stack ) ).sort( function( a, b ) {
				return ( parseInt( $( a ).css( "zIndex" ), 10 ) || 0 ) -
					( parseInt( $( b ).css( "zIndex" ), 10 ) || 0 );
			} );

		if ( !group.length ) { return; }

		min = parseInt( $( group[ 0 ] ).css( "zIndex" ), 10 ) || 0;
		$( group ).each( function( i ) {
			$( this ).css( "zIndex", min + i );
		} );
		this.css( "zIndex", ( min + group.length ) );
	}
} );

$.ui.plugin.add( "draggable", "zIndex", {
	start: function( event, ui, instance ) {
		var t = $( ui.helper ),
			o = instance.options;

		if ( t.css( "zIndex" ) ) {
			o._zIndex = t.css( "zIndex" );
		}
		t.css( "zIndex", o.zIndex );
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;

		if ( o._zIndex ) {
			$( ui.helper ).css( "zIndex", o._zIndex );
		}
	}
} );

var widgetsDraggable = $.ui.draggable;


/*!
 * jQuery UI Droppable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Droppable
//>>group: Interactions
//>>description: Enables drop targets for draggable elements.
//>>docs: http://api.jqueryui.com/droppable/
//>>demos: http://jqueryui.com/droppable/



$.widget( "ui.droppable", {
	version: "1.12.1",
	widgetEventPrefix: "drop",
	options: {
		accept: "*",
		addClasses: true,
		greedy: false,
		scope: "default",
		tolerance: "intersect",

		// Callbacks
		activate: null,
		deactivate: null,
		drop: null,
		out: null,
		over: null
	},
	_create: function() {

		var proportions,
			o = this.options,
			accept = o.accept;

		this.isover = false;
		this.isout = true;

		this.accept = $.isFunction( accept ) ? accept : function( d ) {
			return d.is( accept );
		};

		this.proportions = function( /* valueToWrite */ ) {
			if ( arguments.length ) {

				// Store the droppable's proportions
				proportions = arguments[ 0 ];
			} else {

				// Retrieve or derive the droppable's proportions
				return proportions ?
					proportions :
					proportions = {
						width: this.element[ 0 ].offsetWidth,
						height: this.element[ 0 ].offsetHeight
					};
			}
		};

		this._addToManager( o.scope );

		o.addClasses && this._addClass( "ui-droppable" );

	},

	_addToManager: function( scope ) {

		// Add the reference and positions to the manager
		$.ui.ddmanager.droppables[ scope ] = $.ui.ddmanager.droppables[ scope ] || [];
		$.ui.ddmanager.droppables[ scope ].push( this );
	},

	_splice: function( drop ) {
		var i = 0;
		for ( ; i < drop.length; i++ ) {
			if ( drop[ i ] === this ) {
				drop.splice( i, 1 );
			}
		}
	},

	_destroy: function() {
		var drop = $.ui.ddmanager.droppables[ this.options.scope ];

		this._splice( drop );
	},

	_setOption: function( key, value ) {

		if ( key === "accept" ) {
			this.accept = $.isFunction( value ) ? value : function( d ) {
				return d.is( value );
			};
		} else if ( key === "scope" ) {
			var drop = $.ui.ddmanager.droppables[ this.options.scope ];

			this._splice( drop );
			this._addToManager( value );
		}

		this._super( key, value );
	},

	_activate: function( event ) {
		var draggable = $.ui.ddmanager.current;

		this._addActiveClass();
		if ( draggable ) {
			this._trigger( "activate", event, this.ui( draggable ) );
		}
	},

	_deactivate: function( event ) {
		var draggable = $.ui.ddmanager.current;

		this._removeActiveClass();
		if ( draggable ) {
			this._trigger( "deactivate", event, this.ui( draggable ) );
		}
	},

	_over: function( event ) {

		var draggable = $.ui.ddmanager.current;

		// Bail if draggable and droppable are same element
		if ( !draggable || ( draggable.currentItem ||
				draggable.element )[ 0 ] === this.element[ 0 ] ) {
			return;
		}

		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem ||
				draggable.element ) ) ) {
			this._addHoverClass();
			this._trigger( "over", event, this.ui( draggable ) );
		}

	},

	_out: function( event ) {

		var draggable = $.ui.ddmanager.current;

		// Bail if draggable and droppable are same element
		if ( !draggable || ( draggable.currentItem ||
				draggable.element )[ 0 ] === this.element[ 0 ] ) {
			return;
		}

		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem ||
				draggable.element ) ) ) {
			this._removeHoverClass();
			this._trigger( "out", event, this.ui( draggable ) );
		}

	},

	_drop: function( event, custom ) {

		var draggable = custom || $.ui.ddmanager.current,
			childrenIntersection = false;

		// Bail if draggable and droppable are same element
		if ( !draggable || ( draggable.currentItem ||
				draggable.element )[ 0 ] === this.element[ 0 ] ) {
			return false;
		}

		this.element
			.find( ":data(ui-droppable)" )
			.not( ".ui-draggable-dragging" )
			.each( function() {
				var inst = $( this ).droppable( "instance" );
				if (
					inst.options.greedy &&
					!inst.options.disabled &&
					inst.options.scope === draggable.options.scope &&
					inst.accept.call(
						inst.element[ 0 ], ( draggable.currentItem || draggable.element )
					) &&
					intersect(
						draggable,
						$.extend( inst, { offset: inst.element.offset() } ),
						inst.options.tolerance, event
					)
				) {
					childrenIntersection = true;
					return false; }
			} );
		if ( childrenIntersection ) {
			return false;
		}

		if ( this.accept.call( this.element[ 0 ],
				( draggable.currentItem || draggable.element ) ) ) {
			this._removeActiveClass();
			this._removeHoverClass();

			this._trigger( "drop", event, this.ui( draggable ) );
			return this.element;
		}

		return false;

	},

	ui: function( c ) {
		return {
			draggable: ( c.currentItem || c.element ),
			helper: c.helper,
			position: c.position,
			offset: c.positionAbs
		};
	},

	// Extension points just to make backcompat sane and avoid duplicating logic
	// TODO: Remove in 1.13 along with call to it below
	_addHoverClass: function() {
		this._addClass( "ui-droppable-hover" );
	},

	_removeHoverClass: function() {
		this._removeClass( "ui-droppable-hover" );
	},

	_addActiveClass: function() {
		this._addClass( "ui-droppable-active" );
	},

	_removeActiveClass: function() {
		this._removeClass( "ui-droppable-active" );
	}
} );

var intersect = $.ui.intersect = ( function() {
	function isOverAxis( x, reference, size ) {
		return ( x >= reference ) && ( x < ( reference + size ) );
	}

	return function( draggable, droppable, toleranceMode, event ) {

		if ( !droppable.offset ) {
			return false;
		}

		var x1 = ( draggable.positionAbs ||
				draggable.position.absolute ).left + draggable.margins.left,
			y1 = ( draggable.positionAbs ||
				draggable.position.absolute ).top + draggable.margins.top,
			x2 = x1 + draggable.helperProportions.width,
			y2 = y1 + draggable.helperProportions.height,
			l = droppable.offset.left,
			t = droppable.offset.top,
			r = l + droppable.proportions().width,
			b = t + droppable.proportions().height;

		switch ( toleranceMode ) {
		case "fit":
			return ( l <= x1 && x2 <= r && t <= y1 && y2 <= b );
		case "intersect":
			return ( l < x1 + ( draggable.helperProportions.width / 2 ) && // Right Half
				x2 - ( draggable.helperProportions.width / 2 ) < r && // Left Half
				t < y1 + ( draggable.helperProportions.height / 2 ) && // Bottom Half
				y2 - ( draggable.helperProportions.height / 2 ) < b ); // Top Half
		case "pointer":
			return isOverAxis( event.pageY, t, droppable.proportions().height ) &&
				isOverAxis( event.pageX, l, droppable.proportions().width );
		case "touch":
			return (
				( y1 >= t && y1 <= b ) || // Top edge touching
				( y2 >= t && y2 <= b ) || // Bottom edge touching
				( y1 < t && y2 > b ) // Surrounded vertically
			) && (
				( x1 >= l && x1 <= r ) || // Left edge touching
				( x2 >= l && x2 <= r ) || // Right edge touching
				( x1 < l && x2 > r ) // Surrounded horizontally
			);
		default:
			return false;
		}
	};
} )();

/*
	This manager tracks offsets of draggables and droppables
*/
$.ui.ddmanager = {
	current: null,
	droppables: { "default": [] },
	prepareOffsets: function( t, event ) {

		var i, j,
			m = $.ui.ddmanager.droppables[ t.options.scope ] || [],
			type = event ? event.type : null, // workaround for #2317
			list = ( t.currentItem || t.element ).find( ":data(ui-droppable)" ).addBack();

		droppablesLoop: for ( i = 0; i < m.length; i++ ) {

			// No disabled and non-accepted
			if ( m[ i ].options.disabled || ( t && !m[ i ].accept.call( m[ i ].element[ 0 ],
					( t.currentItem || t.element ) ) ) ) {
				continue;
			}

			// Filter out elements in the current dragged item
			for ( j = 0; j < list.length; j++ ) {
				if ( list[ j ] === m[ i ].element[ 0 ] ) {
					m[ i ].proportions().height = 0;
					continue droppablesLoop;
				}
			}

			m[ i ].visible = m[ i ].element.css( "display" ) !== "none";
			if ( !m[ i ].visible ) {
				continue;
			}

			// Activate the droppable if used directly from draggables
			if ( type === "mousedown" ) {
				m[ i ]._activate.call( m[ i ], event );
			}

			m[ i ].offset = m[ i ].element.offset();
			m[ i ].proportions( {
				width: m[ i ].element[ 0 ].offsetWidth,
				height: m[ i ].element[ 0 ].offsetHeight
			} );

		}

	},
	drop: function( draggable, event ) {

		var dropped = false;

		// Create a copy of the droppables in case the list changes during the drop (#9116)
		$.each( ( $.ui.ddmanager.droppables[ draggable.options.scope ] || [] ).slice(), function() {

			if ( !this.options ) {
				return;
			}
			if ( !this.options.disabled && this.visible &&
					intersect( draggable, this, this.options.tolerance, event ) ) {
				dropped = this._drop.call( this, event ) || dropped;
			}

			if ( !this.options.disabled && this.visible && this.accept.call( this.element[ 0 ],
					( draggable.currentItem || draggable.element ) ) ) {
				this.isout = true;
				this.isover = false;
				this._deactivate.call( this, event );
			}

		} );
		return dropped;

	},
	dragStart: function( draggable, event ) {

		// Listen for scrolling so that if the dragging causes scrolling the position of the
		// droppables can be recalculated (see #5003)
		draggable.element.parentsUntil( "body" ).on( "scroll.droppable", function() {
			if ( !draggable.options.refreshPositions ) {
				$.ui.ddmanager.prepareOffsets( draggable, event );
			}
		} );
	},
	drag: function( draggable, event ) {

		// If you have a highly dynamic page, you might try this option. It renders positions
		// every time you move the mouse.
		if ( draggable.options.refreshPositions ) {
			$.ui.ddmanager.prepareOffsets( draggable, event );
		}

		// Run through all droppables and check their positions based on specific tolerance options
		$.each( $.ui.ddmanager.droppables[ draggable.options.scope ] || [], function() {

			if ( this.options.disabled || this.greedyChild || !this.visible ) {
				return;
			}

			var parentInstance, scope, parent,
				intersects = intersect( draggable, this, this.options.tolerance, event ),
				c = !intersects && this.isover ?
					"isout" :
					( intersects && !this.isover ? "isover" : null );
			if ( !c ) {
				return;
			}

			if ( this.options.greedy ) {

				// find droppable parents with same scope
				scope = this.options.scope;
				parent = this.element.parents( ":data(ui-droppable)" ).filter( function() {
					return $( this ).droppable( "instance" ).options.scope === scope;
				} );

				if ( parent.length ) {
					parentInstance = $( parent[ 0 ] ).droppable( "instance" );
					parentInstance.greedyChild = ( c === "isover" );
				}
			}

			// We just moved into a greedy child
			if ( parentInstance && c === "isover" ) {
				parentInstance.isover = false;
				parentInstance.isout = true;
				parentInstance._out.call( parentInstance, event );
			}

			this[ c ] = true;
			this[ c === "isout" ? "isover" : "isout" ] = false;
			this[ c === "isover" ? "_over" : "_out" ].call( this, event );

			// We just moved out of a greedy child
			if ( parentInstance && c === "isout" ) {
				parentInstance.isout = false;
				parentInstance.isover = true;
				parentInstance._over.call( parentInstance, event );
			}
		} );

	},
	dragStop: function( draggable, event ) {
		draggable.element.parentsUntil( "body" ).off( "scroll.droppable" );

		// Call prepareOffsets one final time since IE does not fire return scroll events when
		// overflow was caused by drag (see #5003)
		if ( !draggable.options.refreshPositions ) {
			$.ui.ddmanager.prepareOffsets( draggable, event );
		}
	}
};

// DEPRECATED
// TODO: switch return back to widget declaration at top of file when this is removed
if ( $.uiBackCompat !== false ) {

	// Backcompat for activeClass and hoverClass options
	$.widget( "ui.droppable", $.ui.droppable, {
		options: {
			hoverClass: false,
			activeClass: false
		},
		_addActiveClass: function() {
			this._super();
			if ( this.options.activeClass ) {
				this.element.addClass( this.options.activeClass );
			}
		},
		_removeActiveClass: function() {
			this._super();
			if ( this.options.activeClass ) {
				this.element.removeClass( this.options.activeClass );
			}
		},
		_addHoverClass: function() {
			this._super();
			if ( this.options.hoverClass ) {
				this.element.addClass( this.options.hoverClass );
			}
		},
		_removeHoverClass: function() {
			this._super();
			if ( this.options.hoverClass ) {
				this.element.removeClass( this.options.hoverClass );
			}
		}
	} );
}

var widgetsDroppable = $.ui.droppable;




}));
/**
 * jQuery contextMenu v2.4.5 - Plugin for simple contextMenu handling
 *
 * Version: v2.4.5
 *
 * Authors: Björn Brala (SWIS.nl), Rodney Rehm, Addy Osmani (patches for FF)
 * Web: http://swisnl.github.io/jQuery-contextMenu/
 *
 * Copyright (c) 2011-2017 SWIS BV and contributors
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 * Date: 2017-05-05T14:40:36.990Z
 */

// jscs:disable
/* jshint ignore:start */
(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as anonymous module.
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node / CommonJS
        factory(require('jquery'));
    } else {
        // Browser globals.
        factory(jQuery);
    }
})(function ($) {

    'use strict';

    // TODO: -
    // ARIA stuff: menuitem, menuitemcheckbox und menuitemradio
    // create <menu> structure if $.support[htmlCommand || htmlMenuitem] and !opt.disableNative

    // determine html5 compatibility
    $.support.htmlMenuitem = ('HTMLMenuItemElement' in window);
    $.support.htmlCommand = ('HTMLCommandElement' in window);
    $.support.eventSelectstart = ('onselectstart' in document.documentElement);
    /* // should the need arise, test for css user-select
     $.support.cssUserSelect = (function(){
     var t = false,
     e = document.createElement('div');

     $.each('Moz|Webkit|Khtml|O|ms|Icab|'.split('|'), function(i, prefix) {
     var propCC = prefix + (prefix ? 'U' : 'u') + 'serSelect',
     prop = (prefix ? ('-' + prefix.toLowerCase() + '-') : '') + 'user-select';

     e.style.cssText = prop + ': text;';
     if (e.style[propCC] == 'text') {
     t = true;
     return false;
     }

     return true;
     });

     return t;
     })();
     */


    if (!$.ui || !$.widget) {
        // duck punch $.cleanData like jQueryUI does to get that remove event
        $.cleanData = (function (orig) {
            return function (elems) {
                var events, elem, i;
                for (i = 0; elems[i] != null; i++) {
                    elem = elems[i];
                    try {
                        // Only trigger remove when necessary to save time
                        events = $._data(elem, 'events');
                        if (events && events.remove) {
                            $(elem).triggerHandler('remove');
                        }

                        // Http://bugs.jquery.com/ticket/8235
                    } catch (e) {
                    }
                }
                orig(elems);
            };
        })($.cleanData);
    }
    /* jshint ignore:end */
    // jscs:enable

    var // currently active contextMenu trigger
        $currentTrigger = null,
        // is contextMenu initialized with at least one menu?
        initialized = false,
        // window handle
        $win = $(window),
        // number of registered menus
        counter = 0,
        // mapping selector to namespace
        namespaces = {},
        // mapping namespace to options
        menus = {},
        // custom command type handlers
        types = {},
        // default values
        defaults = {
            // selector of contextMenu trigger
            selector: null,
            // where to append the menu to
            appendTo: null,
            // method to trigger context menu ["right", "left", "hover"]
            trigger: 'right',
            // hide menu when mouse leaves trigger / menu elements
            autoHide: false,
            // ms to wait before showing a hover-triggered context menu
            delay: 200,
            // flag denoting if a second trigger should simply move (true) or rebuild (false) an open menu
            // as long as the trigger happened on one of the trigger-element's child nodes
            reposition: true,

            //ability to select submenu
            selectableSubMenu: false,

            // Default classname configuration to be able avoid conflicts in frameworks
            classNames: {
                hover: 'context-menu-hover', // Item hover
                disabled: 'context-menu-disabled', // Item disabled
                visible: 'context-menu-visible', // Item visible
                notSelectable: 'context-menu-not-selectable', // Item not selectable

                icon: 'context-menu-icon',
                iconEdit: 'context-menu-icon-edit',
                iconCut: 'context-menu-icon-cut',
                iconCopy: 'context-menu-icon-copy',
                iconPaste: 'context-menu-icon-paste',
                iconDelete: 'context-menu-icon-delete',
                iconAdd: 'context-menu-icon-add',
                iconQuit: 'context-menu-icon-quit',
                iconLoadingClass: 'context-menu-icon-loading'
            },

            // determine position to show menu at
            determinePosition: function ($menu) {
                // position to the lower middle of the trigger element
                if ($.ui && $.ui.position) {
                    // .position() is provided as a jQuery UI utility
                    // (...and it won't work on hidden elements)
                    $menu.css('display', 'block').position({
                        my: 'center top',
                        at: 'center bottom',
                        of: this,
                        offset: '0 5',
                        collision: 'fit'
                    }).css('display', 'none');
                } else {
                    // determine contextMenu position
                    var offset = this.offset();
                    offset.top += this.outerHeight();
                    offset.left += this.outerWidth() / 2 - $menu.outerWidth() / 2;
                    $menu.css(offset);
                }
            },
            // position menu
            position: function (opt, x, y) {
                var offset;
                // determine contextMenu position
                if (!x && !y) {
                    opt.determinePosition.call(this, opt.$menu);
                    return;
                } else if (x === 'maintain' && y === 'maintain') {
                    // x and y must not be changed (after re-show on command click)
                    offset = opt.$menu.position();
                } else {
                    // x and y are given (by mouse event)
                    var offsetParentOffset = opt.$menu.offsetParent().offset();
                    offset = {top: y - offsetParentOffset.top, left: x -offsetParentOffset.left};
                }

                // correct offset if viewport demands it
                var bottom = $win.scrollTop() + $win.height(),
                    right = $win.scrollLeft() + $win.width(),
                    height = opt.$menu.outerHeight(),
                    width = opt.$menu.outerWidth();

                if (offset.top + height > bottom) {
                    offset.top -= height;
                }

                if (offset.top < 0) {
                    offset.top = 0;
                }

                if (offset.left + width > right) {
                    offset.left -= width;
                }

                if (offset.left < 0) {
                    offset.left = 0;
                }

                opt.$menu.css(offset);
            },
            // position the sub-menu
            positionSubmenu: function ($menu) {
                if (typeof $menu === 'undefined') {
                    // When user hovers over item (which has sub items) handle.focusItem will call this.
                    // but the submenu does not exist yet if opt.items is a promise. just return, will
                    // call positionSubmenu after promise is completed.
                    return;
                }
                if ($.ui && $.ui.position) {
                    // .position() is provided as a jQuery UI utility
                    // (...and it won't work on hidden elements)
                    $menu.css('display', 'block').position({
                        my: 'left top-5',
                        at: 'right top',
                        of: this,
                        collision: 'flipfit fit'
                    }).css('display', '');
                } else {
                    // determine contextMenu position
                    var offset = {
                        top: -9,
                        left: this.outerWidth() - 5
                    };
                    $menu.css(offset);
                }
            },
            // offset to add to zIndex
            zIndex: 1,
            // show hide animation settings
            animation: {
                duration: 50,
                show: 'slideDown',
                hide: 'slideUp'
            },
            // events
            events: {
                show: $.noop,
                hide: $.noop
            },
            // default callback
            callback: null,
            // list of contextMenu items
            items: {}
        },
        // mouse position for hover activation
        hoveract = {
            timer: null,
            pageX: null,
            pageY: null
        },
        // determine zIndex
        zindex = function ($t) {
            var zin = 0,
                $tt = $t;

            while (true) {
                zin = Math.max(zin, parseInt($tt.css('z-index'), 10) || 0);
                $tt = $tt.parent();
                if (!$tt || !$tt.length || 'html body'.indexOf($tt.prop('nodeName').toLowerCase()) > -1) {
                    break;
                }
            }
            return zin;
        },
        // event handlers
        handle = {
            // abort anything
            abortevent: function (e) {
                e.preventDefault();
                e.stopImmediatePropagation();
            },
            // contextmenu show dispatcher
            contextmenu: function (e) {
                var $this = $(this);

                // disable actual context-menu if we are using the right mouse button as the trigger
                if (e.data.trigger === 'right') {
                    e.preventDefault();
                    e.stopImmediatePropagation();
                }

                // abort native-triggered events unless we're triggering on right click
                if ((e.data.trigger !== 'right' && e.data.trigger !== 'demand') && e.originalEvent) {
                    return;
                }

                // Let the current contextmenu decide if it should show or not based on its own trigger settings
                if (typeof e.mouseButton !== 'undefined' && e.data) {
                    if (!(e.data.trigger === 'left' && e.mouseButton === 0) && !(e.data.trigger === 'right' && e.mouseButton === 2)) {
                        // Mouse click is not valid.
                        return;
                    }
                }

                // abort event if menu is visible for this trigger
                if ($this.hasClass('context-menu-active')) {
                    return;
                }

                if (!$this.hasClass('context-menu-disabled')) {
                    // theoretically need to fire a show event at <menu>
                    // http://www.whatwg.org/specs/web-apps/current-work/multipage/interactive-elements.html#context-menus
                    // var evt = jQuery.Event("show", { data: data, pageX: e.pageX, pageY: e.pageY, relatedTarget: this });
                    // e.data.$menu.trigger(evt);

                    $currentTrigger = $this;
                    if (e.data.build) {
                        var built = e.data.build($currentTrigger, e);
                        // abort if build() returned false
                        if (built === false) {
                            return;
                        }

                        // dynamically build menu on invocation
                        e.data = $.extend(true, {}, defaults, e.data, built || {});

                        // abort if there are no items to display
                        if (!e.data.items || $.isEmptyObject(e.data.items)) {
                            // Note: jQuery captures and ignores errors from event handlers
                            if (window.console) {
                                (console.error || console.log).call(console, 'No items specified to show in contextMenu');
                            }

                            throw new Error('No Items specified');
                        }

                        // backreference for custom command type creation
                        e.data.$trigger = $currentTrigger;

                        op.create(e.data);
                    }
                    var showMenu = false;
                    for (var item in e.data.items) {
                        if (e.data.items.hasOwnProperty(item)) {
                            var visible;
                            if ($.isFunction(e.data.items[item].visible)) {
                                visible = e.data.items[item].visible.call($(e.currentTarget), item, e.data);
                            } else if (typeof e.data.items[item] !== 'undefined' && e.data.items[item].visible) {
                                visible = e.data.items[item].visible === true;
                            } else {
                                visible = true;
                            }
                            if (visible) {
                                showMenu = true;
                            }
                        }
                    }
                    if (showMenu) {
                        // show menu
                        op.show.call($this, e.data, e.pageX, e.pageY);
                    }
                }
            },
            // contextMenu left-click trigger
            click: function (e) {
                e.preventDefault();
                e.stopImmediatePropagation();
                $(this).trigger($.Event('contextmenu', {data: e.data, pageX: e.pageX, pageY: e.pageY}));
            },
            // contextMenu right-click trigger
            mousedown: function (e) {
                // register mouse down
                var $this = $(this);

                // hide any previous menus
                if ($currentTrigger && $currentTrigger.length && !$currentTrigger.is($this)) {
                    $currentTrigger.data('contextMenu').$menu.trigger('contextmenu:hide');
                }

                // activate on right click
                if (e.button === 2) {
                    $currentTrigger = $this.data('contextMenuActive', true);
                }
            },
            // contextMenu right-click trigger
            mouseup: function (e) {
                // show menu
                var $this = $(this);
                if ($this.data('contextMenuActive') && $currentTrigger && $currentTrigger.length && $currentTrigger.is($this) && !$this.hasClass('context-menu-disabled')) {
                    e.preventDefault();
                    e.stopImmediatePropagation();
                    $currentTrigger = $this;
                    $this.trigger($.Event('contextmenu', {data: e.data, pageX: e.pageX, pageY: e.pageY}));
                }

                $this.removeData('contextMenuActive');
            },
            // contextMenu hover trigger
            mouseenter: function (e) {
                var $this = $(this),
                    $related = $(e.relatedTarget),
                    $document = $(document);

                // abort if we're coming from a menu
                if ($related.is('.context-menu-list') || $related.closest('.context-menu-list').length) {
                    return;
                }

                // abort if a menu is shown
                if ($currentTrigger && $currentTrigger.length) {
                    return;
                }

                hoveract.pageX = e.pageX;
                hoveract.pageY = e.pageY;
                hoveract.data = e.data;
                $document.on('mousemove.contextMenuShow', handle.mousemove);
                hoveract.timer = setTimeout(function () {
                    hoveract.timer = null;
                    $document.off('mousemove.contextMenuShow');
                    $currentTrigger = $this;
                    $this.trigger($.Event('contextmenu', {
                        data: hoveract.data,
                        pageX: hoveract.pageX,
                        pageY: hoveract.pageY
                    }));
                }, e.data.delay);
            },
            // contextMenu hover trigger
            mousemove: function (e) {
                hoveract.pageX = e.pageX;
                hoveract.pageY = e.pageY;
            },
            // contextMenu hover trigger
            mouseleave: function (e) {
                // abort if we're leaving for a menu
                var $related = $(e.relatedTarget);
                if ($related.is('.context-menu-list') || $related.closest('.context-menu-list').length) {
                    return;
                }

                try {
                    clearTimeout(hoveract.timer);
                } catch (e) {
                }

                hoveract.timer = null;
            },
            // click on layer to hide contextMenu
            layerClick: function (e) {
                var $this = $(this),
                    root = $this.data('contextMenuRoot'),
                    button = e.button,
                    x = e.pageX,
                    y = e.pageY,
                    target,
                    offset;

                e.preventDefault();

                setTimeout(function () {
                    var $window;
                    var triggerAction = ((root.trigger === 'left' && button === 0) || (root.trigger === 'right' && button === 2));

                    // find the element that would've been clicked, wasn't the layer in the way
                    if (document.elementFromPoint && root.$layer) {
                        root.$layer.hide();
                        target = document.elementFromPoint(x - $win.scrollLeft(), y - $win.scrollTop());

                        // also need to try and focus this element if we're in a contenteditable area,
                        // as the layer will prevent the browser mouse action we want
                        if (target.isContentEditable) {
                            var range = document.createRange(),
                                sel = window.getSelection();
                            range.selectNode(target);
                            range.collapse(true);
                            sel.removeAllRanges();
                            sel.addRange(range);
                        }
                        $(target).trigger(e);
                        root.$layer.show();
                    }

                    if (root.reposition && triggerAction) {
                        if (document.elementFromPoint) {
                            if (root.$trigger.is(target)) {
                                root.position.call(root.$trigger, root, x, y);
                                return;
                            }
                        } else {
                            offset = root.$trigger.offset();
                            $window = $(window);
                            // while this looks kinda awful, it's the best way to avoid
                            // unnecessarily calculating any positions
                            offset.top += $window.scrollTop();
                            if (offset.top <= e.pageY) {
                                offset.left += $window.scrollLeft();
                                if (offset.left <= e.pageX) {
                                    offset.bottom = offset.top + root.$trigger.outerHeight();
                                    if (offset.bottom >= e.pageY) {
                                        offset.right = offset.left + root.$trigger.outerWidth();
                                        if (offset.right >= e.pageX) {
                                            // reposition
                                            root.position.call(root.$trigger, root, x, y);
                                            return;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if (target && triggerAction) {
                        root.$trigger.one('contextmenu:hidden', function () {
                            $(target).contextMenu({x: x, y: y, button: button});
                        });
                    }

                    if (root !== null && typeof root !== 'undefined' && root.$menu !== null  && typeof root.$menu !== 'undefined') {
                        root.$menu.trigger('contextmenu:hide');
                    }
                }, 50);
            },
            // key handled :hover
            keyStop: function (e, opt) {
                if (!opt.isInput) {
                    e.preventDefault();
                }

                e.stopPropagation();
            },
            key: function (e) {

                var opt = {};

                // Only get the data from $currentTrigger if it exists
                if ($currentTrigger) {
                    opt = $currentTrigger.data('contextMenu') || {};
                }
                // If the trigger happen on a element that are above the contextmenu do this
                if (typeof opt.zIndex === 'undefined') {
                    opt.zIndex = 0;
                }
                var targetZIndex = 0;
                var getZIndexOfTriggerTarget = function (target) {
                    if (target.style.zIndex !== '') {
                        targetZIndex = target.style.zIndex;
                    } else {
                        if (target.offsetParent !== null && typeof target.offsetParent !== 'undefined') {
                            getZIndexOfTriggerTarget(target.offsetParent);
                        }
                        else if (target.parentElement !== null && typeof target.parentElement !== 'undefined') {
                            getZIndexOfTriggerTarget(target.parentElement);
                        }
                    }
                };
                getZIndexOfTriggerTarget(e.target);
                // If targetZIndex is heigher then opt.zIndex dont progress any futher.
                // This is used to make sure that if you are using a dialog with a input / textarea / contenteditable div
                // and its above the contextmenu it wont steal keys events
                if (opt.$menu && parseInt(targetZIndex,10) > parseInt(opt.$menu.css("zIndex"),10)) {
                    return;
                }
                switch (e.keyCode) {
                    case 9:
                    case 38: // up
                        handle.keyStop(e, opt);
                        // if keyCode is [38 (up)] or [9 (tab) with shift]
                        if (opt.isInput) {
                            if (e.keyCode === 9 && e.shiftKey) {
                                e.preventDefault();
                                if (opt.$selected) {
                                    opt.$selected.find('input, textarea, select').blur();
                                }
                                if (opt.$menu !== null && typeof opt.$menu !== 'undefined') {
                                    opt.$menu.trigger('prevcommand');
                                }
                                return;
                            } else if (e.keyCode === 38 && opt.$selected.find('input, textarea, select').prop('type') === 'checkbox') {
                                // checkboxes don't capture this key
                                e.preventDefault();
                                return;
                            }
                        } else if (e.keyCode !== 9 || e.shiftKey) {
                            if (opt.$menu !== null && typeof opt.$menu !== 'undefined') {
                                opt.$menu.trigger('prevcommand');
                            }
                            return;
                        }
                        break;
                    // omitting break;
                    // case 9: // tab - reached through omitted break;
                    case 40: // down
                        handle.keyStop(e, opt);
                        if (opt.isInput) {
                            if (e.keyCode === 9) {
                                e.preventDefault();
                                if (opt.$selected) {
                                    opt.$selected.find('input, textarea, select').blur();
                                }
                                if (opt.$menu !== null && typeof opt.$menu !== 'undefined') {
                                    opt.$menu.trigger('nextcommand');
                                }
                                return;
                            } else if (e.keyCode === 40 && opt.$selected.find('input, textarea, select').prop('type') === 'checkbox') {
                                // checkboxes don't capture this key
                                e.preventDefault();
                                return;
                            }
                        } else {
                            if (opt.$menu !== null && typeof opt.$menu !== 'undefined') {
                                opt.$menu.trigger('nextcommand');
                            }
                            return;
                        }
                        break;

                    case 37: // left
                        handle.keyStop(e, opt);
                        if (opt.isInput || !opt.$selected || !opt.$selected.length) {
                            break;
                        }

                        if (!opt.$selected.parent().hasClass('context-menu-root')) {
                            var $parent = opt.$selected.parent().parent();
                            opt.$selected.trigger('contextmenu:blur');
                            opt.$selected = $parent;
                            return;
                        }
                        break;

                    case 39: // right
                        handle.keyStop(e, opt);
                        if (opt.isInput || !opt.$selected || !opt.$selected.length) {
                            break;
                        }

                        var itemdata = opt.$selected.data('contextMenu') || {};
                        if (itemdata.$menu && opt.$selected.hasClass('context-menu-submenu')) {
                            opt.$selected = null;
                            itemdata.$selected = null;
                            itemdata.$menu.trigger('nextcommand');
                            return;
                        }
                        break;

                    case 35: // end
                    case 36: // home
                        if (opt.$selected && opt.$selected.find('input, textarea, select').length) {
                            return;
                        } else {
                            (opt.$selected && opt.$selected.parent() || opt.$menu)
                                .children(':not(.' + opt.classNames.disabled + ', .' + opt.classNames.notSelectable + ')')[e.keyCode === 36 ? 'first' : 'last']()
                                .trigger('contextmenu:focus');
                            e.preventDefault();
                            return;
                        }
                        break;

                    case 13: // enter
                        handle.keyStop(e, opt);
                        if (opt.isInput) {
                            if (opt.$selected && !opt.$selected.is('textarea, select')) {
                                e.preventDefault();
                                return;
                            }
                            break;
                        }
                        if (typeof opt.$selected !== 'undefined' && opt.$selected !== null) {
                            opt.$selected.trigger('mouseup');
                        }
                        return;

                    case 32: // space
                    case 33: // page up
                    case 34: // page down
                        // prevent browser from scrolling down while menu is visible
                        handle.keyStop(e, opt);
                        return;

                    case 27: // esc
                        handle.keyStop(e, opt);
                        if (opt.$menu !== null && typeof opt.$menu !== 'undefined') {
                            opt.$menu.trigger('contextmenu:hide');
                        }
                        return;

                    default: // 0-9, a-z
                        var k = (String.fromCharCode(e.keyCode)).toUpperCase();
                        if (opt.accesskeys && opt.accesskeys[k]) {
                            // according to the specs accesskeys must be invoked immediately
                            opt.accesskeys[k].$node.trigger(opt.accesskeys[k].$menu ? 'contextmenu:focus' : 'mouseup');
                            return;
                        }
                        break;
                }
                // pass event to selected item,
                // stop propagation to avoid endless recursion
                e.stopPropagation();
                if (typeof opt.$selected !== 'undefined' && opt.$selected !== null) {
                    opt.$selected.trigger(e);
                }
            },
            // select previous possible command in menu
            prevItem: function (e) {
                e.stopPropagation();
                var opt = $(this).data('contextMenu') || {};
                var root = $(this).data('contextMenuRoot') || {};

                // obtain currently selected menu
                if (opt.$selected) {
                    var $s = opt.$selected;
                    opt = opt.$selected.parent().data('contextMenu') || {};
                    opt.$selected = $s;
                }

                var $children = opt.$menu.children(),
                    $prev = !opt.$selected || !opt.$selected.prev().length ? $children.last() : opt.$selected.prev(),
                    $round = $prev;

                // skip disabled or hidden elements
                while ($prev.hasClass(root.classNames.disabled) || $prev.hasClass(root.classNames.notSelectable) || $prev.is(':hidden')) {
                    if ($prev.prev().length) {
                        $prev = $prev.prev();
                    } else {
                        $prev = $children.last();
                    }
                    if ($prev.is($round)) {
                        // break endless loop
                        return;
                    }
                }

                // leave current
                if (opt.$selected) {
                    handle.itemMouseleave.call(opt.$selected.get(0), e);
                }

                // activate next
                handle.itemMouseenter.call($prev.get(0), e);

                // focus input
                var $input = $prev.find('input, textarea, select');
                if ($input.length) {
                    $input.focus();
                }
            },
            // select next possible command in menu
            nextItem: function (e) {
                e.stopPropagation();
                var opt = $(this).data('contextMenu') || {};
                var root = $(this).data('contextMenuRoot') || {};

                // obtain currently selected menu
                if (opt.$selected) {
                    var $s = opt.$selected;
                    opt = opt.$selected.parent().data('contextMenu') || {};
                    opt.$selected = $s;
                }

                var $children = opt.$menu.children(),
                    $next = !opt.$selected || !opt.$selected.next().length ? $children.first() : opt.$selected.next(),
                    $round = $next;

                // skip disabled
                while ($next.hasClass(root.classNames.disabled) || $next.hasClass(root.classNames.notSelectable) || $next.is(':hidden')) {
                    if ($next.next().length) {
                        $next = $next.next();
                    } else {
                        $next = $children.first();
                    }
                    if ($next.is($round)) {
                        // break endless loop
                        return;
                    }
                }

                // leave current
                if (opt.$selected) {
                    handle.itemMouseleave.call(opt.$selected.get(0), e);
                }

                // activate next
                handle.itemMouseenter.call($next.get(0), e);

                // focus input
                var $input = $next.find('input, textarea, select');
                if ($input.length) {
                    $input.focus();
                }
            },
            // flag that we're inside an input so the key handler can act accordingly
            focusInput: function () {
                var $this = $(this).closest('.context-menu-item'),
                    data = $this.data(),
                    opt = data.contextMenu,
                    root = data.contextMenuRoot;

                root.$selected = opt.$selected = $this;
                root.isInput = opt.isInput = true;
            },
            // flag that we're inside an input so the key handler can act accordingly
            blurInput: function () {
                var $this = $(this).closest('.context-menu-item'),
                    data = $this.data(),
                    opt = data.contextMenu,
                    root = data.contextMenuRoot;

                root.isInput = opt.isInput = false;
            },
            // :hover on menu
            menuMouseenter: function () {
                var root = $(this).data().contextMenuRoot;
                root.hovering = true;
            },
            // :hover on menu
            menuMouseleave: function (e) {
                var root = $(this).data().contextMenuRoot;
                if (root.$layer && root.$layer.is(e.relatedTarget)) {
                    root.hovering = false;
                }
            },
            // :hover done manually so key handling is possible
            itemMouseenter: function (e) {
                var $this = $(this),
                    data = $this.data(),
                    opt = data.contextMenu,
                    root = data.contextMenuRoot;

                root.hovering = true;

                // abort if we're re-entering
                if (e && root.$layer && root.$layer.is(e.relatedTarget)) {
                    e.preventDefault();
                    e.stopImmediatePropagation();
                }

                // make sure only one item is selected
                (opt.$menu ? opt : root).$menu
                    .children('.' + root.classNames.hover).trigger('contextmenu:blur')
                    .children('.hover').trigger('contextmenu:blur');

                if ($this.hasClass(root.classNames.disabled) || $this.hasClass(root.classNames.notSelectable)) {
                    opt.$selected = null;
                    return;
                }


                $this.trigger('contextmenu:focus');
            },
            // :hover done manually so key handling is possible
            itemMouseleave: function (e) {
                var $this = $(this),
                    data = $this.data(),
                    opt = data.contextMenu,
                    root = data.contextMenuRoot;

                if (root !== opt && root.$layer && root.$layer.is(e.relatedTarget)) {
                    if (typeof root.$selected !== 'undefined' && root.$selected !== null) {
                        root.$selected.trigger('contextmenu:blur');
                    }
                    e.preventDefault();
                    e.stopImmediatePropagation();
                    root.$selected = opt.$selected = opt.$node;
                    return;
                }

                if(opt && opt.$menu && opt.$menu.hasClass('context-menu-visible')){
                    return;
                }

                $this.trigger('contextmenu:blur');
            },
            // contextMenu item click
            itemClick: function (e) {
                var $this = $(this),
                    data = $this.data(),
                    opt = data.contextMenu,
                    root = data.contextMenuRoot,
                    key = data.contextMenuKey,
                    callback;

                // abort if the key is unknown or disabled or is a menu
                if (!opt.items[key] || $this.is('.' + root.classNames.disabled + ', .context-menu-separator, .' + root.classNames.notSelectable) || ($this.is('.context-menu-submenu') && root.selectableSubMenu === false )) {
                    return;
                }

                e.preventDefault();
                e.stopImmediatePropagation();

                if ($.isFunction(opt.callbacks[key]) && Object.prototype.hasOwnProperty.call(opt.callbacks, key)) {
                    // item-specific callback
                    callback = opt.callbacks[key];
                } else if ($.isFunction(root.callback)) {
                    // default callback
                    callback = root.callback;
                } else {
                    // no callback, no action
                    return;
                }

                // hide menu if callback doesn't stop that
                if (callback.call(root.$trigger, key, root) !== false) {
                    root.$menu.trigger('contextmenu:hide');
                } else if (root.$menu.parent().length) {
                    op.update.call(root.$trigger, root);
                }
            },
            // ignore click events on input elements
            inputClick: function (e) {
                e.stopImmediatePropagation();
            },
            // hide <menu>
            hideMenu: function (e, data) {
                var root = $(this).data('contextMenuRoot');
                op.hide.call(root.$trigger, root, data && data.force);
            },
            // focus <command>
            focusItem: function (e) {
                e.stopPropagation();
                var $this = $(this),
                    data = $this.data(),
                    opt = data.contextMenu,
                    root = data.contextMenuRoot;

                if ($this.hasClass(root.classNames.disabled) || $this.hasClass(root.classNames.notSelectable)) {
                    return;
                }

                $this
                    .addClass([root.classNames.hover, root.classNames.visible].join(' '))
                    // select other items and included items
                    .parent().find('.context-menu-item').not($this)
                    .removeClass(root.classNames.visible)
                    .filter('.' + root.classNames.hover)
                    .trigger('contextmenu:blur');

                // remember selected
                opt.$selected = root.$selected = $this;


                if(opt && opt.$node && opt.$node.hasClass('context-menu-submenu')){
                    opt.$node.addClass(root.classNames.hover);
                }

                // position sub-menu - do after show so dumb $.ui.position can keep up
                if (opt.$node) {
                    root.positionSubmenu.call(opt.$node, opt.$menu);
                }
            },
            // blur <command>
            blurItem: function (e) {
                e.stopPropagation();
                var $this = $(this),
                    data = $this.data(),
                    opt = data.contextMenu,
                    root = data.contextMenuRoot;

                if (opt.autoHide) { // for tablets and touch screens this needs to remain
                    $this.removeClass(root.classNames.visible);
                }
                $this.removeClass(root.classNames.hover);
                opt.$selected = null;
            }
        },
        // operations
        op = {
            show: function (opt, x, y) {
                var $trigger = $(this),
                    css = {};

                // hide any open menus
                $('#context-menu-layer').trigger('mousedown');

                // backreference for callbacks
                opt.$trigger = $trigger;

                // show event
                if (opt.events.show.call($trigger, opt) === false) {
                    $currentTrigger = null;
                    return;
                }

                // create or update context menu
                op.update.call($trigger, opt);

                // position menu
                opt.position.call($trigger, opt, x, y);

                // make sure we're in front
                if (opt.zIndex) {
                    var additionalZValue = opt.zIndex;
                    // If opt.zIndex is a function, call the function to get the right zIndex.
                    if (typeof opt.zIndex === 'function') {
                        additionalZValue = opt.zIndex.call($trigger, opt);
                    }
                    css.zIndex = zindex($trigger) + additionalZValue;
                }

                // add layer
                op.layer.call(opt.$menu, opt, css.zIndex);

                // adjust sub-menu zIndexes
                opt.$menu.find('ul').css('zIndex', css.zIndex + 1);

                // position and show context menu
                opt.$menu.css(css)[opt.animation.show](opt.animation.duration, function () {
                    $trigger.trigger('contextmenu:visible');
                });
                // make options available and set state
                $trigger
                    .data('contextMenu', opt)
                    .addClass('context-menu-active');

                // register key handler
                $(document).off('keydown.contextMenu').on('keydown.contextMenu', handle.key);
                // register autoHide handler
                if (opt.autoHide) {
                    // mouse position handler
                    $(document).on('mousemove.contextMenuAutoHide', function (e) {
                        // need to capture the offset on mousemove,
                        // since the page might've been scrolled since activation
                        var pos = $trigger.offset();
                        pos.right = pos.left + $trigger.outerWidth();
                        pos.bottom = pos.top + $trigger.outerHeight();

                        if (opt.$layer && !opt.hovering && (!(e.pageX >= pos.left && e.pageX <= pos.right) || !(e.pageY >= pos.top && e.pageY <= pos.bottom))) {
                            /* Additional hover check after short time, you might just miss the edge of the menu */
                            setTimeout(function () {
                                if (!opt.hovering && opt.$menu !== null && typeof opt.$menu !== 'undefined') {
                                    opt.$menu.trigger('contextmenu:hide');
                                }
                            }, 50);
                        }
                    });
                }
            },
            hide: function (opt, force) {
                var $trigger = $(this);
                if (!opt) {
                    opt = $trigger.data('contextMenu') || {};
                }

                // hide event
                if (!force && opt.events && opt.events.hide.call($trigger, opt) === false) {
                    return;
                }

                // remove options and revert state
                $trigger
                    .removeData('contextMenu')
                    .removeClass('context-menu-active');

                if (opt.$layer) {
                    // keep layer for a bit so the contextmenu event can be aborted properly by opera
                    setTimeout((function ($layer) {
                        return function () {
                            $layer.remove();
                        };
                    })(opt.$layer), 10);

                    try {
                        delete opt.$layer;
                    } catch (e) {
                        opt.$layer = null;
                    }
                }

                // remove handle
                $currentTrigger = null;
                // remove selected
                opt.$menu.find('.' + opt.classNames.hover).trigger('contextmenu:blur');
                opt.$selected = null;
                // collapse all submenus
                opt.$menu.find('.' + opt.classNames.visible).removeClass(opt.classNames.visible);
                // unregister key and mouse handlers
                // $(document).off('.contextMenuAutoHide keydown.contextMenu'); // http://bugs.jquery.com/ticket/10705
                $(document).off('.contextMenuAutoHide').off('keydown.contextMenu');
                // hide menu
                if (opt.$menu) {
                    opt.$menu[opt.animation.hide](opt.animation.duration, function () {
                        // tear down dynamically built menu after animation is completed.
                        if (opt.build) {
                            opt.$menu.remove();
                            $.each(opt, function (key) {
                                switch (key) {
                                    case 'ns':
                                    case 'selector':
                                    case 'build':
                                    case 'trigger':
                                        return true;

                                    default:
                                        opt[key] = undefined;
                                        try {
                                            delete opt[key];
                                        } catch (e) {
                                        }
                                        return true;
                                }
                            });
                        }

                        setTimeout(function () {
                            $trigger.trigger('contextmenu:hidden');
                        }, 10);
                    });
                }
            },
            create: function (opt, root) {
                if (typeof root === 'undefined') {
                    root = opt;
                }

                // create contextMenu
                opt.$menu = $('<ul class="context-menu-list"></ul>').addClass(opt.className || '').data({
                    'contextMenu': opt,
                    'contextMenuRoot': root
                });

                $.each(['callbacks', 'commands', 'inputs'], function (i, k) {
                    opt[k] = {};
                    if (!root[k]) {
                        root[k] = {};
                    }
                });

                if (!root.accesskeys) {
                    root.accesskeys = {};
                }

                function createNameNode(item) {
                    var $name = $('<span></span>');
                    if (item._accesskey) {
                        if (item._beforeAccesskey) {
                            $name.append(document.createTextNode(item._beforeAccesskey));
                        }
                        $('<span></span>')
                            .addClass('context-menu-accesskey')
                            .text(item._accesskey)
                            .appendTo($name);
                        if (item._afterAccesskey) {
                            $name.append(document.createTextNode(item._afterAccesskey));
                        }
                    } else {
                        if (item.isHtmlName) {
                            // restrict use with access keys
                            if (typeof item.accesskey !== 'undefined') {
                                throw new Error('accesskeys are not compatible with HTML names and cannot be used together in the same item');
                            }
                            $name.html(item.name);
                        } else {
                            $name.text(item.name);
                        }
                    }
                    return $name;
                }

                // create contextMenu items
                $.each(opt.items, function (key, item) {
                    var $t = $('<li class="context-menu-item"></li>').addClass(item.className || ''),
                        $label = null,
                        $input = null;

                    // iOS needs to see a click-event bound to an element to actually
                    // have the TouchEvents infrastructure trigger the click event
                    $t.on('click', $.noop);

                    // Make old school string seperator a real item so checks wont be
                    // akward later.
                    // And normalize 'cm_separator' into 'cm_seperator'.
                    if (typeof item === 'string' || item.type === 'cm_separator') {
                        item = {type: 'cm_seperator'};
                    }

                    item.$node = $t.data({
                        'contextMenu': opt,
                        'contextMenuRoot': root,
                        'contextMenuKey': key
                    });

                    // register accesskey
                    // NOTE: the accesskey attribute should be applicable to any element, but Safari5 and Chrome13 still can't do that
                    if (typeof item.accesskey !== 'undefined') {
                        var aks = splitAccesskey(item.accesskey);
                        for (var i = 0, ak; ak = aks[i]; i++) {
                            if (!root.accesskeys[ak]) {
                                root.accesskeys[ak] = item;
                                var matched = item.name.match(new RegExp('^(.*?)(' + ak + ')(.*)$', 'i'));
                                if (matched) {
                                    item._beforeAccesskey = matched[1];
                                    item._accesskey = matched[2];
                                    item._afterAccesskey = matched[3];
                                }
                                break;
                            }
                        }
                    }

                    if (item.type && types[item.type]) {
                        // run custom type handler
                        types[item.type].call($t, item, opt, root);
                        // register commands
                        $.each([opt, root], function (i, k) {
                            k.commands[key] = item;
                            // Overwrite only if undefined or the item is appended to the root. This so it
                            // doesn't overwrite callbacks of root elements if the name is the same.
                            if ($.isFunction(item.callback) && (typeof k.callbacks[key] === 'undefined' || typeof opt.type === 'undefined')) {
                                k.callbacks[key] = item.callback;
                            }
                        });
                    } else {
                        // add label for input
                        if (item.type === 'cm_seperator') {
                            $t.addClass('context-menu-separator ' + root.classNames.notSelectable);
                        } else if (item.type === 'html') {
                            $t.addClass('context-menu-html ' + root.classNames.notSelectable);
                        } else if (item.type === 'sub') {
                            // We don't want to execute the next else-if if it is a sub.
                        } else if (item.type) {
                            $label = $('<label></label>').appendTo($t);
                            createNameNode(item).appendTo($label);

                            $t.addClass('context-menu-input');
                            opt.hasTypes = true;
                            $.each([opt, root], function (i, k) {
                                k.commands[key] = item;
                                k.inputs[key] = item;
                            });
                        } else if (item.items) {
                            item.type = 'sub';
                        }

                        switch (item.type) {
                            case 'cm_seperator':
                                break;

                            case 'text':
                                $input = $('<input type="text" value="1" name="" />')
                                    .attr('name', 'context-menu-input-' + key)
                                    .val(item.value || '')
                                    .appendTo($label);
                                break;

                            case 'textarea':
                                $input = $('<textarea name=""></textarea>')
                                    .attr('name', 'context-menu-input-' + key)
                                    .val(item.value || '')
                                    .appendTo($label);

                                if (item.height) {
                                    $input.height(item.height);
                                }
                                break;

                            case 'checkbox':
                                $input = $('<input type="checkbox" value="1" name="" />')
                                    .attr('name', 'context-menu-input-' + key)
                                    .val(item.value || '')
                                    .prop('checked', !!item.selected)
                                    .prependTo($label);
                                break;

                            case 'radio':
                                $input = $('<input type="radio" value="1" name="" />')
                                    .attr('name', 'context-menu-input-' + item.radio)
                                    .val(item.value || '')
                                    .prop('checked', !!item.selected)
                                    .prependTo($label);
                                break;

                            case 'select':
                                $input = $('<select name=""></select>')
                                    .attr('name', 'context-menu-input-' + key)
                                    .appendTo($label);
                                if (item.options) {
                                    $.each(item.options, function (value, text) {
                                        $('<option></option>').val(value).text(text).appendTo($input);
                                    });
                                    $input.val(item.selected);
                                }
                                break;

                            case 'sub':
                                createNameNode(item).appendTo($t);
                                item.appendTo = item.$node;
                                $t.data('contextMenu', item).addClass('context-menu-submenu');
                                item.callback = null;

                                // If item contains items, and this is a promise, we should create it later
                                // check if subitems is of type promise. If it is a promise we need to create
                                // it later, after promise has been resolved.
                                if ('function' === typeof item.items.then) {
                                    // probably a promise, process it, when completed it will create the sub menu's.
                                    op.processPromises(item, root, item.items);
                                } else {
                                    // normal submenu.
                                    op.create(item, root);
                                }
                                break;

                            case 'html':
                                $(item.html).appendTo($t);
                                break;

                            default:
                                $.each([opt, root], function (i, k) {
                                    k.commands[key] = item;
                                    // Overwrite only if undefined or the item is appended to the root. This so it
                                    // doesn't overwrite callbacks of root elements if the name is the same.
                                    if ($.isFunction(item.callback) && (typeof k.callbacks[key] === 'undefined' || typeof opt.type === 'undefined')) {
                                        k.callbacks[key] = item.callback;
                                    }
                                });
                                createNameNode(item).appendTo($t);
                                break;
                        }

                        // disable key listener in <input>
                        if (item.type && item.type !== 'sub' && item.type !== 'html' && item.type !== 'cm_seperator') {
                            $input
                                .on('focus', handle.focusInput)
                                .on('blur', handle.blurInput);

                            if (item.events) {
                                $input.on(item.events, opt);
                            }
                        }

                        // add icons
                        if (item.icon) {
                            if ($.isFunction(item.icon)) {
                                item._icon = item.icon.call(this, this, $t, key, item);
                            } else {
                                if (typeof(item.icon) === 'string' && item.icon.substring(0, 3) === 'fa-') {
                                    // to enable font awesome
                                    item._icon = root.classNames.icon + ' ' + root.classNames.icon + '--fa fa ' + item.icon;
                                } else {
                                    item._icon = root.classNames.icon + ' ' + root.classNames.icon + '-' + item.icon;
                                }
                            }
                            $t.addClass(item._icon);
                        }
                    }

                    // cache contained elements
                    item.$input = $input;
                    item.$label = $label;

                    // attach item to menu
                    $t.appendTo(opt.$menu);

                    // Disable text selection
                    if (!opt.hasTypes && $.support.eventSelectstart) {
                        // browsers support user-select: none,
                        // IE has a special event for text-selection
                        // browsers supporting neither will not be preventing text-selection
                        $t.on('selectstart.disableTextSelect', handle.abortevent);
                    }
                });
                // attach contextMenu to <body> (to bypass any possible overflow:hidden issues on parents of the trigger element)
                if (!opt.$node) {
                    opt.$menu.css('display', 'none').addClass('context-menu-root');
                }
                opt.$menu.appendTo(opt.appendTo || document.body);
            },
            resize: function ($menu, nested) {
                var domMenu;
                // determine widths of submenus, as CSS won't grow them automatically
                // position:absolute within position:absolute; min-width:100; max-width:200; results in width: 100;
                // kinda sucks hard...

                // determine width of absolutely positioned element
                $menu.css({position: 'absolute', display: 'block'});
                // don't apply yet, because that would break nested elements' widths
                $menu.data('width',
                    (domMenu = $menu.get(0)).getBoundingClientRect ?
                        Math.ceil(domMenu.getBoundingClientRect().width) :
                        $menu.outerWidth() + 1); // outerWidth() returns rounded pixels
                // reset styles so they allow nested elements to grow/shrink naturally
                $menu.css({
                    position: 'static',
                    minWidth: '0px',
                    maxWidth: '100000px'
                });
                // identify width of nested menus
                $menu.find('> li > ul').each(function () {
                    op.resize($(this), true);
                });
                // reset and apply changes in the end because nested
                // elements' widths wouldn't be calculatable otherwise
                if (!nested) {
                    $menu.find('ul').addBack().css({
                        position: '',
                        display: '',
                        minWidth: '',
                        maxWidth: ''
                    }).outerWidth(function () {
                        return $(this).data('width');
                    });
                }
            },
            update: function (opt, root) {
                var $trigger = this;
                if (typeof root === 'undefined') {
                    root = opt;
                    op.resize(opt.$menu);
                }
                // re-check disabled for each item
                opt.$menu.children().each(function () {
                    var $item = $(this),
                        key = $item.data('contextMenuKey'),
                        item = opt.items[key],
                        disabled = ($.isFunction(item.disabled) && item.disabled.call($trigger, key, root)) || item.disabled === true,
                        visible;
                    if ($.isFunction(item.visible)) {
                        visible = item.visible.call($trigger, key, root);
                    } else if (typeof item.visible !== 'undefined') {
                        visible = item.visible === true;
                    } else {
                        visible = true;
                    }
                    $item[visible ? 'show' : 'hide']();

                    // dis- / enable item
                    $item[disabled ? 'addClass' : 'removeClass'](root.classNames.disabled);

                    if ($.isFunction(item.icon)) {
                        $item.removeClass(item._icon);
                        item._icon = item.icon.call(this, $trigger, $item, key, item);
                        $item.addClass(item._icon);
                    }

                    if (item.type) {
                        // dis- / enable input elements
                        $item.find('input, select, textarea').prop('disabled', disabled);

                        // update input states
                        switch (item.type) {
                            case 'text':
                            case 'textarea':
                                item.$input.val(item.value || '');
                                break;

                            case 'checkbox':
                            case 'radio':
                                item.$input.val(item.value || '').prop('checked', !!item.selected);
                                break;

                            case 'select':
                                item.$input.val((item.selected === 0 ? "0" : item.selected) || '');
                                break;
                        }
                    }

                    if (item.$menu) {
                        // update sub-menu
                        op.update.call($trigger, item, root);
                    }
                });
            },
            layer: function (opt, zIndex) {
                // add transparent layer for click area
                // filter and background for Internet Explorer, Issue #23
                var $layer = opt.$layer = $('<div id="context-menu-layer"></div>')
                    .css({
                        height: $win.height(),
                        width: $win.width(),
                        display: 'block',
                        position: 'fixed',
                        'z-index': zIndex,
                        top: 0,
                        left: 0,
                        opacity: 0,
                        filter: 'alpha(opacity=0)',
                        'background-color': '#000'
                    })
                    .data('contextMenuRoot', opt)
                    .insertBefore(this)
                    .on('contextmenu', handle.abortevent)
                    .on('mousedown', handle.layerClick);

                // IE6 doesn't know position:fixed;
                if (typeof document.body.style.maxWidth === 'undefined') { // IE6 doesn't support maxWidth
                    $layer.css({
                        'position': 'absolute',
                        'height': $(document).height()
                    });
                }

                return $layer;
            },
            processPromises: function (opt, root, promise) {
                // Start
                opt.$node.addClass(root.classNames.iconLoadingClass);

                function completedPromise(opt, root, items) {
                    // Completed promise (dev called promise.resolve). We now have a list of items which can
                    // be used to create the rest of the context menu.
                    if (typeof items === 'undefined') {
                        // Null result, dev should have checked
                        errorPromise(undefined);//own error object
                    }
                    finishPromiseProcess(opt, root, items);
                }

                function errorPromise(opt, root, errorItem) {
                    // User called promise.reject() with an error item, if not, provide own error item.
                    if (typeof errorItem === 'undefined') {
                        errorItem = {
                            "error": {
                                name: "No items and no error item",
                                icon: "context-menu-icon context-menu-icon-quit"
                            }
                        };
                        if (window.console) {
                            (console.error || console.log).call(console, 'When you reject a promise, provide an "items" object, equal to normal sub-menu items');
                        }
                    } else if (typeof errorItem === 'string') {
                        errorItem = {"error": {name: errorItem}};
                    }
                    finishPromiseProcess(opt, root, errorItem);
                }

                function finishPromiseProcess(opt, root, items) {
                    if (typeof root.$menu === 'undefined' || !root.$menu.is(':visible')) {
                        return;
                    }
                    opt.$node.removeClass(root.classNames.iconLoadingClass);
                    opt.items = items;
                    op.create(opt, root, true); // Create submenu
                    op.update(opt, root); // Correctly update position if user is already hovered over menu item
                    root.positionSubmenu.call(opt.$node, opt.$menu); // positionSubmenu, will only do anything if user already hovered over menu item that just got new subitems.
                }

                // Wait for promise completion. .then(success, error, notify) (we don't track notify). Bind the opt
                // and root to avoid scope problems
                promise.then(completedPromise.bind(this, opt, root), errorPromise.bind(this, opt, root));
            }
        };

    // split accesskey according to http://www.whatwg.org/specs/web-apps/current-work/multipage/editing.html#assigned-access-key
    function splitAccesskey(val) {
        var t = val.split(/\s+/);
        var keys = [];

        for (var i = 0, k; k = t[i]; i++) {
            k = k.charAt(0).toUpperCase(); // first character only
            // theoretically non-accessible characters should be ignored, but different systems, different keyboard layouts, ... screw it.
            // a map to look up already used access keys would be nice
            keys.push(k);
        }

        return keys;
    }

// handle contextMenu triggers
    $.fn.contextMenu = function (operation) {
        var $t = this, $o = operation;
        if (this.length > 0) {  // this is not a build on demand menu
            if (typeof operation === 'undefined') {
                this.first().trigger('contextmenu');
            } else if (typeof operation.x !== 'undefined' && typeof operation.y !== 'undefined') {
                this.first().trigger($.Event('contextmenu', {
                    pageX: operation.x,
                    pageY: operation.y,
                    mouseButton: operation.button
                }));
            } else if (operation === 'hide') {
                var $menu = this.first().data('contextMenu') ? this.first().data('contextMenu').$menu : null;
                if ($menu) {
                    $menu.trigger('contextmenu:hide');
                }
            } else if (operation === 'destroy') {
                $.contextMenu('destroy', {context: this});
            } else if ($.isPlainObject(operation)) {
                operation.context = this;
                $.contextMenu('create', operation);
            } else if (operation) {
                this.removeClass('context-menu-disabled');
            } else if (!operation) {
                this.addClass('context-menu-disabled');
            }
        } else {
            $.each(menus, function () {
                if (this.selector === $t.selector) {
                    $o.data = this;

                    $.extend($o.data, {trigger: 'demand'});
                }
            });

            handle.contextmenu.call($o.target, $o);
        }

        return this;
    };

    // manage contextMenu instances
    $.contextMenu = function (operation, options) {
        if (typeof operation !== 'string') {
            options = operation;
            operation = 'create';
        }

        if (typeof options === 'string') {
            options = {selector: options};
        } else if (typeof options === 'undefined') {
            options = {};
        }

        // merge with default options
        var o = $.extend(true, {}, defaults, options || {});
        var $document = $(document);
        var $context = $document;
        var _hasContext = false;

        if (!o.context || !o.context.length) {
            o.context = document;
        } else {
            // you never know what they throw at you...
            $context = $(o.context).first();
            o.context = $context.get(0);
            _hasContext = !$(o.context).is(document);
        }

        switch (operation) {
            case 'create':
                // no selector no joy
                if (!o.selector) {
                    throw new Error('No selector specified');
                }
                // make sure internal classes are not bound to
                if (o.selector.match(/.context-menu-(list|item|input)($|\s)/)) {
                    throw new Error('Cannot bind to selector "' + o.selector + '" as it contains a reserved className');
                }
                if (!o.build && (!o.items || $.isEmptyObject(o.items))) {
                    throw new Error('No Items specified');
                }
                counter++;
                o.ns = '.contextMenu' + counter;
                if (!_hasContext) {
                    namespaces[o.selector] = o.ns;
                }
                menus[o.ns] = o;

                // default to right click
                if (!o.trigger) {
                    o.trigger = 'right';
                }

                if (!initialized) {
                    var itemClick = o.itemClickEvent === 'click' ? 'click.contextMenu' : 'mouseup.contextMenu';
                    var contextMenuItemObj = {
                        // 'mouseup.contextMenu': handle.itemClick,
                        // 'click.contextMenu': handle.itemClick,
                        'contextmenu:focus.contextMenu': handle.focusItem,
                        'contextmenu:blur.contextMenu': handle.blurItem,
                        'contextmenu.contextMenu': handle.abortevent,
                        'mouseenter.contextMenu': handle.itemMouseenter,
                        'mouseleave.contextMenu': handle.itemMouseleave
                    };
                    contextMenuItemObj[itemClick] = handle.itemClick;
                    // make sure item click is registered first
                    $document
                        .on({
                            'contextmenu:hide.contextMenu': handle.hideMenu,
                            'prevcommand.contextMenu': handle.prevItem,
                            'nextcommand.contextMenu': handle.nextItem,
                            'contextmenu.contextMenu': handle.abortevent,
                            'mouseenter.contextMenu': handle.menuMouseenter,
                            'mouseleave.contextMenu': handle.menuMouseleave
                        }, '.context-menu-list')
                        .on('mouseup.contextMenu', '.context-menu-input', handle.inputClick)
                        .on(contextMenuItemObj, '.context-menu-item');

                    initialized = true;
                }

                // engage native contextmenu event
                $context
                    .on('contextmenu' + o.ns, o.selector, o, handle.contextmenu);

                if (_hasContext) {
                    // add remove hook, just in case
                    $context.on('remove' + o.ns, function () {
                        $(this).contextMenu('destroy');
                    });
                }

                switch (o.trigger) {
                    case 'hover':
                        $context
                            .on('mouseenter' + o.ns, o.selector, o, handle.mouseenter)
                            .on('mouseleave' + o.ns, o.selector, o, handle.mouseleave);
                        break;

                    case 'left':
                        $context.on('click' + o.ns, o.selector, o, handle.click);
                        break;
                    /*
                     default:
                     // http://www.quirksmode.org/dom/events/contextmenu.html
                     $document
                     .on('mousedown' + o.ns, o.selector, o, handle.mousedown)
                     .on('mouseup' + o.ns, o.selector, o, handle.mouseup);
                     break;
                     */
                }

                // create menu
                if (!o.build) {
                    op.create(o);
                }
                break;

            case 'destroy':
                var $visibleMenu;
                if (_hasContext) {
                    // get proper options
                    var context = o.context;
                    $.each(menus, function (ns, o) {

                        if (!o) {
                            return true;
                        }

                        // Is this menu equest to the context called from
                        if (!$(context).is(o.selector)) {
                            return true;
                        }

                        $visibleMenu = $('.context-menu-list').filter(':visible');
                        if ($visibleMenu.length && $visibleMenu.data().contextMenuRoot.$trigger.is($(o.context).find(o.selector))) {
                            $visibleMenu.trigger('contextmenu:hide', {force: true});
                        }

                        try {
                            if (menus[o.ns].$menu) {
                                menus[o.ns].$menu.remove();
                            }

                            delete menus[o.ns];
                        } catch (e) {
                            menus[o.ns] = null;
                        }

                        $(o.context).off(o.ns);

                        return true;
                    });
                } else if (!o.selector) {
                    $document.off('.contextMenu .contextMenuAutoHide');
                    $.each(menus, function (ns, o) {
                        $(o.context).off(o.ns);
                    });

                    namespaces = {};
                    menus = {};
                    counter = 0;
                    initialized = false;

                    $('#context-menu-layer, .context-menu-list').remove();
                } else if (namespaces[o.selector]) {
                    $visibleMenu = $('.context-menu-list').filter(':visible');
                    if ($visibleMenu.length && $visibleMenu.data().contextMenuRoot.$trigger.is(o.selector)) {
                        $visibleMenu.trigger('contextmenu:hide', {force: true});
                    }

                    try {
                        if (menus[namespaces[o.selector]].$menu) {
                            menus[namespaces[o.selector]].$menu.remove();
                        }

                        delete menus[namespaces[o.selector]];
                    } catch (e) {
                        menus[namespaces[o.selector]] = null;
                    }

                    $document.off(namespaces[o.selector]);
                }
                break;

            case 'html5':
                // if <command> or <menuitem> are not handled by the browser,
                // or options was a bool true,
                // initialize $.contextMenu for them
                if ((!$.support.htmlCommand && !$.support.htmlMenuitem) || (typeof options === 'boolean' && options)) {
                    $('menu[type="context"]').each(function () {
                        if (this.id) {
                            $.contextMenu({
                                selector: '[contextmenu=' + this.id + ']',
                                items: $.contextMenu.fromMenu(this)
                            });
                        }
                    }).css('display', 'none');
                }
                break;

            default:
                throw new Error('Unknown operation "' + operation + '"');
        }

        return this;
    };

// import values into <input> commands
    $.contextMenu.setInputValues = function (opt, data) {
        if (typeof data === 'undefined') {
            data = {};
        }

        $.each(opt.inputs, function (key, item) {
            switch (item.type) {
                case 'text':
                case 'textarea':
                    item.value = data[key] || '';
                    break;

                case 'checkbox':
                    item.selected = data[key] ? true : false;
                    break;

                case 'radio':
                    item.selected = (data[item.radio] || '') === item.value;
                    break;

                case 'select':
                    item.selected = data[key] || '';
                    break;
            }
        });
    };

// export values from <input> commands
    $.contextMenu.getInputValues = function (opt, data) {
        if (typeof data === 'undefined') {
            data = {};
        }

        $.each(opt.inputs, function (key, item) {
            switch (item.type) {
                case 'text':
                case 'textarea':
                case 'select':
                    data[key] = item.$input.val();
                    break;

                case 'checkbox':
                    data[key] = item.$input.prop('checked');
                    break;

                case 'radio':
                    if (item.$input.prop('checked')) {
                        data[item.radio] = item.value;
                    }
                    break;
            }
        });

        return data;
    };

// find <label for="xyz">
    function inputLabel(node) {
        return (node.id && $('label[for="' + node.id + '"]').val()) || node.name;
    }

// convert <menu> to items object
    function menuChildren(items, $children, counter) {
        if (!counter) {
            counter = 0;
        }

        $children.each(function () {
            var $node = $(this),
                node = this,
                nodeName = this.nodeName.toLowerCase(),
                label,
                item;

            // extract <label><input>
            if (nodeName === 'label' && $node.find('input, textarea, select').length) {
                label = $node.text();
                $node = $node.children().first();
                node = $node.get(0);
                nodeName = node.nodeName.toLowerCase();
            }

            /*
             * <menu> accepts flow-content as children. that means <embed>, <canvas> and such are valid menu items.
             * Not being the sadistic kind, $.contextMenu only accepts:
             * <command>, <menuitem>, <hr>, <span>, <p> <input [text, radio, checkbox]>, <textarea>, <select> and of course <menu>.
             * Everything else will be imported as an html node, which is not interfaced with contextMenu.
             */

            // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#concept-command
            switch (nodeName) {
                // http://www.whatwg.org/specs/web-apps/current-work/multipage/interactive-elements.html#the-menu-element
                case 'menu':
                    item = {name: $node.attr('label'), items: {}};
                    counter = menuChildren(item.items, $node.children(), counter);
                    break;

                // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-a-element-to-define-a-command
                case 'a':
                // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-button-element-to-define-a-command
                case 'button':
                    item = {
                        name: $node.text(),
                        disabled: !!$node.attr('disabled'),
                        callback: (function () {
                            return function () {
                                $node.get(0).click()
                            };
                        })()
                    };
                    break;

                // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-command-element-to-define-a-command
                case 'menuitem':
                case 'command':
                    switch ($node.attr('type')) {
                        case undefined:
                        case 'command':
                        case 'menuitem':
                            item = {
                                name: $node.attr('label'),
                                disabled: !!$node.attr('disabled'),
                                icon: $node.attr('icon'),
                                callback: (function () {
                                    return function () {
                                        $node.get(0).click()
                                    };
                                })()
                            };
                            break;

                        case 'checkbox':
                            item = {
                                type: 'checkbox',
                                disabled: !!$node.attr('disabled'),
                                name: $node.attr('label'),
                                selected: !!$node.attr('checked')
                            };
                            break;
                        case 'radio':
                            item = {
                                type: 'radio',
                                disabled: !!$node.attr('disabled'),
                                name: $node.attr('label'),
                                radio: $node.attr('radiogroup'),
                                value: $node.attr('id'),
                                selected: !!$node.attr('checked')
                            };
                            break;

                        default:
                            item = undefined;
                    }
                    break;

                case 'hr':
                    item = '-------';
                    break;

                case 'input':
                    switch ($node.attr('type')) {
                        case 'text':
                            item = {
                                type: 'text',
                                name: label || inputLabel(node),
                                disabled: !!$node.attr('disabled'),
                                value: $node.val()
                            };
                            break;

                        case 'checkbox':
                            item = {
                                type: 'checkbox',
                                name: label || inputLabel(node),
                                disabled: !!$node.attr('disabled'),
                                selected: !!$node.attr('checked')
                            };
                            break;

                        case 'radio':
                            item = {
                                type: 'radio',
                                name: label || inputLabel(node),
                                disabled: !!$node.attr('disabled'),
                                radio: !!$node.attr('name'),
                                value: $node.val(),
                                selected: !!$node.attr('checked')
                            };
                            break;

                        default:
                            item = undefined;
                            break;
                    }
                    break;

                case 'select':
                    item = {
                        type: 'select',
                        name: label || inputLabel(node),
                        disabled: !!$node.attr('disabled'),
                        selected: $node.val(),
                        options: {}
                    };
                    $node.children().each(function () {
                        item.options[this.value] = $(this).text();
                    });
                    break;

                case 'textarea':
                    item = {
                        type: 'textarea',
                        name: label || inputLabel(node),
                        disabled: !!$node.attr('disabled'),
                        value: $node.val()
                    };
                    break;

                case 'label':
                    break;

                default:
                    item = {type: 'html', html: $node.clone(true)};
                    break;
            }

            if (item) {
                counter++;
                items['key' + counter] = item;
            }
        });

        return counter;
    }

// convert html5 menu
    $.contextMenu.fromMenu = function (element) {
        var $this = $(element),
            items = {};

        menuChildren(items, $this.children());

        return items;
    };

// make defaults accessible
    $.contextMenu.defaults = defaults;
    $.contextMenu.types = types;
// export internal functions - undocumented, for hacking only!
    $.contextMenu.handle = handle;
    $.contextMenu.op = op;
    $.contextMenu.menus = menus;
});

/*! jQuery UI - v1.12.1 - 2016-09-16
 * http://jqueryui.com
 * Includes: position.js
 * Copyright jQuery Foundation and other contributors; Licensed MIT */

(function( factory ) {
    if ( typeof define === "function" && define.amd ) {

        // AMD. Register as an anonymous module.
        define([ "jquery" ], factory );
    } else {

        // Browser globals
        factory( jQuery );
    }
}(function( $ ) {

    $.ui = $.ui || {};

    var version = $.ui.version = "1.12.1";


    /*!
     * jQuery UI Position 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/position/
     */

//>>label: Position
//>>group: Core
//>>description: Positions elements relative to other elements.
//>>docs: http://api.jqueryui.com/position/
//>>demos: http://jqueryui.com/position/


    ( function() {
        var cachedScrollbarWidth,
            max = Math.max,
            abs = Math.abs,
            rhorizontal = /left|center|right/,
            rvertical = /top|center|bottom/,
            roffset = /[\+\-]\d+(\.[\d]+)?%?/,
            rposition = /^\w+/,
            rpercent = /%$/,
            _position = $.fn.position;

        function getOffsets( offsets, width, height ) {
            return [
                parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
                parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
            ];
        }

        function parseCss( element, property ) {
            return parseInt( $.css( element, property ), 10 ) || 0;
        }

        function getDimensions( elem ) {
            var raw = elem[ 0 ];
            if ( raw.nodeType === 9 ) {
                return {
                    width: elem.width(),
                    height: elem.height(),
                    offset: { top: 0, left: 0 }
                };
            }
            if ( $.isWindow( raw ) ) {
                return {
                    width: elem.width(),
                    height: elem.height(),
                    offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
                };
            }
            if ( raw.preventDefault ) {
                return {
                    width: 0,
                    height: 0,
                    offset: { top: raw.pageY, left: raw.pageX }
                };
            }
            return {
                width: elem.outerWidth(),
                height: elem.outerHeight(),
                offset: elem.offset()
            };
        }

        $.position = {
            scrollbarWidth: function() {
                if ( cachedScrollbarWidth !== undefined ) {
                    return cachedScrollbarWidth;
                }
                var w1, w2,
                    div = $( "<div " +
                        "style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'>" +
                        "<div style='height:100px;width:auto;'></div></div>" ),
                    innerDiv = div.children()[ 0 ];

                $( "body" ).append( div );
                w1 = innerDiv.offsetWidth;
                div.css( "overflow", "scroll" );

                w2 = innerDiv.offsetWidth;

                if ( w1 === w2 ) {
                    w2 = div[ 0 ].clientWidth;
                }

                div.remove();

                return ( cachedScrollbarWidth = w1 - w2 );
            },
            getScrollInfo: function( within ) {
                var overflowX = within.isWindow || within.isDocument ? "" :
                        within.element.css( "overflow-x" ),
                    overflowY = within.isWindow || within.isDocument ? "" :
                        within.element.css( "overflow-y" ),
                    hasOverflowX = overflowX === "scroll" ||
                        ( overflowX === "auto" && within.width < within.element[ 0 ].scrollWidth ),
                    hasOverflowY = overflowY === "scroll" ||
                        ( overflowY === "auto" && within.height < within.element[ 0 ].scrollHeight );
                return {
                    width: hasOverflowY ? $.position.scrollbarWidth() : 0,
                    height: hasOverflowX ? $.position.scrollbarWidth() : 0
                };
            },
            getWithinInfo: function( element ) {
                var withinElement = $( element || window ),
                    isWindow = $.isWindow( withinElement[ 0 ] ),
                    isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9,
                    hasOffset = !isWindow && !isDocument;
                return {
                    element: withinElement,
                    isWindow: isWindow,
                    isDocument: isDocument,
                    offset: hasOffset ? $( element ).offset() : { left: 0, top: 0 },
                    scrollLeft: withinElement.scrollLeft(),
                    scrollTop: withinElement.scrollTop(),
                    width: withinElement.outerWidth(),
                    height: withinElement.outerHeight()
                };
            }
        };

        $.fn.position = function( options ) {
            if ( !options || !options.of ) {
                return _position.apply( this, arguments );
            }

            // Make a copy, we don't want to modify arguments
            options = $.extend( {}, options );

            var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
                target = $( options.of ),
                within = $.position.getWithinInfo( options.within ),
                scrollInfo = $.position.getScrollInfo( within ),
                collision = ( options.collision || "flip" ).split( " " ),
                offsets = {};

            dimensions = getDimensions( target );
            if ( target[ 0 ].preventDefault ) {

                // Force left top to allow flipping
                options.at = "left top";
            }
            targetWidth = dimensions.width;
            targetHeight = dimensions.height;
            targetOffset = dimensions.offset;

            // Clone to reuse original targetOffset later
            basePosition = $.extend( {}, targetOffset );

            // Force my and at to have valid horizontal and vertical positions
            // if a value is missing or invalid, it will be converted to center
            $.each( [ "my", "at" ], function() {
                var pos = ( options[ this ] || "" ).split( " " ),
                    horizontalOffset,
                    verticalOffset;

                if ( pos.length === 1 ) {
                    pos = rhorizontal.test( pos[ 0 ] ) ?
                        pos.concat( [ "center" ] ) :
                        rvertical.test( pos[ 0 ] ) ?
                            [ "center" ].concat( pos ) :
                            [ "center", "center" ];
                }
                pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
                pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

                // Calculate offsets
                horizontalOffset = roffset.exec( pos[ 0 ] );
                verticalOffset = roffset.exec( pos[ 1 ] );
                offsets[ this ] = [
                    horizontalOffset ? horizontalOffset[ 0 ] : 0,
                    verticalOffset ? verticalOffset[ 0 ] : 0
                ];

                // Reduce to just the positions without the offsets
                options[ this ] = [
                    rposition.exec( pos[ 0 ] )[ 0 ],
                    rposition.exec( pos[ 1 ] )[ 0 ]
                ];
            } );

            // Normalize collision option
            if ( collision.length === 1 ) {
                collision[ 1 ] = collision[ 0 ];
            }

            if ( options.at[ 0 ] === "right" ) {
                basePosition.left += targetWidth;
            } else if ( options.at[ 0 ] === "center" ) {
                basePosition.left += targetWidth / 2;
            }

            if ( options.at[ 1 ] === "bottom" ) {
                basePosition.top += targetHeight;
            } else if ( options.at[ 1 ] === "center" ) {
                basePosition.top += targetHeight / 2;
            }

            atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
            basePosition.left += atOffset[ 0 ];
            basePosition.top += atOffset[ 1 ];

            return this.each( function() {
                var collisionPosition, using,
                    elem = $( this ),
                    elemWidth = elem.outerWidth(),
                    elemHeight = elem.outerHeight(),
                    marginLeft = parseCss( this, "marginLeft" ),
                    marginTop = parseCss( this, "marginTop" ),
                    collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) +
                        scrollInfo.width,
                    collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) +
                        scrollInfo.height,
                    position = $.extend( {}, basePosition ),
                    myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

                if ( options.my[ 0 ] === "right" ) {
                    position.left -= elemWidth;
                } else if ( options.my[ 0 ] === "center" ) {
                    position.left -= elemWidth / 2;
                }

                if ( options.my[ 1 ] === "bottom" ) {
                    position.top -= elemHeight;
                } else if ( options.my[ 1 ] === "center" ) {
                    position.top -= elemHeight / 2;
                }

                position.left += myOffset[ 0 ];
                position.top += myOffset[ 1 ];

                collisionPosition = {
                    marginLeft: marginLeft,
                    marginTop: marginTop
                };

                $.each( [ "left", "top" ], function( i, dir ) {
                    if ( $.ui.position[ collision[ i ] ] ) {
                        $.ui.position[ collision[ i ] ][ dir ]( position, {
                            targetWidth: targetWidth,
                            targetHeight: targetHeight,
                            elemWidth: elemWidth,
                            elemHeight: elemHeight,
                            collisionPosition: collisionPosition,
                            collisionWidth: collisionWidth,
                            collisionHeight: collisionHeight,
                            offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
                            my: options.my,
                            at: options.at,
                            within: within,
                            elem: elem
                        } );
                    }
                } );

                if ( options.using ) {

                    // Adds feedback as second argument to using callback, if present
                    using = function( props ) {
                        var left = targetOffset.left - position.left,
                            right = left + targetWidth - elemWidth,
                            top = targetOffset.top - position.top,
                            bottom = top + targetHeight - elemHeight,
                            feedback = {
                                target: {
                                    element: target,
                                    left: targetOffset.left,
                                    top: targetOffset.top,
                                    width: targetWidth,
                                    height: targetHeight
                                },
                                element: {
                                    element: elem,
                                    left: position.left,
                                    top: position.top,
                                    width: elemWidth,
                                    height: elemHeight
                                },
                                horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
                                vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
                            };
                        if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
                            feedback.horizontal = "center";
                        }
                        if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
                            feedback.vertical = "middle";
                        }
                        if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
                            feedback.important = "horizontal";
                        } else {
                            feedback.important = "vertical";
                        }
                        options.using.call( this, props, feedback );
                    };
                }

                elem.offset( $.extend( position, { using: using } ) );
            } );
        };

        $.ui.position = {
            fit: {
                left: function( position, data ) {
                    var within = data.within,
                        withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
                        outerWidth = within.width,
                        collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                        overLeft = withinOffset - collisionPosLeft,
                        overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
                        newOverRight;

                    // Element is wider than within
                    if ( data.collisionWidth > outerWidth ) {

                        // Element is initially over the left side of within
                        if ( overLeft > 0 && overRight <= 0 ) {
                            newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -
                                withinOffset;
                            position.left += overLeft - newOverRight;

                            // Element is initially over right side of within
                        } else if ( overRight > 0 && overLeft <= 0 ) {
                            position.left = withinOffset;

                            // Element is initially over both left and right sides of within
                        } else {
                            if ( overLeft > overRight ) {
                                position.left = withinOffset + outerWidth - data.collisionWidth;
                            } else {
                                position.left = withinOffset;
                            }
                        }

                        // Too far left -> align with left edge
                    } else if ( overLeft > 0 ) {
                        position.left += overLeft;

                        // Too far right -> align with right edge
                    } else if ( overRight > 0 ) {
                        position.left -= overRight;

                        // Adjust based on position and margin
                    } else {
                        position.left = max( position.left - collisionPosLeft, position.left );
                    }
                },
                top: function( position, data ) {
                    var within = data.within,
                        withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
                        outerHeight = data.within.height,
                        collisionPosTop = position.top - data.collisionPosition.marginTop,
                        overTop = withinOffset - collisionPosTop,
                        overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
                        newOverBottom;

                    // Element is taller than within
                    if ( data.collisionHeight > outerHeight ) {

                        // Element is initially over the top of within
                        if ( overTop > 0 && overBottom <= 0 ) {
                            newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -
                                withinOffset;
                            position.top += overTop - newOverBottom;

                            // Element is initially over bottom of within
                        } else if ( overBottom > 0 && overTop <= 0 ) {
                            position.top = withinOffset;

                            // Element is initially over both top and bottom of within
                        } else {
                            if ( overTop > overBottom ) {
                                position.top = withinOffset + outerHeight - data.collisionHeight;
                            } else {
                                position.top = withinOffset;
                            }
                        }

                        // Too far up -> align with top
                    } else if ( overTop > 0 ) {
                        position.top += overTop;

                        // Too far down -> align with bottom edge
                    } else if ( overBottom > 0 ) {
                        position.top -= overBottom;

                        // Adjust based on position and margin
                    } else {
                        position.top = max( position.top - collisionPosTop, position.top );
                    }
                }
            },
            flip: {
                left: function( position, data ) {
                    var within = data.within,
                        withinOffset = within.offset.left + within.scrollLeft,
                        outerWidth = within.width,
                        offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
                        collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                        overLeft = collisionPosLeft - offsetLeft,
                        overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
                        myOffset = data.my[ 0 ] === "left" ?
                            -data.elemWidth :
                            data.my[ 0 ] === "right" ?
                                data.elemWidth :
                                0,
                        atOffset = data.at[ 0 ] === "left" ?
                            data.targetWidth :
                            data.at[ 0 ] === "right" ?
                                -data.targetWidth :
                                0,
                        offset = -2 * data.offset[ 0 ],
                        newOverRight,
                        newOverLeft;

                    if ( overLeft < 0 ) {
                        newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -
                            outerWidth - withinOffset;
                        if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
                            position.left += myOffset + atOffset + offset;
                        }
                    } else if ( overRight > 0 ) {
                        newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +
                            atOffset + offset - offsetLeft;
                        if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
                            position.left += myOffset + atOffset + offset;
                        }
                    }
                },
                top: function( position, data ) {
                    var within = data.within,
                        withinOffset = within.offset.top + within.scrollTop,
                        outerHeight = within.height,
                        offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
                        collisionPosTop = position.top - data.collisionPosition.marginTop,
                        overTop = collisionPosTop - offsetTop,
                        overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
                        top = data.my[ 1 ] === "top",
                        myOffset = top ?
                            -data.elemHeight :
                            data.my[ 1 ] === "bottom" ?
                                data.elemHeight :
                                0,
                        atOffset = data.at[ 1 ] === "top" ?
                            data.targetHeight :
                            data.at[ 1 ] === "bottom" ?
                                -data.targetHeight :
                                0,
                        offset = -2 * data.offset[ 1 ],
                        newOverTop,
                        newOverBottom;
                    if ( overTop < 0 ) {
                        newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -
                            outerHeight - withinOffset;
                        if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
                            position.top += myOffset + atOffset + offset;
                        }
                    } else if ( overBottom > 0 ) {
                        newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +
                            offset - offsetTop;
                        if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
                            position.top += myOffset + atOffset + offset;
                        }
                    }
                }
            },
            flipfit: {
                left: function() {
                    $.ui.position.flip.left.apply( this, arguments );
                    $.ui.position.fit.left.apply( this, arguments );
                },
                top: function() {
                    $.ui.position.flip.top.apply( this, arguments );
                    $.ui.position.fit.top.apply( this, arguments );
                }
            }
        };

    } )();

    var position = $.ui.position;




}));
/**
 * complete.ly 1.0.1
 * MIT Licensing
 * Copyright (c) 2013 Lorenzo Puccetti
 *
 * This Software shall be used for doing good things, not bad things.
 *
**/

// Modified from complete.ly 1.0.1

function completely(container, config) {
    config = config || {};
    config.fontSize =                       config.fontSize   || '16px';
    config.fontFamily =                     config.fontFamily || 'sans-serif';
    config.promptInnerHTML =                config.promptInnerHTML || '';
    config.color =                          config.color || '#333';
    config.hintColor =                      config.hintColor || '#aaa';
    config.backgroundColor =                config.backgroundColor || '#fff';
    config.dropDownBorderColor =            config.dropDownBorderColor || '#aaa';
    config.dropDownZIndex =                 config.dropDownZIndex || '100'; // to ensure we are in front of everybody
    config.dropDownOnHoverBackgroundColor = config.dropDownOnHoverBackgroundColor || '#ddd';

    var txtInput = document.createElement('input');
    txtInput.type ='text';
    txtInput.spellcheck = false;
    txtInput.style.fontSize =        config.fontSize;
    txtInput.style.fontFamily =      config.fontFamily;
    txtInput.style.color =           config.color;
    txtInput.style.backgroundColor = config.backgroundColor;
    txtInput.style.width = '100%';
    txtInput.style.outline = '0';
    txtInput.style.border =  '0';
    txtInput.style.margin =  '0';
    txtInput.style.padding = '0';

    var textHint;

    // txtInput.style.backgroundColor ='transparent';
    txtInput.style.verticalAlign = 'top';
    txtInput.style.position = 'relative';

    var wrapper = document.createElement('div');
    wrapper.style.position = 'relative';
    wrapper.style.outline = '0';
    wrapper.style.border =  '0';
    wrapper.style.margin =  '0';
    wrapper.style.padding = '0';

    var prompt = document.createElement('div');
    prompt.style.position = 'absolute';
    prompt.style.outline = '0';
    prompt.style.margin =  '0';
    prompt.style.padding = '0';
    prompt.style.border =  '0';
    prompt.style.fontSize =   config.fontSize;
    prompt.style.fontFamily = config.fontFamily;
    prompt.style.color =           config.color;
    prompt.style.backgroundColor = config.backgroundColor;
    prompt.style.top = '0';
    prompt.style.left = '0';
    prompt.style.overflow = 'hidden';
    prompt.innerHTML = config.promptInnerHTML;
    prompt.style.background = 'transparent';
    if (document.body === undefined) {
        throw 'document.body is undefined. The library was wired up incorrectly.';
    }
    document.body.appendChild(prompt);
    var w = prompt.getBoundingClientRect().right; // works out the width of the prompt.
    wrapper.appendChild(prompt);
    prompt.style.visibility = 'visible';
    prompt.style.left = '-'+w+'px';
    wrapper.style.marginLeft= w+'px';

    wrapper.appendChild(txtInput);

    var dropDown = document.createElement('div');
    dropDown.classList.add('ui', 'menu');
    dropDown.style.display = 'block';
    dropDown.style.position = 'absolute';
    dropDown.style.visibility = 'hidden';
    dropDown.style.outline = '0';
    dropDown.style.margin =  '0';
    dropDown.style.padding = '0';
    dropDown.style.textAlign = 'left';
    dropDown.style.fontSize =   config.fontSize;
    dropDown.style.fontFamily = config.fontFamily;
    dropDown.style.backgroundColor = config.backgroundColor;
    dropDown.style.zIndex = config.dropDownZIndex;
    dropDown.style.cursor = 'default';
    dropDown.style.borderStyle = 'solid';
    dropDown.style.borderWidth = '1px';
    dropDown.style.borderColor = config.dropDownBorderColor;
    dropDown.style.overflowX= 'hidden';
    dropDown.style.whiteSpace = 'pre';
    dropDown.style.overflowY = 'scroll';  // note: this might be ugly when the scrollbar is not required. however in this way the width of the dropDown takes into account


    var createDropDownController = function(elem) {
        var rows = [];
        var ix = 0;
        var oldIndex = -1;

        var onMouseOver =  function() { this.style.outline = '2px solid #89c2ed'; }
        var onMouseOut =   function() { this.style.outline = '0'; }
        var onMouseDown =  function() { p.hide(); p.onmouseselection(this.__hint); }

        var p = {
            hide :  function() { elem.style.visibility = 'hidden'; },
            refresh : function(token, array) {
                elem.style.visibility = 'hidden';
                ix = 0;
                elem.innerHTML ='';
                var vph = (window.innerHeight || document.documentElement.clientHeight);
                var rect = elem.parentNode.getBoundingClientRect();
                var distanceToTop = rect.top - 6;                        // heuristic give 6px
                var distanceToBottom = vph - rect.bottom -6;  // distance from the browser border.

                rows = [];
                for (var i=0;i<array.length;i++) {
                    if (array[i].indexOf(token)!==0) { continue; }
                    var divRow =document.createElement('div');
                    divRow.classList.add('item');
                    divRow.style.color = config.color;
                    divRow.onmouseover = onMouseOver;
                    divRow.onmouseout =  onMouseOut;
                    divRow.onmousedown = onMouseDown;
                    divRow.__hint =    array[i];
                    divRow.innerHTML = token+'<b>'+array[i].substring(token.length)+'</b>';
                    rows.push(divRow);
                    elem.appendChild(divRow);
                }
                if (rows.length===0) {
                    return; // nothing to show.
                }
                if (rows.length===1 && token === rows[0].__hint) {
                    return; // do not show the dropDown if it has only one element which matches what we have just displayed.
                }

                // if (rows.length<2) return;
                p.highlight(0);

                if (distanceToTop > distanceToBottom*3) {        // Heuristic (only when the distance to the to top is 4 times more than distance to the bottom
                    elem.style.maxHeight =  distanceToTop+'px';  // we display the dropDown on the top of the input text
                    elem.style.top ='';
                    elem.style.bottom ='100%';
                } else {
                    elem.style.top = '100%';
                    elem.style.bottom = '';
                    elem.style.maxHeight =  distanceToBottom+'px';
                }
                elem.style.visibility = 'visible';
            },
            highlight : function(index) {
                if (oldIndex !=-1 && rows[oldIndex]) {
                    rows[oldIndex].style.backgroundColor = config.backgroundColor;
                }
                rows[index].style.backgroundColor = config.dropDownOnHoverBackgroundColor; // <-- should be config
                oldIndex = index;
            },
            move : function(step) { // moves the selection either up or down (unless it's not possible) step is either +1 or -1.
                if (elem.style.visibility === 'hidden')             return ''; // nothing to move if there is no dropDown. (this happens if the user hits escape and then down or up)
                if (ix+step === -1 || ix+step === rows.length) return rows[ix].__hint; // NO CIRCULAR SCROLLING.
                ix+=step;
                p.highlight(ix);
                return rows[ix].__hint;//txtShadow.value = uRows[uIndex].__hint ;
            },
            onmouseselection : function() {} // it will be overwritten.
        };
        return p;
    }

    var dropDownController = createDropDownController(dropDown);

    dropDownController.onmouseselection = function(text) {
        txtInput.value = textHint = leftSide + text + rightSide;
        rs.onSelect(txtInput.value, rightSide);
        rs.onChange(txtInput.value); // <-- forcing it.
        registerOnTextChangeOldValue = txtInput.value; // <-- ensure that mouse down will not show the dropDown now.
        setTimeout(function() { txtInput.focus(); },0);  // <-- I need to do this for IE
    }

    wrapper.appendChild(dropDown);
    container.appendChild(wrapper);

    var spacer;
    var leftSide; // <-- it will contain the leftSide part of the textfield (the bit that was already autocompleted)
    var rightSide = '';

    function calculateWidthForText(text) {
        if (spacer === undefined) { // on first call only.
            spacer = document.createElement('span');
            spacer.style.visibility = 'hidden';
            spacer.style.position = 'fixed';
            spacer.style.outline = '0';
            spacer.style.margin =  '0';
            spacer.style.padding = '0';
            spacer.style.border =  '0';
            spacer.style.left = '0';
            spacer.style.whiteSpace = 'pre';
            spacer.style.fontSize =   config.fontSize;
            spacer.style.fontFamily = config.fontFamily;
            spacer.style.fontWeight = 'normal';
            document.body.appendChild(spacer);
        }

        // Used to encode an HTML string into a plain text.
        // taken from http://stackoverflow.com/questions/1219860/javascript-jquery-html-encoding
        spacer.innerHTML = String(text).replace(/&/g, '&amp;')
                                       .replace(/"/g, '&quot;')
                                       .replace(/'/g, '&#39;')
                                       .replace(/</g, '&lt;')
                                       .replace(/>/g, '&gt;');
        return spacer.getBoundingClientRect().right;
    }


    var rs = {
        onArrowDown : function() {},               // defaults to no action.
        onArrowUp :   function() {},               // defaults to no action.
        onEnter :     function() {},               // defaults to no action.
        onTab :       function() {},               // defaults to no action.
        onSelect :    function() {},
        onChange:     function() { rs.repaint() }, // defaults to repainting.
        startFrom:    0,
        options:      [],
        wrapper : wrapper,      // Only to allow  easy access to the HTML elements to the final user (possibly for minor customizations)
        input :  txtInput,      // Only to allow  easy access to the HTML elements to the final user (possibly for minor customizations)
        hint  :  textHint,       // Only to allow  easy access to the HTML elements to the final user (possibly for minor customizations)
        dropDown :  dropDown,         // Only to allow  easy access to the HTML elements to the final user (possibly for minor customizations)
        prompt : prompt,
        endIndex: 0,
        setText : function(text) {
            textHint = text;
            txtInput.value = text;
        },
        getText : function() {
            return txtInput.value;
        },
        hideDropDown : function() {
            dropDownController.hide();
        },
        repaint : function() {
            var text = txtInput.value;
            var startFrom =  rs.startFrom;
            var endIndex = rs.endIndex;
            var options =    rs.options;
            var optionsLength = options.length;

            // breaking text in leftSide and token.
            if (endIndex === 0) {
                var token = text.substring(startFrom);
                leftSide =  text.substring(0,startFrom);
                rightSide = '';
            }
            else {
                var token = text.substring(startFrom, endIndex);
                leftSide =  text.substring(0,startFrom);
                rightSide = text.substring(endIndex);
            }

            // updating the hint.
            textHint ='';
            for (var i=0; i<optionsLength; i++) {
                var opt = options[i];
                if (opt.indexOf(token) === 0) {         // <-- how about upperCase vs. lowercase
                    textHint = leftSide + opt + rightSide;
                    break;
                }
            }

            // moving the dropDown and refreshing it.
            dropDown.style.left = calculateWidthForText(leftSide)+'px';
            dropDownController.refresh(token, rs.options);
        }
    };

    var registerOnTextChangeOldValue;

    /**
     * Register a callback function to detect changes to the content of the input-type-text.
     * Those changes are typically followed by user's action: a key-stroke event but sometimes it might be a mouse click.
    **/
    var registerOnTextChange = function(txt, callback) {
        registerOnTextChangeOldValue = txt.value;
        var handler = function() {
            var value = txt.value;
            if (registerOnTextChangeOldValue !== value) {
                registerOnTextChangeOldValue = value;
                callback(value);
            }
        };

        //
        // For user's actions, we listen to both input events and key up events
        // It appears that input events are not enough so we defensively listen to key up events too.
        // source: http://help.dottoro.com/ljhxklln.php
        //
        // The cost of listening to three sources should be negligible as the handler will invoke callback function
        // only if the text.value was effectively changed.
        //
        //
        if (txt.addEventListener) {
            txt.addEventListener("input",  handler, false);
            txt.addEventListener('keyup',  handler, false);
            txt.addEventListener('change', handler, false);
        } else { // is this a fair assumption: that attachEvent will exist ?
            txt.attachEvent('oninput', handler); // IE<9
            txt.attachEvent('onkeyup', handler); // IE<9
            txt.attachEvent('onchange',handler); // IE<9
        }
    };


    registerOnTextChange(txtInput,function(text) { // note the function needs to be wrapped as API-users will define their onChange
        rs.onChange(text);
    });


    var keyDownHandler = function(e) {
        e = e || window.event;
        var keyCode = e.keyCode;

        if (keyCode == 33) { return; } // page up (do nothing)
        if (keyCode == 34) { return; } // page down (do nothing);
        if (keyCode == 39) { return; } // right arrow (do nothing);

        if (keyCode == 27) { //escape
            dropDownController.hide();
            textHint = txtInput.value; // ensure that no hint is left.
            txtInput.focus();
            return;
        }

        if (keyCode == 13) {       // enter  (autocomplete triggered)
            if (textHint.length == 0) { // if there is a hint
                rs.onEnter();
            } else {
                var wasDropDownHidden = (dropDown.style.visibility == 'hidden');
                dropDownController.hide();

                if (wasDropDownHidden) {
                    textHint = txtInput.value; // ensure that no hint is left.
                    txtInput.focus();
                    rs.onEnter();
                    return;
                }

                txtInput.value = textHint;
                rs.onSelect(txtInput.value, rightSide);
                var hasTextChanged = registerOnTextChangeOldValue != txtInput.value
                registerOnTextChangeOldValue = txtInput.value; // <-- to avoid dropDown to appear again.
                                                          // for example imagine the array contains the following words: bee, beef, beetroot
                                                          // user has hit enter to get 'bee' it would be prompted with the dropDown again (as beef and beetroot also match)
                if (hasTextChanged) {
                    rs.onChange(txtInput.value); // <-- forcing it.
                }

            }
            return;
        }

        if (keyCode == 40) {     // down
            var m = dropDownController.move(+1);
            if (m == '') { rs.onArrowDown(); }
            textHint = leftSide + m + rightSide;
            return;
        }

        if (keyCode == 38 ) {    // up
            var m = dropDownController.move(-1);
            if (m == '') { rs.onArrowUp(); }
            textHint = leftSide + m + rightSide;
            e.preventDefault();
            e.stopPropagation();
            return;
        }

        // it's important to reset the textHint on key down.
        // think: user presses a letter (e.g. 'x') and never releases... you get (xxxxxxxxxxxxxxxxx)
        // and you would see still the hint
        textHint =''; // resets the textHint. (it might be updated onKeyUp)

    };

    if (txtInput.addEventListener) {
        txtInput.addEventListener("keydown",  keyDownHandler, false);
        txtInput.addEventListener("blur", function() {
            rs.hideDropDown();
        }, false)
    } else { // is this a fair assumption: that attachEvent will exist ?
        txtInput.attachEvent('onkeydown', keyDownHandler); // IE<9
    }
    return rs;
}

/**
 * jQuery Timepicker
 * http://timepicker.co
 *
 * Enhances standard form input fields helping users to select (or type) times.
 *
 * Copyright (c) 2016 Willington Vega; Licensed MIT, GPL
 */

(function (factory) {
    if ( typeof module === 'object' && typeof module.exports === 'object' ) {
        factory(require('jquery'), window, document);
    } else if (typeof jQuery !== 'undefined') {
        factory(jQuery, window, document);
    }
}(function($, window, document, undefined) {
    (function() {

        function pad(str, ch, length) {
            return (new Array(length + 1 - str.length).join(ch)) + str;
        }

        function normalize() {
            if (arguments.length === 1) {
                var date = arguments[0];
                if (typeof date === 'string') {
                    date = $.fn.timepicker.parseTime(date);
                }
                return new Date(0, 0, 0, date.getHours(), date.getMinutes(), date.getSeconds());
            } else if (arguments.length === 3) {
                return new Date(0, 0, 0, arguments[0], arguments[1], arguments[2]);
            } else if (arguments.length === 2) {
                return new Date(0, 0, 0, arguments[0], arguments[1], 0);
            } else {
                return new Date(0, 0, 0);
            }
        }

        $.TimePicker = function() {
            var widget = this;

            widget.container = $('<div></div>').addClass('ui-timepicker-container')
                                .addClass('ui-timepicker-hidden ui-helper-hidden')
            widget.ui = $( '<div></div>' ).addClass('ui-timepicker')
                                .addClass('ui-widget ui-widget-content ui-menu')
                                .addClass('ui-corner-all')
                                .appendTo(widget.container);
            widget.viewport = $('<ul></ul>').addClass( 'ui-timepicker-viewport' )
                                .appendTo( widget.ui );

            if ($.fn.jquery >= '1.4.2') {
                widget.ui.delegate('a', 'mouseenter.timepicker', function() {
                    // passing false instead of an instance object tells the function
                    // to use the current instance
                    widget.activate(false, $(this).parent());
                }).delegate('a', 'mouseleave.timepicker', function() {
                    widget.deactivate(false);
                }).delegate('a', 'click.timepicker', function(event) {
                    event.preventDefault();
                    widget.select(false, $(this).parent());
                });
            }
            
        };

        $.TimePicker.count = 0;
        $.TimePicker.instance = function() {
            $.TimePicker._instance = new $.TimePicker();
            return $.TimePicker._instance;
        };

        $.TimePicker.prototype = {
            // extracted from from jQuery UI Core
            // http://github,com/jquery/jquery-ui/blob/master/ui/jquery.ui.core.js
            keyCode: {
                ALT: 18,
                BLOQ_MAYUS: 20,
                CTRL: 17,
                DOWN: 40,
                END: 35,
                ENTER: 13,
                HOME: 36,
                LEFT: 37,
                NUMPAD_ENTER: 108,
                PAGE_DOWN: 34,
                PAGE_UP: 33,
                RIGHT: 39,
                SHIFT: 16,
                TAB: 9,
                UP: 38
            },

            _items: function(i, startTime) {
                var widget = this, ul = $('<ul></ul>'), item = null, time, end;

                // interval should be a multiple of 60 if timeFormat is not
                // showing minutes
                if (i.options.timeFormat.indexOf('m') === -1 && i.options.interval % 60 !== 0) {
                    i.options.interval = Math.max(Math.round(i.options.interval / 60), 1) * 60;
                }

                if (startTime) {
                    time = normalize(startTime);
                } else if (i.options.startTime) {
                    time = normalize(i.options.startTime);
                } else {
                    time = normalize(i.options.startHour, i.options.startMinutes);
                }

                end = new Date(time.getTime() + 24 * 60 * 60 * 1000);

                while(time < end) {
                    if (widget._isValidTime(i, time)) {
                        item = $('<li>').addClass('ui-menu-item').appendTo(ul);
                        $('<a>').addClass('ui-corner-all').text($.fn.timepicker.formatTime(i.options.timeFormat, time)).appendTo(item);
                        item.data('time-value', time);
                    }
                    time = new Date(time.getTime() + i.options.interval * 60 * 1000);
                }

                return ul.children();
            },

            _isValidTime: function(i, time) {
                var min = null, max = null;

                time = normalize(time);

                if (i.options.minTime !== null) {
                    min = normalize(i.options.minTime);
                } else if (i.options.minHour !== null || i.options.minMinutes !== null) {
                    min = normalize(i.options.minHour, i.options.minMinutes);
                }

                if (i.options.maxTime !== null) {
                    max = normalize(i.options.maxTime);
                } else if (i.options.maxHour !== null || i.options.maxMinutes !== null) {
                    max = normalize(i.options.maxHour, i.options.maxMinutes);
                }

                if (min !== null && max !== null) {
                    return time >= min && time <= max;
                } else if (min !== null) {
                    return time >= min;
                } else if (max !== null) {
                    return time <= max;
                }

                return true;
            },

            _hasScroll: function() {
                // fix for jQuery 1.6 new prop method
                var m = typeof this.ui.prop !== 'undefined' ? 'prop' : 'attr';
                return this.ui.height() < this.ui[m]('scrollHeight');
            },

            /**
             * TODO: Write me!
             *
             * @param i
             * @param direction
             * @param edge
             * */
            _move: function(i, direction, edge) {
                var widget = this;
                if (widget.closed()) {
                    widget.open(i);
                }
                if (!widget.active) {
                    widget.activate( i, widget.viewport.children( edge ) );
                    return;
                }
                var next = widget.active[direction + 'All']('.ui-menu-item').eq(0);
                if (next.length) {
                    widget.activate(i, next);
                } else {
                    widget.activate( i, widget.viewport.children( edge ) );
                }
            },

            //
            // protected methods
            //

            register: function(node, options) {
                var widget = this, i = {}; // timepicker instance object

                widget.container.appendTo($(node).parent())

                i.element = $(node);

                if (i.element.data('TimePicker')) {
                    return;
                }

                i.options = $.metadata ? $.extend({}, options, i.element.metadata()) : $.extend({}, options);
                i.widget = widget;

                // proxy functions for the exposed api methods
                $.extend(i, {
                    next: function() {return widget.next(i) ;},
                    previous: function() {return widget.previous(i) ;},
                    first: function() { return widget.first(i) ;},
                    last: function() { return widget.last(i) ;},
                    selected: function() { return widget.selected(i) ;},
                    open: function() { return widget.open(i) ;},
                    close: function() { return widget.close(i) ;},
                    closed: function() { return widget.closed(i) ;},
                    destroy: function() { return widget.destroy(i) ;},

                    parse: function(str) { return widget.parse(i, str) ;},
                    format: function(time, format) { return widget.format(i, time, format); },
                    getTime: function() { return widget.getTime(i) ;},
                    setTime: function(time, silent) { return widget.setTime(i, time, silent); },
                    option: function(name, value) { return widget.option(i, name, value); }
                });

                widget._setDefaultTime(i);
                widget._addInputEventsHandlers(i);

                i.element.data('TimePicker', i);
            },

            _setDefaultTime: function(i) {
                if (i.options.defaultTime === 'now') {
                    i.setTime(normalize(new Date()));
                } else if (i.options.defaultTime && i.options.defaultTime.getFullYear) {
                    i.setTime(normalize(i.options.defaultTime));
                } else if (i.options.defaultTime) {
                    i.setTime($.fn.timepicker.parseTime(i.options.defaultTime));
                }
            },

            _addInputEventsHandlers: function(i) {
                var widget = this;

                i.element.bind('keydown.timepicker', function(event) {
                    switch (event.which || event.keyCode) {
                    case widget.keyCode.ENTER:
                    case widget.keyCode.NUMPAD_ENTER:
                        event.preventDefault();
                        if (widget.closed()) {
                            i.element.trigger('change.timepicker');
                        } else {
                            widget.select(i, widget.active);
                        }
                        break;
                    case widget.keyCode.UP:
                        i.previous();
                        break;
                    case widget.keyCode.DOWN:
                        i.next();
                        break;
                    default:
                        if (!widget.closed()) {
                            i.close(true);
                        }
                        break;
                    }
                }).bind('focus.timepicker', function() {
                    i.open();
                }).bind('blur.timepicker', function() {
                    setTimeout(function() {
                        if (i.element.data('timepicker-user-clicked-outside')) {
                            i.close();
                        }
                    });
                }).bind('change.timepicker', function() {
                    if (i.closed()) {
                        i.setTime($.fn.timepicker.parseTime(i.element.val()));
                    }
                });
            },

            select: function(i, item) {
                var widget = this, instance = i === false ? widget.instance : i;
                widget.setTime(instance, $.fn.timepicker.parseTime(item.children('a').text()));
                widget.close(instance, true);
            },

            activate: function(i, item) {
                var widget = this, instance = i === false ? widget.instance : i;

                if (instance !== widget.instance) {
                    return;
                } else {
                    widget.deactivate();
                }

                if (widget._hasScroll()) {
                    var offset = item.offset().top - widget.ui.offset().top,
                        scroll = widget.ui.scrollTop(),
                        height = widget.ui.height();
                    if (offset < 0) {
                        widget.ui.scrollTop(scroll + offset);
                    } else if (offset >= height) {
                        widget.ui.scrollTop(scroll + offset - height + item.height());
                    }
                }

                widget.active = item.eq(0).children('a').addClass('ui-state-hover')
                                                        .attr('id', 'ui-active-item')
                                          .end();
            },

            deactivate: function() {
                var widget = this;
                if (!widget.active) { return; }
                widget.active.children('a').removeClass('ui-state-hover').removeAttr('id');
                widget.active = null;
            },

            /**
             * _activate, _deactivate, first, last, next, previous, _move and
             * _hasScroll were extracted from jQuery UI Menu
             * http://github,com/jquery/jquery-ui/blob/menu/ui/jquery.ui.menu.js
             */

            //
            // public methods
            //

            next: function(i) {
                if (this.closed() || this.instance === i) {
                    this._move(i, 'next', '.ui-menu-item:first');
                }
                return i.element;
            },

            previous: function(i) {
                if (this.closed() || this.instance === i) {
                    this._move(i, 'prev', '.ui-menu-item:last');
                }
                return i.element;
            },

            first: function(i) {
                if (this.instance === i) {
                    return this.active && this.active.prevAll('.ui-menu-item').length === 0;
                }
                return false;
            },

            last: function(i) {
                if (this.instance === i) {
                    return this.active && this.active.nextAll('.ui-menu-item').length === 0;
                }
                return false;
            },

            selected: function(i) {
                if (this.instance === i)  {
                    return this.active ? this.active : null;
                }
                return null;
            },

            open: function(i) {
                var widget = this,
                    selectedTime = i.getTime(),
                    arrange = i.options.dynamic && selectedTime;
                
                widget.container.closest('.ui.input.timetextbox').addClass('active')

                // return if dropdown is disabled
                if (!i.options.dropdown) { return i.element; }

                // fix for issue https://github.com/wvega/timepicker/issues/56
                // idea from https://prototype.lighthouseapp.com/projects/8887/tickets/248-results-popup-from-ajaxautocompleter-disappear-when-user-clicks-on-scrollbars-in-ie6ie7
                i.element.data('timepicker-event-namespace', Math.random());

                $(document).bind('click.timepicker-' + i.element.data('timepicker-event-namespace'), function(event) {
                    if (i.element.get(0) === event.target) {
                        i.element.data('timepicker-user-clicked-outside', false);
                    } else {
                        i.element.data('timepicker-user-clicked-outside', true).blur();
                    }
                });

                // if a date is already selected and options.dynamic is true,
                // arrange the items in the list so the first item is
                // cronologically right after the selected date.
                // TODO: set selectedTime
                if (i.rebuild || !i.items || arrange) {
                    i.items = widget._items(i, arrange ? selectedTime : null);
                }

                // remove old li elements keeping associated events, then append
                // the new li elements to the ul
                if (i.rebuild || widget.instance !== i || arrange) {
                    // handle menu events when using jQuery versions previous to
                    // 1.4.2 (thanks to Brian Link)
                    // http://github.com/wvega/timepicker/issues#issue/4
                    if ($.fn.jquery < '1.4.2') {
                        widget.viewport.children().remove();
                        widget.viewport.append(i.items);
                        widget.viewport.find('a').bind('mouseover.timepicker', function() {
                            widget.activate(i, $(this).parent());
                        }).bind('mouseout.timepicker', function() {
                            widget.deactivate(i);
                        }).bind('click.timepicker', function(event) {
                            event.preventDefault();
                            widget.select(i, $(this).parent());
                        });
                    } else {
                        widget.viewport.children().detach();
                        widget.viewport.append(i.items);
                    }
                }

                i.rebuild = false;

                // theme
                widget.container.removeClass('ui-helper-hidden ui-timepicker-hidden ui-timepicker-standard ui-timepicker-corners').show();

                switch (i.options.theme) {
                case 'standard':
                    widget.container.addClass('ui-timepicker-standard');
                    break;
                case 'standard-rounded-corners':
                    widget.container.addClass('ui-timepicker-standard ui-timepicker-corners');
                    break;
                default:
                    break;
                }

                /* resize ui */

                // we are hiding the scrollbar in the dropdown menu adding a 40px
                // padding to the wrapper element making the scrollbar appear in the
                // part of the wrapper that's hidden by the container (a DIV).
                if ( ! widget.container.hasClass( 'ui-timepicker-no-scrollbar' ) && ! i.options.scrollbar ) {
                    widget.container.addClass( 'ui-timepicker-no-scrollbar' );
                    widget.viewport.css( { paddingRight: 40 } );
                }

                var containerDecorationHeight = widget.container.outerHeight() - widget.container.height(),
                    zindex = i.options.zindex ? i.options.zindex : i.element.offsetParent().css( 'z-index' ),
                    elementOffset = i.element.offset();

                // then show the container so that the browser can consider the timepicker's
                // height to calculate the page's total height and decide if adding scrollbars
                // is necessary.
                widget.container.show();

                // now we need to calculate the element offset and position the container again.
                // If the browser added scrollbars, the container's original position is not aligned
                // with the element's final position. This step fixes that problem.
                widget.container.css( {
                    height: widget.ui.outerHeight() + containerDecorationHeight,
                    width: i.element.outerWidth(),
                    zIndex: zindex,
                    cursor: 'default'
                } );

                var calculatedWidth = widget.container.width() - ( widget.ui.outerWidth() - widget.ui.width() );

                // hardcode ui, viewport and item's width. I couldn't get it to work using CSS only
                widget.ui.css( { width: calculatedWidth } );
                widget.viewport.css( { width: calculatedWidth } );
                i.items.css( { width: calculatedWidth } );

                // XXX: what's this line doing here?
                widget.instance = i;

                // try to match input field's current value with an item in the
                // dropdown
                if (selectedTime) {
                    i.items.each(function() {
                        var item = $(this), time;

                        if ($.fn.jquery < '1.4.2') {
                            time = $.fn.timepicker.parseTime(item.find('a').text());
                        } else {
                            time = item.data('time-value');
                        }

                        if (time.getTime() === selectedTime.getTime()) {
                            widget.activate(i, item);
                            return false;
                        }
                        return true;
                    });
                } else {
                    widget.deactivate(i);
                }

                // don't break the chain
                return i.element;
            },

            close: function(i) {
                var widget = this;

                widget.container.closest('.ui.input.timetextbox').removeClass('active')

                if (widget.instance === i) {
                    widget.container.addClass('ui-helper-hidden ui-timepicker-hidden').hide();
                    widget.ui.scrollTop(0);
                    widget.ui.children().removeClass('ui-state-hover');
                }

                $(document).unbind('click.timepicker-' + i.element.data('timepicker-event-namespace'));

                return i.element;
            },

            closed: function() {
                return this.ui.is(':hidden');
            },

            destroy: function(i) {
                var widget = this;
                widget.close(i, true);
                return i.element.unbind('.timepicker').data('TimePicker', null);
            },

            //

            parse: function(i, str) {
                return $.fn.timepicker.parseTime(str);
            },

            format: function(i, time, format) {
                format = format || i.options.timeFormat;
                return $.fn.timepicker.formatTime(format, time);
            },

            getTime: function(i) {
                var widget = this,
                    current = $.fn.timepicker.parseTime(i.element.val());

                // if current value is not valid, we return null.
                // stored Date object is ignored, because the current value
                // (valid or invalid) always takes priority
                if (current instanceof Date && !widget._isValidTime(i, current)) {
                    return null;
                } else if (current instanceof Date && i.selectedTime) {
                    // if the textfield's value and the stored Date object
                    // have the same representation using current format
                    // we prefer the stored Date object to avoid unnecesary
                    // lost of precision.
                    if (i.format(current) === i.format(i.selectedTime)) {
                        return i.selectedTime;
                    } else {
                        return current;
                    }
                } else if (current instanceof Date) {
                    return current;
                } else {
                    return null;
                }
            },

            setTime: function(i, time, silent) {
                var widget = this, previous = i.selectedTime;

                if (typeof time === 'string') {
                    time = i.parse(time);
                }

                if (time && time.getMinutes && widget._isValidTime(i, time)) {
                    time = normalize(time);
                    i.selectedTime = time;
                    i.element.val(i.format(time, i.options.timeFormat));

                    // TODO: add documentaion about setTime being chainable
                    if (silent) { return i; }
                } else {
                    i.selectedTime = null;
                }

                // custom change event and change callback
                // TODO: add documentation about this event
                if (previous !== null || i.selectedTime !== null) {
                    i.element.trigger('time-change', [time]);
                    if ($.isFunction(i.options.change)) {
                        i.options.change.apply(i.element, [time]);
                    }
                }

                return i.element;
            },

            option: function(i, name, value) {
                if (typeof value === 'undefined') {
                    return i.options[name];
                }

                var time = i.getTime(),
                    options, destructive;

                if (typeof name === 'string') {
                    options = {};
                    options[name] = value;
                } else {
                    options = name;
                }

                // some options require rebuilding the dropdown items
                destructive = ['minHour', 'minMinutes', 'minTime',
                               'maxHour', 'maxMinutes', 'maxTime',
                               'startHour', 'startMinutes', 'startTime',
                               'timeFormat', 'interval', 'dropdown'];


                $.each(options, function(name) {
                    i.options[name] = options[name];
                    i.rebuild = i.rebuild || $.inArray(name, destructive) > -1;
                });

                if (i.rebuild) {
                    i.setTime(time);
                }
            }
        };

        $.TimePicker.defaults =  {
            timeFormat: 'hh:mm p',
            minHour: null,
            minMinutes: null,
            minTime: null,
            maxHour: null,
            maxMinutes: null,
            maxTime: null,
            startHour: null,
            startMinutes: null,
            startTime: null,
            interval: 30,
            dynamic: true,
            theme: 'standard',
            zindex: null,
            dropdown: true,
            scrollbar: false,
            // callbacks
            change: function(/*time*/) {}
        };

        $.TimePicker.methods = {
            chainable: [
                'next',
                'previous',
                'open',
                'close',
                'destroy',
                'setTime'
            ]
        };

        $.fn.timepicker = function(options) {
            // support calling API methods using the following syntax:
            //   $(...).timepicker('parse', '11p');
            if (typeof options === 'string') {
                var args = Array.prototype.slice.call(arguments, 1),
                    method, result;

                // chainable API methods
                if (options === 'option' && arguments.length > 2) {
                    method = 'each';
                } else if ($.inArray(options, $.TimePicker.methods.chainable) !== -1) {
                    method = 'each';
                // API methods that return a value
                } else {
                    method = 'map';
                }

                result = this[method](function() {
                    var element = $(this), i = element.data('TimePicker');
                    if (typeof i === 'object') {
                        return i[options].apply(i, args);
                    }
                });

                if (method === 'map' && this.length === 1) {
                    return $.makeArray(result).shift();
                } else if (method === 'map') {
                    return $.makeArray(result);
                } else {
                    return result;
                }
            }

            // calling the constructor again on a jQuery object with a single
            // element returns a reference to a TimePicker object.
            if (this.length === 1 && this.data('TimePicker')) {
                return this.data('TimePicker');
            }

            var globals = $.extend({}, $.TimePicker.defaults, options);

            return this.each(function() {
                $.TimePicker.instance().register(this, globals);
            });
        };

        /**
         * TODO: documentation
         */
        $.fn.timepicker.formatTime = function(format, time) {
            var hours = time.getHours(),
                hours12 = hours % 12,
                minutes = time.getMinutes(),
                seconds = time.getSeconds(),
                replacements = {
                    hh: pad((hours12 === 0 ? 12 : hours12).toString(), '0', 2),
                    HH: pad(hours.toString(), '0', 2),
                    mm: pad(minutes.toString(), '0', 2),
                    ss: pad(seconds.toString(), '0', 2),
                    h: (hours12 === 0 ? 12 : hours12),
                    H: hours,
                    m: minutes,
                    s: seconds,
                    p: hours > 11 ? 'PM' : 'AM'
                },
                str = format, k = '';
            for (k in replacements) {
                if (replacements.hasOwnProperty(k)) {
                    str = str.replace(new RegExp(k,'g'), replacements[k]);
                }
            }
            // replacements is not guaranteed to be order and the 'p' can cause problems
            str = str.replace(new RegExp('a','g'), hours > 11 ? 'pm' : 'am');
            return str;
        };

        /**
         * Convert a string representing a given time into a Date object.
         *
         * The Date object will have attributes others than hours, minutes and
         * seconds set to current local time values. The function will return
         * false if given string can't be converted.
         *
         * If there is an 'a' in the string we set am to true, if there is a 'p'
         * we set pm to true, if both are present only am is setted to true.
         *
         * All non-digit characters are removed from the string before trying to
         * parse the time.
         *
         * ''       can't be converted and the function returns false.
         * '1'      is converted to     01:00:00 am
         * '11'     is converted to     11:00:00 am
         * '111'    is converted to     01:11:00 am
         * '1111'   is converted to     11:11:00 am
         * '11111'  is converted to     01:11:11 am
         * '111111' is converted to     11:11:11 am
         *
         * Only the first six (or less) characters are considered.
         *
         * Special case:
         *
         * When hours is greater than 24 and the last digit is less or equal than 6, and minutes
         * and seconds are less or equal than 60, we append a trailing zero and
         * start parsing process again. Examples:
         *
         * '95' is treated as '950' and converted to 09:50:00 am
         * '46' is treated as '460' and converted to 05:00:00 am
         * '57' can't be converted and the function returns false.
         *
         * For a detailed list of supported formats check the unit tests at
         * http://github.com/wvega/timepicker/tree/master/tests/
         */
        $.fn.timepicker.parseTime = (function() {
            var patterns = [
                    // 1, 12, 123, 1234, 12345, 123456
                    [/^(\d+)$/, '$1'],
                    // :1, :2, :3, :4 ... :9
                    [/^:(\d)$/, '$10'],
                    // :1, :12, :123, :1234 ...
                    [/^:(\d+)/, '$1'],
                    // 6:06, 5:59, 5:8
                    [/^(\d):([7-9])$/, '0$10$2'],
                    [/^(\d):(\d\d)$/, '$1$2'],
                    [/^(\d):(\d{1,})$/, '0$1$20'],
                    // 10:8, 10:10, 10:34
                    [/^(\d\d):([7-9])$/, '$10$2'],
                    [/^(\d\d):(\d)$/, '$1$20'],
                    [/^(\d\d):(\d*)$/, '$1$2'],
                    // 123:4, 1234:456
                    [/^(\d{3,}):(\d)$/, '$10$2'],
                    [/^(\d{3,}):(\d{2,})/, '$1$2'],
                    //
                    [/^(\d):(\d):(\d)$/, '0$10$20$3'],
                    [/^(\d{1,2}):(\d):(\d\d)/, '$10$2$3']
                ],
                length = patterns.length;

            return function(str) {
                var time = normalize(new Date()),
                    am = false, pm = false, h = false, m = false, s = false;

                if (typeof str === 'undefined' || !str.toLowerCase) { return null; }

                str = str.toLowerCase();
                am = /a/.test(str);
                pm = am ? false : /p/.test(str);
                str = str.replace(/[^0-9:]/g, '').replace(/:+/g, ':');

                for (var k = 0; k < length; k = k + 1) {
                    if (patterns[k][0].test(str)) {
                        str = str.replace(patterns[k][0], patterns[k][1]);
                        break;
                    }
                }
                str = str.replace(/:/g, '');

                if (str.length === 1) {
                    h = str;
                } else if (str.length === 2) {
                    h = str;
                } else if (str.length === 3 || str.length === 5) {
                    h = str.substr(0, 1);
                    m = str.substr(1, 2);
                    s = str.substr(3, 2);
                } else if (str.length === 4 || str.length > 5) {
                    h = str.substr(0, 2);
                    m = str.substr(2, 2);
                    s = str.substr(4, 2);
                }

                if (str.length > 0 && str.length < 5) {
                    if (str.length < 3) {
                        m = 0;
                    }
                    s = 0;
                }

                if (h === false || m === false || s === false) {
                    return false;
                }

                h = parseInt(h, 10);
                m = parseInt(m, 10);
                s = parseInt(s, 10);

                if (am && h === 12) {
                    h = 0;
                } else if (pm && h < 12) {
                    h = h + 12;
                }

                if (h > 24) {
                    if (str.length >= 6) {
                        return $.fn.timepicker.parseTime(str.substr(0,5));
                    } else {
                        return $.fn.timepicker.parseTime(str + '0' + (am ? 'a' : '') + (pm ? 'p' : ''));
                    }
                } else {
                    time.setHours(h, m, s);
                    return time;
                }
            };
        })();
    })();
}));

//>>built
(function(g,n){var l,p=function(){},k=function(a){for(var b in a)return 0;return 1},f={}.toString,m=function(a){return"[object Function]"==f.call(a)},e=function(a){return"[object String]"==f.call(a)},c=function(a){return"[object Array]"==f.call(a)},a=function(a,b){if(a)for(var d=0;d<a.length;)b(a[d++])},b=function(a,b){for(var d in b)a[d]=b[d];return a},h=function(a,d){return b(Error(a),{src:"dojoLoader",info:d})},d=1,q=function(){return"_"+d++},s=function(a,b,d){return La(a,b,d,0,s)},r=this,v=r.document,
t=v&&v.createElement("DiV"),u=s.has=function(a){return m(w[a])?w[a]=w[a](r,v,t):w[a]},w=u.cache=n.hasCache;u.add=function(a,b,d,h){(void 0===w[a]||h)&&(w[a]=b);return d&&u(a)};u.add("host-webworker","undefined"!==typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope);u("host-webworker")&&(b(n.hasCache,{"host-browser":0,dom:0,"dojo-dom-ready-api":0,"dojo-sniff":0,"dojo-inject-api":1,"host-webworker":1,"dojo-guarantee-console":0}),n.loaderPatch={injectUrl:function(a,b){try{importScripts(a),b()}catch(d){console.error(d)}}});
for(var A in g.has)u.add(A,g.has[A],0,1);var y=0,x=[],z=0,C=p,B=p,G;s.isXdUrl=p;s.initSyncLoader=function(a,b,d){z||(z=a,C=b,B=d);return{sync:"sync",requested:1,arrived:2,nonmodule:3,executing:4,executed:5,syncExecStack:x,modules:H,execQ:U,getModule:X,injectModule:na,setArrived:ba,signal:D,finishExec:ea,execModule:fa,dojoRequirePlugin:z,getLegacyMode:function(){return y},guardCheckComplete:ga}};var L=location.protocol,M=location.host;s.isXdUrl=function(a){return/^\./.test(a)?!1:/^\/\//.test(a)?!0:
(a=a.match(/^([^\/\:]+\:)\/+([^\/]+)/))&&(a[1]!=L||M&&a[2]!=M)};u.add("dojo-force-activex-xhr",!v.addEventListener&&"file:"==window.location.protocol);u.add("native-xhr","undefined"!=typeof XMLHttpRequest);if(u("native-xhr")&&!u("dojo-force-activex-xhr"))G=function(){return new XMLHttpRequest};else{var P=["Msxml2.XMLHTTP","Microsoft.XMLHTTP","Msxml2.XMLHTTP.4.0"],I;for(l=0;3>l;)try{if(I=P[l++],new ActiveXObject(I))break}catch(J){}G=function(){return new ActiveXObject(I)}}s.getXhr=G;u.add("dojo-gettext-api",
1);s.getText=function(a,b,d){var c=G();c.open("GET",oa(a),!1);c.send(null);if(200==c.status||!location.host&&!c.status)d&&d(c.responseText,b);else throw h("xhrFailed",c.status);return c.responseText};var F=u("csp-restrictions")?function(){}:new Function("return eval(arguments[0]);");s.eval=function(a,b){return F(a+"\r\n//# sourceURL\x3d"+b)};var E={},D=s.signal=function(b,d){var h=E[b];a(h&&h.slice(0),function(a){a.apply(null,c(d)?d:[d])})},T=s.on=function(a,b){var d=E[a]||(E[a]=[]);d.push(b);return{remove:function(){for(var a=
0;a<d.length;a++)if(d[a]===b){d.splice(a,1);break}}}},K=[],N={},Q=[],R={},O=s.map={},V=[],H={},S="",Z={},pa={},qa={},ca=0,ra=function(a,b){b=!1!==b;var d,h,c,q;for(d in pa)h=pa[d],(c=d.match(/^url\:(.+)/))?Z["url:"+Ma(c[1],a)]=h:"*now"==d?q=h:"*noref"!=d&&(c=ha(d,a,!0),Z[c.mid]=Z["url:"+c.url]=h);q&&q(Ca(a));b&&(pa={})},Na=function(a){return a.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g,function(a){return"\\"+a})},Da=function(a,b){b.splice(0,b.length);for(var d in a)b.push([d,a[d],RegExp("^"+Na(d)+"(/|$)"),
d.length]);b.sort(function(a,b){return b[3]-a[3]});return b},$a=function(b,d){a(b,function(a){d.push([e(a[0])?RegExp("^"+Na(a[0])+"$"):a[0],a[1]])})},Oa=function(a){var d=a.name;d||(d=a,a={name:d});a=b({main:"main"},a);a.location=a.location?a.location:d;a.packageMap&&(O[d]=a.packageMap);a.main.indexOf("./")||(a.main=a.main.substring(2));R[d]=a},Pa=[],ia=function(d,h,c){for(var q in d){"waitSeconds"==q&&(s.waitms=1E3*(d[q]||0));"cacheBust"==q&&(S=d[q]?e(d[q])?d[q]:(new Date).getTime()+"":"");if("baseUrl"==
q||"combo"==q)s[q]=d[q];if("async"==q){var r=d[q];s.legacyMode=y=e(r)&&/sync|legacyAsync/.test(r)?r:!r?"sync":!1;s.async=!y}d[q]!==w&&(s.rawConfig[q]=d[q],"has"!=q&&u.add("config-"+q,d[q],0,h))}s.baseUrl||(s.baseUrl="./");/\/$/.test(s.baseUrl)||(s.baseUrl+="/");for(q in d.has)u.add(q,d.has[q],0,h);a(d.packages,Oa);for(var t in d.packagePaths)a(d.packagePaths[t],function(a){var b=t+"/"+a;e(a)&&(a={name:a});a.location=b;Oa(a)});Da(b(O,d.map),V);a(V,function(a){a[1]=Da(a[1],[]);"*"==a[0]&&(V.star=a)});
Da(b(N,d.paths),Q);$a(d.aliases,K);if(h)Pa.push({config:d.config});else for(q in d.config)h=X(q,c),h.config=b(h.config||{},d.config[q]);d.cache&&(ra(),pa=d.cache,ra(0,!!d.cache["*noref"]));D("config",[d,s.rawConfig])};u("dojo-cdn");var sa=v.getElementsByTagName("script");l=0;for(var Y,aa,ta,ja;l<sa.length;){Y=sa[l++];if((ta=Y.getAttribute("src"))&&(ja=ta.match(/(((.*)\/)|^)dojo\.js(\W|$)/i)))aa=ja[3]||"",n.baseUrl=n.baseUrl||aa,ca=Y;if(ta=Y.getAttribute("data-dojo-config")||Y.getAttribute("djConfig"))qa=
s.eval("({ "+ta+" })","data-dojo-config"),ca=Y}s.rawConfig={};ia(n,1);u("dojo-cdn")&&((R.dojo.location=aa)&&(aa+="/"),R.dijit.location=aa+"../dijit/",R.dojox.location=aa+"../dojox/");ia(g,1);ia(qa,1);var ka=function(b){ga(function(){a(b.deps,na)})},La=function(a,d,r,t,u){var f;if(e(a)){if((f=X(a,t,!0))&&f.executed)return f.result;throw h("undefinedModule",a);}c(a)||(ia(a,0,t),a=d,d=r);if(c(a))if(a.length){r="require*"+q();for(var m,k=[],v=0;v<a.length;)m=a[v++],k.push(X(m,t));f=b(ua("",r,0,""),{injected:2,
deps:k,def:d||p,require:t?t.require:s,gc:1});H[f.mid]=f;ka(f);var g=la&&"sync"!=y;ga(function(){fa(f,g)});f.executed||U.push(f);da()}else d&&d();return u},Ca=function(a){if(!a)return s;var d=a.require;d||(d=function(b,h,c){return La(b,h,c,a,d)},a.require=b(d,s),d.module=a,d.toUrl=function(b){return Ma(b,a)},d.toAbsMid=function(b){return Ea(b,a)},d.syncLoadNls=function(b){b=ha(b,a);var d=H[b.mid];if(!d||!d.executed)if($=Z[b.mid]||Z["url:"+b.url])va($),d=H[b.mid];return d&&d.executed&&d.result});return d},
U=[],wa=[],W={},ab=function(a){a.injected=1;W[a.mid]=1;a.url&&(W[a.url]=a.pack||1);Qa()},ba=function(a){a.injected=2;delete W[a.mid];a.url&&delete W[a.url];k(W)&&(xa(),"xd"==y&&(y="sync"))},bb=s.idle=function(){return!wa.length&&k(W)&&!U.length&&!la},ya=function(a,b){if(b)for(var d=0;d<b.length;d++)if(b[d][2].test(a))return b[d];return 0},Ra=function(a){var b=[],d,h;for(a=a.replace(/\\/g,"/").split("/");a.length;)d=a.shift(),".."==d&&b.length&&".."!=h?(b.pop(),h=b[b.length-1]):"."!=d&&b.push(h=d);
return b.join("/")},ua=function(a,b,d,h){var c=s.isXdUrl(h);return{pid:a,mid:b,pack:d,url:h,executed:0,def:0,isXd:c,isAmd:!!(c||R[a]&&R[a].isAmd)}},Sa=function(b,d,c,q,e,s,r,t,f,k){var v,g,w,l;l=/^\./.test(b);if(/(^\/)|(\:)|(\.js$)/.test(b)||l&&!d)return ua(0,b,0,b);b=Ra(l?d.mid+"/../"+b:b);if(/^\./.test(b))throw h("irrationalPath",b);!k&&(!l&&s.star)&&(w=ya(b,s.star[1]));!w&&d&&(w=(w=ya(d.mid,s))&&ya(b,w[1]));w&&(b=w[1]+b.substring(w[3]));d=(ja=b.match(/^([^\/]+)(\/(.+))?$/))?ja[1]:"";(v=c[d])?b=
d+"/"+(g=ja[3]||v.main):d="";var z=0;a(t,function(a){var d=b.match(a[0]);d&&0<d.length&&(z=m(a[1])?b.replace(a[0],a[1]):a[1])});if(z)return Sa(z,0,c,q,e,s,r,t,f);if(c=q[b])return f?ua(c.pid,c.mid,c.pack,c.url):q[b];q=(w=ya(b,r))?w[1]+b.substring(w[3]):d?v.location+"/"+g:u("config-tlmSiblingOfDojo")?"../"+b:b;/(^\/)|(\:)/.test(q)||(q=e+q);return ua(d,b,v,Ra(q+".js"))},ha=function(a,b,d){return Sa(a,b,R,H,s.baseUrl,V,Q,K,void 0,d)},Ta=function(a,b,d){return a.normalize?a.normalize(b,function(a){return Ea(a,
d)}):Ea(b,d)},Ua=0,X=function(a,b,d){var h,c;(h=a.match(/^(.+?)\!(.*)$/))?(c=X(h[1],b,d),"sync"==y&&!c.executed&&(na(c),2===c.injected&&!c.executed&&ga(function(){fa(c)}),c.executed?za(c):U.unshift(c)),5===c.executed&&!c.load&&za(c),c.load?(h=Ta(c,h[2],b),a=c.mid+"!"+(c.dynamic?++Ua+"!":"")+h):(h=h[2],a=c.mid+"!"+ ++Ua+"!waitingForPlugin"),a={plugin:c,mid:a,req:Ca(b),prid:h}):a=ha(a,b);return H[a.mid]||!d&&(H[a.mid]=a)},Ea=s.toAbsMid=function(a,b){return ha(a,b).mid},Ma=s.toUrl=function(a,b){var d=
ha(a+"/x",b),h=d.url;return oa(0===d.pid?a:h.substring(0,h.length-5))},Va={injected:2,executed:5,def:3,result:3},Fa=function(a){return H[a]=b({mid:a},Va)},cb=Fa("require"),db=Fa("exports"),eb=Fa("module"),Aa={},Ga=0,za=function(a){var b=a.result;a.dynamic=b.dynamic;a.normalize=b.normalize;a.load=b.load;return a},fb=function(d){var h={};a(d.loadQ,function(a){var c=Ta(d,a.prid,a.req.module),q=d.dynamic?a.mid.replace(/waitingForPlugin$/,c):d.mid+"!"+c,c=b(b({},a),{mid:q,prid:c,injected:0});if(!H[q]||
!H[q].injected)Wa(H[q]=c);h[a.mid]=H[q];ba(a);delete H[a.mid]});d.loadQ=0;var c=function(a){for(var b=a.deps||[],d=0;d<b.length;d++)(a=h[b[d].mid])&&(b[d]=a)},q;for(q in H)c(H[q]);a(U,c)},ea=function(b){s.trace("loader-finish-exec",[b.mid]);b.executed=5;b.defOrder=Ga++;a(b.provides,function(a){a()});b.loadQ&&(za(b),fb(b));for(l=0;l<U.length;)U[l]===b?U.splice(l,1):l++;/^require\*/.test(b.mid)&&delete H[b.mid]},gb=[],fa=function(a,b){if(4===a.executed)return s.trace("loader-circular-dependency",[gb.concat(a.mid).join("-\x3e")]),
!a.def||b?Aa:a.cjs&&a.cjs.exports;if(!a.executed){if(!a.def)return Aa;var d=a.mid,c=a.deps||[],q,e=[],r=0;for(a.executed=4;q=c[r++];){q=q===cb?Ca(a):q===db?a.cjs.exports:q===eb?a.cjs:fa(q,b);if(q===Aa)return a.executed=0,s.trace("loader-exec-module",["abort",d]),Aa;e.push(q)}s.trace("loader-run-factory",[a.mid]);var d=a.def,t;x.unshift(a);if(u("config-dojo-loader-catches"))try{t=m(d)?d.apply(null,e):d}catch(f){D("error",a.result=h("factoryThrew",[a,f]))}else t=m(d)?d.apply(null,e):d;a.result=void 0===
t&&a.cjs?a.cjs.exports:t;x.shift(a);ea(a)}return a.result},la=0,ga=function(a){try{la++,a()}catch(b){throw b;}finally{la--}bb()&&D("idle",[])},da=function(){la||ga(function(){C();for(var a,b,d=0;d<U.length;)a=Ga,b=U[d],fa(b),a!=Ga?(C(),d=0):d++})};void 0===u("dojo-loader-eval-hint-url")&&u.add("dojo-loader-eval-hint-url",1);var oa="function"==typeof g.fixupUrl?g.fixupUrl:function(a){a+="";return a+(S?(/\?/.test(a)?"\x26":"?")+S:"")},Wa=function(a){var b=a.plugin;5===b.executed&&!b.load&&za(b);var d=
function(b){a.result=b;ba(a);ea(a);da()};b.load?b.load(a.prid,a.req,d):b.loadQ?b.loadQ.push(a):(b.loadQ=[a],U.unshift(b),na(b))},$=0,ma=0,Ha=0,va=function(a,b){u("config-stripStrict")&&(a=a.replace(/(["'])use strict\1/g,""));Ha=1;if(u("config-dojo-loader-catches"))try{a===$?$.call(null):s.eval(a,u("dojo-loader-eval-hint-url")?b.url:b.mid)}catch(d){D("error",h("evalModuleThrew",b))}else a===$?$.call(null):s.eval(a,u("dojo-loader-eval-hint-url")?b.url:b.mid);Ha=0},na=function(d){var c=d.mid,q=d.url;
if(!d.executed&&!d.injected&&!(W[c]||d.url&&(d.pack&&W[d.url]===d.pack||1==W[d.url])))if(ab(d),d.plugin)Wa(d);else{var e=function(){Xa(d);if(2!==d.injected){if(u("dojo-enforceDefine")){D("error",h("noDefine",d));return}ba(d);b(d,Va);s.trace("loader-define-nonmodule",[d.url])}y?!x.length&&da():da()};if($=Z[c]||Z["url:"+d.url])s.trace("loader-inject",["cache",d.mid,q]),va($,d),e();else{if(y)if(d.isXd)"sync"==y&&(y="xd");else if(!(d.isAmd&&"sync"!=y)){var r=function(b){if("sync"==y){x.unshift(d);va(b,
d);x.shift();Xa(d);d.cjs||(ba(d),ea(d));if(d.finish){b=c+"*finish";var h=d.finish;delete d.finish;Ia(b,["dojo",("dojo/require!"+h.join(",")).replace(/\./g,"/")],function(b){a(h,function(a){b.require(a)})});U.unshift(X(b))}e()}else(b=B(d,b))?(va(b,d),e()):(ma=d,s.injectUrl(oa(q),e,d),ma=0)};s.trace("loader-inject",["xhr",d.mid,q,"sync"!=y]);if(u("config-dojo-loader-catches"))try{s.getText(q,"sync"!=y,r)}catch(t){D("error",h("xhrInjectFailed",[d,t]))}else s.getText(q,"sync"!=y,r);return}s.trace("loader-inject",
["script",d.mid,q]);ma=d;s.injectUrl(oa(q),e,d);ma=0}}},Ja=function(a,d,c){s.trace("loader-define-module",[a.mid,d]);var q=a.mid;if(2===a.injected)return D("error",h("multipleDefine",a)),a;b(a,{deps:d,def:c,cjs:{id:a.mid,uri:a.url,exports:a.result={},setExports:function(b){a.cjs.exports=b},config:function(){return a.config}}});for(var e=0;d[e];e++)d[e]=X(d[e],a);y&&!W[q]&&(ka(a),U.push(a),da());ba(a);!m(c)&&!d.length&&(a.result=c,ea(a));return a},Xa=function(b,d){for(var h=[],c,q;wa.length;)q=wa.shift(),
d&&(q[0]=d.shift()),c=q[0]&&X(q[0])||b,h.push([c,q[1],q[2]]);ra(b);a(h,function(a){ka(Ja.apply(null,a))})},Ba=0,xa=p,Qa=p,xa=function(){Ba&&clearTimeout(Ba);Ba=0},Qa=function(){xa();s.waitms&&(Ba=r.setTimeout(function(){xa();D("error",h("timeout",W))},s.waitms))};u.add("ie-event-behavior",v.attachEvent&&"undefined"===typeof Windows&&("undefined"===typeof opera||"[object Opera]"!=opera.toString()));var Ka=function(a,b,d,h){if(u("ie-event-behavior"))return a.attachEvent(d,h),function(){a.detachEvent(d,
h)};a.addEventListener(b,h,!1);return function(){a.removeEventListener(b,h,!1)}},hb=Ka(window,"load","onload",function(){s.pageLoaded=1;try{"complete"!=v.readyState&&(v.readyState="complete")}catch(a){}hb()}),sa=v.getElementsByTagName("script");for(l=0;!ca;)if(!/^dojo/.test((Y=sa[l++])&&Y.type))ca=Y;s.injectUrl=function(a,b,d){d=d.node=v.createElement("script");var c=Ka(d,"load","onreadystatechange",function(a){a=a||window.event;var d=a.target||a.srcElement;if("load"===a.type||/complete|loaded/.test(d.readyState))c(),
q(),b&&b()}),q=Ka(d,"error","onerror",function(b){c();q();D("error",h("scriptError",[a,b]))});d.type="text/javascript";d.charset="utf-8";d.src=a;ca.parentNode.insertBefore(d,ca);return d};s.log=function(){try{for(var a=0;a<arguments.length;a++);}catch(b){}};s.trace=p;var Ia=function(a,b,d){var c=arguments.length,q=["require","exports","module"],r=[0,a,b];1==c?r=[0,m(a)?q:[],a]:2==c&&e(a)?r=[a,m(b)?q:[],b]:3==c&&(r=[a,b,d]);s.trace("loader-define",r.slice(0,2));if((c=r[0]&&X(r[0]))&&!W[c.mid])ka(Ja(c,
r[1],r[2]));else if(!u("ie-event-behavior")||Ha)wa.push(r);else{c=c||ma;if(!c)for(a in W)if((q=H[a])&&q.node&&"interactive"===q.node.readyState){c=q;break}c?(ra(c),ka(Ja(c,r[1],r[2]))):D("error",h("ieDefineFailed",r[0]));da()}};Ia.amd={vendor:"dojotoolkit.org"};b(b(s,n.loaderPatch),g.loaderPatch);T("error",function(a){try{if(console.error(a),a instanceof Error)for(var b in a);}catch(d){}});b(s,{uid:q,cache:Z,packs:R});if(r.define)D("error",h("defineAlreadyDefined",0));else{r.define=Ia;r.require=s;
a(Pa,function(a){ia(a)});var Ya=qa.deps||g.deps||n.deps,Za=qa.callback||g.callback||n.callback;s.boot=Ya||Za?[Ya||[],Za]:0}})(this.dojoConfig||this.djConfig||this.require||{},{async:0,hasCache:{"config-selectorEngine":"lite","config-tlmSiblingOfDojo":1,"dojo-built":1,"dojo-loader":1,dom:1,"host-browser":1},packages:[{location:".",name:"dojo"},{location:"../dojox",name:"dojox"},{location:"../dijit",name:"dijit"},{location:"../dgrid",main:"OnDemandGrid",name:"dgrid"},{location:"../dstore",main:"Store",
name:"dstore"},{location:"../bundle",name:"bundle"}]});
require({cache:{"bundle/bundle":function(){require("dojo/_base/declare dgrid/Grid dgrid/OnDemandGrid dgrid/Selection dgrid/extensions/ColumnResizer dgrid/Keyboard dgrid/extensions/ColumnHider dojo/aspect dojo/dom-class dojo/dom-construct dojo/dom-style dgrid/Editor dstore/Memory dgrid/extensions/CompoundColumns dojo/_base/declare dstore/Rest dstore/Trackable dstore/SimpleQuery dojo/_base/declare dgrid/OnDemandGrid dgrid/Selection dgrid/extensions/ColumnResizer dgrid/Keyboard dgrid/extensions/ColumnHider dojo/aspect dojo/dom-class dojo/dom-construct dojo/dom-style dgrid/Editor dstore/Memory dstore/Trackable dstore/Tree dgrid/Tree dstore/Memory dstore/RequestMemory dstore/Cache dstore/Request dojo/main dgrid/util/touch dijit/TooltipDialog dijit/popup dgrid/ColumnSet dijit/_base/manager dijit/_base".split(" "),function(){})},
"dojo/_base/declare":function(){define(["./kernel","../has","./lang"],function(g,n,l){function p(a,b){throw Error("declare"+(b?" "+b:"")+": "+a);}function k(a,b,d){var h,c,q,e,r,s,t,f=this._inherited=this._inherited||{};"string"==typeof a&&(h=a,a=b,b=d);d=0;e=a.callee;(h=h||e.nom)||p("can't deduce a name to call inherited()",this.declaredClass);r=this.constructor._meta;q=r.bases;t=f.p;if(h!=z){if(f.c!==e&&(t=0,s=q[0],r=s._meta,r.hidden[h]!==e)){(c=r.chains)&&"string"==typeof c[h]&&p("calling chained method with inherited: "+
h,this.declaredClass);do if(r=s._meta,c=s.prototype,r&&(c[h]===e&&c.hasOwnProperty(h)||r.hidden[h]===e))break;while(s=q[++t]);t=s?t:-1}if(s=q[++t])if(c=s.prototype,s._meta&&c.hasOwnProperty(h))d=c[h];else{e=w[h];do if(c=s.prototype,(d=c[h])&&(s._meta?c.hasOwnProperty(h):d!==e))break;while(s=q[++t])}d=s&&d||w[h]}else{if(f.c!==e&&(t=0,(r=q[0]._meta)&&r.ctor!==e)){c=r.chains;for((!c||"manual"!==c.constructor)&&p("calling chained constructor with inherited",this.declaredClass);(s=q[++t])&&!((r=s._meta)&&
r.ctor===e););t=s?t:-1}for(;(s=q[++t])&&!(d=(r=s._meta)?r.ctor:s););d=s&&d}f.c=d;f.p=t;if(d)return!0===b?d:d.apply(this,b||a)}function f(a,b){return"string"==typeof a?this.__inherited(a,b,!0):this.__inherited(a,!0)}function m(a,b,d){var h=this.getInherited(a,b);if(h)return h.apply(this,d||b||a)}function e(a){for(var b=this.constructor._meta.bases,d=0,h=b.length;d<h;++d)if(b[d]===a)return!0;return this instanceof a}function c(a,b){for(var d in b)d!=z&&b.hasOwnProperty(d)&&(a[d]=b[d]);if(n("bug-for-in-skips-shadowed"))for(var h=
l._extraNames,c=h.length;c;)d=h[--c],d!=z&&b.hasOwnProperty(d)&&(a[d]=b[d])}function a(a){t.safeMixin(this.prototype,a);return this}function b(a,b){a instanceof Array||"function"==typeof a||(b=a,a=void 0);b=b||{};a=a||[];return t([this].concat(a),b)}function h(a,b){return function(){var d=arguments,h=d,c=d[0],q,e;e=a.length;var r;if(!(this instanceof d.callee))return v(d);if(b&&(c&&c.preamble||this.preamble)){r=Array(a.length);r[0]=d;for(q=0;;){if(c=d[0])(c=c.preamble)&&(d=c.apply(this,d)||d);c=a[q].prototype;
(c=c.hasOwnProperty("preamble")&&c.preamble)&&(d=c.apply(this,d)||d);if(++q==e)break;r[q]=d}}for(q=e-1;0<=q;--q)c=a[q],(c=(e=c._meta)?e.ctor:c)&&c.apply(this,r?r[q]:d);(c=this.postscript)&&c.apply(this,h)}}function d(a,b){return function(){var d=arguments,h=d,c=d[0];if(!(this instanceof d.callee))return v(d);b&&(c&&(c=c.preamble)&&(h=c.apply(this,h)||h),(c=this.preamble)&&c.apply(this,h));a&&a.apply(this,d);(c=this.postscript)&&c.apply(this,d)}}function q(a){return function(){var b=arguments,d=0,
h,c;if(!(this instanceof b.callee))return v(b);for(;h=a[d];++d)if(h=(c=h._meta)?c.ctor:h){h.apply(this,b);break}(h=this.postscript)&&h.apply(this,b)}}function s(a,b,d){return function(){var h,c,q=0,e=1;d&&(q=b.length-1,e=-1);for(;h=b[q];q+=e)c=h._meta,(h=(c?c.hidden:h.prototype)[a])&&h.apply(this,arguments)}}function r(a){y.prototype=a.prototype;a=new y;y.prototype=null;return a}function v(a){var b=a.callee,d=r(b);b.apply(d,a);return d}function t(m,v,g){"string"!=typeof m&&(g=v,v=m,m="");g=g||{};
var n,y,I,J,F,E,D,T=1,K=v;if("[object Array]"==A.call(v)){T=m;I=[];J=[{cls:0,refs:[]}];E={};for(var N=1,Q=v.length,R=0,O,V,H,S;R<Q;++R){(O=v[R])?"[object Function]"!=A.call(O)&&p("mixin #"+R+" is not a callable constructor.",T):p("mixin #"+R+" is unknown. Did you use dojo.require to pull it in?",T);V=O._meta?O._meta.bases:[O];H=0;for(O=V.length-1;0<=O;--O)S=V[O].prototype,S.hasOwnProperty("declaredClass")||(S.declaredClass="uniqName_"+x++),S=S.declaredClass,E.hasOwnProperty(S)||(E[S]={count:0,refs:[],
cls:V[O]},++N),S=E[S],H&&H!==S&&(S.refs.push(H),++H.count),H=S;++H.count;J[0].refs.push(H)}for(;J.length;){H=J.pop();I.push(H.cls);for(--N;y=H.refs,1==y.length;){H=y[0];if(!H||--H.count){H=0;break}I.push(H.cls);--N}if(H){R=0;for(Q=y.length;R<Q;++R)H=y[R],--H.count||J.push(H)}}N&&p("can't build consistent linearization",T);O=v[0];I[0]=O?O._meta&&O===I[I.length-O._meta.bases.length]?O._meta.bases.length:1:0;E=I;I=E[0];T=E.length-I;v=E[T]}else E=[0],v?"[object Function]"==A.call(v)?(I=v._meta,E=E.concat(I?
I.bases:v)):p("base class is not a callable constructor.",m):null!==v&&p("unknown base class. Did you use dojo.require to pull it in?",m);if(v)for(y=T-1;;--y){n=r(v);if(!y)break;I=E[y];(I._meta?c:u)(n,I.prototype);J=new Function;J.superclass=v;J.prototype=n;v=n.constructor=J}else n={};t.safeMixin(n,g);I=g.constructor;I!==w.constructor&&(I.nom=z,n.constructor=I);for(y=T-1;y;--y)(I=E[y]._meta)&&I.chains&&(D=u(D||{},I.chains));n["-chains-"]&&(D=u(D||{},n["-chains-"]));I=!D||!D.hasOwnProperty(z);E[0]=
J=D&&"manual"===D.constructor?q(E):1==E.length?d(g.constructor,I):h(E,I);J._meta={bases:E,hidden:g,chains:D,parents:K,ctor:g.constructor};J.superclass=v&&v.prototype;J.extend=a;J.createSubclass=b;J.prototype=n;n.constructor=J;n.getInherited=f;n.isInstanceOf=e;n.inherited=C;n.__inherited=k;m&&(n.declaredClass=m,l.setObject(m,J));if(D)for(F in D)n[F]&&("string"==typeof D[F]&&F!=z)&&(I=n[F]=s(F,E,"after"===D[F]),I.nom=F);return J}var u=l.mixin,w=Object.prototype,A=w.toString,y,x=0,z="constructor";y=
n("csp-restrictions")?function(){}:new Function;var C=g.config.isDebug?m:k;g.safeMixin=t.safeMixin=function(a,b){var d,h;for(d in b)if(h=b[d],(h!==w[d]||!(d in w))&&d!=z)"[object Function]"==A.call(h)&&(h.nom=d),a[d]=h;if(n("bug-for-in-skips-shadowed")&&b)for(var c=l._extraNames,q=c.length;q;)if(d=c[--q],h=b[d],(h!==w[d]||!(d in w))&&d!=z)"[object Function]"==A.call(h)&&(h.nom=d),a[d]=h;return a};return g.declare=t})},"dojo/_base/kernel":function(){define(["../has","./config","require","module"],
function(g,n,l,p){var k,f=function(){return this}(),m={},e={},c={config:n,global:f,dijit:m,dojox:e},m={dojo:["dojo",c],dijit:["dijit",m],dojox:["dojox",e]};p=l.map&&l.map[p.id.match(/[^\/]+/)[0]];for(k in p)m[k]?m[k][0]=p[k]:m[k]=[p[k],{}];for(k in m)p=m[k],p[1]._scopeName=p[0],n.noGlobals||(f[p[0]]=p[1]);c.scopeMap=m;c.baseUrl=c.config.baseUrl=l.baseUrl;c.isAsync=l.async;c.locale=n.locale;f="$Rev: 91fa0cb $".match(/[0-9a-f]{7,}/);c.version={major:1,minor:11,patch:2,flag:"",revision:f?f[0]:NaN,toString:function(){var a=
c.version;return a.major+"."+a.minor+"."+a.patch+a.flag+" ("+a.revision+")"}};g("csp-restrictions")||Function("d","d.eval \x3d function(){return d.global.eval ? d.global.eval(arguments[0]) : eval(arguments[0]);}")(c);c.exit=function(){};g("host-webworker");g.add("dojo-debug-messages",!!n.isDebug);c.deprecated=c.experimental=function(){};g("dojo-debug-messages")&&(c.deprecated=function(a,b,h){a="DEPRECATED: "+a;b&&(a+=" "+b);h&&(a+=" -- will be removed in version: "+h);console.warn(a)},c.experimental=
function(a,b){var h="EXPERIMENTAL: "+a+" -- APIs subject to change without notice.";b&&(h+=" "+b);console.warn(h)});if(n.modulePaths){c.deprecated("dojo.modulePaths","use paths configuration");g={};for(k in n.modulePaths)g[k.replace(/\./g,"/")]=n.modulePaths[k];l({paths:g})}c.moduleUrl=function(a,b){c.deprecated("dojo.moduleUrl()","use require.toUrl","2.0");var h=null;a&&(h=l.toUrl(a.replace(/\./g,"/")+(b?"/"+b:"")+"/*.*").replace(/\/\*\.\*/,"")+(b?"":"/"));return h};c._hasResource={};return c})},
"dojo/has":function(){define(["require","module"],function(g,n){var l=g.has||function(){};l.add("dom-addeventlistener",!!document.addEventListener);l.add("touch","ontouchstart"in document||"onpointerdown"in document&&0<navigator.maxTouchPoints||window.navigator.msMaxTouchPoints);l.add("touch-events","ontouchstart"in document);l.add("pointer-events","pointerEnabled"in window.navigator?window.navigator.pointerEnabled:"PointerEvent"in window);l.add("MSPointer",window.navigator.msPointerEnabled);l.add("device-width",
screen.availWidth||innerWidth);var p=document.createElement("form");l.add("dom-attributes-explicit",0==p.attributes.length);l.add("dom-attributes-specified-flag",0<p.attributes.length&&40>p.attributes.length);l.clearElement=function(k){k.innerHTML="";return k};l.normalize=function(k,f){var m=k.match(/[\?:]|[^:\?]*/g),e=0,c=function(a){var b=m[e++];if(":"==b)return 0;if("?"==m[e++]){if(!a&&l(b))return c();c(!0);return c(a)}return b||0};return(k=c())&&f(k)};l.load=function(k,f,m){k?f([k],m):m()};return l})},
"dojo/_base/config":function(){define(["../has","require"],function(g,n){var l={},p=n.rawConfig,k;for(k in p)l[k]=p[k];if(!l.locale&&"undefined"!=typeof navigator&&(p=navigator.languages&&navigator.languages.length?navigator.languages[0]:navigator.language||navigator.userLanguage))l.locale=p.toLowerCase();return l})},"dojo/_base/lang":function(){define(["./kernel","../has","../sniff"],function(g,n){n.add("bug-for-in-skips-shadowed",function(){for(var a in{toString:1})return 0;return 1});var l=n("bug-for-in-skips-shadowed")?
"hasOwnProperty valueOf isPrototypeOf propertyIsEnumerable toLocaleString toString constructor".split(" "):[],p=l.length,k=function(a,b,h){h||(h=a[0]&&g.scopeMap[a[0]]?g.scopeMap[a.shift()][1]:g.global);try{for(var d=0;d<a.length;d++){var c=a[d];if(!(c in h))if(b)h[c]={};else return;h=h[c]}return h}catch(e){}},f=Object.prototype.toString,m=function(a,b,h){return(h||[]).concat(Array.prototype.slice.call(a,b||0))},e=/\{([^\}]+)\}/g,c={_extraNames:l,_mixin:function(a,b,h){var d,c,e,r={};for(d in b)if(c=
b[d],!(d in a)||a[d]!==c&&(!(d in r)||r[d]!==c))a[d]=h?h(c):c;if(n("bug-for-in-skips-shadowed")&&b)for(e=0;e<p;++e)if(d=l[e],c=b[d],!(d in a)||a[d]!==c&&(!(d in r)||r[d]!==c))a[d]=h?h(c):c;return a},mixin:function(a,b){a||(a={});for(var h=1,d=arguments.length;h<d;h++)c._mixin(a,arguments[h]);return a},setObject:function(a,b,h){var d=a.split(".");a=d.pop();return(h=k(d,!0,h))&&a?h[a]=b:void 0},getObject:function(a,b,h){return!a?h:k(a.split("."),b,h)},exists:function(a,b){return void 0!==c.getObject(a,
!1,b)},isString:function(a){return"string"==typeof a||a instanceof String},isArray:Array.isArray||function(a){return"[object Array]"==f.call(a)},isFunction:function(a){return"[object Function]"===f.call(a)},isObject:function(a){return void 0!==a&&(null===a||"object"==typeof a||c.isArray(a)||c.isFunction(a))},isArrayLike:function(a){return!!a&&!c.isString(a)&&!c.isFunction(a)&&!(a.tagName&&"form"==a.tagName.toLowerCase())&&(c.isArray(a)||isFinite(a.length))},isAlien:function(a){return a&&!c.isFunction(a)&&
/\{\s*\[native code\]\s*\}/.test(String(a))},extend:function(a,b){for(var h=1,d=arguments.length;h<d;h++)c._mixin(a.prototype,arguments[h]);return a},_hitchArgs:function(a,b){var h=c._toArray(arguments,2),d=c.isString(b);return function(){var q=c._toArray(arguments),e=d?(a||g.global)[b]:b;return e&&e.apply(a||this,h.concat(q))}},hitch:function(a,b){if(2<arguments.length)return c._hitchArgs.apply(g,arguments);b||(b=a,a=null);if(c.isString(b)){a=a||g.global;if(!a[b])throw['lang.hitch: scope["',b,'"] is null (scope\x3d"',
a,'")'].join("");return function(){return a[b].apply(a,arguments||[])}}return!a?b:function(){return b.apply(a,arguments||[])}},delegate:function(){function a(){}return function(b,h){a.prototype=b;var d=new a;a.prototype=null;h&&c._mixin(d,h);return d}}(),_toArray:n("ie")?function(){function a(a,h,d){d=d||[];for(h=h||0;h<a.length;h++)d.push(a[h]);return d}return function(b){return(b.item?a:m).apply(this,arguments)}}():m,partial:function(a){return c.hitch.apply(g,[null].concat(c._toArray(arguments)))},
clone:function(a){if(!a||"object"!=typeof a||c.isFunction(a))return a;if(a.nodeType&&"cloneNode"in a)return a.cloneNode(!0);if(a instanceof Date)return new Date(a.getTime());if(a instanceof RegExp)return RegExp(a);var b,h,d;if(c.isArray(a)){b=[];h=0;for(d=a.length;h<d;++h)h in a&&(b[h]=c.clone(a[h]))}else b=a.constructor?new a.constructor:{};return c._mixin(b,a,c.clone)},trim:String.prototype.trim?function(a){return a.trim()}:function(a){return a.replace(/^\s\s*/,"").replace(/\s\s*$/,"")},replace:function(a,
b,h){return a.replace(h||e,c.isFunction(b)?b:function(a,h){return c.getObject(h,!1,b)})}};c.mixin(g,c);return c})},"dojo/sniff":function(){define(["./has"],function(g){var n=navigator,l=n.userAgent,n=n.appVersion,p=parseFloat(n);g.add("air",0<=l.indexOf("AdobeAIR"));g.add("wp",parseFloat(l.split("Windows Phone")[1])||void 0);g.add("msapp",parseFloat(l.split("MSAppHost/")[1])||void 0);g.add("khtml",0<=n.indexOf("Konqueror")?p:void 0);g.add("edge",parseFloat(l.split("Edge/")[1])||void 0);g.add("opr",
parseFloat(l.split("OPR/")[1])||void 0);g.add("webkit",!g("wp")&&!g("edge")&&parseFloat(l.split("WebKit/")[1])||void 0);g.add("chrome",!g("edge")&&!g("opr")&&parseFloat(l.split("Chrome/")[1])||void 0);g.add("android",!g("wp")&&parseFloat(l.split("Android ")[1])||void 0);g.add("safari",0<=n.indexOf("Safari")&&!g("wp")&&!g("chrome")&&!g("android")&&!g("edge")&&!g("opr")?parseFloat(n.split("Version/")[1]):void 0);g.add("mac",0<=n.indexOf("Macintosh"));g.add("quirks","BackCompat"==document.compatMode);
if(!g("wp")&&l.match(/(iPhone|iPod|iPad)/)){var k=RegExp.$1.replace(/P/,"p"),f=l.match(/OS ([\d_]+)/)?RegExp.$1:"1",f=parseFloat(f.replace(/_/,".").replace(/_/g,""));g.add(k,f);g.add("ios",f)}g.add("bb",(0<=l.indexOf("BlackBerry")||0<=l.indexOf("BB10"))&&parseFloat(l.split("Version/")[1])||void 0);g.add("trident",parseFloat(n.split("Trident/")[1])||void 0);g.add("svg","undefined"!==typeof SVGAngle);g("webkit")||(0<=l.indexOf("Opera")&&g.add("opera",9.8<=p?parseFloat(l.split("Version/")[1])||p:p),
0<=l.indexOf("Gecko")&&(!g("wp")&&!g("khtml")&&!g("trident")&&!g("edge"))&&g.add("mozilla",p),g("mozilla")&&g.add("ff",parseFloat(l.split("Firefox/")[1]||l.split("Minefield/")[1])||void 0),document.all&&!g("opera")&&(l=parseFloat(n.split("MSIE ")[1])||void 0,(n=document.documentMode)&&(5!=n&&Math.floor(l)!=n)&&(l=n),g.add("ie",l)),g.add("wii","undefined"!=typeof opera&&opera.wiiremote));return g})},"dgrid/Grid":function(){define("dojo/_base/declare dojo/_base/lang dojo/dom-construct dojo/dom-class dojo/on dojo/has ./List ./util/misc dojo/_base/sniff".split(" "),
function(g,n,l,p,k,f,m,e){function c(a,b){b&&b.nodeType&&a.appendChild(b)}g=g(m,{columns:null,hasNeutralSort:!1,cellNavigation:!0,tabableHeader:!0,showHeader:!0,column:function(a){return"object"!==typeof a?this.columns[a]:this.cell(a).column},listType:"grid",cell:function(a,b){if(a.column&&a.element)return a;a.target&&a.target.nodeType&&(a=a.target);var h;if(a.nodeType){do{if(this._rowIdToObject[a.id])break;var d=a.columnId;if(d){b=d;h=a;break}a=a.parentNode}while(a&&a!==this.domNode)}if(!h&&"undefined"!==
typeof b){var c=this.row(a);if(d=c&&c.element)for(var d=d.getElementsByTagName("td"),e=0;e<d.length;e++)if(d[e].columnId===b){h=d[e];break}}if(null!=a)return{row:c||this.row(a),column:b&&this.column(b),element:h}},createRowCells:function(a,b,h,d,c){var s=l.create("table",{className:"dgrid-row-table",role:"presentation"}),r=9>f("ie")?l.create("tbody",null,s):s,m,t,u,k,g,p,n,z,C,B;h=h||this.subRows;t=0;for(u=h.length;t<u;t++){p=h[t];m=l.create("tr",null,r);p.className&&(m.className=p.className);k=0;
for(g=p.length;k<g;k++){n=p[k];z=n.id;C=n.field?" field-"+e.escapeCssIdentifier(n.field,"-"):"";(B="function"===typeof n.className?n.className(d):n.className)&&(C+=" "+B);C=l.create(a,{className:"dgrid-cell"+(z?" dgrid-column-"+e.escapeCssIdentifier(z,"-"):"")+C,role:"th"===a?"columnheader":"gridcell"});C.columnId=z;if(z=n.colSpan)C.colSpan=z;if(z=n.rowSpan)C.rowSpan=z;b(C,n,d,c);m.appendChild(C)}}return s},_createBodyRowCell:function(a,b,h,d){var q=h;b.get?q=b.get(h):"field"in b&&"_item"!==b.field&&
(q=h[b.field]);b.renderCell?c(a,b.renderCell(h,q,a,d)):this._defaultRenderCell.call(b,h,q,a,d)},_createHeaderRowCell:function(a,b){var h=b.headerNode=a,d=b.field;d&&(a.field=d);if(b.renderHeaderCell)c(h,b.renderHeaderCell(h));else if("label"in b||b.field)h.appendChild(document.createTextNode("label"in b?b.label:b.field));!1!==b.sortable&&(d&&"_item"!==d)&&(a.sortable=!0,a.className+=" dgrid-sortable")},left:function(a,b){a.element||(a=this.cell(a));return this.cell(this._move(a,-(b||1),"dgrid-cell"))},
right:function(a,b){a.element||(a=this.cell(a));return this.cell(this._move(a,b||1,"dgrid-cell"))},_defaultRenderCell:function(a,b,h){if(this.formatter){var d=this.formatter,c=this.grid.formatterScope;h.innerHTML="string"===typeof d&&c?c[d](b,a):this.formatter(b,a)}else null!=b&&h.appendChild(document.createTextNode(b))},renderRow:function(a,b){var h=this.createRowCells("td",n.hitch(this,"_createBodyRowCell"),b&&b.subRows,a,b),d=l.create("div",{role:"row"});d.appendChild(h);return d},renderHeader:function(){var a=
this,b=this.headerNode;b.setAttribute("role","row");l.empty(b);var h=this.createRowCells("th",n.hitch(this,"_createHeaderRowCell"),this.subRows&&this.subRows.headerRows);this._rowIdToObject[h.id=this.id+"-header"]=this.columns;b.appendChild(h);this._sortListener&&this._sortListener.remove();this._sortListener=k(h,"click,keydown",function(d){if("click"===d.type||32===d.keyCode||!f("opera")&&13===d.keyCode){var h=d.target,c,e;do if(h.sortable){c=h.field||h.columnId;e=a.sort[0];c=!a.hasNeutralSort||
!e||e.property!==c||!e.descending?[{property:c,descending:e&&e.property===c&&!e.descending}]:[];e={bubbles:!0,cancelable:!0,grid:a,parentType:d.type,sort:c};k.emit(d.target,"dgrid-sort",e)&&(a._sortNode=h,a.set("sort",c));break}while((h=h.parentNode)&&h!==b)}})},resize:function(){var a=this.headerNode.firstChild,b=this.contentNode,h;this.inherited(arguments);b.style.width="";if(b&&a&&(h=a.offsetWidth)>b.offsetWidth)b.style.width=h+"px"},destroy:function(){this._destroyColumns();this._sortListener&&
this._sortListener.remove();this.inherited(arguments)},_setSort:function(){this.inherited(arguments);this.updateSortArrow(this.sort)},_findSortArrowParent:function(a){var b=this.columns,h;for(h in b){var d=b[h];if(d.field===a)return d.headerNode}},updateSortArrow:function(a,b){this._lastSortedArrow&&(p.remove(this._lastSortedArrow.parentNode,"dgrid-sort-up dgrid-sort-down"),l.destroy(this._lastSortedArrow),delete this._lastSortedArrow);b&&(this.sort=a);if(a[0]){var h=a[0].property,d=a[0].descending,
h=this._sortNode||this._findSortArrowParent(h);delete this._sortNode;h&&(h=h.contents||h,this._lastSortedArrow=l.create("div",{className:"dgrid-sort-arrow ui-icon",innerHTML:"\x26nbsp;",role:"presentation"},h,"first"),p.add(h,"dgrid-sort-"+(d?"down":"up")),this.resize())}},styleColumn:function(a,b){return this.addCssRule("#"+e.escapeCssIdentifier(this.domNode.id)+" .dgrid-column-"+e.escapeCssIdentifier(a,"-"),b)},_configColumns:function(a,b){var h=[],d=b instanceof Array;e.each(b,function(c,e){"string"===
typeof c&&(b[e]=c={label:c});!d&&!c.field&&(c.field=e);e=c.id=c.id||(isNaN(e)?e:a+e);this._configColumn&&(this._configColumn(c,b,a),e=c.id);d&&(this.columns[e]=c);c.grid=this;h.push(c)},this);return d?b:h},_destroyColumns:function(){this.cleanup()},configStructure:function(){var a=this.subRows,b=this._columns=this.columns;this.columns=!b||b instanceof Array?{}:b;if(a)for(b=0;b<a.length;b++)a[b]=this._configColumns(b+"-",a[b]);else this.subRows=[this._configColumns("",b)]},_getColumns:function(){return this._columns||
this.columns},_setColumns:function(a){this._destroyColumns();this.subRows=null;this.columns=a;this._updateColumns()},_setSubRows:function(a){this._destroyColumns();this.subRows=a;this._updateColumns()},_updateColumns:function(){this.configStructure();this.renderHeader();this.refresh();this._lastCollection&&this.renderArray(this._lastCollection);this._started&&(this.sort.length?(this._lastSortedArrow=null,this.updateSortArrow(this.sort)):this.resize())}});g.appendIfNode=c;return g})},"dojo/dom-construct":function(){define("exports ./_base/kernel ./sniff ./_base/window ./dom ./dom-attr".split(" "),
function(g,n,l,p,k,f){function m(a,b){var d=b.parentNode;d&&d.insertBefore(a,b)}function e(a){if("innerHTML"in a)try{a.innerHTML="";return}catch(b){}for(var d;d=a.lastChild;)a.removeChild(d)}var c={option:["select"],tbody:["table"],thead:["table"],tfoot:["table"],tr:["table","tbody"],td:["table","tbody","tr"],th:["table","thead","tr"],legend:["fieldset"],caption:["table"],colgroup:["table"],col:["table","colgroup"],li:["ul"]},a=/<\s*([\w\:]+)/,b={},h=0,d="__"+n._scopeName+"ToDomId",q;for(q in c)c.hasOwnProperty(q)&&
(n=c[q],n.pre="option"==q?'\x3cselect multiple\x3d"multiple"\x3e':"\x3c"+n.join("\x3e\x3c")+"\x3e",n.post="\x3c/"+n.reverse().join("\x3e\x3c/")+"\x3e");var s;8>=l("ie")&&(s=function(a){a.__dojo_html5_tested="yes";var b=r("div",{innerHTML:"\x3cnav\x3ea\x3c/nav\x3e",style:{visibility:"hidden"}},a.body);1!==b.childNodes.length&&"abbr article aside audio canvas details figcaption figure footer header hgroup mark meter nav output progress section summary time video".replace(/\b\w+\b/g,function(b){a.createElement(b)});
v(b)});g.toDom=function(e,q){q=q||p.doc;var r=q[d];r||(q[d]=r=++h+"",b[r]=q.createElement("div"));8>=l("ie")&&!q.__dojo_html5_tested&&q.body&&s(q);e+="";var f=e.match(a),m=f?f[1].toLowerCase():"",r=b[r];if(f&&c[m]){f=c[m];r.innerHTML=f.pre+e+f.post;for(f=f.length;f;--f)r=r.firstChild}else r.innerHTML=e;if(1==r.childNodes.length)return r.removeChild(r.firstChild);for(m=q.createDocumentFragment();f=r.firstChild;)m.appendChild(f);return m};g.place=function(a,b,d){b=k.byId(b);"string"==typeof a&&(a=/^\s*</.test(a)?
g.toDom(a,b.ownerDocument):k.byId(a));if("number"==typeof d){var h=b.childNodes;!h.length||h.length<=d?b.appendChild(a):m(a,h[0>d?0:d])}else switch(d){case "before":m(a,b);break;case "after":d=a;(h=b.parentNode)&&(h.lastChild==b?h.appendChild(d):h.insertBefore(d,b.nextSibling));break;case "replace":b.parentNode.replaceChild(a,b);break;case "only":g.empty(b);b.appendChild(a);break;case "first":if(b.firstChild){m(a,b.firstChild);break}default:b.appendChild(a)}return a};var r=g.create=function(a,b,d,
h){var c=p.doc;d&&(d=k.byId(d),c=d.ownerDocument);"string"==typeof a&&(a=c.createElement(a));b&&f.set(a,b);d&&g.place(a,d,h);return a};g.empty=function(a){e(k.byId(a))};var v=g.destroy=function(a){if(a=k.byId(a)){var b=a;a=a.parentNode;b.firstChild&&e(b);a&&(l("ie")&&a.canHaveChildren&&"removeNode"in b?b.removeNode(!1):a.removeChild(b))}}})},"dojo/_base/window":function(){define(["./kernel","./lang","../sniff"],function(g,n,l){var p={global:g.global,doc:g.global.document||null,body:function(k){k=
k||g.doc;return k.body||k.getElementsByTagName("body")[0]},setContext:function(k,f){g.global=p.global=k;g.doc=p.doc=f},withGlobal:function(k,f,m,e){var c=g.global;try{return g.global=p.global=k,p.withDoc.call(null,k.document,f,m,e)}finally{g.global=p.global=c}},withDoc:function(k,f,m,e){var c=p.doc,a=l("quirks"),b=l("ie"),h,d,q;try{g.doc=p.doc=k;g.isQuirks=l.add("quirks","BackCompat"==g.doc.compatMode,!0,!0);if(l("ie")&&(q=k.parentWindow)&&q.navigator)h=parseFloat(q.navigator.appVersion.split("MSIE ")[1])||
void 0,(d=k.documentMode)&&(5!=d&&Math.floor(h)!=d)&&(h=d),g.isIE=l.add("ie",h,!0,!0);m&&"string"==typeof f&&(f=m[f]);return f.apply(m,e||[])}finally{g.doc=p.doc=c,g.isQuirks=l.add("quirks",a,!0,!0),g.isIE=l.add("ie",b,!0,!0)}}};n.mixin(g,p);return p})},"dojo/dom":function(){define(["./sniff","./_base/window","./_base/kernel"],function(g,n,l){if(7>=g("ie"))try{document.execCommand("BackgroundImageCache",!1,!0)}catch(p){}var k={};g("ie")?k.byId=function(f,e){if("string"!=typeof f)return f;var c=e||
n.doc,a=f&&c.getElementById(f);if(a&&(a.attributes.id.value==f||a.id==f))return a;c=c.all[f];if(!c||c.nodeName)c=[c];for(var b=0;a=c[b++];)if(a.attributes&&a.attributes.id&&a.attributes.id.value==f||a.id==f)return a}:k.byId=function(f,e){return("string"==typeof f?(e||n.doc).getElementById(f):f)||null};l=l.global.document||null;g.add("dom-contains",!(!l||!l.contains));k.isDescendant=g("dom-contains")?function(f,e){return!(!(e=k.byId(e))||!e.contains(k.byId(f)))}:function(f,e){try{f=k.byId(f);for(e=
k.byId(e);f;){if(f==e)return!0;f=f.parentNode}}catch(c){}return!1};g.add("css-user-select",function(f,e,c){if(!c)return!1;f=c.style;e=["Khtml","O","Moz","Webkit"];c=e.length;var a="userSelect";do if("undefined"!==typeof f[a])return a;while(c--&&(a=e[c]+"UserSelect"));return!1});var f=g("css-user-select");k.setSelectable=f?function(m,e){k.byId(m).style[f]=e?"":"none"}:function(f,e){f=k.byId(f);var c=f.getElementsByTagName("*"),a=c.length;if(e)for(f.removeAttribute("unselectable");a--;)c[a].removeAttribute("unselectable");
else for(f.setAttribute("unselectable","on");a--;)c[a].setAttribute("unselectable","on")};return k})},"dojo/dom-attr":function(){define("exports ./sniff ./_base/lang ./dom ./dom-style ./dom-prop".split(" "),function(g,n,l,p,k,f){function m(a,b){var h=a.getAttributeNode&&a.getAttributeNode(b);return!!h&&h.specified}var e={innerHTML:1,textContent:1,className:1,htmlFor:n("ie"),value:1},c={classname:"class",htmlfor:"for",tabindex:"tabIndex",readonly:"readOnly"};g.has=function(a,b){var h=b.toLowerCase();
return e[f.names[h]||b]||m(p.byId(a),c[h]||b)};g.get=function(a,b){a=p.byId(a);var h=b.toLowerCase(),d=f.names[h]||b,q=a[d];if(e[d]&&"undefined"!=typeof q)return q;if("textContent"==d)return f.get(a,d);if("href"!=d&&("boolean"==typeof q||l.isFunction(q)))return q;h=c[h]||b;return m(a,h)?a.getAttribute(h):null};g.set=function(a,b,h){a=p.byId(a);if(2==arguments.length){for(var d in b)g.set(a,d,b[d]);return a}d=b.toLowerCase();var q=f.names[d]||b,s=e[q];if("style"==q&&"string"!=typeof h)return k.set(a,
h),a;if(s||"boolean"==typeof h||l.isFunction(h))return f.set(a,b,h);a.setAttribute(c[d]||b,h);return a};g.remove=function(a,b){p.byId(a).removeAttribute(c[b.toLowerCase()]||b)};g.getNodeProp=function(a,b){a=p.byId(a);var h=b.toLowerCase(),d=f.names[h]||b;if(d in a&&"href"!=d)return a[d];h=c[h]||b;return m(a,h)?a.getAttribute(h):null}})},"dojo/dom-style":function(){define(["./sniff","./dom"],function(g,n){function l(d,h,c){h=h.toLowerCase();if("auto"==c){if("height"==h)return d.offsetHeight;if("width"==
h)return d.offsetWidth}if("fontweight"==h)switch(c){case 700:return"bold";default:return"normal"}h in a||(a[h]=b.test(h));return a[h]?f(d,c):c}var p,k={};p=g("webkit")?function(a){var b;if(1==a.nodeType){var h=a.ownerDocument.defaultView;b=h.getComputedStyle(a,null);!b&&a.style&&(a.style.display="",b=h.getComputedStyle(a,null))}return b||{}}:g("ie")&&(9>g("ie")||g("quirks"))?function(a){return 1==a.nodeType&&a.currentStyle?a.currentStyle:{}}:function(a){return 1==a.nodeType?a.ownerDocument.defaultView.getComputedStyle(a,
null):{}};k.getComputedStyle=p;var f;f=g("ie")?function(a,b){if(!b)return 0;if("medium"==b)return 4;if(b.slice&&"px"==b.slice(-2))return parseFloat(b);var h=a.style,c=a.runtimeStyle,e=h.left,f=c.left;c.left=a.currentStyle.left;try{h.left=b,b=h.pixelLeft}catch(m){b=0}h.left=e;c.left=f;return b}:function(a,b){return parseFloat(b)||0};k.toPixelValue=f;var m=function(a,b){try{return a.filters.item("DXImageTransform.Microsoft.Alpha")}catch(h){return b?{}:null}},e=9>g("ie")||10>g("ie")&&g("quirks")?function(a){try{return m(a).Opacity/
100}catch(b){return 1}}:function(a){return p(a).opacity},c=9>g("ie")||10>g("ie")&&g("quirks")?function(a,b){""===b&&(b=1);var h=100*b;1===b?(a.style.zoom="",m(a)&&(a.style.filter=a.style.filter.replace(/\s*progid:DXImageTransform.Microsoft.Alpha\([^\)]+?\)/i,""))):(a.style.zoom=1,m(a)?m(a,1).Opacity=h:a.style.filter+=" progid:DXImageTransform.Microsoft.Alpha(Opacity\x3d"+h+")",m(a,1).Enabled=!0);if("tr"==a.tagName.toLowerCase())for(h=a.firstChild;h;h=h.nextSibling)"td"==h.tagName.toLowerCase()&&c(h,
b);return b}:function(a,b){return a.style.opacity=b},a={left:!0,top:!0},b=/margin|padding|width|height|max|min|offset/,h={cssFloat:1,styleFloat:1,"float":1};k.get=function(a,b){var c=n.byId(a),r=arguments.length;if(2==r&&"opacity"==b)return e(c);b=h[b]?"cssFloat"in c.style?"cssFloat":"styleFloat":b;var f=k.getComputedStyle(c);return 1==r?f:l(c,b,f[b]||c.style[b])};k.set=function(a,b,e){var r=n.byId(a),f=arguments.length,t="opacity"==b;b=h[b]?"cssFloat"in r.style?"cssFloat":"styleFloat":b;if(3==f)return t?
c(r,e):r.style[b]=e;for(var m in b)k.set(a,m,b[m]);return k.getComputedStyle(r)};return k})},"dojo/dom-prop":function(){define("exports ./_base/kernel ./sniff ./_base/lang ./dom ./dom-style ./dom-construct ./_base/connect".split(" "),function(g,n,l,p,k,f,m,e){function c(a){var b="";a=a.childNodes;for(var h=0,e;e=a[h];h++)8!=e.nodeType&&(b=1==e.nodeType?b+c(e):b+e.nodeValue);return b}var a={},b=1,h=n._scopeName+"attrid";l.add("dom-textContent",function(a,b,h){return"textContent"in h});g.names={"class":"className",
"for":"htmlFor",tabindex:"tabIndex",readonly:"readOnly",colspan:"colSpan",frameborder:"frameBorder",rowspan:"rowSpan",textcontent:"textContent",valuetype:"valueType"};g.get=function(a,b){a=k.byId(a);var h=b.toLowerCase(),h=g.names[h]||b;return"textContent"==h&&!l("dom-textContent")?c(a):a[h]};g.set=function(d,c,s){d=k.byId(d);if(2==arguments.length&&"string"!=typeof c){for(var r in c)g.set(d,r,c[r]);return d}r=c.toLowerCase();r=g.names[r]||c;if("style"==r&&"string"!=typeof s)return f.set(d,s),d;if("innerHTML"==
r)return l("ie")&&d.tagName.toLowerCase()in{col:1,colgroup:1,table:1,tbody:1,tfoot:1,thead:1,tr:1,title:1}?(m.empty(d),d.appendChild(m.toDom(s,d.ownerDocument))):d[r]=s,d;if("textContent"==r&&!l("dom-textContent"))return m.empty(d),d.appendChild(d.ownerDocument.createTextNode(s)),d;if(p.isFunction(s)){var v=d[h];v||(v=b++,d[h]=v);a[v]||(a[v]={});var t=a[v][r];if(t)e.disconnect(t);else try{delete d[r]}catch(u){}s?a[v][r]=e.connect(d,r,s):d[r]=null;return d}d[r]=s;return d}})},"dojo/_base/connect":function(){define("./kernel ../on ../topic ../aspect ./event ../mouse ./sniff ./lang ../keys".split(" "),
function(g,n,l,p,k,f,m,e){function c(a,b,d,h,c){h=e.hitch(d,h);if(!a||!a.addEventListener&&!a.attachEvent)return p.after(a||g.global,b,h,!0);"string"==typeof b&&"on"==b.substring(0,2)&&(b=b.substring(2));a||(a=g.global);if(!c)switch(b){case "keypress":b=q;break;case "mouseenter":b=f.enter;break;case "mouseleave":b=f.leave}return n(a,b,h,c)}function a(a){a.keyChar=a.charCode?String.fromCharCode(a.charCode):"";a.charOrCode=a.keyChar||a.keyCode}m.add("events-keypress-typed",function(){var a={charCode:0};
try{a=document.createEvent("KeyboardEvent"),(a.initKeyboardEvent||a.initKeyEvent).call(a,"keypress",!0,!0,null,!1,!1,!1,!1,9,3)}catch(b){}return 0==a.charCode&&!m("opera")});var b={106:42,111:47,186:59,187:43,188:44,189:45,190:46,191:47,192:96,219:91,220:92,221:93,222:39,229:113},h=m("mac")?"metaKey":"ctrlKey",d=function(b,d){var h=e.mixin({},b,d);a(h);h.preventDefault=function(){b.preventDefault()};h.stopPropagation=function(){b.stopPropagation()};return h},q;q=m("events-keypress-typed")?function(a,
h){var c=n(a,"keydown",function(a){var c=a.keyCode,e=13!=c&&32!=c&&(27!=c||!m("ie"))&&(48>c||90<c)&&(96>c||111<c)&&(186>c||192<c)&&(219>c||222<c)&&229!=c;if(e||a.ctrlKey){e=e?0:c;if(a.ctrlKey){if(3==c||13==c)return h.call(a.currentTarget,a);e=95<e&&106>e?e-48:!a.shiftKey&&65<=e&&90>=e?e+32:b[e]||e}c=d(a,{type:"keypress",faux:!0,charCode:e});h.call(a.currentTarget,c);if(m("ie"))try{a.keyCode=c.keyCode}catch(q){}}}),e=n(a,"keypress",function(a){var b=a.charCode;a=d(a,{charCode:32<=b?b:0,faux:!0});return h.call(this,
a)});return{remove:function(){c.remove();e.remove()}}}:m("opera")?function(a,b){return n(a,"keypress",function(a){var h=a.which;3==h&&(h=99);h=32>h&&!a.shiftKey?0:h;a.ctrlKey&&(!a.shiftKey&&65<=h&&90>=h)&&(h+=32);return b.call(this,d(a,{charCode:h}))})}:function(b,d){return n(b,"keypress",function(b){a(b);return d.call(this,b)})};var s={_keypress:q,connect:function(a,b,d,h,e){var q=arguments,f=[],s=0;f.push("string"==typeof q[0]?null:q[s++],q[s++]);var m=q[s+1];f.push("string"==typeof m||"function"==
typeof m?q[s++]:null,q[s++]);for(m=q.length;s<m;s++)f.push(q[s]);return c.apply(this,f)},disconnect:function(a){a&&a.remove()},subscribe:function(a,b,d){return l.subscribe(a,e.hitch(b,d))},publish:function(a,b){return l.publish.apply(l,[a].concat(b))},connectPublisher:function(a,b,d){var h=function(){s.publish(a,arguments)};return d?s.connect(b,d,h):s.connect(b,h)},isCopyKey:function(a){return a[h]}};s.unsubscribe=s.disconnect;e.mixin(g,s);return s})},"dojo/on":function(){define(["./has!dom-addeventlistener?:./aspect",
"./_base/kernel","./sniff"],function(g,n,l){function p(a,b,d,f,r){if(f=b.match(/(.*):(.*)/))return b=f[2],f=f[1],e.selector(f,b).call(r,a,d);l("touch")&&(c.test(b)&&(d=x(d)),!l("event-orientationchange")&&"orientationchange"==b&&(b="resize",a=window,d=x(d)));q&&(d=q(d));if(a.addEventListener){var s=b in h,m=s?h[b]:b;a.addEventListener(m,d,s);return{remove:function(){a.removeEventListener(m,d,s)}}}if(t&&a.attachEvent)return t(a,"on"+b,d);throw Error("Target must be an event emitter");}function k(){this.cancelable=
!1;this.defaultPrevented=!0}function f(){this.bubbles=!1}var m=window.ScriptEngineMajorVersion;l.add("jscript",m&&m()+ScriptEngineMinorVersion()/10);l.add("event-orientationchange",l("touch")&&!l("android"));l.add("event-stopimmediatepropagation",window.Event&&!!window.Event.prototype&&!!window.Event.prototype.stopImmediatePropagation);l.add("event-focusin",function(a,b,d){return"onfocusin"in d});l("touch")&&l.add("touch-can-modify-event-delegate",function(){var a=function(){};a.prototype=document.createEvent("MouseEvents");
try{var b=new a;b.target=null;return null===b.target}catch(d){return!1}});var e=function(a,b,d,h){return"function"==typeof a.on&&"function"!=typeof b&&!a.nodeType?a.on(b,d):e.parse(a,b,d,p,h,this)};e.pausable=function(a,b,d,h){var c;a=e(a,b,function(){if(!c)return d.apply(this,arguments)},h);a.pause=function(){c=!0};a.resume=function(){c=!1};return a};e.once=function(a,b,d,h){var c=e(a,b,function(){c.remove();return d.apply(this,arguments)});return c};e.parse=function(a,b,d,h,c,q){var f;if(b.call)return b.call(q,
a,d);b instanceof Array?f=b:-1<b.indexOf(",")&&(f=b.split(/\s*,\s*/));if(f){var r=[];b=0;for(var s;s=f[b++];)r.push(e.parse(a,s,d,h,c,q));r.remove=function(){for(var a=0;a<r.length;a++)r[a].remove()};return r}return h(a,b,d,c,q)};var c=/^touch/;e.matches=function(a,b,d,h,c){c=c&&"function"==typeof c.matches?c:n.query;h=!1!==h;1!=a.nodeType&&(a=a.parentNode);for(;!c.matches(a,b,d);)if(a==d||!1===h||!(a=a.parentNode)||1!=a.nodeType)return!1;return a};e.selector=function(a,b,d){return function(h,c){function q(b){return e.matches(b,
a,h,d,f)}var f="function"==typeof a?{matches:a}:this,r=b.bubble;return r?e(h,r(q),c):e(h,b,function(a){var b=q(a.target);if(b)return a.selectorTarget=b,c.call(b,a)})}};var a=[].slice,b=e.emit=function(b,d,h){var c=a.call(arguments,2),e="on"+d;if("parentNode"in b){var q=c[0]={},r;for(r in h)q[r]=h[r];q.preventDefault=k;q.stopPropagation=f;q.target=b;q.type=d;h=q}do b[e]&&b[e].apply(b,c);while(h&&h.bubbles&&(b=b.parentNode));return h&&h.cancelable&&h},h=l("event-focusin")?{}:{focusin:"focus",focusout:"blur"};
if(!l("event-stopimmediatepropagation"))var d=function(){this.modified=this.immediatelyStopped=!0},q=function(a){return function(b){if(!b.immediatelyStopped)return b.stopImmediatePropagation=d,a.apply(this,arguments)}};if(l("dom-addeventlistener"))e.emit=function(a,d,h){if(a.dispatchEvent&&document.createEvent){var c=(a.ownerDocument||document).createEvent("HTMLEvents");c.initEvent(d,!!h.bubbles,!!h.cancelable);for(var q in h)q in c||(c[q]=h[q]);return a.dispatchEvent(c)&&c}return b.apply(e,arguments)};
else{e._fixEvent=function(a,b){a||(a=(b&&(b.ownerDocument||b.document||b).parentWindow||window).event);if(!a)return a;try{s&&(a.type==s.type&&a.srcElement==s.target)&&(a=s)}catch(d){}if(!a.target)switch(a.target=a.srcElement,a.currentTarget=b||a.srcElement,"mouseover"==a.type&&(a.relatedTarget=a.fromElement),"mouseout"==a.type&&(a.relatedTarget=a.toElement),a.stopPropagation||(a.stopPropagation=u,a.preventDefault=w),a.type){case "keypress":var h="charCode"in a?a.charCode:a.keyCode;10==h?(h=0,a.keyCode=
13):13==h||27==h?h=0:3==h&&(h=99);a.charCode=h;h=a;h.keyChar=h.charCode?String.fromCharCode(h.charCode):"";h.charOrCode=h.keyChar||h.keyCode}return a};var s,r=function(a){this.handle=a};r.prototype.remove=function(){delete _dojoIEListeners_[this.handle]};var v=function(a){return function(b){b=e._fixEvent(b,this);var d=a.call(this,b);b.modified&&(s||setTimeout(function(){s=null}),s=b);return d}},t=function(a,b,d){d=v(d);if(((a.ownerDocument?a.ownerDocument.parentWindow:a.parentWindow||a.window||window)!=
top||5.8>l("jscript"))&&!l("config-_allow_leaks")){"undefined"==typeof _dojoIEListeners_&&(_dojoIEListeners_=[]);var h=a[b];if(!h||!h.listeners){var c=h,h=Function("event","var callee \x3d arguments.callee; for(var i \x3d 0; i\x3ccallee.listeners.length; i++){var listener \x3d _dojoIEListeners_[callee.listeners[i]]; if(listener){listener.call(this,event);}}");h.listeners=[];a[b]=h;h.global=this;c&&h.listeners.push(_dojoIEListeners_.push(c)-1)}h.listeners.push(a=h.global._dojoIEListeners_.push(d)-
1);return new r(a)}return g.after(a,b,d,!0)},u=function(){this.cancelBubble=!0},w=e._preventDefault=function(){this.bubbledKeyCode=this.keyCode;if(this.ctrlKey)try{this.keyCode=0}catch(a){}this.defaultPrevented=!0;this.returnValue=!1;this.modified=!0}}if(l("touch"))var A=function(){},y=window.orientation,x=function(a){return function(b){var d=b.corrected;if(!d){var h=b.type;try{delete b.type}catch(c){}if(b.type){if(l("touch-can-modify-event-delegate"))A.prototype=b,d=new A;else{var d={},e;for(e in b)d[e]=
b[e]}d.preventDefault=function(){b.preventDefault()};d.stopPropagation=function(){b.stopPropagation()}}else d=b,d.type=h;b.corrected=d;if("resize"==h){if(y==window.orientation)return null;y=window.orientation;d.type="orientationchange";return a.call(this,d)}"rotation"in d||(d.rotation=0,d.scale=1);var h=d.changedTouches[0],q;for(q in h)delete d[q],d[q]=h[q]}return a.call(this,d)}};return e})},"dojo/topic":function(){define(["./Evented"],function(g){var n=new g;return{publish:function(g,p){return n.emit.apply(n,
arguments)},subscribe:function(g,p){return n.on.apply(n,arguments)}}})},"dojo/Evented":function(){define(["./aspect","./on"],function(g,n){function l(){}var p=g.after;l.prototype={on:function(k,f){return n.parse(this,k,f,function(m,e){return p(m,"on"+e,f,!0)})},emit:function(k,f){var m=[this];m.push.apply(m,arguments);return n.emit.apply(n,m)}};return l})},"dojo/aspect":function(){define([],function(){function g(f,e,c,a){var b=f[e],h="around"==e,d;if(h){var q=c(function(){return b.advice(this,arguments)});
d={remove:function(){q&&(q=f=c=null)},advice:function(a,d){return q?q.apply(a,d):b.advice(a,d)}}}else d={remove:function(){if(d.advice){var a=d.previous,b=d.next;!b&&!a?delete f[e]:(a?a.next=b:f[e]=b,b&&(b.previous=a));f=c=d.advice=null}},id:f.nextId++,advice:c,receiveArguments:a};if(b&&!h)if("after"==e){for(;b.next&&(b=b.next););b.next=d;d.previous=b}else"before"==e&&(f[e]=d,d.next=b,b.previous=d);else f[e]=d;return d}function n(f){return function(e,c,a,b){var h=e[c],d;if(!h||h.target!=e)e[c]=d=
function(){for(var a=d.nextId,b=arguments,h=d.before;h;)h.advice&&(b=h.advice.apply(this,b)||b),h=h.next;if(d.around)var c=d.around.advice(this,b);for(h=d.after;h&&h.id<a;){if(h.advice)if(h.receiveArguments)var e=h.advice.apply(this,b),c=e===l?c:e;else c=h.advice.call(this,c,b);h=h.next}return c},h&&(d.around={advice:function(a,b){return h.apply(a,b)}}),d.target=e,d.nextId=d.nextId||0;e=g(d||h,f,a,b);a=null;return e}}var l,p=n("after"),k=n("before"),f=n("around");return{before:k,around:f,after:p}})},
"dojo/_base/event":function(){define(["./kernel","../on","../has","../dom-geometry"],function(g,n,l,p){if(n._fixEvent){var k=n._fixEvent;n._fixEvent=function(f,e){(f=k(f,e))&&p.normalizeEvent(f);return f}}var f={fix:function(f,e){return n._fixEvent?n._fixEvent(f,e):f},stop:function(f){l("dom-addeventlistener")||f&&f.preventDefault?(f.preventDefault(),f.stopPropagation()):(f=f||window.event,f.cancelBubble=!0,n._preventDefault.call(f))}};g.fixEvent=f.fix;g.stopEvent=f.stop;return f})},"dojo/dom-geometry":function(){define(["./sniff",
"./_base/window","./dom","./dom-style"],function(g,n,l,p){function k(a,b,h,d,c,e){e=e||"px";a=a.style;isNaN(b)||(a.left=b+e);isNaN(h)||(a.top=h+e);0<=d&&(a.width=d+e);0<=c&&(a.height=c+e)}function f(a){return"button"==a.tagName.toLowerCase()||"input"==a.tagName.toLowerCase()&&"button"==(a.getAttribute("type")||"").toLowerCase()}function m(a){return"border-box"==e.boxModel||"table"==a.tagName.toLowerCase()||f(a)}var e={boxModel:"content-box"};g("ie")&&(e.boxModel="BackCompat"==document.compatMode?
"border-box":"content-box");e.getPadExtents=function(a,b){a=l.byId(a);var h=b||p.getComputedStyle(a),d=p.toPixelValue,c=d(a,h.paddingLeft),e=d(a,h.paddingTop),f=d(a,h.paddingRight),h=d(a,h.paddingBottom);return{l:c,t:e,r:f,b:h,w:c+f,h:e+h}};e.getBorderExtents=function(a,b){a=l.byId(a);var h=p.toPixelValue,d=b||p.getComputedStyle(a),c="none"!=d.borderLeftStyle?h(a,d.borderLeftWidth):0,e="none"!=d.borderTopStyle?h(a,d.borderTopWidth):0,f="none"!=d.borderRightStyle?h(a,d.borderRightWidth):0,h="none"!=
d.borderBottomStyle?h(a,d.borderBottomWidth):0;return{l:c,t:e,r:f,b:h,w:c+f,h:e+h}};e.getPadBorderExtents=function(a,b){a=l.byId(a);var h=b||p.getComputedStyle(a),d=e.getPadExtents(a,h),h=e.getBorderExtents(a,h);return{l:d.l+h.l,t:d.t+h.t,r:d.r+h.r,b:d.b+h.b,w:d.w+h.w,h:d.h+h.h}};e.getMarginExtents=function(a,b){a=l.byId(a);var h=b||p.getComputedStyle(a),d=p.toPixelValue,c=d(a,h.marginLeft),e=d(a,h.marginTop),f=d(a,h.marginRight),h=d(a,h.marginBottom);return{l:c,t:e,r:f,b:h,w:c+f,h:e+h}};e.getMarginBox=
function(a,b){a=l.byId(a);var h=b||p.getComputedStyle(a),d=e.getMarginExtents(a,h),c=a.offsetLeft-d.l,f=a.offsetTop-d.t,r=a.parentNode,k=p.toPixelValue;if(g("mozilla")){var t=parseFloat(h.left),h=parseFloat(h.top);!isNaN(t)&&!isNaN(h)?(c=t,f=h):r&&r.style&&(r=p.getComputedStyle(r),"visible"!=r.overflow&&(c+="none"!=r.borderLeftStyle?k(a,r.borderLeftWidth):0,f+="none"!=r.borderTopStyle?k(a,r.borderTopWidth):0))}else if((g("opera")||8==g("ie")&&!g("quirks"))&&r)r=p.getComputedStyle(r),c-="none"!=r.borderLeftStyle?
k(a,r.borderLeftWidth):0,f-="none"!=r.borderTopStyle?k(a,r.borderTopWidth):0;return{l:c,t:f,w:a.offsetWidth+d.w,h:a.offsetHeight+d.h}};e.getContentBox=function(a,b){a=l.byId(a);var h=b||p.getComputedStyle(a),d=a.clientWidth,c=e.getPadExtents(a,h),f=e.getBorderExtents(a,h);d?(h=a.clientHeight,f.w=f.h=0):(d=a.offsetWidth,h=a.offsetHeight);g("opera")&&(c.l+=f.l,c.t+=f.t);return{l:c.l,t:c.t,w:d-c.w-f.w,h:h-c.h-f.h}};e.setContentSize=function(a,b,h){a=l.byId(a);var d=b.w;b=b.h;m(a)&&(h=e.getPadBorderExtents(a,
h),0<=d&&(d+=h.w),0<=b&&(b+=h.h));k(a,NaN,NaN,d,b)};var c={l:0,t:0,w:0,h:0};e.setMarginBox=function(a,b,h){a=l.byId(a);var d=h||p.getComputedStyle(a);h=b.w;var q=b.h,s=m(a)?c:e.getPadBorderExtents(a,d),d=e.getMarginExtents(a,d);if(g("webkit")&&f(a)){var r=a.style;0<=h&&!r.width&&(r.width="4px");0<=q&&!r.height&&(r.height="4px")}0<=h&&(h=Math.max(h-s.w-d.w,0));0<=q&&(q=Math.max(q-s.h-d.h,0));k(a,b.l,b.t,h,q)};e.isBodyLtr=function(a){a=a||n.doc;return"ltr"==(n.body(a).dir||a.documentElement.dir||"ltr").toLowerCase()};
e.docScroll=function(a){a=a||n.doc;var b=n.doc.parentWindow||n.doc.defaultView;return"pageXOffset"in b?{x:b.pageXOffset,y:b.pageYOffset}:(b=g("quirks")?n.body(a):a.documentElement)&&{x:e.fixIeBiDiScrollLeft(b.scrollLeft||0,a),y:b.scrollTop||0}};e.getIeDocumentElementOffset=function(a){return{x:0,y:0}};e.fixIeBiDiScrollLeft=function(a,b){b=b||n.doc;var h=g("ie");if(h&&!e.isBodyLtr(b)){var d=g("quirks"),c=d?n.body(b):b.documentElement,f=n.global;6==h&&(!d&&f.frameElement&&c.scrollHeight>c.clientHeight)&&
(a+=c.clientLeft);return 8>h||d?a+c.clientWidth-c.scrollWidth:-a}return a};e.position=function(a,b){a=l.byId(a);var h=n.body(a.ownerDocument),d=a.getBoundingClientRect(),d={x:d.left,y:d.top,w:d.right-d.left,h:d.bottom-d.top};9>g("ie")&&(d.x-=g("quirks")?h.clientLeft+h.offsetLeft:0,d.y-=g("quirks")?h.clientTop+h.offsetTop:0);b&&(h=e.docScroll(a.ownerDocument),d.x+=h.x,d.y+=h.y);return d};e.getMarginSize=function(a,b){a=l.byId(a);var h=e.getMarginExtents(a,b||p.getComputedStyle(a)),d=a.getBoundingClientRect();
return{w:d.right-d.left+h.w,h:d.bottom-d.top+h.h}};e.normalizeEvent=function(a){"layerX"in a||(a.layerX=a.offsetX,a.layerY=a.offsetY);if(!("pageX"in a)){var b=a.target,b=b&&b.ownerDocument||document,h=g("quirks")?b.body:b.documentElement;a.pageX=a.clientX+e.fixIeBiDiScrollLeft(h.scrollLeft||0,b);a.pageY=a.clientY+(h.scrollTop||0)}};return e})},"dojo/mouse":function(){define(["./_base/kernel","./on","./has","./dom","./_base/window"],function(g,n,l,p,k){function f(k,e){var c=function(a,b){return n(a,
k,function(h){if(e)return e(h,b);if(!p.isDescendant(h.relatedTarget,a))return b.call(this,h)})};c.bubble=function(a){return f(k,function(b,h){var d=a(b.target),c=b.relatedTarget;if(d&&d!=(c&&1==c.nodeType&&a(c)))return h.call(d,b)})};return c}l.add("dom-quirks",k.doc&&"BackCompat"==k.doc.compatMode);l.add("events-mouseenter",k.doc&&"onmouseenter"in k.doc.createElement("div"));l.add("events-mousewheel",k.doc&&"onmousewheel"in k.doc);k=l("dom-quirks")&&l("ie")||!l("dom-addeventlistener")?{LEFT:1,MIDDLE:4,
RIGHT:2,isButton:function(f,e){return f.button&e},isLeft:function(f){return f.button&1},isMiddle:function(f){return f.button&4},isRight:function(f){return f.button&2}}:{LEFT:0,MIDDLE:1,RIGHT:2,isButton:function(f,e){return f.button==e},isLeft:function(f){return 0==f.button},isMiddle:function(f){return 1==f.button},isRight:function(f){return 2==f.button}};g.mouseButtons=k;g=l("events-mousewheel")?"mousewheel":function(f,e){return n(f,"DOMMouseScroll",function(c){c.wheelDelta=-c.detail;e.call(this,
c)})};return{_eventHandler:f,enter:f("mouseover"),leave:f("mouseout"),wheel:g,isLeft:k.isLeft,isMiddle:k.isMiddle,isRight:k.isRight}})},"dojo/_base/sniff":function(){define(["./kernel","./lang","../sniff"],function(g,n,l){g._name="browser";n.mixin(g,{isBrowser:!0,isFF:l("ff"),isIE:l("ie"),isKhtml:l("khtml"),isWebKit:l("webkit"),isMozilla:l("mozilla"),isMoz:l("mozilla"),isOpera:l("opera"),isSafari:l("safari"),isChrome:l("chrome"),isMac:l("mac"),isIos:l("ios"),isAndroid:l("android"),isWii:l("wii"),
isQuirks:l("quirks"),isAir:l("air")});return l})},"dojo/keys":function(){define(["./_base/kernel","./sniff"],function(g,n){return g.keys={BACKSPACE:8,TAB:9,CLEAR:12,ENTER:13,SHIFT:16,CTRL:17,ALT:18,META:n("webkit")?91:224,PAUSE:19,CAPS_LOCK:20,ESCAPE:27,SPACE:32,PAGE_UP:33,PAGE_DOWN:34,END:35,HOME:36,LEFT_ARROW:37,UP_ARROW:38,RIGHT_ARROW:39,DOWN_ARROW:40,INSERT:45,DELETE:46,HELP:47,LEFT_WINDOW:91,RIGHT_WINDOW:92,SELECT:93,NUMPAD_0:96,NUMPAD_1:97,NUMPAD_2:98,NUMPAD_3:99,NUMPAD_4:100,NUMPAD_5:101,NUMPAD_6:102,
NUMPAD_7:103,NUMPAD_8:104,NUMPAD_9:105,NUMPAD_MULTIPLY:106,NUMPAD_PLUS:107,NUMPAD_ENTER:108,NUMPAD_MINUS:109,NUMPAD_PERIOD:110,NUMPAD_DIVIDE:111,F1:112,F2:113,F3:114,F4:115,F5:116,F6:117,F7:118,F8:119,F9:120,F10:121,F11:122,F12:123,F13:124,F14:125,F15:126,NUM_LOCK:144,SCROLL_LOCK:145,UP_DPAD:175,DOWN_DPAD:176,LEFT_DPAD:177,RIGHT_DPAD:178,copyKey:n("mac")&&!n("air")?n("safari")?91:224:17}})},"dojo/dom-class":function(){define(["./_base/lang","./_base/array","./dom"],function(g,n,l){function p(c){if("string"==
typeof c||c instanceof String){if(c&&!f.test(c))return m[0]=c,m;c=c.split(f);c.length&&!c[0]&&c.shift();c.length&&!c[c.length-1]&&c.pop();return c}return!c?[]:n.filter(c,function(a){return a})}var k,f=/\s+/,m=[""],e={};return k={contains:function(c,a){return 0<=(" "+l.byId(c).className+" ").indexOf(" "+a+" ")},add:function(c,a){c=l.byId(c);a=p(a);var b=c.className,h,b=b?" "+b+" ":" ";h=b.length;for(var d=0,e=a.length,f;d<e;++d)(f=a[d])&&0>b.indexOf(" "+f+" ")&&(b+=f+" ");h<b.length&&(c.className=
b.substr(1,b.length-2))},remove:function(c,a){c=l.byId(c);var b;if(void 0!==a){a=p(a);b=" "+c.className+" ";for(var h=0,d=a.length;h<d;++h)b=b.replace(" "+a[h]+" "," ");b=g.trim(b)}else b="";c.className!=b&&(c.className=b)},replace:function(c,a,b){c=l.byId(c);e.className=c.className;k.remove(e,b);k.add(e,a);c.className!==e.className&&(c.className=e.className)},toggle:function(c,a,b){c=l.byId(c);if(void 0===b){a=p(a);for(var h=0,d=a.length,e;h<d;++h)e=a[h],k[k.contains(c,e)?"remove":"add"](c,e)}else k[b?
"add":"remove"](c,a);return b}}})},"dojo/_base/array":function(){define(["./kernel","../has","./lang"],function(g,n,l){function p(a){return m[a]=new Function("item","index","array",a)}function k(a){var b=!a;return function(h,d,c){var e=0,f=h&&h.length||0,k;f&&"string"==typeof h&&(h=h.split(""));"string"==typeof d&&(d=m[d]||p(d));if(c)for(;e<f;++e){if(k=!d.call(c,h[e],e,h),a^k)return!k}else for(;e<f;++e)if(k=!d(h[e],e,h),a^k)return!k;return b}}function f(a){var b=1,h=0,d=0;a||(b=h=d=-1);return function(f,
k,r,g){if(g&&0<b)return c.lastIndexOf(f,k,r);g=f&&f.length||0;var t=a?g+d:h;r===e?r=a?h:g+d:0>r?(r=g+r,0>r&&(r=h)):r=r>=g?g+d:r;for(g&&"string"==typeof f&&(f=f.split(""));r!=t;r+=b)if(f[r]==k)return r;return-1}}var m={},e,c={every:k(!1),some:k(!0),indexOf:f(!0),lastIndexOf:f(!1),forEach:function(a,b,h){var d=0,c=a&&a.length||0;c&&"string"==typeof a&&(a=a.split(""));"string"==typeof b&&(b=m[b]||p(b));if(h)for(;d<c;++d)b.call(h,a[d],d,a);else for(;d<c;++d)b(a[d],d,a)},map:function(a,b,h,d){var c=0,
e=a&&a.length||0;d=new (d||Array)(e);e&&"string"==typeof a&&(a=a.split(""));"string"==typeof b&&(b=m[b]||p(b));if(h)for(;c<e;++c)d[c]=b.call(h,a[c],c,a);else for(;c<e;++c)d[c]=b(a[c],c,a);return d},filter:function(a,b,h){var d=0,c=a&&a.length||0,e=[],f;c&&"string"==typeof a&&(a=a.split(""));"string"==typeof b&&(b=m[b]||p(b));if(h)for(;d<c;++d)f=a[d],b.call(h,f,d,a)&&e.push(f);else for(;d<c;++d)f=a[d],b(f,d,a)&&e.push(f);return e},clearCache:function(){m={}}};l.mixin(g,c);return c})},"dgrid/List":function(){define("dojo/_base/declare dojo/dom-construct dojo/dom-class dojo/on dojo/has ./util/misc dojo/_base/sniff".split(" "),
function(g,n,l,p,k,f){function m(a,b){a.className="dgrid-scrollbar-measure";document.body.appendChild(a);var d=a["offset"+b]-a["client"+b];a.className="";a.parentNode&&document.body.removeChild(a);return d}function e(a){l.replace(this.domNode,a,this._class||"");this._class=a}function c(){return this._class}var a=[];k("mozilla")&&a.push("has-mozilla");k("touch")&&a.push("has-touch");l.add(document.documentElement,a);k.add("pointer",function(a){return"PointerEvent"in a?"pointer":"MSPointerEvent"in a?
"MSPointer":!1});var b,h;k.add("dom-scrollbar-width",function(a,b,d){return m(d,"Width")});k.add("dom-scrollbar-height",function(a,b,d){return m(d,"Height")});k.add("dom-rtl-scrollbar-left",function(a,b,d){a=document.createElement("div");d.className="dgrid-scrollbar-measure";d.setAttribute("dir","rtl");d.appendChild(a);document.body.appendChild(d);b=!!k("ie")||!!k("trident")||/\bEdge\//.test(navigator.userAgent)||a.offsetLeft>=k("dom-scrollbar-width");d.className="";d.parentNode&&document.body.removeChild(d);
n.destroy(a);d.removeAttribute("dir");return b});var d=0,q=function(){this._started&&this.resize()},s=g(null,{tabableHeader:!1,showHeader:!1,showFooter:!1,maintainOddEven:!0,cleanAddedRules:!0,addUiClasses:!0,highlightDuration:250,postscript:function(a,b){var d=this;(this._Row=function(a,b,d){this.id=a;this.data=b;this.element=d}).prototype.remove=function(){d.removeRow(this.element)};b&&(this.srcNodeRef=b=b.nodeType?b:document.getElementById(b));this.create(a,b)},listType:"list",create:function(a,
b){var h=this.domNode=b||document.createElement("div"),c;a&&(this.params=a,g.safeMixin(this,a),c=a["class"]||a.className||h.className);this.sort=this.sort||[];this._listeners=[];this._rowIdToObject={};this.postMixInProperties&&this.postMixInProperties();this.id=h.id=h.id||this.id||s.autoIdPrefix+d++;this.buildRendering();c&&e.call(this,c);this.postCreate();delete this.srcNodeRef;this.domNode.offsetHeight&&this.startup()},buildRendering:function(){var a=this.domNode,b=this.addUiClasses,d=this,h,c,
e;e=this.isRTL="rtl"===(document.body.dir||document.documentElement.dir||document.body.style.direction).toLowerCase();a.className="";a.setAttribute("role","grid");l.add(a,"dgrid dgrid-"+this.listType+(b?" ui-widget":""));h=this.headerNode=n.create("div",{className:"dgrid-header dgrid-header-row"+(b?" ui-widget-header":"")+(this.showHeader?"":" dgrid-header-hidden")},a);c=this.bodyNode=n.create("div",{className:"dgrid-scroller"},a);k("ff")&&(c.tabIndex=-1);this.headerScrollNode=n.create("div",{className:"dgrid-header dgrid-header-scroll dgrid-scrollbar-width"+
(b?" ui-widget-header":"")},a);this.footerNode=n.create("div",{className:"dgrid-footer"+(this.showFooter?"":" dgrid-footer-hidden")},a);e&&(a.className+=" dgrid-rtl"+(k("dom-rtl-scrollbar-left")?" dgrid-rtl-swap":""));p(c,"scroll",function(b){d.showHeader&&(h.scrollLeft=b.scrollLeft||c.scrollLeft);b.stopPropagation();p.emit(a,"scroll",{scrollTarget:c})});this.configStructure();this.renderHeader();this.contentNode=this.touchNode=n.create("div",{className:"dgrid-content"+(b?" ui-widget-content":"")},
this.bodyNode);this._listeners.push(this._resizeHandle=p(window,"resize",f.throttleDelayed(q,this)))},postCreate:function(){},startup:function(){this._started||(this.inherited(arguments),this._started=!0,this.resize(),this.set("sort",this.sort))},configStructure:function(){},resize:function(){var a=this.bodyNode,d=this.footerNode,d=this.showFooter?d.offsetHeight:0;this.headerScrollNode.style.height=a.style.marginTop=this.headerNode.offsetHeight+"px";a.style.marginBottom=d+"px";b||(b=k("dom-scrollbar-width"),
h=k("dom-scrollbar-height"),k("ie")&&(b++,h++),f.addCssRule(".dgrid-scrollbar-width","width: "+b+"px"),f.addCssRule(".dgrid-scrollbar-height","height: "+h+"px"),17!==b&&(f.addCssRule(".dgrid-header-row","right: "+b+"px"),f.addCssRule(".dgrid-rtl-swap .dgrid-header-row","left: "+b+"px")))},addCssRule:function(a,b){var d=f.addCssRule(a,b);this.cleanAddedRules&&this._listeners.push(d);return d},on:function(a,b){var d=p(this.domNode,a,b);k("dom-addeventlistener")||this._listeners.push(d);return d},cleanup:function(){for(var a in this._rowIdToObject)if(this._rowIdToObject[a]!==
this.columns){var b=document.getElementById(a);b&&this.removeRow(b,!0)}},destroy:function(){if(this._listeners){for(var a=this._listeners.length;a--;)this._listeners[a].remove();this._listeners=null}this._started=!1;this.cleanup();n.destroy(this.domNode)},refresh:function(){this.cleanup();this._rowIdToObject={};this._autoRowId=0;this.contentNode.innerHTML="";this.scrollTo({x:0,y:0})},highlightRow:function(a,b){var d="dgrid-highlight"+(this.addUiClasses?" ui-state-highlight":"");a=a.element||a;l.add(a,
d);setTimeout(function(){l.remove(a,d)},b||this.highlightDuration)},adjustRowIndices:function(a){var b=a.rowIndex;if(-1<b){do-1<a.rowIndex&&(this.maintainOddEven&&l.contains(a,"dgrid-row")&&l.replace(a,1===b%2?"dgrid-row-odd":"dgrid-row-even",0===b%2?"dgrid-row-odd":"dgrid-row-even"),a.rowIndex=b++);while((a=a.nextSibling)&&a.rowIndex!==b)}},renderArray:function(a,b,d){d=d||{};var h=d.start||0,c=document.createDocumentFragment(),e=[],f=0,q=a.length;b||(this._lastCollection=a);for(;f<q;)e[f]=this.insertRow(a[f],
c,null,h++,d),f++;if((a=b?b.parentNode:this.contentNode)&&a.parentNode&&(a!==this.contentNode||q))a.insertBefore(c,b||null),q&&this.adjustRowIndices(e[q-1]);return e},renderHeader:function(){},_autoRowId:0,insertRow:function(a,b,d,h,c){var e=this.id+"-row-"+(this.collection&&this.collection.getIdentity?this.collection.getIdentity(a):this._autoRowId++),f=document.getElementById(e),q=f&&f.previousSibling;f&&(f===d&&(d=(d.connected||d).nextSibling),this.removeRow(f,!1,c));f=this.renderRow(a,c);f.className=
(f.className||"")+" dgrid-row "+(1===h%2?"dgrid-row-odd":"dgrid-row-even")+(this.addUiClasses?" ui-state-default":"");this._rowIdToObject[f.id=e]=a;b.insertBefore(f,d||null);f.rowIndex=h;q&&q.rowIndex!==f.rowIndex-1&&this.adjustRowIndices(q);return f},renderRow:function(a){var b=document.createElement("div");b.appendChild(document.createTextNode(a));return b},removeRow:function(a,b){a=a.element||a;delete this._rowIdToObject[a.id];b||n.destroy(a)},row:function(a){var b;if(a instanceof this._Row)return a;
a.target&&a.target.nodeType&&(a=a.target);if(a.nodeType){do{var d=a.id;if(b=this._rowIdToObject[d])return new this._Row(d.substring(this.id.length+5),b,a);a=a.parentNode}while(a&&a!==this.domNode)}else return"object"===typeof a?b=this.collection.getIdentity(a):(b=a,a=this._rowIdToObject[this.id+"-row-"+b]),new this._Row(b,a,document.getElementById(this.id+"-row-"+b))},cell:function(a){return{row:this.row(a)}},_move:function(a,b,d,h){var c,e;e=c=a.element;b=b||1;do if(a=c[0>b?"previousSibling":"nextSibling"]){do if((c=
a)&&-1<(c.className+" ").indexOf(d+" ")){e=c;b+=0>b?1:-1;break}while(a=(!h||!c.hidden)&&c[0>b?"lastChild":"firstChild"])}else if(c=c.parentNode,!c||c===this.bodyNode||c===this.headerNode)break;while(b);return e},up:function(a,b,d){a.element||(a=this.row(a));return this.row(this._move(a,-(b||1),"dgrid-row",d))},down:function(a,b,d){a.element||(a=this.row(a));return this.row(this._move(a,b||1,"dgrid-row",d))},scrollTo:function(a){"undefined"!==typeof a.x&&(this.bodyNode.scrollLeft=a.x);"undefined"!==
typeof a.y&&(this.bodyNode.scrollTop=a.y)},getScrollPosition:function(){return{x:this.bodyNode.scrollLeft,y:this.bodyNode.scrollTop}},get:function(a){var b="_get"+a.charAt(0).toUpperCase()+a.slice(1);return"function"===typeof this[b]?this[b].apply(this,[].slice.call(arguments,1)):this[a]},set:function(a,b){if("object"===typeof a)for(var d in a)this.set(d,a[d]);else d="_set"+a.charAt(0).toUpperCase()+a.slice(1),"function"===typeof this[d]?this[d].apply(this,[].slice.call(arguments,1)):this[a]=b;return this},
_getClass:c,_setClass:e,_getClassName:c,_setClassName:e,_setSort:function(a,b){this.sort="string"!==typeof a?a:[{property:a,descending:b}];this._applySort()},_applySort:function(){this.refresh();if(this._lastCollection){var a=this.sort;if(a&&0<a.length){var b=a[0].property,d=!!a[0].descending;this._lastCollection.sort(function(a,h){var c=a[b],e=h[b];void 0===c&&(c="");void 0===e&&(e="");return c===e?0:c>e!==d?1:-1})}this.renderArray(this._lastCollection)}},_setShowHeader:function(a){var b=this.headerNode;
this.showHeader=a;l.toggle(b,"dgrid-header-hidden",!a);this.renderHeader();this.resize();a&&(b.scrollLeft=this.getScrollPosition().x)},_setShowFooter:function(a){this.showFooter=a;l.toggle(this.footerNode,"dgrid-footer-hidden",!a);this.resize()}});s.autoIdPrefix="dgrid_";return s})},"dgrid/util/misc":function(){define(["dojo/has"],function(g){g.add("dom-contains",function(e,c,a){return!!a.contains});var n=[],l,p,k,f=/([^A-Za-z0-9_\u00A0-\uFFFF-])/g,m={defaultDelay:15,throttle:function(e,c,a){var b=
!1;a=a||m.defaultDelay;return function(){b||(b=!0,e.apply(c,arguments),setTimeout(function(){b=!1},a))}},throttleDelayed:function(e,c,a){var b=!1;a=a||m.defaultDelay;return function(){if(!b){b=!0;var h=arguments;setTimeout(function(){b=!1;e.apply(c,h)},a)}}},debounce:function(e,c,a){var b;a=a||m.defaultDelay;return function(){b&&(clearTimeout(b),b=null);var h=arguments;b=setTimeout(function(){e.apply(c,h)},a)}},each:function(e,c,a){var b,h;if(e)if("number"===typeof e.length){b=0;for(h=e.length;b<
h;b++)c.call(a,e[b],b,e)}else for(b in e)c.call(a,e[b],b,e)},addCssRule:function(e,c){l||(l=document.createElement("style"),document.getElementsByTagName("head")[0].appendChild(l),l=l.sheet||l.styleSheet,p=l.deleteRule?"deleteRule":"removeRule",k=l.cssRules?"cssRules":"rules");var a=n.length;n[a]=(l.cssRules||l.rules).length;l.addRule?l.addRule(e,c):l.insertRule(e+"{"+c+"}",n[a]);return{get:function(b){return l[k][n[a]].style[b]},set:function(b,h){"undefined"!==typeof n[a]&&(l[k][n[a]].style[b]=h)},
remove:function(){var b=n[a],h,d;if(void 0!==b){l[p](b);n[a]=void 0;h=a+1;for(d=n.length;h<d;h++)n[h]>b&&n[h]--}}}},escapeCssIdentifier:function(e,c){return"string"===typeof e?e.replace(f,c||"\\$1"):e}};return m})},"dgrid/OnDemandGrid":function(){define(["dojo/_base/declare","./Grid","./OnDemandList"],function(g,n,l){return g([n,l],{})})},"dgrid/OnDemandList":function(){define("./List ./_StoreMixin dojo/_base/declare dojo/_base/lang dojo/dom-construct dojo/on dojo/when ./util/misc".split(" "),function(g,
n,l,p,k,f,m,e){return l([g,n],{minRowsPerPage:25,maxRowsPerPage:250,maxEmptySpace:Infinity,bufferRows:10,farOffRemoval:2E3,queryRowsOverlap:0,pagingMethod:"debounce",pagingDelay:e.defaultDelay,keepScrollPosition:!1,rowHeight:0,postCreate:function(){this.inherited(arguments);var c=this;f(this.bodyNode,"scroll",e[this.pagingMethod](function(a){c._processScroll(a)},null,this.pagingDelay))},renderQuery:function(c,a){var b=this,h=a&&a.container||this.contentNode,d={query:c,count:0},e,f=this.preload,g=
{node:k.create("div",{className:"dgrid-preload",style:{height:"0"}},h),count:0,query:c,next:d};g.node.rowIndex=0;d.node=e=k.create("div",{className:"dgrid-preload"},h);d.previous=g;e.rowIndex=this.minRowsPerPage;f?((d.next=f.next)&&e.offsetTop>=f.node.offsetTop?d.previous=f:(d.next=f,d.previous=f.previous),d.previous.next=d,d.next.previous=d):this.preload=d;var l=k.create("div",{className:"dgrid-loading"},e,"before");k.create("div",{className:"dgrid-below"},l).innerHTML=this.loadingMessage;a=p.mixin({start:0,
count:this.minRowsPerPage},"level"in c?{queryLevel:c.level}:null);return this._trackError(function(){var h=c(a);return b.renderQueryResults(h,e,a).then(function(c){return h.totalLength.then(function(h){var f=c.length,g=e.parentNode;b._rows&&(b._rows.min=0,b._rows.max=f===h?Infinity:f-1);k.destroy(l);"queryLevel"in a||(b._total=h);0===h&&g&&(b.noDataNode&&k.destroy(b.noDataNode),b._insertNoDataNode(g));b._calcAverageRowHeight(c);h-=f;d.count=h;e.rowIndex=f;h?e.style.height=Math.min(h*b.rowHeight,b.maxEmptySpace)+
"px":e.style.display="none";b._previousScrollPosition&&(b.scrollTo(b._previousScrollPosition),delete b._previousScrollPosition);return m(b._processScroll()).then(function(){return c})})}).otherwise(function(a){k.destroy(l);throw a;})})},refresh:function(c){var a=this,b=c&&c.keepScrollPosition;"undefined"===typeof b&&(b=this.keepScrollPosition);b&&(this._previousScrollPosition=this.getScrollPosition());this.inherited(arguments);if(this._renderedCollection)return this.renderQuery(function(b){return a._renderedCollection.fetchRange({start:b.start,
end:b.start+b.count})}).then(function(){a._emitRefreshComplete()})},resize:function(){this.inherited(arguments);this.rowHeight||this._calcAverageRowHeight(this.contentNode.getElementsByClassName("dgrid-row"));this._processScroll()},cleanup:function(){this.inherited(arguments);this.preload=null},renderQueryResults:function(c){var a=this.inherited(arguments),b=this._renderedCollection;b&&b.releaseRange&&a.then(function(a){a[0]&&!a[0].parentNode.tagName&&c.totalLength.then(function(){b.releaseRange(a[0].rowIndex,
a[a.length-1].rowIndex+1)})});return a},_getFirstRowSibling:function(c){return c.lastChild},_calcRowHeight:function(c){var a=c.nextSibling;return a&&!/\bdgrid-preload\b/.test(a.className)?a.offsetTop-c.offsetTop:c.offsetHeight},_calcAverageRowHeight:function(c){for(var a=c.length,b=0,h=0;h<a;h++)b+=this._calcRowHeight(c[h]);a&&b&&(this.rowHeight=b/a)},lastScrollTop:0,_processScroll:function(c){function a(a,h,c,e){var f=d.farOffRemoval,q=a.node;if(h>2*f){for(var m,g=q[c],s=0,u=0,t=[],r=g&&g.rowIndex,
l;m=g;){var n=d._calcRowHeight(m);if(s+n+f>h||0>g.className.indexOf("dgrid-row")&&0>g.className.indexOf("dgrid-loading"))break;g=m[c];s+=n;u+=m.count||1;d.removeRow(m,!0);t.push(m);"rowIndex"in m&&(l=m.rowIndex)}d._renderedCollection.releaseRange&&("number"===typeof r&&"number"===typeof l)&&(e?d._renderedCollection.releaseRange(l,r+1):d._renderedCollection.releaseRange(r,l+1),d._rows[e?"max":"min"]=l,d._rows.max>=d._total-1&&(d._rows.max=Infinity));a.count+=u;e?(q.rowIndex-=u,b(a)):q.style.height=
q.offsetHeight+s+"px";var p=document.createElement("div");for(a=t.length;a--;)p.appendChild(t[a]);setTimeout(function(){k.destroy(p)},1)}}function b(a,b){a.node.style.height=Math.min(a.count*d.rowHeight,b?Infinity:d.maxEmptySpace)+"px"}function h(a,b){do a=b?a.next:a.previous;while(a&&!a.node.offsetWidth);return a}if(this.rowHeight){var d=this,e=d.bodyNode;c=c&&c.scrollTop||this.getScrollPosition().y;var e=e.offsetHeight+c,f,g,m=d.preload,t=d.lastScrollTop,u=d.bufferRows*d.rowHeight,l=u-d.rowHeight,
n,p=!0;for(d.lastScrollTop=c;m&&!m.node.offsetWidth;)m=m.previous;for(;m&&m!==f;){f=d.preload;d.preload=m;g=m.node;var x=g.offsetTop;if(e+1+l<x)m=h(m,p=!1);else if(c-1-l>x+g.offsetHeight)m=h(m,p=!0);else{var x=((g.rowIndex?c-u:e)-x)/d.rowHeight,z=(e-c+2*u)/d.rowHeight,C=Math.max(Math.min((c-t)*d.rowHeight,d.maxRowsPerPage/2),d.maxRowsPerPage/-2),z=z+Math.min(Math.abs(C),10);0===g.rowIndex&&(x-=z);x=Math.max(x,0);10>x&&(0<x&&z+x<d.maxRowsPerPage)&&(z+=Math.max(0,x),x=0);z=Math.min(Math.max(z,d.minRowsPerPage),
d.maxRowsPerPage,m.count);if(0===z)m=h(m,p);else{var z=Math.ceil(z),x=Math.min(Math.floor(x),m.count-z),B={};m.count-=z;var G=g,L,C=d.queryRowsOverlap,M=(0<g.rowIndex||g.offsetTop>c)&&m;if(M){var P=m.previous;P&&(a(P,c-(P.node.offsetTop+P.node.offsetHeight),"nextSibling"),0<x&&P.node===g.previousSibling?(x=Math.min(m.count,x),m.previous.count+=x,b(m.previous,!0),g.rowIndex+=x,C=0):z+=x,m.count-=x);B.start=g.rowIndex-C;B.count=Math.min(z+C,d.maxRowsPerPage);g.rowIndex=B.start+B.count}else m.next&&
(a(m.next,m.next.node.offsetTop-e,"previousSibling",!0),G=g.nextSibling,G===m.next.node?(m.next.count+=m.count-x,m.next.node.rowIndex=x+z,b(m.next),m.count=x,C=0):L=!0),B.start=m.count,B.count=Math.min(z+C,d.maxRowsPerPage);L&&(G&&G.offsetWidth)&&(L=G.offsetTop);b(m);"level"in m.query&&(B.queryLevel=m.query.level);if("queryLevel"in B||!(B.start>d._total||0>B.count)){var I=k.create("div",{className:"dgrid-loading",style:{height:z*d.rowHeight+"px"}},G,"before");k.create("div",{className:"dgrid-"+(M?
"below":"above"),innerHTML:d.loadingMessage},I);I.count=z;d._trackError(function(){(function(a,h,c){var e=m.query(B);n=d.renderQueryResults(e,a,B).then(function(f){var q=d._rows;q&&(!("queryLevel"in B)&&f.length)&&(h?(q.max<=q.min&&(q.min=f[0].rowIndex),q.max=f[f.length-1].rowIndex):(q.max<=q.min&&(q.max=f[f.length-1].rowIndex),q.min=f[0].rowIndex));G=a.nextSibling;k.destroy(a);c&&(G&&G.offsetWidth)&&(q=d.getScrollPosition(),d.scrollTo({x:q.x,y:q.y+G.offsetTop-c,preserveMomentum:!0}));e.totalLength.then(function(a){"queryLevel"in
B||(d._total=a,d._rows&&d._rows.max>=d._total-1&&(d._rows.max=Infinity));h&&(h.count=a-h.node.rowIndex,b(h))});d._processScroll();return f},function(b){k.destroy(a);throw b;})})(I,M,L)});m=m.previous}}}}return n}}})})},"dgrid/_StoreMixin":function(){define("dojo/_base/declare dojo/_base/lang dojo/Deferred dojo/aspect dojo/dom-construct dojo/has dojo/on dojo/when".split(" "),function(g,n,l,p,k,f,m,e){function c(a){if("object"!==typeof a)a=Error(a);else if("cancel"===a.dojoType)return;m.emit(this.domNode,
"dgrid-error",{grid:this,error:a,cancelable:!0,bubbles:!0})&&console.error(a)}return g(null,{collection:null,_renderedCollection:null,_rows:null,_observerHandle:null,shouldTrackCollection:!0,getBeforePut:!0,noDataMessage:"",loadingMessage:"",_total:0,constructor:function(){this.dirty={};this._updating={};this._columnsWithSet={};p.before(this,"configStructure",n.hitch(this,function(){this._columnsWithSet={}}))},destroy:function(){this.inherited(arguments);this._renderedCollection&&this._cleanupCollection();
this._refreshTimeout&&clearTimeout(this._refreshTimeout)},_configColumn:function(a){a.set&&(this._columnsWithSet[a.field]=a);this.inherited(arguments)},_setCollection:function(a){this._renderedCollection&&(this.cleanup(),this._cleanupCollection({shouldRevert:!a||a.storage!==this._renderedCollection.storage}));this.collection=a;if(this._started){if(a){var b=a;this.sort&&0<this.sort.length&&(b=a.sort(this.sort));b.track&&this.shouldTrackCollection&&(b=b.track(),this._rows=[],this._observerHandle=this._observeCollection(b,
this.contentNode,{rows:this._rows}));this._renderedCollection=b}this.refresh()}},_setStore:function(){},_getTotal:function(){return this._total},_cleanupCollection:function(a){a=a||{};this._renderedCollection.tracking&&this._renderedCollection.tracking.remove();this._observerHandle&&(this._observerHandle.remove(),this._observerHandle=this._rows=null);!1!==a.shouldRevert&&(this.dirty={});this._renderedCollection=this.collection=null},_applySort:function(){this.collection&&this.set("collection",this.collection)},
_emitRefreshComplete:function(){var a=this;this._refreshTimeout=setTimeout(function(){m.emit(a.domNode,"dgrid-refresh-complete",{bubbles:!0,cancelable:!1,grid:a});a._refreshTimeout=null},0)},_insertNoDataNode:function(a){a=a||this.contentNode;var b=this.noDataNode=k.create("div",{className:"dgrid-no-data",innerHTML:this.noDataMessage});a.insertBefore(b,this._getFirstRowSibling&&this._getFirstRowSibling(a));return b},row:function(){var a=this.inherited(arguments);a&&(a.data&&"undefined"!==typeof a.id)&&
(a.id=this.collection.getIdentity(a.data));return a},refresh:function(){var a=this.inherited(arguments);this.collection||this._insertNoDataNode();return a},refreshCell:function(a){if(!this.collection||!this._createBodyRowCell)throw Error("refreshCell requires a Grid with a collection.");this.inherited(arguments);return this.collection.get(a.row.id).then(n.hitch(this,"_refreshCellFromItem",a))},_refreshCellFromItem:function(a,b,h){var d=a.element;k.empty(d);var c=this.dirty&&this.dirty[a.row.id];c&&
(b=n.delegate(b,c));this._createBodyRowCell(d,a.column,b,h)},renderArray:function(){var a=this.inherited(arguments);this.collection||a.length&&this.noDataNode&&k.destroy(this.noDataNode);return a},insertRow:function(a,b,h,d,c){var e=this.collection,f=this.dirty,e=e&&e.getIdentity(a),m;e in f&&!(e in this._updating)&&(m=f[e]);m&&(a=n.delegate(a,m));f=this.inherited(arguments);c&&c.rows&&(c.rows[d]=f);this.noDataNode&&(k.destroy(this.noDataNode),this.noDataNode=null);return f},updateDirty:function(a,
b,h){var d=this.dirty,c=d[a];c||(c=d[a]={});c[b]=h},save:function(){function a(a,c){return function(f){var q=b._columnsWithSet,m=b._updating,k,g;if("function"===typeof f.set)f.set(c);else for(k in c)f[k]=c[k];for(k in q)g=q[k].set(f),void 0!==g&&(f[k]=g);m[a]=!0;return h.put(f).then(function(b){delete d[a];delete m[a];e[a]=b;return e})}}var b=this,h=this.collection,d=this.dirty,c=new l,e={},f=function(a){var d;return b.getBeforePut||!(d=b.row(a).data)?function(){return h.get(a)}:function(){return d}},
m=c.then(function(){return e}),k;for(k in d)var g=a(k,d[k]),m=m.then(f(k)).then(g);c.resolve();return m},revert:function(){this.dirty={};this.refresh()},_trackError:function(a){"string"===typeof a&&(a=n.hitch(this,a));var b=this,h;try{h=e(a())}catch(d){a=new l,a.reject(d),h=a.promise}h.otherwise(function(a){c.call(b,a)});return h},removeRow:function(a,b,h){var d={element:a};!b&&(this.up(d).element===a&&this.down(d).element===a)&&this._insertNoDataNode();(d=h&&h.rows||this._rows)&&delete d[a.rowIndex];
return this.inherited(arguments)},renderQueryResults:function(a,b,h){h=n.mixin({rows:this._rows},h);var d=this;return a.then(function(a){a=d.renderArray(a,b,h);delete d._lastCollection;return a})},_observeCollection:function(a,b,h){var d=this,c=h.rows,e,f=[a.on("delete, update",function(a){var f=a.previousIndex,m=a.index;void 0!==f&&c[f]&&("max"in c&&(void 0===m||m<c.min||m>c.max)&&c.max--,e=c[f],e.parentNode===b&&d.removeRow(e,!1,h),c.splice(f,1),("delete"===a.type||"update"===a.type&&(f<m||void 0===
m))&&c[f]&&c[f].rowIndex--);"delete"===a.type&&(e=null)}),a.on("add, update",function(a){var f=a.previousIndex,m=a.index;if(void 0!==m&&(!("max"in c)||m>=c.min&&m<=c.max)){"max"in c&&(void 0===f||f<c.min||f>c.max)&&c.max++;if(c.length){if(f=c[m],!f&&(f=c[m-1]))f=(f.connected||f).nextSibling}else f=d._getFirstRowSibling&&d._getFirstRowSibling(b);e&&(f&&e.id===f.id)&&(f=(f.connected||f).nextSibling);f&&!f.parentNode&&(f=document.getElementById(f.id));c.splice(m,0,void 0);e=d.insertRow(a.target,b,f,
m,h);d.highlightRow(e)}e=null}),a.on("add, delete, update",function(b){var h="undefined"!==typeof b.previousIndex?b.previousIndex:Infinity,e="undefined"!==typeof b.index?b.index:Infinity,f=Math.min(h,e);h!==e&&c[f]&&d.adjustRowIndices(c[f]);Infinity!==h&&(d._processScroll&&(c[h]||c[h-1]))&&d._processScroll();d._onNotification(c,b,a);a===d._renderedCollection&&"totalLength"in b&&(d._total=b.totalLength)})];return{remove:function(){for(;0<f.length;)f.pop().remove()}}},_onNotification:function(){}})})},
"dojo/Deferred":function(){define(["./has","./_base/lang","./errors/CancelError","./promise/Promise","./promise/instrumentation"],function(g,n,l,p,k){var f=Object.freeze||function(){},m=function(a,d,c,f,m){2===d&&(b.instrumentRejected&&0===a.length)&&b.instrumentRejected(c,!1,f,m);for(m=0;m<a.length;m++)e(a[m],d,c,f)},e=function(h,d,e,f){var m=h[d],k=h.deferred;if(m)try{var g=m(e);if(0===d)"undefined"!==typeof g&&a(k,d,g);else{if(g&&"function"===typeof g.then){h.cancel=g.cancel;g.then(c(k,1),c(k,
2),c(k,0));return}a(k,1,g)}}catch(u){a(k,2,u)}else a(k,d,e);2===d&&b.instrumentRejected&&b.instrumentRejected(e,!!m,f,k.promise)},c=function(b,d){return function(c){a(b,d,c)}},a=function(a,b,c){if(!a.isCanceled())switch(b){case 0:a.progress(c);break;case 1:a.resolve(c);break;case 2:a.reject(c)}},b=function(a){var d=this.promise=new p,c=this,k,g,n,t=!1,u=[];Error.captureStackTrace&&(Error.captureStackTrace(c,b),Error.captureStackTrace(d,b));this.isResolved=d.isResolved=function(){return 1===k};this.isRejected=
d.isRejected=function(){return 2===k};this.isFulfilled=d.isFulfilled=function(){return!!k};this.isCanceled=d.isCanceled=function(){return t};this.progress=function(a,b){if(k){if(!0===b)throw Error("This deferred has already been fulfilled.");return d}m(u,0,a,null,c);return d};this.resolve=function(a,b){if(k){if(!0===b)throw Error("This deferred has already been fulfilled.");return d}m(u,k=1,g=a,null,c);u=null;return d};var w=this.reject=function(a,b){if(k){if(!0===b)throw Error("This deferred has already been fulfilled.");
return d}Error.captureStackTrace&&Error.captureStackTrace(n={},w);m(u,k=2,g=a,n,c);u=null;return d};this.then=d.then=function(a,c,h){var f=[h,a,c];f.cancel=d.cancel;f.deferred=new b(function(a){return f.cancel&&f.cancel(a)});k&&!u?e(f,k,g,n):u.push(f);return f.deferred.promise};this.cancel=d.cancel=function(b,d){if(k){if(!0===d)throw Error("This deferred has already been fulfilled.");}else{if(a){var c=a(b);b="undefined"===typeof c?b:c}t=!0;if(k){if(2===k&&g===b)return b}else return"undefined"===typeof b&&
(b=new l),w(b),b}};f(d)};b.prototype.toString=function(){return"[object Deferred]"};k&&k(b);return b})},"dojo/errors/CancelError":function(){define(["./create"],function(g){return g("CancelError",null,null,{dojoType:"cancel"})})},"dojo/errors/create":function(){define(["../_base/lang"],function(g){return function(n,l,p,k){p=p||Error;var f=function(m){if(p===Error){Error.captureStackTrace&&Error.captureStackTrace(this,f);var e=Error.call(this,m),c;for(c in e)e.hasOwnProperty(c)&&(this[c]=e[c]);this.message=
m;this.stack=e.stack}else p.apply(this,arguments);l&&l.apply(this,arguments)};f.prototype=g.delegate(p.prototype,k);f.prototype.name=n;return f.prototype.constructor=f}})},"dojo/promise/Promise":function(){define(["../_base/lang"],function(g){function n(){throw new TypeError("abstract");}return g.extend(function(){},{then:function(g,p,k){n()},cancel:function(g,p){n()},isResolved:function(){n()},isRejected:function(){n()},isFulfilled:function(){n()},isCanceled:function(){n()},always:function(g){return this.then(g,
g)},otherwise:function(g){return this.then(null,g)},trace:function(){return this},traceRejected:function(){return this},toString:function(){return"[object Promise]"}})})},"dojo/promise/instrumentation":function(){define(["./tracer","../has","../_base/lang","../_base/array"],function(g,n,l,p){function k(a,b,c){var e="";a&&a.stack&&(e+=a.stack);b&&b.stack&&(e+="\n    ----------------------------------------\n    rejected"+b.stack.split("\n").slice(1).join("\n").replace(/^\s+/," "));c&&c.stack&&(e+=
"\n    ----------------------------------------\n"+c.stack);console.error(a,e)}function f(a,b,c,e){b||k(a,c,e)}function m(h,d,f,m){p.some(c,function(a){if(a.error===h)return d&&(a.handled=!0),!0})||c.push({error:h,rejection:f,handled:d,deferred:m,timestamp:(new Date).getTime()});a||(a=setTimeout(e,b))}function e(){var h=(new Date).getTime(),d=h-b;c=p.filter(c,function(a){return a.timestamp<d?(a.handled||k(a.error,a.rejection,a.deferred),!1):!0});a=c.length?setTimeout(e,c[0].timestamp+b-h):!1}n.add("config-useDeferredInstrumentation",
"report-unhandled-rejections");var c=[],a=!1,b=1E3;return function(a){var d=n("config-useDeferredInstrumentation");if(d){g.on("resolved",l.hitch(console,"log","resolved"));g.on("rejected",l.hitch(console,"log","rejected"));g.on("progress",l.hitch(console,"log","progress"));var c=[];"string"===typeof d&&(c=d.split(","),d=c.shift());if("report-rejections"===d)a.instrumentRejected=f;else if("report-unhandled-rejections"===d||!0===d||1===d)a.instrumentRejected=m,b=parseInt(c[0],10)||b;else throw Error("Unsupported instrumentation usage \x3c"+
d+"\x3e");}}})},"dojo/promise/tracer":function(){define(["../_base/lang","./Promise","../Evented"],function(g,n,l){function p(m){setTimeout(function(){f.apply(k,m)},0)}var k=new l,f=k.emit;k.emit=null;n.prototype.trace=function(){var f=g._toArray(arguments);this.then(function(e){p(["resolved",e].concat(f))},function(e){p(["rejected",e].concat(f))},function(e){p(["progress",e].concat(f))});return this};n.prototype.traceRejected=function(){var f=g._toArray(arguments);this.otherwise(function(e){p(["rejected",
e].concat(f))});return this};return k})},"dojo/when":function(){define(["./Deferred","./promise/Promise"],function(g,n){return function(l,p,k,f){var m=l&&"function"===typeof l.then,e=m&&l instanceof n;if(m)e||(m=new g(l.cancel),l.then(m.resolve,m.reject,m.progress),l=m.promise);else return 1<arguments.length?p?p(l):l:(new g).resolve(l);return p||k||f?l.then(p,k,f):l}})},"dgrid/Selection":function(){define("dojo/_base/declare dojo/dom-class dojo/on dojo/has dojo/aspect ./List dojo/has!touch?./util/touch dojo/query dojo/_base/sniff dojo/dom".split(" "),
function(g,n,l,p,k,f,m){function e(a,b){for(var d=a.unselectable=b?"on":"",c=a.getElementsByTagName("*"),h=c.length;--h;)"INPUT"===c[h].tagName||"TEXTAREA"===c[h].tagName||(c[h].unselectable=d)}function c(a,d){var c=a.bodyNode,h=d?"text":21>p("ff")?"-moz-none":"none";b&&"msUserSelect"!==b?c.style[b]=h:p("dom-selectstart")?!d&&!a._selectstartHandle?a._selectstartHandle=l(c,"selectstart",function(a){var b=a.target&&a.target.tagName;"INPUT"!==b&&"TEXTAREA"!==b&&a.preventDefault()}):d&&a._selectstartHandle&&
(a._selectstartHandle.remove(),delete a._selectstartHandle):(e(c,!d),!d&&!a._unselectableHandle?a._unselectableHandle=k.after(a,"renderRow",function(a){e(a,!0);return a}):d&&a._unselectableHandle&&(a._unselectableHandle.remove(),delete a._unselectableHandle))}p.add("dom-comparedocumentposition",function(a,b,d){return!!d.compareDocumentPosition});p.add("dom-selectstart","undefined"!==typeof document.onselectstart);var a=p("mac")?"metaKey":"ctrlKey",b=p("css-user-select"),h=(f=p("pointer"))&&"MS"===
f.slice(0,2),d=f?f+(h?"Down":"down"):"mousedown",q=f?f+(h?"Up":"up"):"mouseup";"WebkitUserSelect"===b&&"undefined"!==typeof document.documentElement.style.msUserSelect&&(b=!1);return g(null,{selectionDelegate:".dgrid-row",selectionEvents:d+","+q+",dgrid-cellfocusin",selectionTouchEvents:p("touch")?m.tap:null,deselectOnRefresh:!0,allowSelectAll:!1,selection:{},selectionMode:"extended",allowTextSelection:void 0,_selectionTargetType:"rows",create:function(){this.selection={};return this.inherited(arguments)},
postCreate:function(){this.inherited(arguments);this._initSelectionEvents();var a=this.selectionMode;this.selectionMode="";this._setSelectionMode(a)},destroy:function(){this.inherited(arguments);this._selectstartHandle&&this._selectstartHandle.remove();this._unselectableHandle&&this._unselectableHandle.remove();this._removeDeselectSignals&&this._removeDeselectSignals()},_setSelectionMode:function(a){a!==this.selectionMode&&(this.clearSelection(),this.selectionMode=a,this._selectionHandlerName="_"+
a+"SelectionHandler",this._setAllowTextSelection(this.allowTextSelection))},_setAllowTextSelection:function(a){"undefined"!==typeof a?c(this,a):c(this,"none"===this.selectionMode);this.allowTextSelection=a},_handleSelect:function(a,b){if(this[this._selectionHandlerName]&&this.allowSelect(this.row(b))&&!("dgrid-cellfocusin"===a.type&&"mousedown"===a.parentType||a.type===q&&b!==this._waitForMouseUp)){this._waitForMouseUp=null;this._selectionTriggerEvent=a;if(!a.keyCode||!a.ctrlKey||32===a.keyCode)if(!a.shiftKey&&
a.type===d&&this.isSelected(b))this._waitForMouseUp=b;else this[this._selectionHandlerName](a,b);this._selectionTriggerEvent=null}},_singleSelectionHandler:function(b,d){var c=b.keyCode?b.ctrlKey:b[a];this._lastSelected===d?this.select(d,null,!c||!this.isSelected(d)):(this.clearSelection(),this.select(d),this._lastSelected=d)},_multipleSelectionHandler:function(b,d){var c=this._lastSelected,h=b.keyCode?b.ctrlKey:b[a],e;b.shiftKey||(e=h?null:!0,c=null);this.select(d,c,e);c||(this._lastSelected=d)},
_extendedSelectionHandler:function(b,d){(2===b.button?!this.isSelected(d):!(b.keyCode?b.ctrlKey:b[a]))&&this.clearSelection(null,!0);this._multipleSelectionHandler(b,d)},_toggleSelectionHandler:function(a,b){this.select(b,null,null)},_initSelectionEvents:function(){var b=this,d=this.contentNode,c=this.selectionDelegate;this._selectionEventQueues={deselect:[],select:[]};p("touch")&&!p("pointer")&&this.selectionTouchEvents?(l(d,m.selector(c,this.selectionTouchEvents),function(a){b._handleSelect(a,this);
b._ignoreMouseSelect=this}),l(d,l.selector(c,this.selectionEvents),function(a){b._ignoreMouseSelect!==this?b._handleSelect(a,this):a.type===q&&(b._ignoreMouseSelect=null)})):l(d,l.selector(c,this.selectionEvents),function(a){b._handleSelect(a,this)});this.addKeyHandler&&this.addKeyHandler(32,function(a){b._handleSelect(a,a.target)});if(this.allowSelectAll)this.on("keydown",function(d){d[a]&&(65===d.keyCode&&!/\bdgrid-input\b/.test(d.target.className))&&(d.preventDefault(),b[b.allSelected?"clearSelection":
"selectAll"]())});this._setCollection&&k.before(this,"_setCollection",function(a){b._updateDeselectionAspect(a)});this._updateDeselectionAspect()},_updateDeselectionAspect:function(a){function b(a,c){var h=d.row(a);if(h&&d.selection[h.id])d[c](h)}var d=this,c;this._removeDeselectSignals&&this._removeDeselectSignals();c=a&&a.track&&this._observeCollection?[k.before(this,"_observeCollection",function(a){c.push(a.on("delete",function(a){"undefined"===typeof a.index&&b(a.id,"deselect")}))}),k.after(this,
"_observeCollection",function(a){c.push(a.on("update",function(d){"undefined"!==typeof d.index&&b(a.getIdentity(d.target),"select")}))},!0)]:[k.before(this,"removeRow",function(a,b){var d;b||(d=this.row(a))&&d.id in this.selection&&this.deselect(d)})];this._removeDeselectSignals=function(){for(var a=c.length;a--;)c[a].remove();c=[]}},allowSelect:function(){return!0},_fireSelectionEvent:function(a){var b=this._selectionEventQueues[a],d=this._selectionTriggerEvent,c;c={bubbles:!0,grid:this};d&&(c.parentType=
d.type);c[this._selectionTargetType]=b;this._selectionEventQueues[a]=[];l.emit(this.contentNode,"dgrid-"+a,c)},_fireSelectionEvents:function(){var a=this._selectionEventQueues,b;for(b in a)a[b].length&&this._fireSelectionEvent(b)},_select:function(a,b,d){var c,h,e;"undefined"===typeof d&&(d=!0);a.element||(a=this.row(a));if(!1===d||this.allowSelect(a))if(c=this.selection,h=!!c[a.id],null===d&&(d=!h),e=a.element,!d&&!this.allSelected?delete this.selection[a.id]:c[a.id]=d,e&&(d?n.add(e,"dgrid-selected"+
(this.addUiClasses?" ui-state-active":"")):n.remove(e,"dgrid-selected ui-state-active")),d!==h&&e&&this._selectionEventQueues[(d?"":"de")+"select"].push(a),b)if(b.element||(b=this.row(b)),b){if(b=b.element){c=this._determineSelectionDirection(e,b);c||(b=document.getElementById(b.id),c=this._determineSelectionDirection(e,b));for(;a.element!==b&&(a=this[c](a));)this._select(a,null,d)}}else this._lastSelected=e,console.warn("The selection range has been reset because the beginning of the selection is no longer in the DOM. If you are using OnDemandList, you may wish to increase farOffRemoval to avoid this, but note that keeping more nodes in the DOM may impact performance.")},
_determineSelectionDirection:p("dom-comparedocumentposition")?function(a,b){var d=b.compareDocumentPosition(a);return d&1?!1:2===d?"down":"up"}:function(a,b){return 1>b.sourceIndex?!1:b.sourceIndex>a.sourceIndex?"down":"up"},select:function(a,b,d){this._select(a,b,d);this._fireSelectionEvents()},deselect:function(a,b){this.select(a,b,!1)},clearSelection:function(a,b){this.allSelected=!1;for(var d in this.selection)a!==d&&this._select(d,null,!1);b||(this._lastSelected=null);this._fireSelectionEvents()},
selectAll:function(){this.allSelected=!0;this.selection={};for(var a in this._rowIdToObject){var b=this.row(this._rowIdToObject[a]);this._select(b.id,null,!0)}this._fireSelectionEvents()},isSelected:function(a){if("undefined"===typeof a||null===a)return!1;a.element||(a=this.row(a));return a.id in this.selection?!!this.selection[a.id]:this.allSelected&&(!a.data||this.allowSelect(a))},refresh:function(){this.deselectOnRefresh&&this.clearSelection();this._lastSelected=null;return this.inherited(arguments)},
renderArray:function(){var a=this.inherited(arguments),b=this.selection,d,c,h;for(d=0;d<a.length;d++)c=this.row(a[d]),(h=c.id in b?b[c.id]:this.allSelected)&&this.select(c,null,h);this._fireSelectionEvents();return a}})})},"dojo/query":function(){define("./_base/kernel ./has ./dom ./on ./_base/array ./_base/lang ./selector/_loader ./selector/_loader!default".split(" "),function(g,n,l,p,k,f,m,e){function c(a,b){var d=function(d,c){if("string"==typeof c&&(c=l.byId(c),!c))return new b([]);var h="string"==
typeof d?a(d,c):d?d.end&&d.on?d:[d]:[];return h.end&&h.on?h:new b(h)};d.matches=a.match||function(a,b,c){return 0<d.filter([a],b,c).length};d.filter=a.filter||function(a,b,c){return d(b,c).filter(function(b){return-1<k.indexOf(a,b)})};if("function"!=typeof a){var c=a.search;a=function(a,b){return c(b||document,a)}}return d}n.add("array-extensible",function(){return 1==f.delegate([],{length:1}).length&&!n("bug-for-in-skips-shadowed")});var a=Array.prototype,b=a.slice,h=a.concat,d=k.forEach,q=function(a,
d,c){d=[0].concat(b.call(d,0));c=c||g.global;return function(b){d[0]=b;return a.apply(c,d)}},s=function(a){var b=this instanceof r&&n("array-extensible");"number"==typeof a&&(a=Array(a));var d=a&&"length"in a?a:arguments;if(b||!d.sort){for(var c=b?this:[],h=c.length=d.length,e=0;e<h;e++)c[e]=d[e];if(b)return c;d=c}f._mixin(d,v);d._NodeListCtor=function(a){return r(a)};return d},r=s,v=r.prototype=n("array-extensible")?[]:{};r._wrap=v._wrap=function(a,b,d){a=new (d||this._NodeListCtor||r)(a);return b?
a._stash(b):a};r._adaptAsMap=function(a,b){return function(){return this.map(q(a,arguments,b))}};r._adaptAsForEach=function(a,b){return function(){this.forEach(q(a,arguments,b));return this}};r._adaptAsFilter=function(a,b){return function(){return this.filter(q(a,arguments,b))}};r._adaptWithCondition=function(a,b,d){return function(){var c=arguments,h=q(a,c,d);if(b.call(d||g.global,c))return this.map(h);this.forEach(h);return this}};d(["slice","splice"],function(b){var d=a[b];v[b]=function(){return this._wrap(d.apply(this,
arguments),"slice"==b?this:null)}});d(["indexOf","lastIndexOf","every","some"],function(a){var d=k[a];v[a]=function(){return d.apply(g,[this].concat(b.call(arguments,0)))}});f.extend(s,{constructor:r,_NodeListCtor:r,toString:function(){return this.join(",")},_stash:function(a){this._parent=a;return this},on:function(a,b){var d=this.map(function(d){return p(d,a,b)});d.remove=function(){for(var a=0;a<d.length;a++)d[a].remove()};return d},end:function(){return this._parent?this._parent:new this._NodeListCtor(0)},
concat:function(a){var d=b.call(this,0),c=k.map(arguments,function(a){return b.call(a,0)});return this._wrap(h.apply(d,c),this)},map:function(a,b){return this._wrap(k.map(this,a,b),this)},forEach:function(a,b){d(this,a,b);return this},filter:function(a){var b=arguments,d=this,c=0;if("string"==typeof a){d=t._filterResult(this,b[0]);if(1==b.length)return d._stash(this);c=1}return this._wrap(k.filter(d,b[c],b[c+1]),this)},instantiate:function(a,b){var d=f.isFunction(a)?a:f.getObject(a);b=b||{};return this.forEach(function(a){new d(b,
a)})},at:function(){var a=new this._NodeListCtor(0);d(arguments,function(b){0>b&&(b=this.length+b);this[b]&&a.push(this[b])},this);return a._stash(this)}});var t=c(e,s);g.query=c(e,function(a){return s(a)});t.load=function(a,b,d){m.load(a,b,function(a){d(c(a,s))})};g._filterQueryResult=t._filterResult=function(a,b,d){return new s(t.filter(a,b,d))};g.NodeList=t.NodeList=s;return t})},"dojo/selector/_loader":function(){define(["../has","require"],function(g,n){if("undefined"!==typeof document){var l=
document.createElement("div");g.add("dom-qsa2.1",!!l.querySelectorAll);g.add("dom-qsa3",function(){try{return l.innerHTML="\x3cp class\x3d'TEST'\x3e\x3c/p\x3e",1==l.querySelectorAll(".TEST:empty").length}catch(k){}})}var p;return{load:function(k,f,m,e){if(e&&e.isBuild)m();else{e=n;k="default"==k?g("config-selectorEngine")||"css3":k;k="css2"==k||"lite"==k?"./lite":"css2.1"==k?g("dom-qsa2.1")?"./lite":"./acme":"css3"==k?g("dom-qsa3")?"./lite":"./acme":"acme"==k?"./acme":(e=f)&&k;if("?"==k.charAt(k.length-
1)){k=k.substring(0,k.length-1);var c=!0}if(c&&(g("dom-compliant-qsa")||p))return m(p);e([k],function(a){"./lite"!=k&&(p=a);m(a)})}}}})},"dojo/selector/lite":function(){define(["../has","../_base/kernel"],function(g,n){var l=document.createElement("div"),p=l.matches||l.webkitMatchesSelector||l.mozMatchesSelector||l.msMatchesSelector||l.oMatchesSelector,k=l.querySelectorAll,f=/([^\s,](?:"(?:\\.|[^"])+"|'(?:\\.|[^'])+'|[^,])*)/g;g.add("dom-matches-selector",!!p);g.add("dom-qsa",!!k);var m=function(b,
h){if(a&&-1<b.indexOf(","))return a(b,h);var d=h?h.ownerDocument||h:n.doc||document,f=(k?/^([\w]*)#([\w\-]+$)|^(\.)([\w\-\*]+$)|^(\w+$)/:/^([\w]*)#([\w\-]+)(?:\s+(.*))?$|(?:^|(>|.+\s+))([\w\-\*]+)(\S*$)/).exec(b);h=h||d;if(f){var l=8===g("ie")&&g("quirks")?h.nodeType===d.nodeType:null!==h.parentNode&&9!==h.nodeType&&h.parentNode===d;if(f[2]&&l){var p=n.byId?n.byId(f[2],d):d.getElementById(f[2]);if(!p||f[1]&&f[1]!=p.tagName.toLowerCase())return[];if(h!=d)for(d=p;d!=h;)if(d=d.parentNode,!d)return[];
return f[3]?m(f[3],p):[p]}if(f[3]&&h.getElementsByClassName)return h.getElementsByClassName(f[4]);if(f[5])if(p=h.getElementsByTagName(f[5]),f[4]||f[6])b=(f[4]||"")+f[6];else return p}if(k)return 1===h.nodeType&&"object"!==h.nodeName.toLowerCase()?e(h,b,h.querySelectorAll):h.querySelectorAll(b);p||(p=h.getElementsByTagName("*"));f=[];d=0;for(l=p.length;d<l;d++){var v=p[d];1==v.nodeType&&c(v,b,h)&&f.push(v)}return f},e=function(a,c,d){var e=a,m=a.getAttribute("id"),k=m||"__dojo__",g=a.parentNode,l=
/^\s*[+~]/.test(c);if(l&&!g)return[];m?k=k.replace(/'/g,"\\$\x26"):a.setAttribute("id",k);l&&g&&(a=a.parentNode);c=c.match(f);for(g=0;g<c.length;g++)c[g]="[id\x3d'"+k+"'] "+c[g];c=c.join(",");try{return d.call(a,c)}finally{m||e.removeAttribute("id")}};if(!g("dom-matches-selector"))var c=function(){function a(b,d,c){var h=d.charAt(0);if('"'==h||"'"==h)d=d.slice(1,-1);d=d.replace(/\\/g,"");var e=k[c||""];return function(a){return(a=a.getAttribute(b))&&e(a,d)}}function c(a){return function(b,d){for(;(b=
b.parentNode)!=d;)if(a(b,d))return!0}}function d(a){return function(b,d){b=b.parentNode;return a?b!=d&&a(b,d):b==d}}function e(a,b){return a?function(d,c){return b(d)&&a(d,c)}:b}var f="div"==l.tagName?"toLowerCase":"toUpperCase",m={"":function(a){a=a[f]();return function(b){return b.tagName==a}},".":function(a){var b=" "+a+" ";return function(d){return-1<d.className.indexOf(a)&&-1<(" "+d.className+" ").indexOf(b)}},"#":function(a){return function(b){return b.id==a}}},k={"^\x3d":function(a,b){return 0==
a.indexOf(b)},"*\x3d":function(a,b){return-1<a.indexOf(b)},"$\x3d":function(a,b){return a.substring(a.length-b.length,a.length)==b},"~\x3d":function(a,b){return-1<(" "+a+" ").indexOf(" "+b+" ")},"|\x3d":function(a,b){return 0==(a+"-").indexOf(b+"-")},"\x3d":function(a,b){return a==b},"":function(a,b){return!0}},g={};return function(f,k,l){var p=g[k];if(!p){if(k.replace(/(?:\s*([> ])\s*)|(#|\.)?((?:\\.|[\w-])+)|\[\s*([\w-]+)\s*(.?=)?\s*("(?:\\.|[^"])+"|'(?:\\.|[^'])+'|(?:\\.|[^\]])*)\s*\]/g,function(f,
k,g,l,t,n,u){l?p=e(p,m[g||""](l.replace(/\\/g,""))):k?p=(" "==k?c:d)(p):t&&(p=e(p,a(t,u,n)));return""}))throw Error("Syntax error in query");if(!p)return!0;g[k]=p}return p(f,l)}}();if(!g("dom-qsa"))var a=function(a,c){for(var d=a.match(f),e=[],k=0;k<d.length;k++){a=new String(d[k].replace(/\s*$/,""));a.indexOf=escape;for(var g=m(a,c),l=0,t=g.length;l<t;l++){var p=g[l];e[p.sourceIndex]=p}}d=[];for(k in e)d.push(e[k]);return d};m.match=p?function(a,c,d){return d&&9!=d.nodeType?e(d,c,function(d){return p.call(a,
d)}):p.call(a,c)}:c;return m})},"dgrid/extensions/ColumnResizer":function(){define("dojo/_base/declare dojo/_base/array dojo/on dojo/query dojo/_base/lang dojo/dom dojo/dom-construct dojo/dom-geometry dojo/has ../util/misc dojo/_base/html".split(" "),function(g,n,l,p,k,f,m,e,c,a){function b(a,b,d,c,h){for(var e=1;e<b;e++)a[d+e][c]=h}function h(a){for(var d=a.length,c=d,h=n.filter(a[0],function(a){return!a.hidden}).length,e=Array(d);d--;)e[d]=Array(h);for(var f={},d=0;d<c;d++)for(var k=e[d],m=a[d],
g=0,q=0;g<h;g++){var l=m[q],p;if("undefined"===typeof k[g]){k[g]=l.id;l.rowSpan&&1<l.rowSpan&&b(e,l.rowSpan,d,g,l.id);if(0<d&&l.colSpan&&1<l.colSpan)for(p=1;p<l.colSpan;p++)k[++g]=l.id,l.rowSpan&&1<l.rowSpan&&b(e,l.rowSpan,d,g,l.id);f[l.id]=a[0][g].id;q++}}return f}function d(b,d,c,h,e){if(!(0>=c)){var f=b.columns[d],k;if(f&&(k={grid:b,columnId:d,width:c,bubbles:!0,cancelable:!0},h&&(k.parentType=h),!b._resizedColumns||l.emit(b.headerNode,"dgrid-columnresize",k)))return"auto"===c?delete f.width:(f.width=
c,c+="px"),(h=b._columnSizes[d])?h.set("width",c):h=a.addCssRule("#"+a.escapeCssIdentifier(b.domNode.id)+" .dgrid-column-"+a.escapeCssIdentifier(d,"-"),"width: "+c+";"),b._columnSizes[d]=h,!1!==e&&b.resize(),!0}}var q,s,r=0,v={create:function(){q=m.create("div",{className:"dgrid-column-resizer"});s=m.create("div",{className:"dgrid-resize-guard"})},destroy:function(){m.destroy(q);m.destroy(s);q=s=null},show:function(a){var b=e.position(a.domNode,!0);q.style.top=b.y+"px";q.style.height=b.h+"px";document.body.appendChild(q);
a.domNode.appendChild(s)},move:function(a){q.style.left=a+"px"},hide:function(){q.parentNode.removeChild(q);s.parentNode.removeChild(s)}};return g(null,{resizeNode:null,minWidth:40,adjustLastColumn:!0,_resizedColumns:!1,buildRendering:function(){this.inherited(arguments);r||v.create();r++},destroy:function(){this.inherited(arguments);for(var a in this._columnSizes)this._columnSizes[a].remove();--r||v.destroy()},resizeColumnWidth:function(a,b){return d(this,a,b)},configStructure:function(){var a=this._oldColumnSizes=
k.mixin({},this._columnSizes),b;this._resizedColumns=!1;this._columnSizes={};this.inherited(arguments);for(b in a)b in this._columnSizes||a[b].remove();delete this._oldColumnSizes},_configColumn:function(b){this.inherited(arguments);var d=b.id,c;"width"in b&&((c=this._oldColumnSizes[d])?c.set("width",b.width+"px"):c=a.addCssRule("#"+a.escapeCssIdentifier(this.domNode.id)+" .dgrid-column-"+a.escapeCssIdentifier(d,"-"),"width: "+b.width+"px;"),this._columnSizes[d]=c)},renderHeader:function(){this.inherited(arguments);
var b=this,d;if(this.columnSets&&this.columnSets.length)for(var e=this.columnSets.length;e--;)d=k.mixin(d||{},h(this.columnSets[e]));else this.subRows&&1<this.subRows.length&&(d=h(this.subRows));for(var e=p(".dgrid-cell",b.headerNode),f=e.length;f--;){var g=e[f],q=g.columnId,n=b.columns[q],s=g.childNodes;if(n&&!1!==n.resizable){n=m.create("div",{className:"dgrid-resize-header-container"});for(g.contents=n;0<s.length;)n.appendChild(s[0]);s=m.create("div",{className:"dgrid-resize-handle resizeNode-"+
a.escapeCssIdentifier(q,"-")},n);g.appendChild(n);s.columnId=d&&d[q]||q}}b.mouseMoveListen||(l(b.headerNode,".dgrid-resize-handle:mousedown"+(c("touch")?",.dgrid-resize-handle:touchstart":""),function(a){b._resizeMouseDown(a,this);b.mouseMoveListen.resume();b.mouseUpListen.resume()}),b._listeners.push(b.mouseMoveListen=l.pausable(document,"mousemove"+(c("touch")?",touchmove":""),a.throttleDelayed(function(a){b._updateResizerPosition(a)}))),b._listeners.push(b.mouseUpListen=l.pausable(document,"mouseup"+
(c("touch")?",touchend":""),function(a){b._resizeMouseUp(a);b.mouseMoveListen.pause();b.mouseUpListen.pause()})),b.mouseMoveListen.pause(),b.mouseUpListen.pause())},_resizeMouseDown:function(b,d){b.preventDefault();f.setSelectable(this.domNode,!1);this._startX=this._getResizeMouseLocation(b);this._targetCell=p(".dgrid-column-"+a.escapeCssIdentifier(d.columnId,"-"),this.headerNode)[0];this._updateResizerPosition(b);v.show(this)},_resizeMouseUp:function(b){var c=this._columnSizes,h,e,k;this.adjustLastColumn&&
(k=this.headerNode.clientWidth-1);this._resizedColumns||(h=p(".dgrid-cell",this.headerNode),this.columnSets&&this.columnSets.length?h=h.filter(function(a){return"0"===a.columnId.split("-")[0]&&!(a.columnId in c)}):this.subRows&&1<this.subRows.length&&(h=h.filter(function(a){return"0"===a.columnId.charAt(0)&&!(a.columnId in c)})),e=h.map(function(a){return a.offsetWidth}),h.forEach(function(a,b){d(this,a.columnId,e[b],null,!1)},this),this._resizedColumns=!0);f.setSelectable(this.domNode,!0);h=this._targetCell;
var g=this._getResizeMouseLocation(b)-this._startX,m=h.offsetWidth+g,q=this._getResizedColumnWidths(),l=q.totalWidth,q=q.lastColId,n=p(".dgrid-column-"+a.escapeCssIdentifier(q,"-"),this.headerNode)[0].offsetWidth;m<this.minWidth&&(m=this.minWidth);d(this,h.columnId,m,b.type)&&h.columnId!==q&&this.adjustLastColumn&&(l+g<k?d(this,q,"auto",b.type):n-g<=this.minWidth&&d(this,q,this.minWidth,b.type));v.hide();delete this._startX;delete this._targetCell},_updateResizerPosition:function(a){if(this._targetCell){a=
this._getResizeMouseLocation(a);var b=this._targetCell.offsetWidth,d=a;b+(a-this._startX)<this.minWidth&&(d=this._startX-(b-this.minWidth));v.move(d)}},_getResizeMouseLocation:function(a){var b=0;a.pageX?b=a.pageX:a.clientX&&(b=a.clientX+document.body.scrollLeft+document.documentElement.scrollLeft);return b},_getResizedColumnWidths:function(){var a=0,b=p((this.columnSets?".dgrid-column-set-cell ":"")+"tr:first-child .dgrid-cell",this.headerNode),d=b.length;if(!d)return{};for(var c=b[d-1].columnId;d--;)a+=
b[d].offsetWidth;return{totalWidth:a,lastColId:c}}})})},"dojo/_base/html":function(){define("./kernel ../dom ../dom-style ../dom-attr ../dom-prop ../dom-class ../dom-construct ../dom-geometry".split(" "),function(g,n,l,p,k,f,m,e){g.byId=n.byId;g.isDescendant=n.isDescendant;g.setSelectable=n.setSelectable;g.getAttr=p.get;g.setAttr=p.set;g.hasAttr=p.has;g.removeAttr=p.remove;g.getNodeProp=p.getNodeProp;g.attr=function(c,a,b){return 2==arguments.length?p["string"==typeof a?"get":"set"](c,a):p.set(c,
a,b)};g.hasClass=f.contains;g.addClass=f.add;g.removeClass=f.remove;g.toggleClass=f.toggle;g.replaceClass=f.replace;g._toDom=g.toDom=m.toDom;g.place=m.place;g.create=m.create;g.empty=function(c){m.empty(c)};g._destroyElement=g.destroy=function(c){m.destroy(c)};g._getPadExtents=g.getPadExtents=e.getPadExtents;g._getBorderExtents=g.getBorderExtents=e.getBorderExtents;g._getPadBorderExtents=g.getPadBorderExtents=e.getPadBorderExtents;g._getMarginExtents=g.getMarginExtents=e.getMarginExtents;g._getMarginSize=
g.getMarginSize=e.getMarginSize;g._getMarginBox=g.getMarginBox=e.getMarginBox;g.setMarginBox=e.setMarginBox;g._getContentBox=g.getContentBox=e.getContentBox;g.setContentSize=e.setContentSize;g._isBodyLtr=g.isBodyLtr=e.isBodyLtr;g._docScroll=g.docScroll=e.docScroll;g._getIeDocumentElementOffset=g.getIeDocumentElementOffset=e.getIeDocumentElementOffset;g._fixIeBiDiScrollLeft=g.fixIeBiDiScrollLeft=e.fixIeBiDiScrollLeft;g.position=e.position;g.marginBox=function(c,a){return a?e.setMarginBox(c,a):e.getMarginBox(c)};
g.contentBox=function(c,a){return a?e.setContentSize(c,a):e.getContentBox(c)};g.coords=function(c,a){g.deprecated("dojo.coords()","Use dojo.position() or dojo.marginBox().");c=n.byId(c);var b=l.getComputedStyle(c),b=e.getMarginBox(c,b),h=e.position(c,a);b.x=h.x;b.y=h.y;return b};g.getProp=k.get;g.setProp=k.set;g.prop=function(c,a,b){return 2==arguments.length?k["string"==typeof a?"get":"set"](c,a):k.set(c,a,b)};g.getStyle=l.get;g.setStyle=l.set;g.getComputedStyle=l.getComputedStyle;g.__toPixelValue=
g.toPixelValue=l.toPixelValue;g.style=function(c,a,b){switch(arguments.length){case 1:return l.get(c);case 2:return l["string"==typeof a?"get":"set"](c,a)}return l.set(c,a,b)};return g})},"dgrid/Keyboard":function(){define("dojo/_base/declare dojo/aspect dojo/dom-class dojo/on dojo/_base/lang dojo/has ./util/misc dojo/_base/sniff".split(" "),function(g,n,l,p,k,f,m){function e(a){a.preventDefault()}var c={checkbox:1,radio:1,button:1},a=/\bdgrid-cell\b/,b=/\bdgrid-row\b/,h=g(null,{pageSkip:10,tabIndex:0,
keyMap:null,headerKeyMap:null,postMixInProperties:function(){this.inherited(arguments);this.keyMap||(this.keyMap=k.mixin({},h.defaultKeyMap));this.headerKeyMap||(this.headerKeyMap=k.mixin({},h.defaultHeaderKeyMap))},postCreate:function(){function d(a){var b=a.target;return b.type&&(!c[b.type]||32===a.keyCode)}function h(c){function f(){e._focusedHeaderNode&&(e._focusedHeaderNode.tabIndex=-1);if(e.showHeader){if(g)for(var a=e.headerNode.getElementsByTagName("th"),b=0,d;d=a[b];++b){if(m.test(d.className)){e._focusedHeaderNode=
l=d;break}}else e._focusedHeaderNode=l=e.headerNode;l&&(l.tabIndex=e.tabIndex)}}function k(){var a=e._focusedNode||l;if(!m.test(a.className)||!c.contains(a)){for(var b=c.getElementsByTagName("*"),d=0,h;h=b[d];++d)if(m.test(h.className)){a=e._focusedNode=h;break}l.tabIndex=-1;a.tabIndex=e.tabIndex}}var g=e.cellNavigation,m=g?a:b,q=c===e.headerNode,l=c;q?(f(),n.after(e,"renderHeader",f,!0)):(n.after(e,"renderArray",k,!0),n.after(e,"_onNotification",function(a,b){0===b.totalLength?c.tabIndex=0:1===b.totalLength&&
"add"===b.type&&k()},!0));e._listeners.push(p(c,"mousedown",function(a){d(a)||e._focusOnNode(a.target,q,a)}));e._listeners.push(p(c,"keydown",function(a){if(!a.metaKey&&!a.altKey){var b=e[q?"headerKeyMap":"keyMap"][a.keyCode];b&&!d(a)&&b.call(e,a)}}))}this.inherited(arguments);var e=this;this.tabableHeader&&(h(this.headerNode),p(this.headerNode,"dgrid-cellfocusin",function(){e.scrollTo({x:this.scrollLeft})}));h(this.contentNode);this._debouncedEnsureScroll=m.debounce(this._ensureScroll,this)},removeRow:function(a){if(!this._focusedNode)return this.inherited(arguments);
var b=this,d=document.activeElement===this._focusedNode,c=this[this.cellNavigation?"cell":"row"](this._focusedNode),h=c.row||c,e;a=a.element||a;if(a===h.element){e=this.down(h,!0);if(!e||e.element===a)e=this.up(h,!0);this._removedFocus={active:d,rowId:h.id,columnId:c.column&&c.column.id,siblingId:!e||e.element===a?void 0:e.id};setTimeout(function(){b._removedFocus&&b._restoreFocus(h.id)},0);this._focusedNode=null}this.inherited(arguments)},insertRow:function(){var a=this.inherited(arguments);this._removedFocus&&
!this._removedFocus.wait&&this._restoreFocus(a);return a},_restoreFocus:function(a){var b=this._removedFocus,d;if((a=(a=a&&this.row(a))&&a.element&&a.id===b.rowId?a:"undefined"!==typeof b.siblingId&&this.row(b.siblingId))&&a.element){if(!a.element.parentNode.parentNode){b.wait=!0;return}"undefined"!==typeof b.columnId&&(d=this.cell(a,b.columnId))&&d.element&&(a=d);b.active&&0!==a.element.offsetHeight?this._focusOnNode(a,!1,null):(l.add(a.element,"dgrid-focus"),a.element.tabIndex=this.tabIndex,this._focusedNode=
a.element)}delete this._removedFocus},addKeyHandler:function(a,b,d){return n.after(this[d?"headerKeyMap":"keyMap"],a,b,!0)},_ensureRowScroll:function(a){var b=this.getScrollPosition().y;b>a.offsetTop?this.scrollTo({y:a.offsetTop}):b+this.contentNode.offsetHeight<a.offsetTop+a.offsetHeight&&this.scrollTo({y:a.offsetTop-this.contentNode.offsetHeight+a.offsetHeight})},_ensureColumnScroll:function(a){var b=this.getScrollPosition().x,d=a.offsetLeft;if(b>d)this.scrollTo({x:d});else{var c=this.bodyNode.clientWidth;
a=a.offsetWidth;var h=d+a;b+c<h&&this.scrollTo({x:c>a?h-c:d})}},_ensureScroll:function(a,b){this.cellNavigation&&((this.columnSets||1<this.subRows.length)&&!b)&&this._ensureRowScroll(a.row.element);this.bodyNode.clientWidth<this.contentNode.offsetWidth&&this._ensureColumnScroll(a.element)},_focusOnNode:function(d,c,h){var e="_focused"+(c?"Header":"")+"Node",f=this[e],g=this.cellNavigation?"cell":"row",m=this[g](d),q,n,s,t,r;if(d=m&&m.element){if(this.cellNavigation){q=d.getElementsByTagName("input");
r=0;for(s=q.length;r<s;r++)if(n=q[r],(-1!==n.tabIndex||"_dgridLastValue"in n)&&!n.disabled){n.focus();t=!0;break}}null!==h&&(h=k.mixin({grid:this},h),h.type&&(h.parentType=h.type),h.bubbles||(h.bubbles=!0));f&&(l.remove(f,"dgrid-focus"),f.removeAttribute("tabindex"),h&&(h[g]=this[g](f),p.emit(f,"dgrid-cellfocusout",h)));f=this[e]=d;h&&(h[g]=m);e=this.cellNavigation?a:b;!t&&e.test(d.className)&&(d.tabIndex=this.tabIndex,d.focus());l.add(d,"dgrid-focus");h&&p.emit(f,"dgrid-cellfocusin",h);this._debouncedEnsureScroll(m,
c)}},focusHeader:function(a){this._focusOnNode(a||this._focusedHeaderNode,!0)},focus:function(a){(a=a||this._focusedNode)?this._focusOnNode(a,!1):(this._removedFocus&&(this._removedFocus.active=!0),this.contentNode.focus())}}),d=h.moveFocusVertical=function(a,b){var d=this.cellNavigation,c=this[d?"cell":"row"](a),c=d&&c.column.id,h=this.down(this._focusedNode,b,!0);d&&(h=this.cell(h,c));this._focusOnNode(h,!1,a);a.preventDefault()};g=h.moveFocusUp=function(a){d.call(this,a,-1)};var q=h.moveFocusDown=
function(a){d.call(this,a,1)},s=h.moveFocusPageUp=function(a){d.call(this,a,-this.pageSkip)},r=h.moveFocusPageDown=function(a){d.call(this,a,this.pageSkip)},v=h.moveFocusHorizontal=function(a,b){if(this.cellNavigation){var d=!this.row(a);this._focusOnNode(this.right(this["_focused"+(d?"Header":"")+"Node"],b),d,a);a.preventDefault()}},t=h.moveFocusLeft=function(a){v.call(this,a,-1)},u=h.moveFocusRight=function(a){v.call(this,a,1)},w=h.moveHeaderFocusEnd=function(a,b){var d;this.cellNavigation&&(d=
this.headerNode.getElementsByTagName("th"),this._focusOnNode(d[b?0:d.length-1],!0,a));a.preventDefault()},A=h.moveHeaderFocusHome=function(a){w.call(this,a,!0)},y=h.moveFocusEnd=function(a,b){var d=this.cellNavigation,c=this.contentNode,h=c.scrollTop+(b?0:c.scrollHeight),c=c[b?"firstChild":"lastChild"],e=-1<c.className.indexOf("dgrid-preload"),g=e?c[(b?"next":"previous")+"Sibling"]:c,m;a.preventDefault();this.scrollTo({y:h});if(e){for(;g&&0>g.className.indexOf("dgrid-row");)g=g[(b?"next":"previous")+
"Sibling"];if(!g)return}!e||1>c.offsetHeight?(d&&(g=this.cell(g,this.cell(a).column.id)),this._focusOnNode(g,!1,a)):(f("dom-addeventlistener")||(a=k.mixin({},a)),m=n.after(this,"renderArray",function(c){var h=c[b?0:c.length-1];d&&(h=this.cell(h,this.cell(a).column.id));this._focusOnNode(h,!1,a);m.remove();return c}))},x=h.moveFocusHome=function(a){y.call(this,a,!0)};h.defaultKeyMap={32:e,33:s,34:r,35:y,36:x,37:t,38:g,39:u,40:q};h.defaultHeaderKeyMap={32:e,35:w,36:A,37:t,39:u};return h})},"dgrid/extensions/ColumnHider":function(){define("dojo/_base/declare dojo/dom-construct dojo/has dojo/on ../util/misc dojo/i18n!./nls/columnHider".split(" "),
function(g,n,l,p,k,f){var m,e;return g(null,{hiderMenuNode:null,hiderToggleNode:null,i18nColumnHider:f,_hiderMenuOpened:!1,_columnHiderRules:null,_columnHiderCheckboxes:null,_renderHiderMenuEntries:function(){var c=this.subRows,a=!0,b,h,d,e;delete this._columnHiderFirstCheckbox;d=0;for(b=c.length;d<b;d++){e=0;for(h=c[d].length;e<h;e++)this._renderHiderMenuEntry(c[d][e]),a&&(a=!1,this._columnHiderFirstCheckbox=this._columnHiderCheckboxes[c[d][e].id])}},_renderHiderMenuEntry:function(c){var a=c.id,
b=k.escapeCssIdentifier(a,"-"),h,d;c.hidden&&(c.hidden=!1,this._hideColumn(a),c.hidden=!0);c.unhidable||(h=n.create("div",{className:"dgrid-hider-menu-row"}),d=this.domNode.id+"-hider-menu-check-"+b,a=this._columnHiderCheckboxes[a]=n.create("input",{className:"dgrid-hider-menu-check hider-menu-check-"+b,id:d,type:"checkbox"},h),b=n.create("label",{className:"dgrid-hider-menu-label hider-menu-label-"+b,"for":d},h),b.appendChild(document.createTextNode(c.label||c.field||"")),this.hiderMenuNode.appendChild(h),
c.hidden||(a.checked=!0))},renderHeader:function(){function c(a){a.stopPropagation()}var a=this,b=this.hiderMenuNode,h=this.hiderToggleNode,d;this.inherited(arguments);if(b){for(d in this._columnHiderRules)this._columnHiderRules[d].remove();b.innerHTML=""}else h=this.hiderToggleNode=n.create("button",{"aria-label":this.i18nColumnHider.popupTriggerLabel,className:"ui-icon dgrid-hider-toggle",type:"button"},this.domNode),this._listeners.push(p(h,"click",function(b){a._toggleColumnHiderMenu(b)})),b=
this.hiderMenuNode=n.create("div",{"aria-label":this.i18nColumnHider.popupLabel,className:"dgrid-hider-menu",id:this.id+"-hider-menu",role:"dialog"}),this._listeners.push(p(b,"keyup",function(b){if(27===(b.charCode||b.keyCode))a._toggleColumnHiderMenu(b),h.focus()})),b.style.display="none",this.domNode.appendChild(b),this._listeners.push(p(b,".dgrid-hider-menu-check:"+(9>l("ie")?"click":"change"),function(b){a._updateColumnHiddenState(b.target.id.substr(a.id.length+18),!b.target.checked)})),this._listeners.push(p(b,
"mousedown",c),p(h,"mousedown",c)),e||(e=p.pausable(document,"mousedown",function(a){m&&m._toggleColumnHiderMenu(a)}),e.pause());this._columnHiderCheckboxes={};this._columnHiderRules={};this._renderHiderMenuEntries()},destroy:function(){this.inherited(arguments);for(var c in this._columnHiderRules)this._columnHiderRules[c].remove()},left:function(c,a){return this.right(c,-a)},right:function(c,a){c.element||(c=this.cell(c));for(var b=this.inherited(arguments),h=c;b.column.hidden;){b=this.inherited(arguments,
[b,0<a?1:-1]);if(h.element===b.element)return c;h=b}return b},isColumnHidden:function(c){return!!this._columnHiderRules[c]},_toggleColumnHiderMenu:function(){var c=this._hiderMenuOpened,a=this.hiderMenuNode,b=this.domNode,h;a.style.display=c?"none":"";c?a.style.height="":(a.offsetHeight>b.offsetHeight-12&&(a.style.height=b.offsetHeight-12+"px"),(h=this._columnHiderFirstCheckbox)&&h.focus());e[c?"pause":"resume"]();m=c?null:this;this._hiderMenuOpened=!c},_hideColumn:function(c){var a=this,b="#"+k.escapeCssIdentifier(this.domNode.id)+
" .dgrid-column-",h;if(!this._columnHiderRules[c]&&(this._columnHiderRules[c]=k.addCssRule(b+k.escapeCssIdentifier(c,"-"),"display: none;"),8===l("ie")||10===l("ie")))h=k.addCssRule(".dgrid-row-table","display: inline-table;"),window.setTimeout(function(){h.remove();a.resize()},0)},_showColumn:function(c){this._columnHiderRules[c]&&(this._columnHiderRules[c].remove(),delete this._columnHiderRules[c])},_updateColumnHiddenState:function(c,a){this[a?"_hideColumn":"_showColumn"](c);this.columns[c].hidden=
a;p.emit(this.domNode,"dgrid-columnstatechange",{grid:this,column:this.columns[c],hidden:a,bubbles:!0});this.resize()},toggleColumnHiddenState:function(c,a){"undefined"===typeof a&&(a=!this._columnHiderRules[c]);this._updateColumnHiddenState(c,a);this._columnHiderCheckboxes[c]&&(this._columnHiderCheckboxes[c].checked=!a)}})})},"dojo/i18n":function(){define("./_base/kernel require ./has ./_base/array ./_base/config ./_base/lang ./_base/xhr ./json module".split(" "),function(g,n,l,p,k,f,m,e,c){l.add("dojo-preload-i18n-Api",
1);var a=g.i18n={},b=/(^.*(^|\/)nls)(\/|$)([^\/]*)\/?([^\/]*)/,h=function(a,b,d,c){var h=[d+c];b=b.split("-");for(var e="",f=0;f<b.length;f++)if(e+=(e?"-":"")+b[f],!a||a[e])h.push(d+e+"/"+c),h.specificity=e;return h},d={},q=function(a,b,d){d=d?d.toLowerCase():g.locale;a=a.replace(/\./g,"/");b=b.replace(/\./g,"/");return/root/i.test(d)?a+"/nls/"+b:a+"/nls/"+d+"/"+b},s=g.getL10nName=function(a,b,d){return c.id+"!"+q(a,b,d)},r=function(a,b,c,e,g,k){a([b],function(m){var q=f.clone(m.root||m.ROOT),l=h(!m._v1x&&
m,g,c,e);a(l,function(){for(var a=1;a<l.length;a++)q=f.mixin(f.clone(q),arguments[a]);d[b+"/"+g]=q;q.$locale=l.specificity;k()})})},v=function(a){var b=k.extraLocale||[],b=f.isArray(b)?b:[b];b.push(a);return b},t=function(a,c,h){if(l("dojo-preload-i18n-Api")){var k=a.split("*"),m="preload"==k[1];m&&(d[a]||(d[a]=1,y(k[2],e.parse(k[3]),1,c)),h(1));if(!(k=m))w&&A.push([a,c,h]),k=w;if(k)return}a=b.exec(a);var q=a[1]+"/",n=a[5]||a[4],s=q+n,k=(a=a[5]&&a[4])||g.locale||"",t=s+"/"+k;a=a?[k]:v(k);var u=a.length,
B=function(){--u||h(f.delegate(d[t]))};p.forEach(a,function(a){var b=s+"/"+a;l("dojo-preload-i18n-Api")&&x(b);d[b]?B():r(c,s,q,n,a,B)})};l("dojo-preload-i18n-Api");var u=a.normalizeLocale=function(a){a=a?a.toLowerCase():g.locale;return"root"==a?"ROOT":a},w=0,A=[],y=a._preloadLocalizations=function(a,b,c,h){function e(a,b){h.isXdUrl(n.toUrl(a+".js"))||c?h([a],b):B([a],b,h)}function k(a,b){for(var d=a.split("-");d.length;){if(b(d.join("-")))return;d.pop()}b("ROOT")}function m(){for(--w;!w&&A.length;)t.apply(null,
A.shift())}function q(c){c=u(c);k(c,function(g){if(0<=p.indexOf(b,g)){var q=a.replace(/\./g,"/")+"_"+g;w++;e(q,function(a){for(var b in a){var e=a[b],q=b.match(/(.+)\/([^\/]+)$/),l;if(q&&(l=q[2],q=q[1]+"/",e._localized)){var p;if("ROOT"===g){var s=p=e._localized;delete e._localized;s.root=e;d[n.toAbsMid(b)]=s}else p=e._localized,d[n.toAbsMid(q+l+"/"+g)]=e;g!==c&&function(a,b,e,g){var q=[],l=[];k(c,function(d){g[d]&&(q.push(n.toAbsMid(a+d+"/"+b)),l.push(n.toAbsMid(a+b+"/"+d)))});q.length?(w++,h(q,
function(){for(var h=q.length-1;0<=h;h--)e=f.mixin(f.clone(e),arguments[h]),d[l[h]]=e;d[n.toAbsMid(a+b+"/"+c)]=f.clone(e);m()})):d[n.toAbsMid(a+b+"/"+c)]=e}(q,l,e,p)}}m()});return!0}return!1})}h=h||n;q();p.forEach(g.config.extraLocale,q)},x=function(){},z={},C=new Function("__bundle","__checkForLegacyModules","__mid","__amdValue","var define \x3d function(mid, factory){define.called \x3d 1; __amdValue.result \x3d factory || mid;},\t   require \x3d function(){define.called \x3d 1;};try{define.called \x3d 0;eval(__bundle);if(define.called\x3d\x3d1)return __amdValue;if((__checkForLegacyModules \x3d __checkForLegacyModules(__mid)))return __checkForLegacyModules;}catch(e){}try{return eval('('+__bundle+')');}catch(e){return e;}"),
B=function(a,b,c){var h=[];p.forEach(a,function(a){function b(c){c=C(c,x,a,z);c===z?h.push(d[e]=z.result):(c instanceof Error&&(console.error("failed to evaluate i18n bundle; url\x3d"+e,c),c={}),h.push(d[e]=/nls\/[^\/]+\/[^\/]+$/.test(e)?c:{root:c,_v1x:1}))}var e=c.toUrl(a+".js");if(d[e])h.push(d[e]);else{var f=c.syncLoadNls(a);f||(f=x(a.replace(/nls\/([^\/]*)\/([^\/]*)$/,"nls/$2/$1")));if(f)h.push(f);else if(m)m.get({url:e,sync:!0,load:b,error:function(){h.push(d[e]={})}});else try{c.getText(e,!0,
b)}catch(g){h.push(d[e]={})}}});b&&b.apply(null,h)},x=function(a){for(var b,c=a.split("/"),h=g.global[c[0]],e=1;h&&e<c.length-1;h=h[c[e++]]);h&&((b=h[c[e]])||(b=h[c[e].replace(/-/g,"_")]),b&&(d[a]=b));return b};a.getLocalization=function(a,b,d){var c;a=q(a,b,d);t(a,!n.isXdUrl(n.toUrl(a+".js"))?function(a,b){B(a,b,n)}:n,function(a){c=a});return c};return f.mixin(a,{dynamic:!0,normalize:function(a,b){return/^\./.test(a)?b(a):a},load:t,cache:d,getL10nName:s})})},"dojo/_base/xhr":function(){define("./kernel ./sniff require ../io-query ../dom ../dom-form ./Deferred ./config ./json ./lang ./array ../on ../aspect ../request/watch ../request/xhr ../request/util".split(" "),
function(g,n,l,p,k,f,m,e,c,a,b,h,d,q,s,r){g._xhrObj=s._create;var v=g.config;g.objectToQuery=p.objectToQuery;g.queryToObject=p.queryToObject;g.fieldToObject=f.fieldToObject;g.formToObject=f.toObject;g.formToQuery=f.toQuery;g.formToJson=f.toJson;g._blockAsync=!1;var t=g._contentHandlers=g.contentHandlers={text:function(a){return a.responseText},json:function(a){return c.fromJson(a.responseText||null)},"json-comment-filtered":function(a){e.useCommentedJson||console.warn("Consider using the standard mimetype:application/json. json-commenting can introduce security issues. To decrease the chances of hijacking, use the standard the 'json' handler and prefix your json with: {}\x26\x26\nUse djConfig.useCommentedJson\x3dtrue to turn off this message.");
a=a.responseText;var b=a.indexOf("/*"),d=a.lastIndexOf("*/");if(-1==b||-1==d)throw Error("JSON was not comment filtered");return c.fromJson(a.substring(b+2,d))},javascript:function(a){return g.eval(a.responseText)},xml:function(a){var d=a.responseXML;d&&(n("dom-qsa2.1")&&!d.querySelectorAll&&n("dom-parser"))&&(d=(new DOMParser).parseFromString(a.responseText,"application/xml"));if(n("ie")&&(!d||!d.documentElement)){var c=function(a){return"MSXML"+a+".DOMDocument"},c=["Microsoft.XMLDOM",c(6),c(4),
c(3),c(2)];b.some(c,function(b){try{var c=new ActiveXObject(b);c.async=!1;c.loadXML(a.responseText);d=c}catch(h){return!1}return!0})}return d},"json-comment-optional":function(a){return a.responseText&&/^[^{\[]*\/\*/.test(a.responseText)?t["json-comment-filtered"](a):t.json(a)}};g._ioSetArgs=function(b,d,c,h){var e={args:b,url:b.url},q=null;if(b.form){var q=k.byId(b.form),l=q.getAttributeNode("action");e.url=e.url||(l?l.value:g.doc?g.doc.URL:null);q=f.toObject(q)}l=[{}];q&&l.push(q);b.content&&l.push(b.content);
b.preventCache&&l.push({"dojo.preventCache":(new Date).valueOf()});e.query=p.objectToQuery(a.mixin.apply(null,l));e.handleAs=b.handleAs||"text";var n=new m(function(a){a.canceled=!0;d&&d(a);var b=a.ioArgs.error;b||(b=Error("request cancelled"),b.dojoType="cancel",a.ioArgs.error=b);return b});n.addCallback(c);var s=b.load;s&&a.isFunction(s)&&n.addCallback(function(a){return s.call(b,a,e)});var t=b.error;t&&a.isFunction(t)&&n.addErrback(function(a){return t.call(b,a,e)});var r=b.handle;r&&a.isFunction(r)&&
n.addBoth(function(a){return r.call(b,a,e)});n.addErrback(function(a){return h(a,n)});v.ioPublish&&(g.publish&&!1!==e.args.ioPublish)&&(n.addCallbacks(function(a){g.publish("/dojo/io/load",[n,a]);return a},function(a){g.publish("/dojo/io/error",[n,a]);return a}),n.addBoth(function(a){g.publish("/dojo/io/done",[n,a]);return a}));n.ioArgs=e;return n};var u=function(a){a=t[a.ioArgs.handleAs](a.ioArgs.xhr);return void 0===a?null:a},w=function(a,b){b.ioArgs.args.failOk||console.error(a);return a},A=function(a){0>=
y&&(y=0,v.ioPublish&&(g.publish&&(!a||a&&!1!==a.ioArgs.args.ioPublish))&&g.publish("/dojo/io/stop"))},y=0;d.after(q,"_onAction",function(){y-=1});d.after(q,"_onInFlight",A);g._ioCancelAll=q.cancelAll;g._ioNotifyStart=function(a){v.ioPublish&&(g.publish&&!1!==a.ioArgs.args.ioPublish)&&(y||g.publish("/dojo/io/start"),y+=1,g.publish("/dojo/io/send",[a]))};g._ioWatch=function(b,d,c,h){b.ioArgs.options=b.ioArgs.args;a.mixin(b,{response:b.ioArgs,isValid:function(a){return d(b)},isReady:function(a){return c(b)},
handleResponse:function(a){return h(b)}});q(b);A(b)};g._ioAddQueryToUrl=function(a){a.query.length&&(a.url+=(-1==a.url.indexOf("?")?"?":"\x26")+a.query,a.query=null)};g.xhr=function(a,b,d){var c,h=g._ioSetArgs(b,function(a){c&&c.cancel()},u,w),e=h.ioArgs;"postData"in b?e.query=b.postData:"putData"in b?e.query=b.putData:"rawBody"in b?e.query=b.rawBody:(2<arguments.length&&!d||-1==="POST|PUT".indexOf(a.toUpperCase()))&&g._ioAddQueryToUrl(e);var f={method:a,handleAs:"text",timeout:b.timeout,withCredentials:b.withCredentials,
ioArgs:e};"undefined"!==typeof b.headers&&(f.headers=b.headers);"undefined"!==typeof b.contentType&&(f.headers||(f.headers={}),f.headers["Content-Type"]=b.contentType);"undefined"!==typeof e.query&&(f.data=e.query);"undefined"!==typeof b.sync&&(f.sync=b.sync);g._ioNotifyStart(h);try{c=s(e.url,f,!0)}catch(k){return h.cancel(),h}h.ioArgs.xhr=c.response.xhr;c.then(function(){h.resolve(h)}).otherwise(function(a){e.error=a;a.response&&(a.status=a.response.status,a.responseText=a.response.text,a.xhr=a.response.xhr);
h.reject(a)});return h};g.xhrGet=function(a){return g.xhr("GET",a)};g.rawXhrPost=g.xhrPost=function(a){return g.xhr("POST",a,!0)};g.rawXhrPut=g.xhrPut=function(a){return g.xhr("PUT",a,!0)};g.xhrDelete=function(a){return g.xhr("DELETE",a)};g._isDocumentOk=function(a){return r.checkStatus(a.status)};g._getText=function(a){var b;g.xhrGet({url:a,sync:!0,load:function(a){b=a}});return b};a.mixin(g.xhr,{_xhrObj:g._xhrObj,fieldToObject:f.fieldToObject,formToObject:f.toObject,objectToQuery:p.objectToQuery,
formToQuery:f.toQuery,formToJson:f.toJson,queryToObject:p.queryToObject,contentHandlers:t,_ioSetArgs:g._ioSetArgs,_ioCancelAll:g._ioCancelAll,_ioNotifyStart:g._ioNotifyStart,_ioWatch:g._ioWatch,_ioAddQueryToUrl:g._ioAddQueryToUrl,_isDocumentOk:g._isDocumentOk,_getText:g._getText,get:g.xhrGet,post:g.xhrPost,put:g.xhrPut,del:g.xhrDelete});return g.xhr})},"dojo/io-query":function(){define(["./_base/lang"],function(g){var n={};return{objectToQuery:function(l){var p=encodeURIComponent,k=[],f;for(f in l){var m=
l[f];if(m!=n[f]){var e=p(f)+"\x3d";if(g.isArray(m))for(var c=0,a=m.length;c<a;++c)k.push(e+p(m[c]));else k.push(e+p(m))}}return k.join("\x26")},queryToObject:function(l){var n=decodeURIComponent;l=l.split("\x26");for(var k={},f,m,e=0,c=l.length;e<c;++e)if(m=l[e],m.length){var a=m.indexOf("\x3d");0>a?(f=n(m),m=""):(f=n(m.slice(0,a)),m=n(m.slice(a+1)));"string"==typeof k[f]&&(k[f]=[k[f]]);g.isArray(k[f])?k[f].push(m):k[f]=m}return k}}})},"dojo/dom-form":function(){define(["./_base/lang","./dom","./io-query",
"./json"],function(g,n,l,p){var k={fieldToObject:function(f){var g=null;if(f=n.byId(f)){var e=f.name,c=(f.type||"").toLowerCase();if(e&&c&&!f.disabled)if("radio"==c||"checkbox"==c)f.checked&&(g=f.value);else if(f.multiple){g=[];for(f=[f.firstChild];f.length;)for(e=f.pop();e;e=e.nextSibling)if(1==e.nodeType&&"option"==e.tagName.toLowerCase())e.selected&&g.push(e.value);else{e.nextSibling&&f.push(e.nextSibling);e.firstChild&&f.push(e.firstChild);break}}else g=f.value}return g},toObject:function(f){var m=
{};f=n.byId(f).elements;for(var e=0,c=f.length;e<c;++e){var a=f[e],b=a.name,h=(a.type||"").toLowerCase();if(b&&h&&0>"file|submit|image|reset|button".indexOf(h)&&!a.disabled){var d=m,q=b,a=k.fieldToObject(a);if(null!==a){var l=d[q];"string"==typeof l?d[q]=[l,a]:g.isArray(l)?l.push(a):d[q]=a}"image"==h&&(m[b+".x"]=m[b+".y"]=m[b].x=m[b].y=0)}}return m},toQuery:function(f){return l.objectToQuery(k.toObject(f))},toJson:function(f,g){return p.stringify(k.toObject(f),null,g?4:0)}};return k})},"dojo/json":function(){define(["./has"],
function(g){var n="undefined"!=typeof JSON;g.add("json-parse",n);g.add("json-stringify",n&&'{"a":1}'==JSON.stringify({a:0},function(g,k){return k||1}));if(g("json-stringify"))return JSON;var l=function(g){return('"'+g.replace(/(["\\])/g,"\\$1")+'"').replace(/[\f]/g,"\\f").replace(/[\b]/g,"\\b").replace(/[\n]/g,"\\n").replace(/[\t]/g,"\\t").replace(/[\r]/g,"\\r")};return{parse:g("json-parse")?JSON.parse:function(g,k){if(k&&!/^([\s\[\{]*(?:"(?:\\.|[^"])*"|-?\d[\d\.]*(?:[Ee][+-]?\d+)?|null|true|false|)[\s\]\}]*(?:,|:|$))+$/.test(g))throw new SyntaxError("Invalid characters in JSON");
return eval("("+g+")")},stringify:function(g,k,f){function m(c,a,b){k&&(c=k(b,c));var h;h=typeof c;if("number"==h)return isFinite(c)?c+"":"null";if("boolean"==h)return c+"";if(null===c)return"null";if("string"==typeof c)return l(c);if("function"==h||"undefined"==h)return e;if("function"==typeof c.toJSON)return m(c.toJSON(b),a,b);if(c instanceof Date)return'"{FullYear}-{Month+}-{Date}T{Hours}:{Minutes}:{Seconds}Z"'.replace(/\{(\w+)(\+)?\}/g,function(a,b,d){a=c["getUTC"+b]()+(d?1:0);return 10>a?"0"+
a:a});if(c.valueOf()!==c)return m(c.valueOf(),a,b);var d=f?a+f:"",g=f?" ":"",n=f?"\n":"";if(c instanceof Array){var g=c.length,p=[];for(b=0;b<g;b++)h=m(c[b],d,b),"string"!=typeof h&&(h="null"),p.push(n+d+h);return"["+p.join(",")+n+a+"]"}p=[];for(b in c){var v;if(c.hasOwnProperty(b)){if("number"==typeof b)v='"'+b+'"';else if("string"==typeof b)v=l(b);else continue;h=m(c[b],d,b);"string"==typeof h&&p.push(n+d+v+":"+g+h)}}return"{"+p.join(",")+n+a+"}"}var e;"string"==typeof k&&(f=k,k=null);return m(g,
"","")}}})},"dojo/_base/Deferred":function(){define("./kernel ../Deferred ../promise/Promise ../errors/CancelError ../has ./lang ../when".split(" "),function(g,n,l,p,k,f,m){var e=function(){},c=Object.freeze||function(){},a=g.Deferred=function(b){function h(a){if(m)throw Error("This deferred has already been resolved");g=a;m=!0;d()}function d(){for(var a;!a&&w;){var b=w;w=w.next;if(a=b.progress==e)m=!1;var d=t?b.error:b.resolved;k("config-useDeferredInstrumentation")&&t&&n.instrumentRejected&&n.instrumentRejected(g,
!!d);if(d)try{var c=d(g);c&&"function"===typeof c.then?c.then(f.hitch(b.deferred,"resolve"),f.hitch(b.deferred,"reject"),f.hitch(b.deferred,"progress")):(d=a&&void 0===c,a&&!d&&(t=c instanceof Error),b.deferred[d&&t?"reject":"resolve"](d?g:c))}catch(h){b.deferred.reject(h)}else t?b.deferred.reject(g):b.deferred.resolve(g)}}var g,m,r,v,t,u,w,A=this.promise=new l;this.isResolved=A.isResolved=function(){return 0==v};this.isRejected=A.isRejected=function(){return 1==v};this.isFulfilled=A.isFulfilled=
function(){return 0<=v};this.isCanceled=A.isCanceled=function(){return r};this.resolve=this.callback=function(a){this.fired=v=0;this.results=[a,null];h(a)};this.reject=this.errback=function(a){t=!0;this.fired=v=1;k("config-useDeferredInstrumentation")&&n.instrumentRejected&&n.instrumentRejected(a,!!w);h(a);this.results=[null,a]};this.progress=function(a){for(var b=w;b;){var d=b.progress;d&&d(a);b=b.next}};this.addCallbacks=function(a,b){this.then(a,b,e);return this};A.then=this.then=function(b,c,
h){var f=h==e?this:new a(A.cancel);b={resolved:b,error:c,progress:h,deferred:f};w?u=u.next=b:w=u=b;m&&d();return f.promise};var y=this;A.cancel=this.cancel=function(){if(!m){var a=b&&b(y);m||(a instanceof Error||(a=new p(a)),a.log=!1,y.reject(a))}r=!0};c(A)};f.extend(a,{addCallback:function(a){return this.addCallbacks(f.hitch.apply(g,arguments))},addErrback:function(a){return this.addCallbacks(null,f.hitch.apply(g,arguments))},addBoth:function(a){var c=f.hitch.apply(g,arguments);return this.addCallbacks(c,
c)},fired:-1});a.when=g.when=m;return a})},"dojo/_base/json":function(){define(["./kernel","../json"],function(g,n){g.fromJson=function(g){return eval("("+g+")")};g._escapeString=n.stringify;g.toJsonIndentStr="\t";g.toJson=function(l,p){return n.stringify(l,function(g,f){if(f){var m=f.__json__||f.json;if("function"==typeof m)return m.call(f)}return f},p&&g.toJsonIndentStr)};return g})},"dojo/request/watch":function(){define("./util ../errors/RequestTimeoutError ../errors/CancelError ../_base/array ../_base/window ../has!host-browser?dom-addeventlistener?:../on:".split(" "),
function(g,n,l,p,k,f){function m(){for(var b=+new Date,h=0,d;h<a.length&&(d=a[h]);h++){var f=d.response,g=f.options;if(d.isCanceled&&d.isCanceled()||d.isValid&&!d.isValid(f))a.splice(h--,1),e._onAction&&e._onAction();else if(d.isReady&&d.isReady(f))a.splice(h--,1),d.handleResponse(f),e._onAction&&e._onAction();else if(d.startTime&&d.startTime+(g.timeout||0)<b)a.splice(h--,1),d.cancel(new n("Timeout exceeded",f)),e._onAction&&e._onAction()}e._onInFlight&&e._onInFlight(d);a.length||(clearInterval(c),
c=null)}function e(b){b.response.options.timeout&&(b.startTime=+new Date);b.isFulfilled()||(a.push(b),c||(c=setInterval(m,50)),b.response.options.sync&&m())}var c=null,a=[];e.cancelAll=function(){try{p.forEach(a,function(a){try{a.cancel(new l("All requests canceled."))}catch(b){}})}catch(b){}};k&&(f&&k.doc.attachEvent)&&f(k.global,"unload",function(){e.cancelAll()});return e})},"dojo/request/util":function(){define("exports ../errors/RequestError ../errors/CancelError ../Deferred ../io-query ../_base/array ../_base/lang ../promise/Promise".split(" "),
function(g,n,l,p,k,f,m,e){function c(a){return b(a)}function a(a){return void 0!==a.data?a.data:a.text}g.deepCopy=function(a,b){for(var c in b){var e=a[c],f=b[c];e!==f&&(e&&"object"===typeof e&&f&&"object"===typeof f?g.deepCopy(e,f):a[c]=f)}return a};g.deepCreate=function(a,b){b=b||{};var c=m.delegate(a),e,f;for(e in a)(f=a[e])&&"object"===typeof f&&(c[e]=g.deepCreate(f,b[e]));return g.deepCopy(c,b)};var b=Object.freeze||function(a){return a};g.deferred=function(h,d,f,k,r,v){var t=new p(function(a){d&&
d(t,h);return!a||!(a instanceof n)&&!(a instanceof l)?new l("Request canceled",h):a});t.response=h;t.isValid=f;t.isReady=k;t.handleResponse=r;f=t.then(c).otherwise(function(a){a.response=h;throw a;});g.notify&&f.then(m.hitch(g.notify,"emit","load"),m.hitch(g.notify,"emit","error"));k=f.then(a);r=new e;for(var u in k)k.hasOwnProperty(u)&&(r[u]=k[u]);r.response=f;b(r);v&&t.then(function(a){v.call(t,a)},function(a){v.call(t,h,a)});t.promise=r;t.then=r.then;return t};g.addCommonMethods=function(a,b){f.forEach(b||
["GET","POST","PUT","DELETE"],function(b){a[("DELETE"===b?"DEL":b).toLowerCase()]=function(d,c){c=m.delegate(c||{});c.method=b;return a(d,c)}})};g.parseArgs=function(a,b,c){var e=b.data,f=b.query;if(e&&!c&&"object"===typeof e&&!(e instanceof ArrayBuffer||e instanceof Blob))b.data=k.objectToQuery(e);f?("object"===typeof f&&(f=k.objectToQuery(f)),b.preventCache&&(f+=(f?"\x26":"")+"request.preventCache\x3d"+ +new Date)):b.preventCache&&(f="request.preventCache\x3d"+ +new Date);a&&f&&(a+=(~a.indexOf("?")?
"\x26":"?")+f);return{url:a,options:b,getHeader:function(a){return null}}};g.checkStatus=function(a){a=a||0;return 200<=a&&300>a||304===a||1223===a||!a}})},"dojo/errors/RequestError":function(){define(["./create"],function(g){return g("RequestError",function(g,l){this.response=l})})},"dojo/errors/RequestTimeoutError":function(){define(["./create","./RequestError"],function(g,n){return g("RequestTimeoutError",null,n,{dojoType:"timeout"})})},"dojo/request/xhr":function(){define(["../errors/RequestError",
"./watch","./handlers","./util","../has"],function(g,n,l,p,k){function f(a,b){var d=a.xhr;a.status=a.xhr.status;try{a.text=d.responseText}catch(c){}"xml"===a.options.handleAs&&(a.data=d.responseXML);if(!b)try{l(a)}catch(h){b=h}var e;if(b)this.reject(b);else{try{l(a)}catch(f){e=f}p.checkStatus(d.status)?e?this.reject(e):this.resolve(a):(b=e?new g("Unable to load "+a.url+" status: "+d.status+" and an error in handleAs: transformation of response",a):new g("Unable to load "+a.url+" status: "+d.status,
a),this.reject(b))}}function m(a){return this.xhr.getResponseHeader(a)}function e(l,u,r){var v=k("native-formdata")&&u&&u.data&&u.data instanceof FormData,y=p.parseArgs(l,p.deepCreate(s,u),v);l=y.url;u=y.options;var x,z=p.deferred(y,d,a,b,f,function(){x&&x()}),C=y.xhr=e._create();if(!C)return z.cancel(new g("XHR was not created")),r?z:z.promise;y.getHeader=m;h&&(x=h(C,z,y));var B=u.data,G=!u.sync,L=u.method;try{C.open(L,l,G,u.user||q,u.password||q);u.withCredentials&&(C.withCredentials=u.withCredentials);
k("native-response-type")&&u.handleAs in c&&(C.responseType=c[u.handleAs]);var M=u.headers;l=v?!1:"application/x-www-form-urlencoded";if(M)for(var P in M)"content-type"===P.toLowerCase()?l=M[P]:M[P]&&C.setRequestHeader(P,M[P]);l&&!1!==l&&C.setRequestHeader("Content-Type",l);(!M||!("X-Requested-With"in M))&&C.setRequestHeader("X-Requested-With","XMLHttpRequest");p.notify&&p.notify.emit("send",y,z.promise.cancel);C.send(B)}catch(I){z.reject(I)}n(z);C=null;return r?z:z.promise}k.add("native-xhr",function(){return"undefined"!==
typeof XMLHttpRequest});k.add("dojo-force-activex-xhr",function(){return k("activex")&&"file:"===window.location.protocol});k.add("native-xhr2",function(){if(k("native-xhr")&&!k("dojo-force-activex-xhr")){var a=new XMLHttpRequest;return"undefined"!==typeof a.addEventListener&&("undefined"===typeof opera||"undefined"!==typeof a.upload)}});k.add("native-formdata",function(){return"undefined"!==typeof FormData});k.add("native-response-type",function(){return k("native-xhr")&&"undefined"!==typeof(new XMLHttpRequest).responseType});
k.add("native-xhr2-blob",function(){if(k("native-response-type")){var a=new XMLHttpRequest;a.open("GET","/",!0);a.responseType="blob";var b=a.responseType;a.abort();return"blob"===b}});var c={blob:k("native-xhr2-blob")?"blob":"arraybuffer",document:"document",arraybuffer:"arraybuffer"},a,b,h,d;k("native-xhr2")?(a=function(a){return!this.isFulfilled()},d=function(a,b){b.xhr.abort()},h=function(a,b,d){function c(a){b.handleResponse(d)}function h(a){a=new g("Unable to load "+d.url+" status: "+a.target.status,
d);b.handleResponse(d,a)}function e(a){a.lengthComputable?(d.loaded=a.loaded,d.total=a.total,b.progress(d)):3===d.xhr.readyState&&(d.loaded="loaded"in a?a.loaded:a.position,b.progress(d))}a.addEventListener("load",c,!1);a.addEventListener("error",h,!1);a.addEventListener("progress",e,!1);return function(){a.removeEventListener("load",c,!1);a.removeEventListener("error",h,!1);a.removeEventListener("progress",e,!1);a=null}}):(a=function(a){return a.xhr.readyState},b=function(a){return 4===a.xhr.readyState},
d=function(a,b){var d=b.xhr,c=typeof d.abort;("function"===c||"object"===c||"unknown"===c)&&d.abort()});var q,s={data:null,query:null,sync:!1,method:"GET"};e._create=function(){throw Error("XMLHTTP not available");};if(k("native-xhr")&&!k("dojo-force-activex-xhr"))e._create=function(){return new XMLHttpRequest};else if(k("activex"))try{new ActiveXObject("Msxml2.XMLHTTP"),e._create=function(){return new ActiveXObject("Msxml2.XMLHTTP")}}catch(r){try{new ActiveXObject("Microsoft.XMLHTTP"),e._create=
function(){return new ActiveXObject("Microsoft.XMLHTTP")}}catch(v){}}p.addCommonMethods(e);return e})},"dojo/request/handlers":function(){define(["../json","../_base/kernel","../_base/array","../has","../selector/_loader"],function(g,n,l,p){function k(b){var c=a[b.options.handleAs];b.data=c?c(b):b.data||b.text;return b}p.add("activex","undefined"!==typeof ActiveXObject);p.add("dom-parser",function(a){return"DOMParser"in a});var f;if(p("activex")){var m=["Msxml2.DOMDocument.6.0","Msxml2.DOMDocument.4.0",
"MSXML2.DOMDocument.3.0","MSXML.DOMDocument"],e;f=function(a){function c(a){try{var b=new ActiveXObject(a);b.async=!1;b.loadXML(f);d=b;e=a}catch(h){return!1}return!0}var d=a.data,f=a.text;d&&(p("dom-qsa2.1")&&!d.querySelectorAll&&p("dom-parser"))&&(d=(new DOMParser).parseFromString(f,"application/xml"));if(!d||!d.documentElement)(!e||!c(e))&&l.some(m,c);return d}}var c=function(a){return!p("native-xhr2-blob")&&"blob"===a.options.handleAs&&"undefined"!==typeof Blob?new Blob([a.xhr.response],{type:a.xhr.getResponseHeader("Content-Type")}):
a.xhr.response},a={javascript:function(a){return n.eval(a.text||"")},json:function(a){return g.parse(a.text||null)},xml:f,blob:c,arraybuffer:c,document:c};k.register=function(b,c){a[b]=c};return k})},"dgrid/extensions/nls/columnHider":function(){define({root:{popupTriggerLabel:"Show or hide columns",popupLabel:"Show or hide columns"},es:!0,ro:!0,sl:!0})},"dgrid/Editor":function(){define("dojo/_base/declare dojo/_base/lang dojo/Deferred dojo/dom-construct dojo/dom-class dojo/on dojo/has dojo/query ./Grid dojo/_base/sniff".split(" "),
function(g,n,l,p,k,f,m,e,c){return g(null,{constructor:function(){this._editorInstances={};this._editorColumnListeners=[];this._editorCellListeners={};this._editorsPendingStartup=[]},postCreate:function(){var a=this;this.inherited(arguments);this.on(".dgrid-input:focusin",function(){a._focusedEditorCell=a.cell(this)});this._editorFocusoutHandle=f.pausable(this.domNode,".dgrid-input:focusout",function(){a._focusedEditorCell=null});this._listeners.push(this._editorFocusoutHandle)},insertRow:function(){this._editorRowListeners=
{};var a=this.inherited(arguments),b=this.row(a),c=this._editorCellListeners[a.id]=this._editorCellListeners[a.id]||{},d;for(d in this._editorRowListeners)c[d]=this._editorRowListeners[d];this._editorRowListeners=null;(c=this._previouslyFocusedEditorCell)&&c.row.id===b.id&&this.edit(this.cell(b,c.column.id));return a},refresh:function(){for(var a in this._editorInstances){var b=this._editorInstances[a].domNode;b&&b.parentNode&&b.parentNode.removeChild(b)}this.inherited(arguments)},removeRow:function(a){var b=
this,c=this._focusedEditorCell;c&&c.row.id===this.row(a).id&&(this._previouslyFocusedEditorCell=c,this._editorFocusoutHandle.pause(),setTimeout(function(){b._editorFocusoutHandle.resume();b._previouslyFocusedEditorCell=null},0));if(this._editorCellListeners[a.id]){for(var d in this._editorCellListeners[a.id])this._editorCellListeners[a.id][d].remove();delete this._editorCellListeners[a.id]}for(c=this._alwaysOnWidgetColumns.length;c--;)if(d=(d=this.cell(a,this._alwaysOnWidgetColumns[c].id).element)&&
(d.contents||d).widget)this._editorFocusoutHandle.pause(),d.destroyRecursive();return this.inherited(arguments)},renderArray:function(){var a=this.inherited(arguments);a.length?this._startupPendingEditors():this._editorsPendingStartup=[];return a},_onNotification:function(){this.inherited(arguments);this._startupPendingEditors()},_destroyColumns:function(){this._editorStructureCleanup();this.inherited(arguments)},_editorStructureCleanup:function(){var a=this._editorInstances,b=this._editorColumnListeners;
this._editTimer&&clearTimeout(this._editTimer);for(var c in a){var d=a[c];d.domNode&&d.destroyRecursive()}this._editorInstances={};for(a=b.length;a--;)b[a].remove();for(var e in this._editorCellListeners)for(c in this._editorCellListeners[e])this._editorCellListeners[e][c].remove();for(a=0;a<this._editorColumnListeners.length;a++)this._editorColumnListeners[a].remove();this._editorCellListeners={};this._editorColumnListeners=[];this._editorsPendingStartup=[]},_configColumns:function(){var a=this.inherited(arguments);
this._alwaysOnWidgetColumns=[];for(var b=0,c=a.length;b<c;b++)a[b].editor&&this._configureEditorColumn(a[b]);return a},_configureEditorColumn:function(a){var b=this,c=a.renderCell||this._defaultRenderCell,d=a.editOn,e="string"!==typeof a.editor;d?this._editorInstances[a.id]=this._createSharedEditor(a,c):e&&this._alwaysOnWidgetColumns.push(a);a.renderCell=d?function(e,g,k,m){if(!m||!m.alreadyHooked){var q=f(k,d,function(){b._activeOptions=m;b.edit(this)});if(b._editorRowListeners)b._editorRowListeners[a.id]=
q;else{var l=b.row(e);b._editorCellListeners[l.element.id][a.id]=q}}return c.call(a,e,g,k,m)}:function(d,f,g,k){if(!a.canEdit||a.canEdit(d,f))d=b._createEditor(a,d),b._showEditor(d,a,g,f),g[e?"widget":"input"]=d;else return c.call(a,d,f,g,k)}},edit:function(a){function b(a){c._activeCell=e;c._showEditor(m,d,e,k);c._editTimer=setTimeout(function(){m.focus&&m.focus();d._editorBlurHandle&&d._editorBlurHandle.resume();c._editTimer=null;a.resolve(m)},0)}var c=this,d,e,f,g,k,m,n;a.column||(a=this.cell(a));
if(!a||!a.element)return null;d=a.column;g=d.field;e=a.element.contents||a.element;if(m=this._editorInstances[d.id]){if(this._activeCell!==e){var p=a.row;k=(f=this.dirty&&this.dirty[p.id])&&g in f?f[g]:d.get?d.get(p.data):p.data[g];if(!d.canEdit||d.canEdit(a.row.data,k))return n=new l,a=m.domNode||m,a.offsetWidth?(a.blur(),setTimeout(function(){b(n)},0)):b(n),n.promise}}else if(d.editor&&(m=e.widget||e.input))return n=new l,m.focus&&m.focus(),n.resolve(m),n.promise;return null},refreshCell:function(a){var b=
a.column,c=b.get?b.get(a.row.data):a.row.data[b.field],d;b.editor&&(a.column.editOn&&this._activeCell===a.element?d=this._editorInstances[a.column.id]:a.column.editOn||(d=a.element.widget||a.element.input));return d?(d.domNode?d.set("value",c):this._updateInputValue(d,c),(new l).resolve()):this.inherited(arguments)},_showEditor:function(a,b,c,d){var e=a.domNode;e||this._updateInputValue(a,d);c.innerHTML="";k.add(c,"dgrid-cell-editing");e&&(b.editOn&&a.validate&&a.reset)&&a.reset();c.appendChild(a.domNode||
a);e&&!b.editOn?this._editorsPendingStartup.push([a,b,c,d]):this._startupEditor(a,b,c,d)},_startupEditor:function(a,b,c,d){a.domNode&&(a._started||a.startup(),a._dgridIgnoreChange=!0,a.set("value",d),setTimeout(function(){a._dgridIgnoreChange=!1},0));a._dgridLastValue=d;this._activeCell&&(this._activeValue=d,f.emit(c,"dgrid-editor-show",{grid:this,cell:this.cell(c),column:b,editor:a,bubbles:!0,cancelable:!1}))},_startupPendingEditors:function(){for(var a=this._editorsPendingStartup,b=a.length;b--;)this._startupEditor.apply(this,
a[b]);this._editorsPendingStartup=[]},_handleEditorChange:function(a,b){var c=a.target;"_dgridLastValue"in c&&-1<c.className.indexOf("dgrid-input")&&this._updatePropertyFromEditor(b||this.cell(c).column,c,a)},_createEditor:function(a,b){var c=a.editor,d=a.editOn,e=this,g="string"!==typeof c&&c,k,l,t={};k=a.editorArgs||{};"function"===typeof k&&(k=k.call(this,a));g?(l=new g(k),k=l.focusNode||l.domNode,k.className+=" dgrid-input",l.on(d?"blur":"change",function(){l._dgridIgnoreChange||e._updatePropertyFromEditor(a,
this,{type:"widget"})})):(this._hasInputListener||(this._hasInputListener=!0,this.on("change",function(a){e._handleEditorChange(a)})),"textarea"===c?g="textarea":(g="input",t.type=c),l=k=p.create(g,n.mixin(t,{className:"dgrid-input",name:a.field,tabIndex:isNaN(a.tabIndex)?-1:a.tabIndex},k)),9>m("ie")&&(c="radio"===c||"checkbox"===c?f(l,"click",function(b){e._handleEditorChange(b,a)}):f(l,"change",function(b){e._handleEditorChange(b,a)}),d?this._editorColumnListeners.push(c):this._editorRowListeners?
this._editorRowListeners[a.id]=c:this._editorCellListeners[this.row(b).element.id][a.id]=c));if(a.autoSelect){var u=l.focusNode||l;u.select&&f(u,"focus",function(){setTimeout(function(){u.select()},0)})}return l},_createSharedEditor:function(a){function b(){var a=d._activeCell;l.blur();"function"===typeof d.focus&&setTimeout(function(){d.focus(a)},e&&9>m("ie")?15:0)}var h=this._createEditor(a),d=this,e=h.domNode,g=h.domNode||h,l=h.focusNode||g,v=e?function(){h.set("value",h._dgridLastValue)}:function(){d._updateInputValue(h,
h._dgridLastValue);d._updatePropertyFromEditor(a,h)};this._editorColumnListeners.push(f(l,"keydown",function(c){c=c.keyCode||c.which;27===c?(v(),d._activeValue=h._dgridLastValue,b()):13===c&&!1!==a.dismissOnEnter&&b()}));(a._editorBlurHandle=f.pausable(h,"blur",function(){var b=g.parentNode,e={alreadyHooked:!0},m=d.cell(g);f.emit(m.element,"dgrid-editor-hide",{grid:d,cell:m,column:a,editor:h,bubbles:!0,cancelable:!1});a._editorBlurHandle.pause();b.removeChild(g);m.row&&(k.remove(m.element,"dgrid-cell-editing"),
p.empty(b),c.appendIfNode(b,a.renderCell(m.row.data,d._activeValue,b,d._activeOptions?n.delegate(e,d._activeOptions):e)));d._focusedEditorCell=d._activeCell=d._activeValue=d._activeOptions=null})).pause();this._editorColumnListeners.push(a._editorBlurHandle);return h},_updatePropertyFromEditor:function(a,b,c){var d;if(!b.isValid||b.isValid())if(c=this._updateProperty((b.domNode||b).parentNode,this._activeCell?this._activeValue:b._dgridLastValue,this._retrieveEditorValue(a,b),c),this._activeCell?this._activeValue=
c:b._dgridLastValue=c,"radio"===b.type&&b.name&&!a.editOn&&a.field)for(d in c=this.row(b),e("input[type\x3dradio][name\x3d"+b.name+"]",this.contentNode).forEach(function(d){var c=this.row(d);d!==b&&d._dgridLastValue&&(d._dgridLastValue=!1,this.updateDirty?this.updateDirty(c.id,a.field,!1):c.data[a.field]=!1)},this),this.dirty)c.id.toString()!==d&&this.dirty[d][a.field]&&this.updateDirty(d,a.field,!1)},_updateProperty:function(a,b,c,d){var e=this;if((b&&b.valueOf())!==(c&&c.valueOf())){var g=this.cell(a),
k=g.row,m=g.column;a=g.element;if(m.field&&k)if(g={grid:this,cell:g,oldValue:b,value:c,bubbles:!0,cancelable:!0},d&&d.type&&(g.parentType=d.type),f.emit(a,"dgrid-datachange",g))this.updateDirty?(this.updateDirty(k.id,m.field,c),m.autoSave&&setTimeout(function(){e._trackError("save")},0)):k.data[m.field]=c;else{var l;(l=a.widget)?(l._dgridIgnoreChange=!0,l.set("value",b),setTimeout(function(){l._dgridIgnoreChange=!1},0)):(l=a.input)&&this._updateInputValue(l,b);return b}}return c},_updateInputValue:function(a,
b){a.value=b;if("radio"===a.type||"checkbox"===a.type)a.checked=a.defaultChecked=!!b},_retrieveEditorValue:function(a,b){return"function"===typeof b.get?this._convertEditorValue(b.get("value")):this._convertEditorValue(b["checkbox"===b.type||"radio"===b.type?"checked":"value"])},_convertEditorValue:function(a,b){if("number"===typeof b)a=isNaN(a)?a:parseFloat(a);else if("boolean"===typeof b)a="true"===a?!0:"false"===a?!1:a;else if(b instanceof Date){var c=new Date(a);a=isNaN(c.getTime())?a:c}return a}})})},
"dstore/Memory":function(){define("dojo/_base/declare dojo/_base/lang dojo/_base/array ./Store ./Promised ./SimpleQuery ./QueryResults".split(" "),function(g,n,l,p,k,f,m){return g([p,k,f],{constructor:function(){this.storage.version=0},postscript:function(){this.inherited(arguments);this.setData(this.data||[])},data:null,autoEmitEvents:!1,getSync:function(e){return this.storage.fullData[this.storage.index[e]]},putSync:function(e,c){c=c||{};var a=this.storage,b=a.index,h=a.fullData,d=this.Model;d&&
!(e instanceof d)&&(e=this._restore(e));var f=this.getIdentity(e);null==f&&(this._setIdentity(e,"id"in c?c.id:Math.random()),f=this.getIdentity(e));a.version++;var a=f in b?"update":"add",d={target:e},g;if("update"===a){if(!1===c.overwrite)throw Error("Object already exists");h.splice(g=b[f],1);f=g}else f=this.defaultNewToStart?0:h.length;var k;if("beforeId"in c){var m=c.beforeId;null===m?k=h.length:(k=b[m],g<k&&--k);void 0!==k?d.beforeId=m:(console.error("options.beforeId was specified but no corresponding index was found"),
k=f)}else k=f;h.splice(k,0,e);g=isFinite(g)?Math.min(g,k):k;for(f=h.length;g<f;++g)b[this.getIdentity(h[g])]=g;this.emit(a,d);return e},addSync:function(e,c){(c=c||{}).overwrite=!1;return this.putSync(e,c)},removeSync:function(e){var c=this.storage,a=c.index,c=c.fullData;if(e in a)return a=c.splice(a[e],1)[0],this._reindex(),this.emit("delete",{id:e,target:a}),!0},setData:function(e){this.parse&&(e=this.parse(e));e.items&&(this.idProperty=e.identifier||this.idProperty,e=e.items);this.storage.fullData=
this.data=e;this._reindex()},_reindex:function(){for(var e=this.storage,c=e.index={},a=e.fullData,b=this.Model,h=Object.prototype,d=0,f=a.length;d<f;d++){var g=a[d];if(b&&!(g instanceof b)){var k=this._restore(g,g.__proto__===h);g!==k&&(a[d]=g=k)}c[this.getIdentity(g)]=d}e.version++},fetchSync:function(){var e=this.data;if(!e||e._version!==this.storage.version){for(var e=this.storage.fullData,c=this.queryLog,a=0,b=c.length;a<b;a++)e=c[a].querier(e);e._version=this.storage.version;this.data=e}return new m(e)},
fetchRangeSync:function(e){var c=this.fetchSync();return new m(c.slice(e.start,e.end),{totalLength:c.length})},_includePropertyInSubCollection:function(e){return"data"!==e&&this.inherited(arguments)}})})},"dstore/Store":function(){define("dojo/_base/lang dojo/_base/array dojo/aspect dojo/has dojo/when dojo/Deferred dojo/_base/declare ./QueryMethod ./Filter dojo/Evented".split(" "),function(g,n,l,p,k,f,m,e,c,a){function b(a){return function(b,c){var h=this;k(b,function(b){b={target:b};var e=c[1]||
{};"beforeId"in e&&(b.beforeId=e.beforeId);h.emit(a,b)});return b}}p.add("object-proto",!!{}.__proto__&&!{}.watch);var h=p("object-proto");return m(a,{constructor:function(d){d&&m.safeMixin(this,d);this.Model&&this.Model.createSubclass&&(this.Model=this.Model.createSubclass([]).extend({_store:this}));this.storage=new a;var c=this;this.autoEmitEvents&&(l.after(this,"add",b("add")),l.after(this,"put",b("update")),l.after(this,"remove",function(a,b){k(a,function(){c.emit("delete",{id:b[0]})});return a}))},
autoEmitEvents:!0,idProperty:"id",queryAccessors:!0,getIdentity:function(a){return a.get?a.get(this.idProperty):a[this.idProperty]},_setIdentity:function(a,b){a.set?a.set(this.idProperty,b):a[this.idProperty]=b},forEach:function(a,b){var c=this;return k(this.fetch(),function(h){for(var e=0,f;void 0!==(f=h[e]);e++)a.call(b,f,e,c);return h})},on:function(a,b){return this.storage.on(a,b)},emit:function(a,b){b=b||{};b.type=a;try{return this.storage.emit(a,b)}finally{return b.cancelable}},parse:null,stringify:null,
Model:null,_restore:function(a,b){var c=this.Model;if(c&&a){var e=c.prototype,f=e._restore;f?a=f.call(a,c,b):h&&b?a.__proto__=e:a=g.delegate(e,a)}return a},create:function(a){return new this.Model(a)},_createSubCollection:function(a){var b=g.delegate(this.constructor.prototype),c;for(c in this)this._includePropertyInSubCollection(c,b)&&(b[c]=this[c]);return m.safeMixin(b,a)},_includePropertyInSubCollection:function(a,b){return!(a in b)||b[a]!==this[a]},queryLog:[],filter:new e({type:"filter",normalizeArguments:function(a){var b=
this.Filter;return a instanceof b?[a]:[new b(a)]}}),Filter:c,sort:new e({type:"sort",normalizeArguments:function(a,b){var c;"function"===typeof a?c=[a]:(c=a instanceof Array?a.slice():"object"===typeof a?[].slice.call(arguments):[{property:a,descending:b}],c=n.map(c,function(a){a=g.mixin({},a);a.descending=!!a.descending;return a}),c=[c]);return c}}),select:new e({type:"select"}),_getQuerierFactory:function(a){return this["_create"+(a[0].toUpperCase()+a.substr(1))+"Querier"]}})})},"dstore/QueryMethod":function(){define([],
function(){return function(g){var n=g.type,l=g.normalizeArguments,p=g.applyQuery,k=g.querierFactory;return function(){var f=Array.prototype.slice.call(arguments),g=l?l.apply(this,f):f,f={type:n,arguments:f,normalizedArguments:g},e=this._getQuerierFactory(n)||k;e&&(f.querier=e.apply(this,g));g=this._createSubCollection({queryLog:this.queryLog.concat(f)});return p?p.call(this,g,f):g}}})},"dstore/Filter":function(){define(["dojo/_base/declare"],function(g){function n(g){return function(){var p=this.constructor,
k=new p;k.type=g;k.args=arguments;return this.type?n("and").call(p.prototype,this,k):k}}g=g(null,{constructor:function(g){var n=typeof g;switch(n){case "object":var n=this,k;for(k in g)var f=g[k],n=f instanceof this.constructor?n[f.type](k,f.args[0]):f&&f.test?n.match(k,f):n.eq(k,f);this.type=n.type;this.args=n.args;break;case "function":case "string":this.type=n,this.args=[g]}},and:n("and"),or:n("or"),eq:n("eq"),ne:n("ne"),lt:n("lt"),lte:n("lte"),gt:n("gt"),gte:n("gte"),contains:n("contains"),"in":n("in"),
match:n("match")});g.filterCreator=n;return g})},"dstore/Promised":function(){define(["dojo/_base/declare","dojo/Deferred","./QueryResults","dojo/when"],function(g,n,l,p){function k(f,g){return function(){var e=new n;try{e.resolve(this[f].apply(this,arguments))}catch(c){e.reject(c)}return g?(e=new l(e.promise),e.totalLength=p(e.totalLength),e):e.promise}}return g(null,{get:k("getSync"),put:k("putSync"),add:k("addSync"),remove:k("removeSync"),fetch:k("fetchSync",!0),fetchRange:k("fetchRangeSync",!0)})})},
"dstore/QueryResults":function(){define(["dojo/_base/lang","dojo/when"],function(g,n){function l(g,k){return n(this,function(f){for(var m=0,e=f.length;m<e;m++)g.call(k,f[m],m,f)})}return function(n,k){var f=k&&"totalLength"in k;if(n.then){n=g.delegate(n);var m=n.then(function(e){var c=f?k.totalLength:e.totalLength||e.length;e.totalLength=c;return!f&&c});n.totalLength=f?k.totalLength:m;n.response=k&&k.response}else n.totalLength=f?k.totalLength:n.length;n.forEach=l;return n}})},"dstore/SimpleQuery":function(){define(["dojo/_base/declare",
"dojo/_base/array"],function(g,n){function l(g,f){if(-1<g.indexOf(".")){var m=g.split("."),e=m.length;return function(c){for(var a=0;a<e;a++)c=c&&(f&&c.get?c.get(m[a]):c[m[a]]);return c}}return function(c){return c.get?c.get(g):c[g]}}var p={eq:function(g,f){return g===f},"in":function(g,f){return-1<n.indexOf(f.data||f,g)},ne:function(g,f){return g!==f},lt:function(g,f){return g<f},lte:function(g,f){return g<=f},gt:function(g,f){return g>f},gte:function(g,f){return g>=f},match:function(g,f,m){return f.test(g,
m)},contains:function(g,f,m,e){var c=this;return n.every(f.data||f,function(a){if("object"===typeof a&&a.type){var b=c._getFilterComparator(a.type);return n.some(g,function(h){return b.call(c,h,a.args[1],m,e)})}return-1<n.indexOf(g,a)})}};return g(null,{_createFilterQuerier:function(g){function f(a){var b=a.type;a=a.args;var h=e._getFilterComparator(b);if(h){var d=a[0],g=l(d,m),k=a[1];k&&k.fetchSync&&(k=k.fetchSync());return function(a){return h.call(e,g(a),k,a,d)}}switch(b){case "and":case "or":for(var n=
0,p=a.length;n<p;n++){var t=f(a[n]);c=c?function(a,d){return"and"===b?function(b){return a(b)&&d(b)}:function(b){return a(b)||d(b)}}(c,t):t}return c;case "function":return a[0];case "string":n=e[a[0]];if(!n)throw Error("No filter function "+a[0]+" was found in the collection");return n;case void 0:return function(){return!0};default:throw Error('Unknown filter operation "'+b+'"');}}var m=this.queryAccessors,e=this,c=f(g);return function(a){return n.filter(a,c)}},_getFilterComparator:function(g){return p[g]||
this.inherited(arguments)},_createSelectQuerier:function(g){return function(f){var m=g.length;return n.map(f,g instanceof Array?function(e){for(var c={},a=0;a<m;a++){var b=g[a];c[b]=e[b]}return c}:function(e){return e[g]})}},_createSortQuerier:function(g){var f=this.queryAccessors;return function(m){m=m.slice();m.sort("function"==typeof g?g:function(e,c){for(var a=0;a<g.length;a++){var b,h=g[a];if("function"==typeof h)b=h(e,c);else{b=h.get||(h.get=l(h.property,f));var h=h.descending,d=b(e);b=b(c);
null!=d&&(d=d.valueOf());null!=b&&(b=b.valueOf());b=d===b?0:Boolean(h)===("undefined"===typeof b||null===b&&"undefined"!==typeof d||null!=d&&d<b)?1:-1}if(0!==b)return b}return 0});return m}}})})},"dgrid/extensions/CompoundColumns":function(){define(["dojo/_base/lang","dojo/_base/declare","dojo/sniff","dojo/query","../util/misc"],function(g,n,l,p,k){return n(null,{configStructure:function(){function f(b,d,h,m){var l=0,q=function(){},n,p;k.each(b,function(k,z){"string"===typeof k&&(k={label:k});!(b instanceof
Array)&&!k.field&&(k.field=z);p=(n=k.children)&&!1!==k.showChildHeaders;k.parentColumn=m;n?null==k.id?k.id=(m&&m.id||d-1)+"-"+c.length:m&&m.id&&(k.id=m.id+"-"+k.id):(a.push(k),c.push(g.delegate(k,{renderHeaderCell:q})),l++);p||(k=g.delegate(k,{rowSpan:-d}));n&&(l+=k.colSpan=f(n,d+1,p,k));h&&(e[d]||(e[d]=[])).push(k)},this);return l}var m=this.subRows&&this.subRows[0]||this.columns,e=[[]],c=e[0],a=[];e[0].className="dgrid-spacer-row";f(m,1,!0);var m=e.length,b,h,d,l;for(b=0;b<m;b++){d=e[b];for(h=0;h<
d.length;h++)l=d[h],1>l.rowSpan&&(l.rowSpan+=m)}a=[a];a.headerRows=e;this.subRows=a;this.inherited(arguments)},renderHeader:function(){var f,g=this.subRows[0],e=this.subRows.headerRows[0];this.inherited(arguments);for(f=g.length;f--;)g[f].headerNode=e[f].headerNode},_findSortArrowParent:function(){var f=this.inherited(arguments),g=p(".dgrid-spacer-row",this.headerNode)[0];if(f&&g.contains(f))return f=f.columnId,f=p(".dgrid-column-"+f,this.headerNode),f[f.length-1]},_configColumn:function(f,g,e){var c=
f.parentColumn,a=f.id;c&&(a=0===a.indexOf(e)?a.substring(e.length):a,e=c.id+"-",f.id=e+a);this.inherited(arguments,[f,g,e])},cell:function(f,g){if("object"!==typeof g){var e=this.column(g);e&&(g=e.id)}return this.inherited(arguments,[f,g])},column:function(f){var g=this.inherited(arguments);if(null==g&&"object"!==typeof f){var e="-"+f,c=e.length,a;for(a in this.columns)if(-1!==a.indexOf(e,a.length-c))return this.columns[a]}return g},_updateCompoundHiddenStates:function(f,g){var e=this.columns[f],
c;if(!(e&&e.hidden===g))for(;e&&e.parentColumn;){e=e.parentColumn;if(c=e.colSpan+=g?-1:1)e.headerNode.colSpan=c;1===c&&!g?this._showColumn(e.id):!c&&g&&this._hideColumn(e.id)}},_hideColumn:function(f){var g=this;this._updateCompoundHiddenStates(f,!0);this.inherited(arguments);l("ff")&&(this.headerNode.style.display="none",setTimeout(function(){g.headerNode.style.display="";g.resize()},0))},_showColumn:function(f){this._updateCompoundHiddenStates(f,!1);this.inherited(arguments)},_getResizedColumnWidths:function(){var f=
0,g=this.columns,e;for(e in g)f+=g[e].headerNode.offsetWidth;return{totalWidth:f,lastColId:this.subRows[0][this.subRows[0].length-1].id}}})})},"dstore/Rest":function(){define("dojo/request dojo/when dojo/_base/lang dojo/json dojo/io-query dojo/_base/declare ./Request".split(" "),function(g,n,l,p,k,f,m){return f(m,{stringify:p.stringify,_getTarget:function(e){var c=this.target;return"/"==c.slice(-1)?c+e:c+"/"+e},get:function(e,c){c=c||{};var a=l.mixin({Accept:this.accepts},this.headers,c.headers||
c),b=this;return g(this._getTarget(e),{headers:a}).then(function(a){return b._restore(b.parse(a),!0)})},autoEmitEvents:!1,put:function(e,c){c=c||{};var a="id"in c?c.id:this.getIdentity(e),b="undefined"!==typeof a,h=this,d="beforeId"in c?null===c.beforeId?{"Put-Default-Position":"end"}:{"Put-Before":c.beforeId}:!b||!1===c.overwrite?{"Put-Default-Position":this.defaultNewToStart?"start":"end"}:null,f=g(b?this._getTarget(a):this.target,{method:b&&!c.incremental?"PUT":"POST",data:this.stringify(e),headers:l.mixin({"Content-Type":"application/json",
Accept:this.accepts,"If-Match":!0===c.overwrite?"*":null,"If-None-Match":!1===c.overwrite?"*":null},d,this.headers,c.headers)});return f.then(function(a){var b={};"beforeId"in c&&(b.beforeId=c.beforeId);a=b.target=a&&h._restore(h.parse(a),!0)||e;n(f.response,function(a){h.emit(201===a.status?"add":"update",b)});return a})},add:function(e,c){c=c||{};c.overwrite=!1;return this.put(e,c)},remove:function(e,c){c=c||{};var a=this;return g(this._getTarget(e),{method:"DELETE",headers:l.mixin({},this.headers,
c.headers)}).then(function(b){var c=b&&a.parse(b);a.emit("delete",{id:e,target:c});return b?c:!0})}})})},"dojo/request":function(){define(["./request/default!"],function(g){return g})},"dojo/request/default":function(){define(["exports","require","../has"],function(g,n,l){var p=l("config-requestProvider");p||(p="./xhr");g.getPlatformDefaultId=function(){return"./xhr"};g.load=function(g,f,m,e){n(["platform"==g?"./xhr":p],function(c){m(c)})}})},"dstore/Request":function(){define("dojo/request dojo/_base/lang dojo/_base/array dojo/json dojo/_base/declare ./Store ./QueryResults".split(" "),
function(g,n,l,p,k,f,m){var e=[].push;return k(f,{constructor:function(){this.headers||(this.headers={});this._targetContainsQueryString=0<=this.target.lastIndexOf("?")},headers:{},parse:p.parse,target:"",ascendingPrefix:"+",descendingPrefix:"-",accepts:"application/json",fetch:function(c){c=this._request(c);return new m(c.data,{response:c.response})},fetchRange:function(c){var a=c.start,b=c.end,h={};this.useRangeHeaders?h.headers=n.mixin(this._renderRangeHeaders(a,b),c.headers):(h.queryParams=this._renderRangeParams(a,
b),c.headers&&(h.headers=c.headers));c=this._request(h);return new m(c.data,{totalLength:c.total,response:c.response})},_request:function(c){c=c||{};var a=n.delegate(this.headers,{Accept:this.accepts});"headers"in c&&n.mixin(a,c.headers);c=this._renderUrl(c.queryParams);var b=g(c,{method:"GET",headers:a}),h=this,a=b.then(function(a){return h.parse(a)});return{data:a.then(function(a){a=a.items||a;for(var b=0,c=a.length;b<c;b++)a[b]=h._restore(a[b],!0);return a}),total:a.then(function(a){a=a.total;
return-1<a?a:b.response.then(function(a){return(a=a.getHeader("Content-Range"))&&(a=a.match(/\/(.*)/))&&+a[1]})}),response:b.response}},_renderFilterParams:function(c){var a=c.type,b=c.args;if(!a)return[""];if("string"===a)return[b[0]];if("and"===a||"or"===a)return[l.map(c.args,function(b){var d=this._renderFilterParams(b);return("and"===b.type||"or"===b.type)&&b.type!==a?"("+d+")":d},this).join("and"===a?"\x26":"|")];(c=b[1])&&(c._renderUrl?c="("+c._renderUrl()+")":c instanceof Array&&(c="("+c+")"));
return[encodeURIComponent(b[0])+"\x3d"+("eq"===a?"":a+"\x3d")+encodeURIComponent(c)]},_renderSortParams:function(c){c=l.map(c,function(a){return(a.descending?this.descendingPrefix:this.ascendingPrefix)+encodeURIComponent(a.property)},this);var a=[];c&&a.push(this.sortParam?encodeURIComponent(this.sortParam)+"\x3d"+c:"sort("+c+")");return a},_renderRangeParams:function(c,a){var b=[];this.rangeStartParam?b.push(this.rangeStartParam+"\x3d"+c,this.rangeCountParam+"\x3d"+(a-c)):b.push("limit("+(a-c)+(c?
","+c:"")+")");return b},_renderSelectParams:function(c){var a=[];this.selectParam?a.push(this.selectParam+"\x3d"+c):a.push("select("+c+")");return a},_renderQueryParams:function(){var c=[];l.forEach(this.queryLog,function(a){var b=a.type,h="_render"+b[0].toUpperCase()+b.substr(1)+"Params";this[h]?e.apply(c,this[h].apply(this,a.normalizedArguments)):console.warn('Unable to render query params for "'+b+'" query',a)},this);return c},_renderUrl:function(c){var a=this._renderQueryParams(),b=this.target;
c&&e.apply(a,c);0<a.length&&(b+=(this._targetContainsQueryString?"\x26":"?")+a.join("\x26"));return b},_renderRangeHeaders:function(c,a){var b="items\x3d"+c+"-"+(a-1);return{Range:b,"X-Range":b}}})})},"dstore/Trackable":function(){define("dojo/_base/lang dojo/_base/declare dojo/aspect dojo/when dojo/promise/all dojo/_base/array dojo/on".split(" "),function(g,n,l,p,k,f,m){function e(a,c,d){for(var e=a.length-1;0<=e;--e){var f=a[e],g=f.start,f=g+f.count;if(c>f){a.splice(e+1,0,{start:c,count:d-c});return}d>=
g&&(c=Math.min(c,g),d=Math.max(d,f),a.splice(e,1))}a.unshift({start:c,count:d-c})}var c=0,a={track:function(){function a(){return function(){var a=this,b=this.inherited(arguments);p(b,function(b){b=a._results=b.slice();a._partialResults&&(a._partialResults=null);a._ranges=[];e(a._ranges,0,b.length)});return b}}function h(){return function(a){var b=this,d=a.start,c=a.end,h=this.inherited(arguments);this._results||p(h,function(a){return p(a.totalLength,function(h){var f=b._partialResults||(b._partialResults=
[]);c=Math.min(c,d+a.length);f.length=h;h=[d,c-d].concat(a);f.splice.apply(f,h);e(b._ranges,d,c);return a})});return h}}function d(a,b){c++;var d=b.target;b=g.delegate(b,w[a]);p(t._results||t._partialResults,function(c){if(c){var h,e,g,m=t._ranges,l,n="id"in b?b.id:k.getIdentity(d),p=-1,s=-1,r=-1,v=-1;if("delete"===a||"update"===a)for(h=0;-1===p&&h<m.length;++h){l=m[h];e=l.start;for(g=e+l.count;e<g;++e)if(k.getIdentity(c[e])==n){p=b.previousIndex=e;s=h;c.splice(p,1);l.count--;for(e=h+1;e<m.length;++e)m[e].start--;
break}}if("add"===a||"update"===a){if(u){if(u([d]).length){var w=0;g=m.length-1;e=-1;for(var K;w<=g&&-1===r;)h=w+Math.round((g-w)/2),l=m[h],s=c.slice(l.start,l.start+l.count),"beforeId"in b&&(e=null===b.beforeId?s.length:A(s,b.beforeId)),-1===e&&(e=p>=Math.max(0,l.start-1)&&p<=l.start+l.count?p:k.defaultNewToStart?0:s.length),s.splice(e,0,d),n=f.indexOf(u(s),d),K=l.start+n,0===n&&0!==l.start?g=h-1:n>=s.length-1&&K<c.length?w=h+1:(r=K,v=h);if(-1===r&&0<w&&w<m.length)var N=!0}}else{e=-1;if("beforeId"in
b)if(null===b.beforeId)r=c.length,e=m.length-1;else{h=0;for(g=m.length;-1===v&&h<g;++h)l=m[h],r=A(c,b.beforeId,l.start,l.start+l.count),-1!==r&&(v=h)}else"update"===a?(r=p,v=s):k.defaultNewToStart?e=r=0:(r=c.length,e=m.length-1);-1!==e&&-1===v&&(l=m[e])&&(l.start<=r&&r<=l.start+l.count)&&(v=e)}if(-1<r&&-1<v){b.index=r;c.splice(r,0,d);m[v].count++;for(h=v+1;h<m.length;++h)m[h].start++}else if(N){b.beforeIndex=m[w].start;for(h=w;h<m.length;++h)m[h].start++}}b.totalLength=c.length}(c=t["on_tracked"+
a])&&c.call(t,b)})}var k=this.store||this,s=[],r={add:1,update:1,"delete":1},v;for(v in r)s.push(this.on(v,function(a){return function(b){d(a,b)}}(v)));var t=n.safeMixin(g.delegate(this),{_ranges:[],fetch:a(),fetchRange:h(),releaseRange:function(a,b){if(this._partialResults){a:for(var d=this._ranges,c=0,h;h=d[c];++c){var e=h.start,f=e+h.count;if(a<=e)if(b>=f)d.splice(c,1);else{h.start=b;h.count=f-h.start;break a}else if(a<f)if(b>e){d.splice(c,1,{start:e,count:a-e},{start:b,count:f-b});break a}else h.count=
a-h.start}for(d=a;d<b;++d)delete this._partialResults[d]}},on:function(a,b){var d=this,c=this.getInherited(arguments);return m.parse(t,a,b,function(a,h){return h in r?l.after(t,"on_tracked"+h,b,!0):c.call(d,h,b)})},tracking:{remove:function(){for(;0<s.length;)s.pop().remove();this.remove=function(){}}},track:null});this.fetchSync&&(n.safeMixin(t,{fetchSync:a(),fetchRangeSync:h()}),t.fetchSync());var u;f.forEach(this.queryLog,function(a){var b=u,d=a.querier;d&&(u=b?function(a){return d(b(a))}:d)});
var w={add:{index:void 0},update:{previousIndex:void 0,index:void 0},"delete":{previousIndex:void 0}},A=function(a,b,d,c){c=void 0!==c?c:a.length;for(d=void 0!==d?d:0;d<c;++d)if(k.getIdentity(a[d])===b)return d;return-1};return t}};k=n(null,a);k.create=function(b,c){b=n.safeMixin(g.delegate(b),a);n.safeMixin(b,c);return b};return k})},"dojo/promise/all":function(){define(["../_base/array","../Deferred","../when"],function(g,n,l){var p=g.some;return function(g){var f,m;g instanceof Array?m=g:g&&"object"===
typeof g&&(f=g);var e,c=[];if(f){m=[];for(var a in f)Object.hasOwnProperty.call(f,a)&&(c.push(a),m.push(f[a]));e={}}else m&&(e=[]);if(!m||!m.length)return(new n).resolve(e);var b=new n;b.promise.always(function(){e=c=null});var h=m.length;p(m,function(a,g){f||c.push(g);l(a,function(a){b.isFulfilled()||(e[c[g]]=a,0===--h&&b.resolve(e))},b.reject);return b.isFulfilled()});return b.promise}})},"dstore/Tree":function(){define(["dojo/_base/declare"],function(g){return g(null,{constructor:function(){this.root=
this},mayHaveChildren:function(g){return"hasChildren"in g?g.hasChildren:!0},getRootCollection:function(){return this.root.filter({parent:null})},getChildren:function(g){return this.root.filter({parent:this.getIdentity(g)})}})})},"dgrid/Tree":function(){define("dojo/_base/declare dojo/_base/lang dojo/_base/array dojo/aspect dojo/dom-construct dojo/dom-class dojo/on dojo/query dojo/when ./util/has-css3 ./Grid dojo/has!touch?./util/touch".split(" "),function(g,n,l,p,k,f,m,e,c,a,b,h){return g(null,{collapseOnRefresh:!1,
enableTreeTransitions:!0,treeIndentWidth:9,constructor:function(){this._treeColumnListeners=[]},shouldExpand:function(a,b,c){return c},expand:function(b,h,g){if(this._treeColumn){var l=this,p=b.element?b:this.row(b),t=!!this._expanded[p.id],u=a("transitionend"),w;b=p.element;b=-1<b.className.indexOf("dgrid-expando-icon")?b:e(".dgrid-expando-icon",b)[0];g=g||!this.enableTreeTransitions;if(b&&b.mayHaveChildren&&(g||h!==t)){var A=void 0===h?!this._expanded[p.id]:h;f.replace(b,"ui-icon-triangle-1-"+(A?
"se":"e"),"ui-icon-triangle-1-"+(A?"e":"se"));f.toggle(p.element,"dgrid-row-expanded",A);h=p.element;var y=h.connected,x,z,C={};if(!y){var y=C.container=h.connected=k.create("div",{className:"dgrid-tree-container"},h,"after"),B=function(a){var b=l._renderedCollection.getChildren(p.data);l.sort&&0<l.sort.length&&(b=b.sort(l.sort));b.track&&l.shouldTrackCollection&&(y._rows=a.rows=[],b=b.track(),y._handles=[b.tracking,l._observeCollection(b,y,a)]);return"start"in a?b.fetchRange({start:a.start,end:a.start+
a.count}):b.fetch()};"level"in b&&(y.level=B.level=b.level+1);if(this.renderQuery)w=this.renderQuery(B,C);else{var G=k.create("div",null,y);w=this._trackError(function(){return l.renderQueryResults(B(C),G,n.mixin({rows:C.rows},"level"in B?{queryLevel:B.level}:null)).then(function(a){k.destroy(G);return a})})}u&&m(y,u,this._onTreeTransitionEnd)}y.hidden=!A;x=y.style;!u||g?(x.display=A?"block":"none",x.height=""):(A?(x.display="block",z=y.scrollHeight,x.height="0px"):(f.add(y,"dgrid-tree-resetting"),
x.height=y.scrollHeight+"px"),setTimeout(function(){f.remove(y,"dgrid-tree-resetting");x.height=A?z?z+"px":"auto":"0px"},0));A?this._expanded[p.id]=!0:delete this._expanded[p.id]}return c(w)}},_configColumns:function(){var a=this.inherited(arguments);this._expanded={};for(var b=0,c=a.length;b<c;b++)if(a[b].renderExpando){this._configureTreeColumn(a[b]);break}return a},insertRow:function(a,b,c,h,e){e=e||{};var g=e.queryLevel="queryLevel"in e?e.queryLevel:"level"in b?b.level:0,k=this.inherited(arguments),
m=this.row(k);(g=this.shouldExpand(m,g,this._expanded[m.id]))&&this.expand(k,!0,!0);(g||!this.collection.mayHaveChildren||this.collection.mayHaveChildren(a))&&f.add(k,"dgrid-row-expandable");return k},removeRow:function(a,b){var c=a.connected,h={};c&&(c._handles&&(l.forEach(c._handles,function(a){a.remove()}),delete c._handles),c._rows&&(h.rows=c._rows),e("\x3e.dgrid-row",c).forEach(function(a){this.removeRow(a,!0,h)},this),c._rows&&(c._rows.length=0,delete c._rows),b||k.destroy(c));this.inherited(arguments)},
_refreshCellFromItem:function(a,b){if(!a.column.renderExpando)return this.inherited(arguments);this.inherited(arguments,[a,b,{queryLevel:e(".dgrid-expando-icon",a.element)[0].level}])},cleanup:function(){this.inherited(arguments);this.collapseOnRefresh&&(this._expanded={})},_destroyColumns:function(){this.inherited(arguments);for(var a=this._treeColumnListeners,b=a.length;b--;)a[b].remove();this._treeColumnListeners=[];this._treeColumn=null},_calcRowHeight:function(a){var b=a.connected;return this.inherited(arguments)+
(b?b.offsetHeight:0)},_configureTreeColumn:function(b){var c=this,e=".dgrid-content .dgrid-column-"+b.id,f;this._treeColumn=b;if(!b._isConfiguredTreeColumn){var g=b.renderCell||this._defaultRenderCell;b._isConfiguredTreeColumn=!0;b.renderCell=function(a,h,e,f){var k=f&&"queryLevel"in f?f.queryLevel:0,m=!c.collection.mayHaveChildren||c.collection.mayHaveChildren(a),l;l=b.renderExpando(k,m,c._expanded[c.collection.getIdentity(a)],a);l.level=k;l.mayHaveChildren=m;(a=g.call(b,a,h,e,f))&&a.nodeType?(e.appendChild(l),
e.appendChild(a)):e.insertBefore(l,e.firstChild)};"function"!==typeof b.renderExpando&&(b.renderExpando=this._defaultRenderExpando)}var k=this._treeColumnListeners;0===k.length&&(k.push(this.on(b.expandOn||".dgrid-expando-icon:click,"+e+":dblclick,"+e+":keydown",function(a){var b=c.row(a);(!c.collection.mayHaveChildren||c.collection.mayHaveChildren(b.data))&&(("keydown"!==a.type||32===a.keyCode)&&!("dblclick"===a.type&&f&&1<f.count&&b.id===f.id&&-1<a.target.className.indexOf("dgrid-expando-icon")))&&
c.expand(b);-1<a.target.className.indexOf("dgrid-expando-icon")&&(f&&f.id===c.row(a).id?f.count++:f={id:c.row(a).id,count:1})})),a("touch")&&k.push(this.on(h.selector(e,h.dbltap),function(){c.expand(this)})))},_defaultRenderExpando:function(a,b,c){var h=this.grid.isRTL?"right":"left",e="dgrid-expando-icon";b&&(e+=" ui-icon ui-icon-triangle-1-"+(c?"se":"e"));return k.create("div",{className:e,innerHTML:"\x26nbsp;",style:"margin-"+h+": "+a*this.grid.treeIndentWidth+"px; float: "+h+";"})},_onNotification:function(a,
b){"delete"===b.type&&delete this._expanded[b.id];this.inherited(arguments)},_onTreeTransitionEnd:function(a){var b=this,c=this.style.height;c&&(this.style.display="0px"===c?"none":"block");a&&(f.add(this,"dgrid-tree-resetting"),setTimeout(function(){f.remove(b,"dgrid-tree-resetting")},0));this.style.height=""}})})},"dgrid/util/has-css3":function(){define(["dojo/has"],function(g){function n(g,k){var f=g.style,m;if(k in f)return!0;k=k.slice(0,1).toUpperCase()+k.slice(1);for(m=l.length;m--;)if(l[m]+
k in f)return l[m];return!1}var l=["ms","O","Moz","Webkit"];g.add("css-transitions",function(g,k,f){return n(f,"transitionProperty")});g.add("css-transforms",function(g,k,f){return n(f,"transform")});g.add("css-transforms3d",function(g,k,f){return n(f,"perspective")});g.add("transitionend",function(){var l=g("css-transitions");return!l?!1:!0===l?"transitionend":{ms:"MSTransitionEnd",O:"oTransitionEnd",Moz:"transitionend",Webkit:"webkitTransitionEnd"}[l]});return g})},"dstore/RequestMemory":function(){define(["dojo/_base/declare",
"./Request","./Cache"],function(g,n,l){return g([n,l],{postscript:function(){this.inherited(arguments);this.fetch()},isValidFetchCache:!0})})},"dstore/Cache":function(){define("dojo/_base/array dojo/when dojo/_base/declare dojo/_base/lang ./Store ./Memory ./QueryResults".split(" "),function(g,n,l,p,k,f,m){function e(a){return function(){var c=this.inherited(arguments),d=this.cachingCollection||this.cachingStore;c.cachingCollection=d[a].apply(d,arguments);c.isValidFetchCache=!0===this.canCacheQuery||
this.canCacheQuery(a,arguments);return c}}function c(a){a.cachingStore||(a.cachingStore=new f);a.cachingStore.Model=a.Model;a.cachingStore.idProperty=a.idProperty}var a={cachingStore:null,constructor:function(){c(this)},canCacheQuery:function(a,c){return!1},isAvailableInCache:function(){return this.isValidFetchCache&&(this.allLoaded||this.fetchRequest)||this._parent&&this._parent.isAvailableInCache()},fetch:function(){return this._fetch(arguments)},fetchRange:function(){return this._fetch(arguments,
!0)},_fetch:function(a,c){var d=this.cachingStore,e=this.cachingCollection||d,f=this,k=this.isAvailableInCache();if(k)return new m(n(k,function(){return f.isAvailableInCache()?c?e.fetchRange(a[0]):e.fetch():f.inherited(a)}));k=this.fetchRequest=this.inherited(a);n(k,function(a){var b=!c;f.fetchRequest=null;g.forEach(a,function(a){!f.isLoaded||f.isLoaded(a)?d.put(a):b=!1});b&&(f.allLoaded=!0);return a});return k},isValidFetchCache:!1,get:function(a,c){var d=this.cachingStore,e=this.getInherited(arguments),
f=this;return n(this.fetchRequest,function(){return n(d.get(a),function(g){if(void 0!==g)return g;if(e)return n(e.call(f,a,c),function(c){c&&d.put(c,{id:a});return c})})})},add:function(a,c){var d=this.cachingStore;return n(this.inherited(arguments),function(e){var f=d.put(a&&"object"===typeof e?e:a,c);return e||f})},put:function(a,c){var d=this.cachingStore;d.remove(c&&c.id||this.getIdentity(a));return n(this.inherited(arguments),function(e){var f=d.put(a&&"object"===typeof e?e:a,c);return e||f})},
remove:function(a,c){var d=this.cachingStore;return n(this.inherited(arguments),function(e){return n(d.remove(a,c),function(){return e})})},evict:function(a){this.allLoaded=!1;return this.cachingStore.remove(a)},invalidate:function(){this.allLoaded=!1},_createSubCollection:function(){var a=this.inherited(arguments);a._parent=this;return a},sort:e("sort"),filter:e("filter"),_getQuerierFactory:function(a){var c=this.cachingStore;return this.inherited(arguments)||p.hitch(c,c._getQuerierFactory(a))}};
k=l(null,a);k.create=function(b,e){b=l.safeMixin(p.delegate(b),a);l.safeMixin(b,e);c(b);return b};return k})},"dojo/main":function(){define("./_base/kernel ./has require ./sniff ./_base/lang ./_base/array ./_base/config ./ready ./_base/declare ./_base/connect ./_base/Deferred ./_base/json ./_base/Color ./has!dojo-firebug?./_firebug/firebug ./_base/browser ./_base/loader".split(" "),function(g,n,l,p,k,f,m,e){m.isDebug&&l(["./_firebug/firebug"]);var c=m.require;c&&(c=f.map(k.isArray(c)?c:[c],function(a){return a.replace(/\./g,
"/")}),g.isAsync?l(c):e(1,function(){l(c)}));return g})},"dojo/ready":function(){define(["./_base/kernel","./has","require","./domReady","./_base/lang"],function(g,n,l,p,k){var f=0,m=[],e=0;n=function(){f=1;g._postLoad=g.config.afterOnLoad=!0;c()};var c=function(){if(!e){for(e=1;f&&(!p||0==p._Q.length)&&(l.idle?l.idle():1)&&m.length;){var a=m.shift();try{a()}catch(b){if(b.info=b.message,l.signal)l.signal("error",b);else throw b;}}e=0}};l.on&&l.on("idle",c);p&&(p._onQEmpty=c);var a=g.ready=g.addOnLoad=
function(a,b,e){var f=k._toArray(arguments);"number"!=typeof a?(e=b,b=a,a=1E3):f.shift();e=e?k.hitch.apply(g,f):function(){b()};e.priority=a;for(f=0;f<m.length&&a>=m[f].priority;f++);m.splice(f,0,e);c()},b=g.config.addOnLoad;if(b)a[k.isArray(b)?"apply":"call"](g,b);g.config.parseOnLoad&&!g.isAsync&&a(99,function(){g.parser||(g.deprecated("Add explicit require(['dojo/parser']);","","2.0"),l(["dojo/parser"]))});p?p(n):n();return a})},"dojo/domReady":function(){define(["./has"],function(g){function n(a){c.push(a);
e&&l()}function l(){if(!a){for(a=!0;c.length;)try{c.shift()(k)}catch(b){console.error(b,"in domReady callback",b.stack)}a=!1;n._onQEmpty()}}var p=function(){return this}(),k=document,f={loaded:1,complete:1},m="string"!=typeof k.readyState,e=!!f[k.readyState],c=[],a;n.load=function(a,b,c){n(c)};n._Q=c;n._onQEmpty=function(){};m&&(k.readyState="loading");if(!e){var b=[],h=function(a){a=a||p.event;e||"readystatechange"==a.type&&!f[k.readyState]||(m&&(k.readyState="complete"),e=1,l())},d=function(a,b){a.addEventListener(b,
h,!1);c.push(function(){a.removeEventListener(b,h,!1)})};if(!g("dom-addeventlistener")){var d=function(a,b){b="on"+b;a.attachEvent(b,h);c.push(function(){a.detachEvent(b,h)})},q=k.createElement("div");try{q.doScroll&&null===p.frameElement&&b.push(function(){try{return q.doScroll("left"),1}catch(a){}})}catch(s){}}d(k,"DOMContentLoaded");d(p,"load");"onreadystatechange"in k?d(k,"readystatechange"):m||b.push(function(){return f[k.readyState]});if(b.length){var r=function(){if(!e){for(var a=b.length;a--;)if(b[a]()){h("poller");
return}setTimeout(r,30)}};r()}}return n})},"dojo/_base/Color":function(){define(["./kernel","./lang","./array","./config"],function(g,n,l,p){var k=g.Color=function(f){f&&this.setColor(f)};k.named={black:[0,0,0],silver:[192,192,192],gray:[128,128,128],white:[255,255,255],maroon:[128,0,0],red:[255,0,0],purple:[128,0,128],fuchsia:[255,0,255],green:[0,128,0],lime:[0,255,0],olive:[128,128,0],yellow:[255,255,0],navy:[0,0,128],blue:[0,0,255],teal:[0,128,128],aqua:[0,255,255],transparent:p.transparentColor||
[0,0,0,0]};n.extend(k,{r:255,g:255,b:255,a:1,_set:function(f,g,e,c){this.r=f;this.g=g;this.b=e;this.a=c},setColor:function(f){n.isString(f)?k.fromString(f,this):n.isArray(f)?k.fromArray(f,this):(this._set(f.r,f.g,f.b,f.a),f instanceof k||this.sanitize());return this},sanitize:function(){return this},toRgb:function(){return[this.r,this.g,this.b]},toRgba:function(){return[this.r,this.g,this.b,this.a]},toHex:function(){return"#"+l.map(["r","g","b"],function(f){f=this[f].toString(16);return 2>f.length?
"0"+f:f},this).join("")},toCss:function(f){var g=this.r+", "+this.g+", "+this.b;return(f?"rgba("+g+", "+this.a:"rgb("+g)+")"},toString:function(){return this.toCss(!0)}});k.blendColors=g.blendColors=function(f,g,e,c){var a=c||new k;l.forEach(["r","g","b","a"],function(b){a[b]=f[b]+(g[b]-f[b])*e;"a"!=b&&(a[b]=Math.round(a[b]))});return a.sanitize()};k.fromRgb=g.colorFromRgb=function(f,g){var e=f.toLowerCase().match(/^rgba?\(([\s\.,0-9]+)\)/);return e&&k.fromArray(e[1].split(/\s*,\s*/),g)};k.fromHex=
g.colorFromHex=function(f,g){var e=g||new k,c=4==f.length?4:8,a=(1<<c)-1;f=Number("0x"+f.substr(1));if(isNaN(f))return null;l.forEach(["b","g","r"],function(b){var h=f&a;f>>=c;e[b]=4==c?17*h:h});e.a=1;return e};k.fromArray=g.colorFromArray=function(f,g){var e=g||new k;e._set(Number(f[0]),Number(f[1]),Number(f[2]),Number(f[3]));isNaN(e.a)&&(e.a=1);return e.sanitize()};k.fromString=g.colorFromString=function(f,g){var e=k.named[f];return e&&k.fromArray(e,g)||k.fromRgb(f,g)||k.fromHex(f,g)};return k})},
"dojo/_base/browser":function(){require.has&&require.has.add("config-selectorEngine","acme");define("../ready ./kernel ./connect ./unload ./window ./event ./html ./NodeList ../query ./xhr ./fx".split(" "),function(g){return g})},"dojo/_base/unload":function(){define(["./kernel","./lang","../on"],function(g,n,l){var p=window,k={addOnWindowUnload:function(f,k){g.windowUnloaded||l(p,"unload",g.windowUnloaded=function(){});l(p,"unload",n.hitch(f,k))},addOnUnload:function(f,g){l(p,"beforeunload",n.hitch(f,
g))}};g.addOnWindowUnload=k.addOnWindowUnload;g.addOnUnload=k.addOnUnload;return k})},"dojo/_base/NodeList":function(){define(["./kernel","../query","./array","./html","../NodeList-dom"],function(g,n,l){n=n.NodeList;var p=n.prototype;p.connect=n._adaptAsForEach(function(){return g.connect.apply(this,arguments)});p.coords=n._adaptAsMap(g.coords);n.events="blur focus change click error keydown keypress keyup load mousedown mouseenter mouseleave mousemove mouseout mouseover mouseup submit".split(" ");
l.forEach(n.events,function(g){var f="on"+g;p[f]=function(g,e){return this.connect(f,g,e)}});return g.NodeList=n})},"dojo/NodeList-dom":function(){define("./_base/kernel ./query ./_base/array ./_base/lang ./dom-class ./dom-construct ./dom-geometry ./dom-attr ./dom-style".split(" "),function(g,n,l,p,k,f,m,e,c){function a(a){return function(b,c,d){return 2==arguments.length?a["string"==typeof c?"get":"set"](b,c):a.set(b,c,d)}}var b=function(a){return 1==a.length&&"string"==typeof a[0]},h=function(a){var b=
a.parentNode;b&&b.removeChild(a)},d=n.NodeList,q=d._adaptWithCondition,s=d._adaptAsForEach,r=d._adaptAsMap;p.extend(d,{_normalize:function(a,b){var c=!0===a.parse;if("string"==typeof a.template){var d=a.templateFunc||g.string&&g.string.substitute;a=d?d(a.template,a):a}d=typeof a;"string"==d||"number"==d?(a=f.toDom(a,b&&b.ownerDocument),a=11==a.nodeType?p._toArray(a.childNodes):[a]):p.isArrayLike(a)?p.isArray(a)||(a=p._toArray(a)):a=[a];c&&(a._runParse=!0);return a},_cloneNode:function(a){return a.cloneNode(!0)},
_place:function(a,b,c,d){if(!(1!=b.nodeType&&"only"==c))for(var e,h=a.length,k=h-1;0<=k;k--){var m=d?this._cloneNode(a[k]):a[k];if(a._runParse&&g.parser&&g.parser.parse){e||(e=b.ownerDocument.createElement("div"));e.appendChild(m);g.parser.parse(e);for(m=e.firstChild;e.firstChild;)e.removeChild(e.firstChild)}k==h-1?f.place(m,b,c):b.parentNode.insertBefore(m,b);b=m}},position:r(m.position),attr:q(a(e),b),style:q(a(c),b),addClass:s(k.add),removeClass:s(k.remove),toggleClass:s(k.toggle),replaceClass:s(k.replace),
empty:s(f.empty),removeAttr:s(e.remove),marginBox:r(m.getMarginBox),place:function(a,b){var c=n(a)[0];return this.forEach(function(a){f.place(a,c,b)})},orphan:function(a){return(a?n._filterResult(this,a):this).forEach(h)},adopt:function(a,b){return n(a).place(this[0],b)._stash(this)},query:function(a){if(!a)return this;var b=new d;this.map(function(c){n(a,c).forEach(function(a){void 0!==a&&b.push(a)})});return b._stash(this)},filter:function(a){var b=arguments,c=this,d=0;if("string"==typeof a){c=
n._filterResult(this,b[0]);if(1==b.length)return c._stash(this);d=1}return this._wrap(l.filter(c,b[d],b[d+1]),this)},addContent:function(a,b){a=this._normalize(a,this[0]);for(var c=0,d;d=this[c];c++)a.length?this._place(a,d,b,0<c):f.empty(d);return this}});return d})},"dojo/_base/fx":function(){define("./kernel ./config ./lang ../Evented ./Color ../aspect ../sniff ../dom ../dom-style".split(" "),function(g,n,l,p,k,f,m,e,c){var a=l.mixin,b={},h=b._Line=function(a,b){this.start=a;this.end=b};h.prototype.getValue=
function(a){return(this.end-this.start)*a+this.start};var d=b.Animation=function(b){a(this,b);l.isArray(this.curve)&&(this.curve=new h(this.curve[0],this.curve[1]))};d.prototype=new p;l.extend(d,{duration:350,repeat:0,rate:20,_percent:0,_startRepeatCount:0,_getStep:function(){var a=this._percent,b=this.easing;return b?b(a):a},_fire:function(a,b){var c=b||[];if(this[a])if(n.debugAtAllCosts)this[a].apply(this,c);else try{this[a].apply(this,c)}catch(d){console.error("exception in animation handler for:",
a),console.error(d)}return this},play:function(a,b){this._delayTimer&&this._clearTimer();if(b)this._stopTimer(),this._active=this._paused=!1,this._percent=0;else if(this._active&&!this._paused)return this;this._fire("beforeBegin",[this.node]);var c=a||this.delay,d=l.hitch(this,"_play",b);if(0<c)return this._delayTimer=setTimeout(d,c),this;d();return this},_play:function(a){this._delayTimer&&this._clearTimer();this._startTime=(new Date).valueOf();this._paused&&(this._startTime-=this.duration*this._percent);
this._active=!0;this._paused=!1;a=this.curve.getValue(this._getStep());this._percent||(this._startRepeatCount||(this._startRepeatCount=this.repeat),this._fire("onBegin",[a]));this._fire("onPlay",[a]);this._cycle();return this},pause:function(){this._delayTimer&&this._clearTimer();this._stopTimer();if(!this._active)return this;this._paused=!0;this._fire("onPause",[this.curve.getValue(this._getStep())]);return this},gotoPercent:function(a,b){this._stopTimer();this._active=this._paused=!0;this._percent=
a;b&&this.play();return this},stop:function(a){this._delayTimer&&this._clearTimer();if(!this._timer)return this;this._stopTimer();a&&(this._percent=1);this._fire("onStop",[this.curve.getValue(this._getStep())]);this._active=this._paused=!1;return this},destroy:function(){this.stop()},status:function(){return this._active?this._paused?"paused":"playing":"stopped"},_cycle:function(){if(this._active){var a=(new Date).valueOf(),a=0===this.duration?1:(a-this._startTime)/this.duration;1<=a&&(a=1);this._percent=
a;this.easing&&(a=this.easing(a));this._fire("onAnimate",[this.curve.getValue(a)]);1>this._percent?this._startTimer():(this._active=!1,0<this.repeat?(this.repeat--,this.play(null,!0)):-1==this.repeat?this.play(null,!0):this._startRepeatCount&&(this.repeat=this._startRepeatCount,this._startRepeatCount=0),this._percent=0,this._fire("onEnd",[this.node]),!this.repeat&&this._stopTimer())}return this},_clearTimer:function(){clearTimeout(this._delayTimer);delete this._delayTimer}});var q=0,s=null,r={run:function(){}};
l.extend(d,{_startTimer:function(){this._timer||(this._timer=f.after(r,"run",l.hitch(this,"_cycle"),!0),q++);s||(s=setInterval(l.hitch(r,"run"),this.rate))},_stopTimer:function(){this._timer&&(this._timer.remove(),this._timer=null,q--);0>=q&&(clearInterval(s),s=null,q=0)}});var v=m("ie")?function(a){var b=a.style;!b.width.length&&"auto"==c.get(a,"width")&&(b.width="auto")}:function(){};b._fade=function(d){d.node=e.byId(d.node);var h=a({properties:{}},d);d=h.properties.opacity={};d.start=!("start"in
h)?function(){return+c.get(h.node,"opacity")||0}:h.start;d.end=h.end;d=b.animateProperty(h);f.after(d,"beforeBegin",l.partial(v,h.node),!0);return d};b.fadeIn=function(c){return b._fade(a({end:1},c))};b.fadeOut=function(c){return b._fade(a({end:0},c))};b._defaultEasing=function(a){return 0.5+Math.sin((a+1.5)*Math.PI)/2};var t=function(a){this._properties=a;for(var b in a){var c=a[b];c.start instanceof k&&(c.tempColor=new k)}};t.prototype.getValue=function(a){var b={},c;for(c in this._properties){var d=
this._properties[c],e=d.start;e instanceof k?b[c]=k.blendColors(e,d.end,a,d.tempColor).toCss():l.isArray(e)||(b[c]=(d.end-e)*a+e+("opacity"!=c?d.units||"px":0))}return b};b.animateProperty=function(b){var h=b.node=e.byId(b.node);b.easing||(b.easing=g._defaultEasing);b=new d(b);f.after(b,"beforeBegin",l.hitch(b,function(){var b={},d;for(d in this.properties){if("width"==d||"height"==d)this.node.display="block";var e=this.properties[d];l.isFunction(e)&&(e=e(h));e=b[d]=a({},l.isObject(e)?e:{end:e});
l.isFunction(e.start)&&(e.start=e.start(h));l.isFunction(e.end)&&(e.end=e.end(h));var f=0<=d.toLowerCase().indexOf("color"),g=function(a,b){var d={height:a.offsetHeight,width:a.offsetWidth}[b];if(void 0!==d)return d;d=c.get(a,b);return"opacity"==b?+d:f?d:parseFloat(d)};"end"in e?"start"in e||(e.start=g(h,d)):e.end=g(h,d);f?(e.start=new k(e.start),e.end=new k(e.end)):e.start="opacity"==d?+e.start:parseFloat(e.start)}this.curve=new t(b)}),!0);f.after(b,"onAnimate",l.hitch(c,"set",b.node),!0);return b};
b.anim=function(a,c,e,h,f,g){return b.animateProperty({node:a,duration:e||d.prototype.duration,properties:c,easing:h,onEnd:f}).play(g||0)};a(g,b);g._Animation=d;return b})},"dojo/_base/loader":function(){define("./kernel ../has require module ../json ./lang ./array".split(" "),function(g,n,l,p,k,f,m){var e=function(a){return a.replace(/\./g,"/")},c=/\/\/>>built/,a=[],b=[],h=function(c,e,h){a.push(h);m.forEach(c.split(","),function(a){a=M(a,e.module);b.push(a);P(a)});d()},d=function(){var b,c;for(c in G)if(b=
G[c],void 0===b.noReqPluginCheck&&(b.noReqPluginCheck=/loadInit\!/.test(c)||/require\!/.test(c)?1:0),!b.executed&&!b.noReqPluginCheck&&b.injected==A)return;T(function(){var b=a;a=[];m.forEach(b,function(a){a(1)})})},q=function(a,b,c){var d=/\(|\)/g,e=1;for(d.lastIndex=b;(b=d.exec(a))&&!(e=")"==b[0]?e-1:e+1,0==e););if(0!=e)throw"unmatched paren around character "+d.lastIndex+" in: "+a;return[g.trim(a.substring(c,d.lastIndex))+";\n",d.lastIndex]},s=/(\/\*([\s\S]*?)\*\/|\/\/(.*)$)/mg,r=/(^|\s)dojo\.(loadInit|require|provide|requireLocalization|requireIf|requireAfterIf|platformRequire)\s*\(/mg,
v=/(^|\s)(require|define)\s*\(/m,t=function(a,b){var c,d,e,h=[],f=[];c=[];for(b=b||a.replace(s,function(a){r.lastIndex=v.lastIndex=0;return r.test(a)||v.test(a)?"":a});c=r.exec(b);)d=r.lastIndex,e=d-c[0].length,d=q(b,d,e),"loadInit"==c[2]?h.push(d[0]):f.push(d[0]),r.lastIndex=d[1];c=h.concat(f);return c.length||!v.test(b)?[a.replace(/(^|\s)dojo\.loadInit\s*\(/g,"\n0 \x26\x26 dojo.loadInit("),c.join(""),c]:0},u=l.initSyncLoader(h,d,function(a,b){var d,e,h=[],f=[];if(c.test(b)||!(d=t(b)))return 0;e=
a.mid+"-*loadInit";for(var g in M("dojo",a).result.scopeMap)h.push(g),f.push('"'+g+'"');return"// xdomain rewrite of "+a.mid+"\ndefine('"+e+"',{\n\tnames:"+k.stringify(h)+",\n\tdef:function("+h.join(",")+"){"+d[1]+"}});\n\ndefine("+k.stringify(h.concat(["dojo/loadInit!"+e]))+", function("+h.join(",")+"){\n"+d[0]+"});"}),w=u.sync,A=u.requested,y=u.arrived,x=u.nonmodule,z=u.executing,C=u.executed,B=u.syncExecStack,G=u.modules,L=u.execQ,M=u.getModule,P=u.injectModule,I=u.setArrived,J=u.signal,F=u.finishExec,
E=u.execModule,D=u.getLegacyMode,T=u.guardCheckComplete,h=u.dojoRequirePlugin;g.provide=function(a){var b=B[0],c=f.mixin(M(e(a),l.module),{executed:z,result:f.getObject(a,!0)});I(c);b&&(b.provides||(b.provides=[])).push(function(){c.result=f.getObject(a);delete c.provides;c.executed!==C&&F(c)});return c.result};n.add("config-publishRequireResult",1,0,0);g.require=function(a,b){var c=function(a,b){var c=M(e(a),l.module);if(B.length&&B[0].finish)B[0].finish.push(a);else{if(c.executed)return c.result;
b&&(c.result=x);var d=D();P(c);d=D();c.executed!==C&&c.injected===y&&u.guardCheckComplete(function(){E(c)});if(c.executed)return c.result;d==w?c.cjs?L.unshift(c):B.length&&(B[0].finish=[a]):L.push(c)}}(a,b);n("config-publishRequireResult")&&(!f.exists(a)&&void 0!==c)&&f.setObject(a,c);return c};g.loadInit=function(a){a()};g.registerModulePath=function(a,b){var c={};c[a.replace(/\./g,"/")]=b;l({paths:c})};g.platformRequire=function(a){a=(a.common||[]).concat(a[g._name]||a["default"]||[]);for(var b;a.length;)f.isArray(b=
a.shift())?g.require.apply(g,b):g.require(b)};g.requireIf=g.requireAfterIf=function(a,b,c){a&&g.require(b,c)};g.requireLocalization=function(a,b,c){l(["../i18n"],function(d){d.getLocalization(a,b,c)})};return{extractLegacyApiApplications:t,require:h,loadInit:function(a,b,c){b([a],function(a){b(a.names,function(){for(var d="",f=[],k=0;k<arguments.length;k++)d+="var "+a.names[k]+"\x3d arguments["+k+"]; ",f.push(arguments[k]);eval(d);var m=b.module,l=[],n,d={provide:function(a){a=e(a);a=M(a,m);a!==m&&
I(a)},require:function(a,b){a=e(a);b&&(M(a,m).result=x);l.push(a)},requireLocalization:function(a,b,c){n||(n=["dojo/i18n"]);c=(c||g.locale).toLowerCase();a=e(a)+"/nls/"+(/root/i.test(c)?"":c+"/")+e(b);M(a,m).isXd&&n.push("dojo/i18n!"+a)},loadInit:function(a){a()}},k={},q;try{for(q in d)k[q]=g[q],g[q]=d[q];a.def.apply(null,f)}catch(r){J("error",[{src:p.id,id:"failedDojoLoadInit"},r])}finally{for(q in d)g[q]=k[q]}n&&(l=l.concat(n));l.length?h(l.join(","),b,c):c()})})}}})},"dgrid/util/touch":function(){define(["dojo/on",
"dojo/query"],function(g,n){function l(k,f,m,e){if(!(1<m.targetTouches.length)){var c=m.changedTouches[0],a=c.screenX,b=c.screenY;e&&m.preventDefault();var h=g(k,"touchend",function(c){var g=c.changedTouches[0];c.targetTouches.length||(Math.abs(g.screenX-a)<p.tapRadius&&Math.abs(g.screenY-b)<p.tapRadius&&(e&&c.preventDefault(),f.call(this,c)),h.remove())})}}var p={tapRadius:10,dbltapTime:250,selector:function(k,f,m){return function(e,c){var a=f.bubble;a?f=a:!1!==m&&(m=!0);return g(e,f,function(a){var h=
a.target;3===h.nodeType&&(h=h.parentNode);for(;!n.matches(h,k,e);)if(h===e||!m||!(h=h.parentNode))return;return c.call(h,a)})}},countCurrentTouches:function(g,f){if(!("touches"in g))return-1;var m,e,c;for(e=m=0;c=g.touches[m];++m)f.contains(c.target)&&++e;return e},tap:function(k,f){return g(k,"touchstart",function(g){l(k,f,g)})},dbltap:function(k,f){var m,e;return g(k,"touchstart",function(c){m?l(k,function(a){if(m){var b=a.changedTouches[0];Math.abs(b.screenX-m.screenX)<p.tapRadius&&Math.abs(b.screenY-
m.screenY)<p.tapRadius&&(e&&clearTimeout(e),m=e=null,f.call(this,a))}},c,!0):l(k,function(a){m=a.changedTouches[0];e=setTimeout(function(){m=e=null},p.dbltapTime)},c)})}};return p})},"dijit/TooltipDialog":function(){define("dojo/_base/declare dojo/dom-class dojo/has dojo/keys dojo/_base/lang dojo/on ./focus ./layout/ContentPane ./_DialogMixin ./form/_FormMixin ./_TemplatedMixin dojo/text!./templates/TooltipDialog.html ./main".split(" "),function(g,n,l,p,k,f,m,e,c,a,b,h,d){g=g("dijit.TooltipDialog",
[e,b,a,c],{title:"",doLayout:!1,autofocus:!0,baseClass:"dijitTooltipDialog",_firstFocusItem:null,_lastFocusItem:null,templateString:h,_setTitleAttr:"containerNode",postCreate:function(){this.inherited(arguments);this.own(f(this.domNode,"keydown",k.hitch(this,"_onKey")))},orient:function(a,b,c){a={"MR-ML":"dijitTooltipRight","ML-MR":"dijitTooltipLeft","TM-BM":"dijitTooltipAbove","BM-TM":"dijitTooltipBelow","BL-TL":"dijitTooltipBelow dijitTooltipABLeft","TL-BL":"dijitTooltipAbove dijitTooltipABLeft",
"BR-TR":"dijitTooltipBelow dijitTooltipABRight","TR-BR":"dijitTooltipAbove dijitTooltipABRight","BR-BL":"dijitTooltipRight","BL-BR":"dijitTooltipLeft","BR-TL":"dijitTooltipBelow dijitTooltipABLeft","BL-TR":"dijitTooltipBelow dijitTooltipABRight","TL-BR":"dijitTooltipAbove dijitTooltipABRight","TR-BL":"dijitTooltipAbove dijitTooltipABLeft"}[b+"-"+c];n.replace(this.domNode,a,this._currentOrientClass||"");this._currentOrientClass=a},focus:function(){this._getFocusItems();m.focus(this._firstFocusItem)},
onOpen:function(a){this.orient(this.domNode,a.aroundCorner,a.corner);var b=a.aroundNodePos;"M"==a.corner.charAt(0)&&"M"==a.aroundCorner.charAt(0)?(this.connectorNode.style.top=b.y+(b.h-this.connectorNode.offsetHeight>>1)-a.y+"px",this.connectorNode.style.left=""):"M"==a.corner.charAt(1)&&"M"==a.aroundCorner.charAt(1)&&(this.connectorNode.style.left=b.x+(b.w-this.connectorNode.offsetWidth>>1)-a.x+"px");this._onShow()},onClose:function(){this.onHide()},_onKey:function(a){if(a.keyCode==p.ESCAPE)this.defer("onCancel"),
a.stopPropagation(),a.preventDefault();else if(a.keyCode==p.TAB){var b=a.target;this._getFocusItems();this._firstFocusItem==this._lastFocusItem?(a.stopPropagation(),a.preventDefault()):b==this._firstFocusItem&&a.shiftKey?(m.focus(this._lastFocusItem),a.stopPropagation(),a.preventDefault()):b==this._lastFocusItem&&!a.shiftKey?(m.focus(this._firstFocusItem),a.stopPropagation(),a.preventDefault()):a.stopPropagation()}}});l("dojo-bidi")&&g.extend({_setTitleAttr:function(a){this.containerNode.title=this.textDir&&
this.enforceTextDirWithUcc?this.enforceTextDirWithUcc(null,a):a;this._set("title",a)},_setTextDirAttr:function(a){if(!this._created||this.textDir!=a)this._set("textDir",a),this.textDir&&this.title&&(this.containerNode.title=this.enforceTextDirWithUcc(null,this.title))}});return g})},"dijit/focus":function(){define("dojo/aspect dojo/_base/declare dojo/dom dojo/dom-attr dojo/dom-class dojo/dom-construct dojo/Evented dojo/_base/lang dojo/on dojo/domReady dojo/sniff dojo/Stateful dojo/_base/window dojo/window ./a11y ./registry ./main".split(" "),
function(g,n,l,p,k,f,m,e,c,a,b,h,d,q,s,r,v){var t,u,w=new (n([h,m],{curNode:null,activeStack:[],constructor:function(){var a=e.hitch(this,function(a){l.isDescendant(this.curNode,a)&&this.set("curNode",null);l.isDescendant(this.prevNode,a)&&this.set("prevNode",null)});g.before(f,"empty",a);g.before(f,"destroy",a)},registerIframe:function(a){return this.registerWin(a.contentWindow,a)},registerWin:function(a,d){var e=this,h=a.document&&a.document.body;if(h){var f=b("pointer-events")?"pointerdown":b("MSPointer")?
"MSPointerDown":b("touch-events")?"mousedown, touchstart":"mousedown",g=c(a.document,f,function(a){if(!a||!(a.target&&null==a.target.parentNode))e._onTouchNode(d||a.target,"mouse")}),k=c(h,"focusin",function(a){if(a.target.tagName){var b=a.target.tagName.toLowerCase();"#document"==b||"body"==b||(s.isFocusable(a.target)?e._onFocusNode(d||a.target):e._onTouchNode(d||a.target))}}),m=c(h,"focusout",function(a){e._onBlurNode(d||a.target)});return{remove:function(){g.remove();k.remove();m.remove();h=g=
k=m=null}}}},_onBlurNode:function(a){a=(new Date).getTime();a<t+100||(this._clearFocusTimer&&clearTimeout(this._clearFocusTimer),this._clearFocusTimer=setTimeout(e.hitch(this,function(){this.set("prevNode",this.curNode);this.set("curNode",null)}),0),this._clearActiveWidgetsTimer&&clearTimeout(this._clearActiveWidgetsTimer),a<u+100||(this._clearActiveWidgetsTimer=setTimeout(e.hitch(this,function(){delete this._clearActiveWidgetsTimer;this._setStack([])}),0)))},_onTouchNode:function(a,b){u=(new Date).getTime();
this._clearActiveWidgetsTimer&&(clearTimeout(this._clearActiveWidgetsTimer),delete this._clearActiveWidgetsTimer);k.contains(a,"dijitPopup")&&(a=a.firstChild);var c=[];try{for(;a;){var e=p.get(a,"dijitPopupParent");if(e)a=r.byId(e).domNode;else if(a.tagName&&"body"==a.tagName.toLowerCase()){if(a===d.body())break;a=q.get(a.ownerDocument).frameElement}else{var h=a.getAttribute&&a.getAttribute("widgetId"),f=h&&r.byId(h);f&&!("mouse"==b&&f.get("disabled"))&&c.unshift(h);a=a.parentNode}}}catch(g){}this._setStack(c,
b)},_onFocusNode:function(a){a&&9!=a.nodeType&&(t=(new Date).getTime(),this._clearFocusTimer&&(clearTimeout(this._clearFocusTimer),delete this._clearFocusTimer),this._onTouchNode(a),a!=this.curNode&&(this.set("prevNode",this.curNode),this.set("curNode",a)))},_setStack:function(a,b){var c=this.activeStack,d=c.length-1,e=a.length-1;if(a[e]!=c[d]){this.set("activeStack",a);var h;for(h=d;0<=h&&c[h]!=a[h];h--)if(d=r.byId(c[h]))d._hasBeenBlurred=!0,d.set("focused",!1),d._focusManager==this&&d._onBlur(b),
this.emit("widget-blur",d,b);for(h++;h<=e;h++)if(d=r.byId(a[h]))d.set("focused",!0),d._focusManager==this&&d._onFocus(b),this.emit("widget-focus",d,b)}},focus:function(a){if(a)try{a.focus()}catch(b){}}}));a(function(){var a=w.registerWin(q.get(document));b("ie")&&c(window,"unload",function(){a&&(a.remove(),a=null)})});v.focus=function(a){w.focus(a)};for(var A in w)/^_/.test(A)||(v.focus[A]="function"==typeof w[A]?e.hitch(w,A):w[A]);w.watch(function(a,b,c){v.focus[a]=c});return w})},"dojo/Stateful":function(){define(["./_base/declare",
"./_base/lang","./_base/array","./when"],function(g,n,l,p){return g("dojo.Stateful",null,{_attrPairNames:{},_getAttrNames:function(g){var f=this._attrPairNames;return f[g]?f[g]:f[g]={s:"_"+g+"Setter",g:"_"+g+"Getter"}},postscript:function(g){g&&this.set(g)},_get:function(g,f){return"function"===typeof this[f.g]?this[f.g]():this[g]},get:function(g){return this._get(g,this._getAttrNames(g))},set:function(g,f){if("object"===typeof g){for(var m in g)g.hasOwnProperty(m)&&"_watchCallbacks"!=m&&this.set(m,
g[m]);return this}m=this._getAttrNames(g);var e=this._get(g,m);m=this[m.s];var c;"function"===typeof m?c=m.apply(this,Array.prototype.slice.call(arguments,1)):this[g]=f;if(this._watchCallbacks){var a=this;p(c,function(){a._watchCallbacks(g,e,f)})}return this},_changeAttrValue:function(g,f){var m=this.get(g);this[g]=f;this._watchCallbacks&&this._watchCallbacks(g,m,f);return this},watch:function(g,f){var m=this._watchCallbacks;if(!m)var e=this,m=this._watchCallbacks=function(a,c,d,f){var g=function(f){if(f){f=
f.slice();for(var g=0,k=f.length;g<k;g++)f[g].call(e,a,c,d)}};g(m["_"+a]);f||g(m["*"])};!f&&"function"===typeof g?(f=g,g="*"):g="_"+g;var c=m[g];"object"!==typeof c&&(c=m[g]=[]);c.push(f);var a={};a.unwatch=a.remove=function(){var a=l.indexOf(c,f);-1<a&&c.splice(a,1)};return a}})})},"dojo/window":function(){define("./_base/lang ./sniff ./_base/window ./dom ./dom-geometry ./dom-style ./dom-construct".split(" "),function(g,n,l,p,k,f,m){n.add("rtl-adjust-position-for-verticalScrollBar",function(c,a){var b=
l.body(a),e=m.create("div",{style:{overflow:"scroll",overflowX:"visible",direction:"rtl",visibility:"hidden",position:"absolute",left:"0",top:"0",width:"64px",height:"64px"}},b,"last"),d=m.create("div",{style:{overflow:"hidden",direction:"ltr"}},e,"last"),f=0!=k.position(d).x;e.removeChild(d);b.removeChild(e);return f});n.add("position-fixed-support",function(c,a){var b=l.body(a),e=m.create("span",{style:{visibility:"hidden",position:"fixed",left:"1px",top:"1px"}},b,"last"),d=m.create("span",{style:{position:"fixed",
left:"0",top:"0"}},e,"last"),f=k.position(d).x!=k.position(e).x;e.removeChild(d);b.removeChild(e);return f});var e={getBox:function(c){c=c||l.doc;var a="BackCompat"==c.compatMode?l.body(c):c.documentElement,b=k.docScroll(c);if(n("touch")){var h=e.get(c);c=h.innerWidth||a.clientWidth;a=h.innerHeight||a.clientHeight}else c=a.clientWidth,a=a.clientHeight;return{l:b.x,t:b.y,w:c,h:a}},get:function(c){if(n("ie")&&e!==document.parentWindow){c.parentWindow.execScript("document._parentWindow \x3d window;",
"Javascript");var a=c._parentWindow;c._parentWindow=null;return a}return c.parentWindow||c.defaultView},scrollIntoView:function(c,a){try{c=p.byId(c);var b=c.ownerDocument||l.doc,e=l.body(b),d=b.documentElement||e.parentNode,g=n("ie")||n("trident"),m=n("webkit");if(!(c==e||c==d))if(!n("mozilla")&&(!g&&!m&&!n("opera")&&!n("trident")&&!n("edge"))&&"scrollIntoView"in c)c.scrollIntoView(!1);else{var r="BackCompat"==b.compatMode,v=Math.min(e.clientWidth||d.clientWidth,d.clientWidth||e.clientWidth),t=Math.min(e.clientHeight||
d.clientHeight,d.clientHeight||e.clientHeight),b=m||r?e:d,u=a||k.position(c),w=c.parentNode,m=function(a){return 6>=g||7==g&&r?!1:n("position-fixed-support")&&"fixed"==f.get(a,"position").toLowerCase()},A=this,y=function(a,b,c){"BODY"==a.tagName||"HTML"==a.tagName?A.get(a.ownerDocument).scrollBy(b,c):(b&&(a.scrollLeft+=b),c&&(a.scrollTop+=c))};if(!m(c))for(;w;){w==e&&(w=b);var x=k.position(w),z=m(w),C="rtl"==f.getComputedStyle(w).direction.toLowerCase();if(w==b){x.w=v;x.h=t;if(b==d&&(g||n("trident"))&&
C)x.x+=b.offsetWidth-x.w;x.x=0;x.y=0}else{var B=k.getPadBorderExtents(w);x.w-=B.w;x.h-=B.h;x.x+=B.l;x.y+=B.t;var G=w.clientWidth,L=x.w-G;0<G&&0<L&&(C&&n("rtl-adjust-position-for-verticalScrollBar")&&(x.x+=L),x.w=G);G=w.clientHeight;L=x.h-G;0<G&&0<L&&(x.h=G)}z&&(0>x.y&&(x.h+=x.y,x.y=0),0>x.x&&(x.w+=x.x,x.x=0),x.y+x.h>t&&(x.h=t-x.y),x.x+x.w>v&&(x.w=v-x.x));var M=u.x-x.x,P=u.y-x.y,I=M+u.w-x.w,J=P+u.h-x.h,F,E;if(0<I*M&&(w.scrollLeft||w==b||w.scrollWidth>w.offsetHeight)){F=Math[0>M?"max":"min"](M,I);if(C&&
(8==g&&!r||5<=n("trident")))F=-F;E=w.scrollLeft;y(w,F,0);F=w.scrollLeft-E;u.x-=F}if(0<J*P&&(w.scrollTop||w==b||w.scrollHeight>w.offsetHeight))F=Math.ceil(Math[0>P?"max":"min"](P,J)),E=w.scrollTop,y(w,0,F),F=w.scrollTop-E,u.y-=F;w=w!=b&&!z&&w.parentNode}}}catch(D){console.error("scrollIntoView: "+D),c.scrollIntoView(!1)}}};g.setObject("dojo.window",e);return e})},"dijit/a11y":function(){define("dojo/_base/array dojo/dom dojo/dom-attr dojo/dom-style dojo/_base/lang dojo/sniff ./main".split(" "),function(g,
n,l,p,k,f,m){var e={_isElementShown:function(c){var a=p.get(c);return"hidden"!=a.visibility&&"collapsed"!=a.visibility&&"none"!=a.display&&"hidden"!=l.get(c,"type")},hasDefaultTabStop:function(c){switch(c.nodeName.toLowerCase()){case "a":return l.has(c,"href");case "area":case "button":case "input":case "object":case "select":case "textarea":return!0;case "iframe":var a;try{var b=c.contentDocument;if("designMode"in b&&"on"==b.designMode)return!0;a=b.body}catch(e){try{a=c.contentWindow.document.body}catch(d){return!1}}return a&&
("true"==a.contentEditable||a.firstChild&&"true"==a.firstChild.contentEditable);default:return"true"==c.contentEditable}},effectiveTabIndex:function(c){return l.get(c,"disabled")?void 0:l.has(c,"tabIndex")?+l.get(c,"tabIndex"):e.hasDefaultTabStop(c)?0:void 0},isTabNavigable:function(c){return 0<=e.effectiveTabIndex(c)},isFocusable:function(c){return-1<=e.effectiveTabIndex(c)},_getTabNavigable:function(c){function a(a){return a&&"input"==a.tagName.toLowerCase()&&a.type&&"radio"==a.type.toLowerCase()&&
a.name&&a.name.toLowerCase()}var b,h,d,g,k,m,n={},p=e._isElementShown,u=e.effectiveTabIndex,w=function(c){for(c=c.firstChild;c;c=c.nextSibling)if(!(1!=c.nodeType||9>=f("ie")&&"HTML"!==c.scopeName||!p(c))){var e=u(c);if(0<=e){if(0==e)b||(b=c),h=c;else if(0<e){if(!d||e<g)g=e,d=c;if(!k||e>=m)m=e,k=c}e=a(c);l.get(c,"checked")&&e&&(n[e]=c)}"SELECT"!=c.nodeName.toUpperCase()&&w(c)}};p(c)&&w(c);return{first:n[a(b)]||b,last:n[a(h)]||h,lowest:n[a(d)]||d,highest:n[a(k)]||k}},getFirstInTabbingOrder:function(c,
a){var b=e._getTabNavigable(n.byId(c,a));return b.lowest?b.lowest:b.first},getLastInTabbingOrder:function(c,a){var b=e._getTabNavigable(n.byId(c,a));return b.last?b.last:b.highest}};k.mixin(m,e);return e})},"dijit/main":function(){define(["dojo/_base/kernel"],function(g){return g.dijit})},"dijit/registry":function(){define(["dojo/_base/array","dojo/_base/window","./main"],function(g,n,l){var p={},k={},f={length:0,add:function(f){if(k[f.id])throw Error("Tried to register widget with id\x3d\x3d"+f.id+
" but that id is already registered");k[f.id]=f;this.length++},remove:function(f){k[f]&&(delete k[f],this.length--)},byId:function(f){return"string"==typeof f?k[f]:f},byNode:function(f){return k[f.getAttribute("widgetId")]},toArray:function(){var f=[],e;for(e in k)f.push(k[e]);return f},getUniqueId:function(f){var e;do e=f+"_"+(f in p?++p[f]:p[f]=0);while(k[e]);return"dijit"==l._scopeName?e:l._scopeName+"_"+e},findWidgets:function(f,e){function c(b){for(b=b.firstChild;b;b=b.nextSibling)if(1==b.nodeType){var h=
b.getAttribute("widgetId");h?(h=k[h])&&a.push(h):b!==e&&c(b)}}var a=[];c(f);return a},_destroyAll:function(){l._curFocus=null;l._prevFocus=null;l._activeStack=[];g.forEach(f.findWidgets(n.body()),function(f){f._destroyed||(f.destroyRecursive?f.destroyRecursive():f.destroy&&f.destroy())})},getEnclosingWidget:function(f){for(;f;){var e=1==f.nodeType&&f.getAttribute("widgetId");if(e)return k[e];f=f.parentNode}return null},_hash:k};return l.registry=f})},"dijit/layout/ContentPane":function(){define("dojo/_base/kernel dojo/_base/lang ../_Widget ../_Container ./_ContentPaneResizeMixin dojo/string dojo/html dojo/_base/array dojo/_base/declare dojo/_base/Deferred dojo/dom dojo/dom-attr dojo/dom-construct dojo/_base/xhr dojo/i18n dojo/when dojo/i18n!../nls/loading".split(" "),
function(g,n,l,p,k,f,m,e,c,a,b,h,d,q,s,r){return c("dijit.layout.ContentPane",[l,p,k],{href:"",content:"",extractContent:!1,parseOnLoad:!0,parserScope:g._scopeName,preventCache:!1,preload:!1,refreshOnShow:!1,loadingMessage:"\x3cspan class\x3d'dijitContentPaneLoading'\x3e\x3cspan class\x3d'dijitInline dijitIconLoading'\x3e\x3c/span\x3e${loadingState}\x3c/span\x3e",errorMessage:"\x3cspan class\x3d'dijitContentPaneError'\x3e\x3cspan class\x3d'dijitInline dijitIconError'\x3e\x3c/span\x3e${errorState}\x3c/span\x3e",
isLoaded:!1,baseClass:"dijitContentPane",ioArgs:{},onLoadDeferred:null,_setTitleAttr:null,stopParser:!0,template:!1,markupFactory:function(a,b,c){var d=new c(a,b);return!d.href&&d._contentSetter&&d._contentSetter.parseDeferred&&!d._contentSetter.parseDeferred.isFulfilled()?d._contentSetter.parseDeferred.then(function(){return d}):d},create:function(a,c){if((!a||!a.template)&&c&&!("href"in a)&&!("content"in a)){c=b.byId(c);for(var d=c.ownerDocument.createDocumentFragment();c.firstChild;)d.appendChild(c.firstChild);
a=n.delegate(a,{content:d})}this.inherited(arguments,[a,c])},postMixInProperties:function(){this.inherited(arguments);var a=s.getLocalization("dijit","loading",this.lang);this.loadingMessage=f.substitute(this.loadingMessage,a);this.errorMessage=f.substitute(this.errorMessage,a)},buildRendering:function(){this.inherited(arguments);this.containerNode||(this.containerNode=this.domNode);this.domNode.removeAttribute("title")},startup:function(){this.inherited(arguments);this._contentSetter&&e.forEach(this._contentSetter.parseResults,
function(a){!a._started&&(!a._destroyed&&n.isFunction(a.startup))&&(a.startup(),a._started=!0)},this)},_startChildren:function(){e.forEach(this.getChildren(),function(a){!a._started&&(!a._destroyed&&n.isFunction(a.startup))&&(a.startup(),a._started=!0)});this._contentSetter&&e.forEach(this._contentSetter.parseResults,function(a){!a._started&&(!a._destroyed&&n.isFunction(a.startup))&&(a.startup(),a._started=!0)},this)},setHref:function(a){g.deprecated("dijit.layout.ContentPane.setHref() is deprecated. Use set('href', ...) instead.",
"","2.0");return this.set("href",a)},_setHrefAttr:function(b){this.cancel();this.onLoadDeferred=new a(n.hitch(this,"cancel"));this.onLoadDeferred.then(n.hitch(this,"onLoad"));this._set("href",b);this.preload||this._created&&this._isShown()?this._load():this._hrefChanged=!0;return this.onLoadDeferred},setContent:function(a){g.deprecated("dijit.layout.ContentPane.setContent() is deprecated.  Use set('content', ...) instead.","","2.0");this.set("content",a)},_setContentAttr:function(b){this._set("href",
"");this.cancel();this.onLoadDeferred=new a(n.hitch(this,"cancel"));this._created&&this.onLoadDeferred.then(n.hitch(this,"onLoad"));this._setContent(b||"");this._isDownloaded=!1;return this.onLoadDeferred},_getContentAttr:function(){return this.containerNode.innerHTML},cancel:function(){this._xhrDfd&&-1==this._xhrDfd.fired&&this._xhrDfd.cancel();delete this._xhrDfd;this.onLoadDeferred=null},destroy:function(){this.cancel();this.inherited(arguments)},destroyRecursive:function(a){this._beingDestroyed||
this.inherited(arguments)},_onShow:function(){this.inherited(arguments);if(this.href&&!this._xhrDfd&&(!this.isLoaded||this._hrefChanged||this.refreshOnShow))return this.refresh()},refresh:function(){this.cancel();this.onLoadDeferred=new a(n.hitch(this,"cancel"));this.onLoadDeferred.then(n.hitch(this,"onLoad"));this._load();return this.onLoadDeferred},_load:function(){this._setContent(this.onDownloadStart(),!0);var a=this,b={preventCache:this.preventCache||this.refreshOnShow,url:this.href,handleAs:"text"};
n.isObject(this.ioArgs)&&n.mixin(b,this.ioArgs);var c=this._xhrDfd=(this.ioMethod||q.get)(b),d;c.then(function(b){d=b;try{return a._isDownloaded=!0,a._setContent(b,!1)}catch(c){a._onError("Content",c)}},function(b){c.canceled||a._onError("Download",b);delete a._xhrDfd;return b}).then(function(){a.onDownloadEnd();delete a._xhrDfd;return d});delete this._hrefChanged},_onLoadHandler:function(a){this._set("isLoaded",!0);try{this.onLoadDeferred.resolve(a)}catch(b){console.error("Error "+this.widgetId+
" running custom onLoad code: "+b.message)}},_onUnloadHandler:function(){this._set("isLoaded",!1);try{this.onUnload()}catch(a){console.error("Error "+this.widgetId+" running custom onUnload code: "+a.message)}},destroyDescendants:function(a){this.isLoaded&&this._onUnloadHandler();var b=this._contentSetter;e.forEach(this.getChildren(),function(b){b.destroyRecursive?b.destroyRecursive(a):b.destroy&&b.destroy(a);b._destroyed=!0});b&&(e.forEach(b.parseResults,function(b){b._destroyed||(b.destroyRecursive?
b.destroyRecursive(a):b.destroy&&b.destroy(a),b._destroyed=!0)}),delete b.parseResults);a||d.empty(this.containerNode);delete this._singleChild},_setContent:function(a,b){a=this.preprocessContent(a);this.destroyDescendants();var c=this._contentSetter;c&&c instanceof m._ContentSetter||(c=this._contentSetter=new m._ContentSetter({node:this.containerNode,_onError:n.hitch(this,this._onError),onContentError:n.hitch(this,function(a){a=this.onContentError(a);try{this.containerNode.innerHTML=a}catch(b){console.error("Fatal "+
this.id+" could not change content due to "+b.message,b)}})}));var d=n.mixin({cleanContent:this.cleanContent,extractContent:this.extractContent,parseContent:!a.domNode&&this.parseOnLoad,parserScope:this.parserScope,startup:!1,dir:this.dir,lang:this.lang,textDir:this.textDir},this._contentSetterParams||{}),d=c.set(n.isObject(a)&&a.domNode?a.domNode:a,d),e=this;return r(d&&d.then?d:c.parseDeferred,function(){delete e._contentSetterParams;b||(e._started&&(e._startChildren(),e._scheduleLayout()),e._onLoadHandler(a))})},
preprocessContent:function(a){return a},_onError:function(a,b,c){this.onLoadDeferred.reject(b);a=this["on"+a+"Error"].call(this,b);c?console.error(c,b):a&&this._setContent(a,!0)},onLoad:function(){},onUnload:function(){},onDownloadStart:function(){return this.loadingMessage},onContentError:function(){},onDownloadError:function(){return this.errorMessage},onDownloadEnd:function(){}})})},"dijit/_Widget":function(){define("dojo/aspect dojo/_base/config dojo/_base/connect dojo/_base/declare dojo/has dojo/_base/kernel dojo/_base/lang dojo/query dojo/ready ./registry ./_WidgetBase ./_OnDijitClickMixin ./_FocusMixin dojo/uacss ./hccss".split(" "),
function(g,n,l,p,k,f,m,e,c,a,b,h,d){function q(){}function s(a){return function(b,c,d,e){return b&&"string"==typeof c&&b[c]==q?b.on(c.substring(2).toLowerCase(),m.hitch(d,e)):a.apply(l,arguments)}}g.around(l,"connect",s);f.connect&&g.around(f,"connect",s);g=p("dijit._Widget",[b,h,d],{onClick:q,onDblClick:q,onKeyDown:q,onKeyPress:q,onKeyUp:q,onMouseDown:q,onMouseMove:q,onMouseOut:q,onMouseOver:q,onMouseLeave:q,onMouseEnter:q,onMouseUp:q,constructor:function(a){this._toConnect={};for(var b in a)this[b]===
q&&(this._toConnect[b.replace(/^on/,"").toLowerCase()]=a[b],delete a[b])},postCreate:function(){this.inherited(arguments);for(var a in this._toConnect)this.on(a,this._toConnect[a]);delete this._toConnect},on:function(a,b){return this[this._onMap(a)]===q?l.connect(this.domNode,a.toLowerCase(),this,b):this.inherited(arguments)},_setFocusedAttr:function(a){this._focused=a;this._set("focused",a)},setAttribute:function(a,b){f.deprecated(this.declaredClass+"::setAttribute(attr, value) is deprecated. Use set() instead.",
"","2.0");this.set(a,b)},attr:function(a,b){return 2<=arguments.length||"object"===typeof a?this.set.apply(this,arguments):this.get(a)},getDescendants:function(){f.deprecated(this.declaredClass+"::getDescendants() is deprecated. Use getChildren() instead.","","2.0");return this.containerNode?e("[widgetId]",this.containerNode).map(a.byNode):[]},_onShow:function(){this.onShow()},onShow:function(){},onHide:function(){},onClose:function(){return!0}});k("dijit-legacy-requires")&&c(0,function(){require(["dijit/_base"])});
return g})},"dijit/_WidgetBase":function(){define("require dojo/_base/array dojo/aspect dojo/_base/config dojo/_base/connect dojo/_base/declare dojo/dom dojo/dom-attr dojo/dom-class dojo/dom-construct dojo/dom-geometry dojo/dom-style dojo/has dojo/_base/kernel dojo/_base/lang dojo/on dojo/ready dojo/Stateful dojo/topic dojo/_base/window ./Destroyable dojo/has!dojo-bidi?./_BidiMixin ./registry".split(" "),function(g,n,l,p,k,f,m,e,c,a,b,h,d,q,s,r,v,t,u,w,A,y,x){function z(a){return function(b){e[b?
"set":"remove"](this.domNode,a,b);this._set(a,b)}}d.add("dijit-legacy-requires",!q.isAsync);d.add("dojo-bidi",!1);d("dijit-legacy-requires")&&v(0,function(){g(["dijit/_base/manager"])});var C={};p=f("dijit._WidgetBase",[t,A],{id:"",_setIdAttr:"domNode",lang:"",_setLangAttr:z("lang"),dir:"",_setDirAttr:z("dir"),"class":"",_setClassAttr:{node:"domNode",type:"class"},_setTypeAttr:null,style:"",title:"",tooltip:"",baseClass:"",srcNodeRef:null,domNode:null,containerNode:null,ownerDocument:null,_setOwnerDocumentAttr:function(a){this._set("ownerDocument",
a)},attributeMap:{},_blankGif:p.blankGif||g.toUrl("dojo/resources/blank.gif"),textDir:"",_introspect:function(){var a=this.constructor;if(!a._setterAttrs){var b=a.prototype,c=a._setterAttrs=[],a=a._onMap={},d;for(d in b.attributeMap)c.push(d);for(d in b)/^on/.test(d)&&(a[d.substring(2).toLowerCase()]=d),/^_set[A-Z](.*)Attr$/.test(d)&&(d=d.charAt(4).toLowerCase()+d.substr(5,d.length-9),(!b.attributeMap||!(d in b.attributeMap))&&c.push(d))}},postscript:function(a,b){this.create(a,b)},create:function(a,
b){this._introspect();this.srcNodeRef=m.byId(b);this._connects=[];this._supportingWidgets=[];this.srcNodeRef&&(this.srcNodeRef.id&&"string"==typeof this.srcNodeRef.id)&&(this.id=this.srcNodeRef.id);a&&(this.params=a,s.mixin(this,a));this.postMixInProperties();this.id||(this.id=x.getUniqueId(this.declaredClass.replace(/\./g,"_")),this.params&&delete this.params.id);this.ownerDocument=this.ownerDocument||(this.srcNodeRef?this.srcNodeRef.ownerDocument:document);this.ownerDocumentBody=w.body(this.ownerDocument);
x.add(this);this.buildRendering();var c;if(this.domNode){this._applyAttributes();var d=this.srcNodeRef;d&&(d.parentNode&&this.domNode!==d)&&(d.parentNode.replaceChild(this.domNode,d),c=!0);this.domNode.setAttribute("widgetId",this.id)}this.postCreate();c&&delete this.srcNodeRef;this._created=!0},_applyAttributes:function(){var a={},b;for(b in this.params||{})a[b]=this._get(b);n.forEach(this.constructor._setterAttrs,function(b){if(!(b in a)){var c=this._get(b);c&&this.set(b,c)}},this);for(b in a)this.set(b,
a[b])},postMixInProperties:function(){},buildRendering:function(){this.domNode||(this.domNode=this.srcNodeRef||this.ownerDocument.createElement("div"));if(this.baseClass){var a=this.baseClass.split(" ");this.isLeftToRight()||(a=a.concat(n.map(a,function(a){return a+"Rtl"})));c.add(this.domNode,a)}},postCreate:function(){},startup:function(){this._started||(this._started=!0,n.forEach(this.getChildren(),function(a){!a._started&&(!a._destroyed&&s.isFunction(a.startup))&&(a.startup(),a._started=!0)}))},
destroyRecursive:function(a){this._beingDestroyed=!0;this.destroyDescendants(a);this.destroy(a)},destroy:function(a){function b(c){c.destroyRecursive?c.destroyRecursive(a):c.destroy&&c.destroy(a)}this._beingDestroyed=!0;this.uninitialize();n.forEach(this._connects,s.hitch(this,"disconnect"));n.forEach(this._supportingWidgets,b);this.domNode&&n.forEach(x.findWidgets(this.domNode,this.containerNode),b);this.destroyRendering(a);x.remove(this.id);this._destroyed=!0},destroyRendering:function(b){this.bgIframe&&
(this.bgIframe.destroy(b),delete this.bgIframe);this.domNode&&(b?e.remove(this.domNode,"widgetId"):a.destroy(this.domNode),delete this.domNode);this.srcNodeRef&&(b||a.destroy(this.srcNodeRef),delete this.srcNodeRef)},destroyDescendants:function(a){n.forEach(this.getChildren(),function(b){b.destroyRecursive&&b.destroyRecursive(a)})},uninitialize:function(){return!1},_setStyleAttr:function(a){var b=this.domNode;s.isObject(a)?h.set(b,a):b.style.cssText=b.style.cssText?b.style.cssText+("; "+a):a;this._set("style",
a)},_attrToDom:function(a,b,d){d=3<=arguments.length?d:this.attributeMap[a];n.forEach(s.isArray(d)?d:[d],function(d){var h=this[d.node||d||"domNode"];switch(d.type||"attribute"){case "attribute":s.isFunction(b)&&(b=s.hitch(this,b));d=d.attribute?d.attribute:/^on[A-Z][a-zA-Z]*$/.test(a)?a.toLowerCase():a;h.tagName?e.set(h,d,b):h.set(d,b);break;case "innerText":h.innerHTML="";h.appendChild(this.ownerDocument.createTextNode(b));break;case "innerHTML":h.innerHTML=b;break;case "class":c.replace(h,b,this[a]);
break;case "toggleClass":c.toggle(h,d.className||a,b)}},this)},get:function(a){var b=this._getAttrNames(a);return this[b.g]?this[b.g]():this._get(a)},set:function(a,b){if("object"===typeof a){for(var c in a)this.set(c,a[c]);return this}c=this._getAttrNames(a);var d=this[c.s];if(s.isFunction(d))var e=d.apply(this,Array.prototype.slice.call(arguments,1));else{var d=this.focusNode&&!s.isFunction(this.focusNode)?"focusNode":"domNode",h=this[d]&&this[d].tagName,f;if(f=h)if(!(f=C[h])){f=this[d];var g={},
k;for(k in f)g[k.toLowerCase()]=!0;f=C[h]=g}k=f;c=a in this.attributeMap?this.attributeMap[a]:c.s in this?this[c.s]:k&&c.l in k&&"function"!=typeof b||/^aria-|^data-|^role$/.test(a)?d:null;null!=c&&this._attrToDom(a,b,c);this._set(a,b)}return e||this},_attrPairNames:{},_getAttrNames:function(a){var b=this._attrPairNames;if(b[a])return b[a];var c=a.replace(/^[a-z]|-[a-zA-Z]/g,function(a){return a.charAt(a.length-1).toUpperCase()});return b[a]={n:a+"Node",s:"_set"+c+"Attr",g:"_get"+c+"Attr",l:c.toLowerCase()}},
_set:function(a,b){var c=this[a];this[a]=b;if(this._created&&!(c===b||c!==c&&b!==b))this._watchCallbacks&&this._watchCallbacks(a,c,b),this.emit("attrmodified-"+a,{detail:{prevValue:c,newValue:b}})},_get:function(a){return this[a]},emit:function(a,b,c){b=b||{};void 0===b.bubbles&&(b.bubbles=!0);void 0===b.cancelable&&(b.cancelable=!0);b.detail||(b.detail={});b.detail.widget=this;var d,e=this["on"+a];e&&(d=e.apply(this,c?c:[b]));this._started&&!this._beingDestroyed&&r.emit(this.domNode,a.toLowerCase(),
b);return d},on:function(a,b){var c=this._onMap(a);return c?l.after(this,c,b,!0):this.own(r(this.domNode,a,b))[0]},_onMap:function(a){var b=this.constructor,c=b._onMap;if(!c){var c=b._onMap={},d;for(d in b.prototype)/^on/.test(d)&&(c[d.replace(/^on/,"").toLowerCase()]=d)}return c["string"==typeof a&&a.toLowerCase()]},toString:function(){return"[Widget "+this.declaredClass+", "+(this.id||"NO ID")+"]"},getChildren:function(){return this.containerNode?x.findWidgets(this.containerNode):[]},getParent:function(){return x.getEnclosingWidget(this.domNode.parentNode)},
connect:function(a,b,c){return this.own(k.connect(a,b,this,c))[0]},disconnect:function(a){a.remove()},subscribe:function(a,b){return this.own(u.subscribe(a,s.hitch(this,b)))[0]},unsubscribe:function(a){a.remove()},isLeftToRight:function(){return this.dir?"ltr"==this.dir.toLowerCase():b.isBodyLtr(this.ownerDocument)},isFocusable:function(){return this.focus&&"none"!=h.get(this.domNode,"display")},placeAt:function(b,c){var d=!b.tagName&&x.byId(b);d&&d.addChild&&(!c||"number"===typeof c)?d.addChild(this,
c):(d=d&&"domNode"in d?d.containerNode&&!/after|before|replace/.test(c||"")?d.containerNode:d.domNode:m.byId(b,this.ownerDocument),a.place(this.domNode,d,c),!this._started&&(this.getParent()||{})._started&&this.startup());return this},defer:function(a,b){var c=setTimeout(s.hitch(this,function(){c&&(c=null,this._destroyed||s.hitch(this,a)())}),b||0);return{remove:function(){c&&(clearTimeout(c),c=null);return null}}}});d("dojo-bidi")&&p.extend(y);return p})},"dijit/Destroyable":function(){define(["dojo/_base/array",
"dojo/aspect","dojo/_base/declare"],function(g,n,l){return l("dijit.Destroyable",null,{destroy:function(g){this._destroyed=!0},own:function(){var l=["destroyRecursive","destroy","remove"];g.forEach(arguments,function(k){function f(){e.remove();g.forEach(c,function(a){a.remove()})}var m,e=n.before(this,"destroy",function(a){k[m](a)}),c=[];k.then?(m="cancel",k.then(f,f)):g.forEach(l,function(a){"function"===typeof k[a]&&(m||(m=a),c.push(n.after(k,a,f,!0)))})},this);return arguments}})})},"dijit/_OnDijitClickMixin":function(){define("dojo/on dojo/_base/array dojo/keys dojo/_base/declare dojo/has ./a11yclick".split(" "),
function(g,n,l,p,k,f){g=p("dijit._OnDijitClickMixin",null,{connect:function(g,e,c){return this.inherited(arguments,[g,"ondijitclick"==e?f:e,c])}});g.a11yclick=f;return g})},"dijit/a11yclick":function(){define(["dojo/keys","dojo/mouse","dojo/on","dojo/touch"],function(g,n,l,p){function k(e){if((e.keyCode===g.ENTER||e.keyCode===g.SPACE)&&!/input|button|textarea/i.test(e.target.nodeName))for(e=e.target;e;e=e.parentNode)if(e.dojoClick)return!0}var f;l(document,"keydown",function(e){k(e)?(f=e.target,e.preventDefault()):
f=null});l(document,"keyup",function(e){k(e)&&e.target==f&&(f=null,l.emit(e.target,"click",{cancelable:!0,bubbles:!0,ctrlKey:e.ctrlKey,shiftKey:e.shiftKey,metaKey:e.metaKey,altKey:e.altKey,_origType:e.type}))});var m=function(e,c){e.dojoClick=!0;return l(e,"click",c)};m.click=m;m.press=function(e,c){var a=l(e,p.press,function(a){("mousedown"!=a.type||n.isLeft(a))&&c(a)}),b=l(e,"keydown",function(a){(a.keyCode===g.ENTER||a.keyCode===g.SPACE)&&c(a)});return{remove:function(){a.remove();b.remove()}}};
m.release=function(e,c){var a=l(e,p.release,function(a){("mouseup"!=a.type||n.isLeft(a))&&c(a)}),b=l(e,"keyup",function(a){(a.keyCode===g.ENTER||a.keyCode===g.SPACE)&&c(a)});return{remove:function(){a.remove();b.remove()}}};m.move=p.move;return m})},"dojo/touch":function(){define("./_base/kernel ./aspect ./dom ./dom-class ./_base/lang ./on ./has ./mouse ./domReady ./_base/window".split(" "),function(g,n,l,p,k,f,m,e,c,a){function b(a,b,c){return s&&c?function(a,b){return f(a,c,b)}:v?function(c,d){var e=
f(c,b,function(a){d.call(this,a);G=(new Date).getTime()}),h=f(c,a,function(a){(!G||(new Date).getTime()>G+1E3)&&d.call(this,a)});return{remove:function(){e.remove();h.remove()}}}:function(b,c){return f(b,a,c)}}function h(a){do if(void 0!==a.dojoClick)return a;while(a=a.parentNode)}function d(b,c,d){if(!e.isRight(b)){var g=h(b.target);if(u=!b.target.disabled&&g&&g.dojoClick)if(A=(w="useTarget"==u)?g:b.target,w&&b.preventDefault(),y=b.changedTouches?b.changedTouches[0].pageX-a.global.pageXOffset:b.clientX,
x=b.changedTouches?b.changedTouches[0].pageY-a.global.pageYOffset:b.clientY,z=("object"==typeof u?u.x:"number"==typeof u?u:0)||4,C=("object"==typeof u?u.y:"number"==typeof u?u:0)||4,!t){t=!0;var k=function(b){u=w?l.isDescendant(a.doc.elementFromPoint(b.changedTouches?b.changedTouches[0].pageX-a.global.pageXOffset:b.clientX,b.changedTouches?b.changedTouches[0].pageY-a.global.pageYOffset:b.clientY),A):u&&(b.changedTouches?b.changedTouches[0].target:b.target)==A&&Math.abs((b.changedTouches?b.changedTouches[0].pageX-
a.global.pageXOffset:b.clientX)-y)<=z&&Math.abs((b.changedTouches?b.changedTouches[0].pageY-a.global.pageYOffset:b.clientY)-x)<=C};a.doc.addEventListener(c,function(a){e.isRight(a)||(k(a),w&&a.preventDefault())},!0);a.doc.addEventListener(d,function(a){if(!e.isRight(a)&&(k(a),u)){B=(new Date).getTime();var b=w?A:a.target;"LABEL"===b.tagName&&(b=l.byId(b.getAttribute("for"))||b);var c=a.changedTouches?a.changedTouches[0]:a,d=function(b){var d=document.createEvent("MouseEvents");d._dojo_click=!0;d.initMouseEvent(b,
!0,!0,a.view,a.detail,c.screenX,c.screenY,c.clientX,c.clientY,a.ctrlKey,a.altKey,a.shiftKey,a.metaKey,0,null);return d},h=d("mousedown"),g=d("mouseup"),m=d("click");setTimeout(function(){f.emit(b,"mousedown",h);f.emit(b,"mouseup",g);f.emit(b,"click",m);B=(new Date).getTime()},0)}},!0);b=function(b){a.doc.addEventListener(b,function(a){var c=a.target;u&&(!a._dojo_click&&(new Date).getTime()<=B+1E3&&!("INPUT"==c.tagName&&p.contains(c,"dijitOffScreen")))&&(a.stopPropagation(),a.stopImmediatePropagation&&
a.stopImmediatePropagation(),"click"==b&&(("INPUT"!=c.tagName||"radio"==c.type&&(p.contains(c,"dijitCheckBoxInput")||p.contains(c,"mblRadioButton"))||"checkbox"==c.type&&(p.contains(c,"dijitCheckBoxInput")||p.contains(c,"mblCheckBox")))&&"TEXTAREA"!=c.tagName&&"AUDIO"!=c.tagName&&"VIDEO"!=c.tagName)&&a.preventDefault())},!0)};b("click");b("mousedown");b("mouseup")}}}var q=5>m("ios"),s=m("pointer-events")||m("MSPointer"),r=function(){var a={},b;for(b in{down:1,move:1,up:1,cancel:1,over:1,out:1})a[b]=
m("MSPointer")?"MSPointer"+b.charAt(0).toUpperCase()+b.slice(1):"pointer"+b;return a}(),v=m("touch-events"),t,u,w=!1,A,y,x,z,C,B,G,L;m("touch")&&(s?c(function(){a.doc.addEventListener(r.down,function(a){d(a,r.move,r.up)},!0)}):c(function(){function b(a){var c=k.delegate(a,{bubbles:!0});6<=m("ios")&&(c.touches=a.touches,c.altKey=a.altKey,c.changedTouches=a.changedTouches,c.ctrlKey=a.ctrlKey,c.metaKey=a.metaKey,c.shiftKey=a.shiftKey,c.targetTouches=a.targetTouches);return c}L=a.body();a.doc.addEventListener("touchstart",
function(a){G=(new Date).getTime();var b=L;L=a.target;f.emit(b,"dojotouchout",{relatedTarget:L,bubbles:!0});f.emit(L,"dojotouchover",{relatedTarget:b,bubbles:!0});d(a,"touchmove","touchend")},!0);f(a.doc,"touchmove",function(c){G=(new Date).getTime();var d=a.doc.elementFromPoint(c.pageX-(q?0:a.global.pageXOffset),c.pageY-(q?0:a.global.pageYOffset));d&&(L!==d&&(f.emit(L,"dojotouchout",{relatedTarget:d,bubbles:!0}),f.emit(d,"dojotouchover",{relatedTarget:L,bubbles:!0}),L=d),f.emit(d,"dojotouchmove",
b(c))||c.preventDefault())});f(a.doc,"touchend",function(c){G=(new Date).getTime();var d=a.doc.elementFromPoint(c.pageX-(q?0:a.global.pageXOffset),c.pageY-(q?0:a.global.pageYOffset))||a.body();f.emit(d,"dojotouchend",b(c))})}));n={press:b("mousedown","touchstart",r.down),move:b("mousemove","dojotouchmove",r.move),release:b("mouseup","dojotouchend",r.up),cancel:b(e.leave,"touchcancel",s?r.cancel:null),over:b("mouseover","dojotouchover",r.over),out:b("mouseout","dojotouchout",r.out),enter:e._eventHandler(b("mouseover",
"dojotouchover",r.over)),leave:e._eventHandler(b("mouseout","dojotouchout",r.out))};return g.touch=n})},"dijit/_FocusMixin":function(){define(["./focus","./_WidgetBase","dojo/_base/declare","dojo/_base/lang"],function(g,n,l,p){p.extend(n,{focused:!1,onFocus:function(){},onBlur:function(){},_onFocus:function(){this.onFocus()},_onBlur:function(){this.onBlur()}});return l("dijit._FocusMixin",null,{_focusManager:g})})},"dojo/uacss":function(){define(["./dom-geometry","./_base/lang","./domReady","./sniff",
"./_base/window"],function(g,n,l,p,k){var f=k.doc.documentElement;k=p("ie");var m=p("trident"),e=p("opera"),c=Math.floor,a=p("ff"),b=g.boxModel.replace(/-/,""),e={dj_quirks:p("quirks"),dj_opera:e,dj_khtml:p("khtml"),dj_webkit:p("webkit"),dj_safari:p("safari"),dj_chrome:p("chrome"),dj_edge:p("edge"),dj_gecko:p("mozilla"),dj_ios:p("ios"),dj_android:p("android")};k&&(e.dj_ie=!0,e["dj_ie"+c(k)]=!0,e.dj_iequirks=p("quirks"));m&&(e.dj_trident=!0,e["dj_trident"+c(m)]=!0);a&&(e["dj_ff"+c(a)]=!0);e["dj_"+
b]=!0;var h="",d;for(d in e)e[d]&&(h+=d+" ");f.className=n.trim(f.className+" "+h);l(function(){if(!g.isBodyLtr()){var a="dj_rtl dijitRtl "+h.replace(/ /g,"-rtl ");f.className=n.trim(f.className+" "+a+"dj_rtl dijitRtl "+h.replace(/ /g,"-rtl "))}});return p})},"dijit/hccss":function(){define(["dojo/dom-class","dojo/hccss","dojo/domReady","dojo/_base/window"],function(g,n,l,p){l(function(){n("highcontrast")&&g.add(p.body(),"dijit_a11y")});return n})},"dojo/hccss":function(){define("require ./_base/config ./dom-class ./dom-style ./has ./domReady ./_base/window".split(" "),
function(g,n,l,p,k,f,m){k.add("highcontrast",function(){var e=m.doc.createElement("div");try{e.style.cssText='border: 1px solid; border-color:red green; position: absolute; height: 5px; top: -999px;background-image: url("'+(n.blankGif||g.toUrl("./resources/blank.gif"))+'");';m.body().appendChild(e);var c=p.getComputedStyle(e),a=c.backgroundImage;return c.borderTopColor==c.borderRightColor||a&&("none"==a||"url(invalid-url:)"==a)}catch(b){return console.warn("hccss: exception detecting high-contrast mode, document is likely hidden: "+
b.toString()),!1}finally{8>=k("ie")?e.outerHTML="":m.body().removeChild(e)}});f(function(){k("highcontrast")&&l.add(m.body(),"dj_a11y")});return k})},"dijit/_Container":function(){define(["dojo/_base/array","dojo/_base/declare","dojo/dom-construct","dojo/_base/kernel"],function(g,n,l,p){return n("dijit._Container",null,{buildRendering:function(){this.inherited(arguments);this.containerNode||(this.containerNode=this.domNode)},addChild:function(g,f){var m=this.containerNode;if(0<f){for(m=m.firstChild;0<
f;)1==m.nodeType&&f--,m=m.nextSibling;m?f="before":(m=this.containerNode,f="last")}l.place(g.domNode,m,f);this._started&&!g._started&&g.startup()},removeChild:function(g){"number"==typeof g&&(g=this.getChildren()[g]);g&&(g=g.domNode)&&g.parentNode&&g.parentNode.removeChild(g)},hasChildren:function(){return 0<this.getChildren().length},_getSiblingOfChild:function(k,f){var m=this.getChildren(),e=g.indexOf(m,k);return m[e+f]},getIndexOfChild:function(k){return g.indexOf(this.getChildren(),k)}})})},"dijit/layout/_ContentPaneResizeMixin":function(){define("dojo/_base/array dojo/_base/declare dojo/dom-class dojo/dom-geometry dojo/dom-style dojo/_base/lang dojo/query ../registry ../Viewport ./utils".split(" "),
function(g,n,l,p,k,f,m,e,c,a){return n("dijit.layout._ContentPaneResizeMixin",null,{doLayout:!0,isLayoutContainer:!0,startup:function(){if(!this._started){var a=this.getParent();this._childOfLayoutWidget=a&&a.isLayoutContainer;this._needLayout=!this._childOfLayoutWidget;this.inherited(arguments);this._isShown()&&this._onShow();this._childOfLayoutWidget||this.own(c.on("resize",f.hitch(this,"resize")))}},_checkIfSingleChild:function(){if(this.doLayout){var a=[],c=!1;m("\x3e *",this.containerNode).some(function(d){var f=
e.byNode(d);f&&f.resize?a.push(f):!/script|link|style/i.test(d.nodeName)&&d.offsetHeight&&(c=!0)});this._singleChild=1==a.length&&!c?a[0]:null;l.toggle(this.containerNode,this.baseClass+"SingleChild",!!this._singleChild)}},resize:function(a,c){this._resizeCalled=!0;this._scheduleLayout(a,c)},_scheduleLayout:function(a,c){this._isShown()?this._layout(a,c):(this._needLayout=!0,this._changeSize=a,this._resultSize=c)},_layout:function(b,c){delete this._needLayout;!this._wasShown&&!1!==this.open&&this._onShow();
b&&p.setMarginBox(this.domNode,b);var d=this.containerNode;if(d===this.domNode){var e=c||{};f.mixin(e,b||{});if(!("h"in e)||!("w"in e))e=f.mixin(p.getMarginBox(d),e);this._contentBox=a.marginBox2contentBox(d,e)}else this._contentBox=p.getContentBox(d);this._layoutChildren()},_layoutChildren:function(){this._checkIfSingleChild();if(this._singleChild&&this._singleChild.resize){var a=this._contentBox||p.getContentBox(this.containerNode);this._singleChild.resize({w:a.w,h:a.h})}else for(var a=this.getChildren(),
c,d=0;c=a[d++];)c.resize&&c.resize()},_isShown:function(){if(this._childOfLayoutWidget)return this._resizeCalled&&"open"in this?this.open:this._resizeCalled;if("open"in this)return this.open;var a=this.domNode,c=this.domNode.parentNode;return"none"!=a.style.display&&"hidden"!=a.style.visibility&&!l.contains(a,"dijitHidden")&&c&&c.style&&"none"!=c.style.display},_onShow:function(){this._wasShown=!0;this._needLayout&&this._layout(this._changeSize,this._resultSize);this.inherited(arguments)}})})},"dijit/Viewport":function(){define(["dojo/Evented",
"dojo/on","dojo/domReady","dojo/sniff","dojo/window"],function(g,n,l,p,k){var f=new g,m;l(function(){var e=k.getBox();f._rlh=n(window,"resize",function(){var a=k.getBox();e.h==a.h&&e.w==a.w||(e=a,f.emit("resize"))});if(8==p("ie")){var c=screen.deviceXDPI;setInterval(function(){screen.deviceXDPI!=c&&(c=screen.deviceXDPI,f.emit("resize"))},500)}p("ios")&&(n(document,"focusin",function(a){m=a.target}),n(document,"focusout",function(a){m=null}))});f.getEffectiveBox=function(e){e=k.getBox(e);var c=m&&
m.tagName&&m.tagName.toLowerCase();if(p("ios")&&m&&!m.readOnly&&("textarea"==c||"input"==c&&/^(color|email|number|password|search|tel|text|url)$/.test(m.type)))e.h*=0==orientation||180==orientation?0.66:0.4,c=m.getBoundingClientRect(),e.h=Math.max(e.h,c.top+c.height);return e};return f})},"dijit/layout/utils":function(){define(["dojo/_base/array","dojo/dom-class","dojo/dom-geometry","dojo/dom-style","dojo/_base/lang"],function(g,n,l,p,k){function f(e,c){var a=e.resize?e.resize(c):l.setMarginBox(e.domNode,
c);a?k.mixin(e,a):(k.mixin(e,l.getMarginBox(e.domNode)),k.mixin(e,c))}var m={marginBox2contentBox:function(e,c){var a=p.getComputedStyle(e),b=l.getMarginExtents(e,a),h=l.getPadBorderExtents(e,a);return{l:p.toPixelValue(e,a.paddingLeft),t:p.toPixelValue(e,a.paddingTop),w:c.w-(b.w+h.w),h:c.h-(b.h+h.h)}},layoutChildren:function(e,c,a,b,h){c=k.mixin({},c);n.add(e,"dijitLayoutContainer");a=g.filter(a,function(a){return"center"!=a.region&&"client"!=a.layoutAlign}).concat(g.filter(a,function(a){return"center"==
a.region||"client"==a.layoutAlign}));g.forEach(a,function(a){var e=a.domNode,g=a.region||a.layoutAlign;if(!g)throw Error("No region setting for "+a.id);var k=e.style;k.left=c.l+"px";k.top=c.t+"px";k.position="absolute";n.add(e,"dijitAlign"+(g.substring(0,1).toUpperCase()+g.substring(1)));e={};b&&b==a.id&&(e["top"==a.region||"bottom"==a.region?"h":"w"]=h);"leading"==g&&(g=a.isLeftToRight()?"left":"right");"trailing"==g&&(g=a.isLeftToRight()?"right":"left");"top"==g||"bottom"==g?(e.w=c.w,f(a,e),c.h-=
a.h,"top"==g?c.t+=a.h:k.top=c.t+c.h+"px"):"left"==g||"right"==g?(e.h=c.h,f(a,e),c.w-=a.w,"left"==g?c.l+=a.w:k.left=c.l+c.w+"px"):("client"==g||"center"==g)&&f(a,c)})}};k.setObject("dijit.layout.utils",m);return m})},"dojo/string":function(){define(["./_base/kernel","./_base/lang"],function(g,n){var l=/[&<>'"\/]/g,p={"\x26":"\x26amp;","\x3c":"\x26lt;","\x3e":"\x26gt;",'"':"\x26quot;","'":"\x26#x27;","/":"\x26#x2F;"},k={};n.setObject("dojo.string",k);k.escape=function(f){return!f?"":f.replace(l,function(f){return p[f]})};
k.rep=function(f,g){if(0>=g||!f)return"";for(var e=[];;){g&1&&e.push(f);if(!(g>>=1))break;f+=f}return e.join("")};k.pad=function(f,g,e,c){e||(e="0");f=String(f);g=k.rep(e,Math.ceil((g-f.length)/e.length));return c?f+g:g+f};k.substitute=function(f,k,e,c){c=c||g.global;e=e?n.hitch(c,e):function(a){return a};return f.replace(/\$\{([^\s\:\}]*)(?:\:([^\s\:\}]+))?\}/g,function(a,b,h){if(""==b)return"$";a=n.getObject(b,!1,k);h&&(a=n.getObject(h,!1,c).call(c,a,b));return e(a,b).toString()})};k.trim=String.prototype.trim?
n.trim:function(f){f=f.replace(/^\s+/,"");for(var g=f.length-1;0<=g;g--)if(/\S/.test(f.charAt(g))){f=f.substring(0,g+1);break}return f};return k})},"dojo/html":function(){define("./_base/kernel ./_base/lang ./_base/array ./_base/declare ./dom ./dom-construct ./parser".split(" "),function(g,n,l,p,k,f,m){var e=0,c={_secureForInnerHtml:function(a){return a.replace(/(?:\s*<!DOCTYPE\s[^>]+>|<title[^>]*>[\s\S]*?<\/title>)/ig,"")},_emptyNode:f.empty,_setNodeContent:function(a,b){f.empty(a);if(b)if("number"==
typeof b&&(b=b.toString()),"string"==typeof b&&(b=f.toDom(b,a.ownerDocument)),!b.nodeType&&n.isArrayLike(b))for(var c=b.length,d=0;d<b.length;d=c==b.length?d+1:0)f.place(b[d],a,"last");else f.place(b,a,"last");return a},_ContentSetter:p("dojo.html._ContentSetter",null,{node:"",content:"",id:"",cleanContent:!1,extractContent:!1,parseContent:!1,parserScope:g._scopeName,startup:!0,constructor:function(a,b){n.mixin(this,a||{});b=this.node=k.byId(this.node||b);this.id||(this.id=["Setter",b?b.id||b.tagName:
"",e++].join("_"))},set:function(a,b){void 0!==a&&(this.content=a);b&&this._mixin(b);this.onBegin();this.setContent();var c=this.onEnd();return c&&c.then?c:this.node},setContent:function(){var a=this.node;if(!a)throw Error(this.declaredClass+": setContent given no node");try{a=c._setNodeContent(a,this.content)}catch(b){var e=this.onContentError(b);try{a.innerHTML=e}catch(d){console.error("Fatal "+this.declaredClass+".setContent could not change content due to "+d.message,d)}}this.node=a},empty:function(){this.parseDeferred&&
(this.parseDeferred.isResolved()||this.parseDeferred.cancel(),delete this.parseDeferred);this.parseResults&&this.parseResults.length&&(l.forEach(this.parseResults,function(a){a.destroy&&a.destroy()}),delete this.parseResults);f.empty(this.node)},onBegin:function(){var a=this.content;if(n.isString(a)&&(this.cleanContent&&(a=c._secureForInnerHtml(a)),this.extractContent)){var b=a.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);b&&(a=b[1])}this.empty();this.content=a;return this.node},onEnd:function(){this.parseContent&&
this._parse();return this.node},tearDown:function(){delete this.parseResults;delete this.parseDeferred;delete this.node;delete this.content},onContentError:function(a){return"Error occurred setting content: "+a},onExecError:function(a){return"Error occurred executing scripts: "+a},_mixin:function(a){var b={},c;for(c in a)c in b||(this[c]=a[c])},_parse:function(){var a=this.node;try{var b={};l.forEach(["dir","lang","textDir"],function(a){this[a]&&(b[a]=this[a])},this);var c=this;this.parseDeferred=
m.parse({rootNode:a,noStart:!this.startup,inherited:b,scope:this.parserScope}).then(function(a){return c.parseResults=a},function(a){c._onError("Content",a,"Error parsing in _ContentSetter#"+this.id)})}catch(d){this._onError("Content",d,"Error parsing in _ContentSetter#"+this.id)}},_onError:function(a,b,e){a=this["on"+a+"Error"].call(this,b);e?console.error(e,b):a&&c._setNodeContent(this.node,a,!0)}}),set:function(a,b,e){void 0==b&&(console.warn("dojo.html.set: no cont argument provided, using empty string"),
b="");"number"==typeof b&&(b=b.toString());return e?(new c._ContentSetter(n.mixin(e,{content:b,node:a}))).set():c._setNodeContent(a,b,!0)}};n.setObject("dojo.html",c);return c})},"dojo/parser":function(){define("require ./_base/kernel ./_base/lang ./_base/array ./_base/config ./dom ./_base/window ./_base/url ./aspect ./promise/all ./date/stamp ./Deferred ./has ./query ./on ./ready".split(" "),function(g,n,l,p,k,f,m,e,c,a,b,h,d,q,s,r){function v(a){return eval("("+a+")")}function t(a){var b=a._nameCaseMap,
c=a.prototype;if(!b||b._extendCnt<w){var b=a._nameCaseMap={},d;for(d in c)"_"!==d.charAt(0)&&(b[d.toLowerCase()]=d);b._extendCnt=w}return b}function u(a,b){b||(b=g);var c=b._dojoParserCtorMap||(b._dojoParserCtorMap={}),d=a.join();if(!c[d]){for(var e=[],h=0,f=a.length;h<f;h++){var k=a[h];e[e.length]=c[k]=c[k]||l.getObject(k)||~k.indexOf("/")&&b(k)}h=e.shift();c[d]=e.length?h.createSubclass?h.createSubclass(e):h.extend.apply(h,e):h}return c[d]}new Date("X");var w=0;c.after(l,"extend",function(){w++},
!0);var A={_clearCache:function(){w++;_ctorMap={}},_functionFromScript:function(a,b){var c="",d="",e=a.getAttribute(b+"args")||a.getAttribute("args"),h=a.getAttribute("with"),e=(e||"").split(/\s*,\s*/);h&&h.length&&p.forEach(h.split(/\s*,\s*/),function(a){c+="with("+a+"){";d+="}"});return new Function(e,c+a.innerHTML+d)},instantiate:function(a,b,c){b=b||{};c=c||{};var d=(c.scope||n._scopeName)+"Type",e="data-"+(c.scope||n._scopeName)+"-",h=e+"type",f=e+"mixins",g=[];p.forEach(a,function(a){var c=
d in b?b[d]:a.getAttribute(h)||a.getAttribute(d);if(c){var e=a.getAttribute(f),c=e?[c].concat(e.split(/\s*,\s*/)):[c];g.push({node:a,types:c})}});return this._instantiate(g,b,c)},_instantiate:function(b,c,d,e){function h(a){!c._started&&!d.noStart&&p.forEach(a,function(a){"function"===typeof a.startup&&!a._started&&a.startup()});return a}b=p.map(b,function(a){var b=a.ctor||u(a.types,d.contextRequire);if(!b)throw Error("Unable to resolve constructor for: '"+a.types.join()+"'");return this.construct(b,
a.node,c,d,a.scripts,a.inherited)},this);return e?a(b).then(h):h(b)},construct:function(a,h,f,g,k,m){function r(a){T&&l.setObject(T,a);for(E=0;E<O.length;E++)c[O[E].advice||"after"](a,O[E].method,l.hitch(a,O[E].func),!0);for(E=0;E<V.length;E++)V[E].call(a);for(E=0;E<H.length;E++)a.watch(H[E].prop,H[E].func);for(E=0;E<S.length;E++)s(a,S[E].event,S[E].func);return a}var u=a&&a.prototype;g=g||{};var w={};g.defaults&&l.mixin(w,g.defaults);m&&l.mixin(w,m);var A;d("dom-attributes-explicit")?A=h.attributes:
d("dom-attributes-specified-flag")?A=p.filter(h.attributes,function(a){return a.specified}):(m=(/^input$|^img$/i.test(h.nodeName)?h:h.cloneNode(!1)).outerHTML.replace(/=[^\s"']+|="[^"]*"|='[^']*'/g,"").replace(/^\s*<[a-zA-Z0-9]*\s*/,"").replace(/\s*>.*$/,""),A=p.map(m.split(/\s+/),function(a){var b=a.toLowerCase();return{name:a,value:"LI"==h.nodeName&&"value"==a||"enctype"==b?h.getAttribute(b):h.getAttributeNode(b).value}}));var J=g.scope||n._scopeName;m="data-"+J+"-";var F={};"dojo"!==J&&(F[m+"props"]=
"data-dojo-props",F[m+"type"]="data-dojo-type",F[m+"mixins"]="data-dojo-mixins",F[J+"type"]="dojotype",F[m+"id"]="data-dojo-id");for(var E=0,D,J=[],T,K;D=A[E++];){var N=D.name,Q=N.toLowerCase();D=D.value;switch(F[Q]||Q){case "data-dojo-type":case "dojotype":case "data-dojo-mixins":break;case "data-dojo-props":K=D;break;case "data-dojo-id":case "jsid":T=D;break;case "data-dojo-attach-point":case "dojoattachpoint":w.dojoAttachPoint=D;break;case "data-dojo-attach-event":case "dojoattachevent":w.dojoAttachEvent=
D;break;case "class":w["class"]=h.className;break;case "style":w.style=h.style&&h.style.cssText;break;default:if(N in u||(N=t(a)[Q]||N),N in u)switch(typeof u[N]){case "string":w[N]=D;break;case "number":w[N]=D.length?Number(D):NaN;break;case "boolean":w[N]="false"!=D.toLowerCase();break;case "function":""===D||-1!=D.search(/[^\w\.]+/i)?w[N]=new Function(D):w[N]=l.getObject(D,!1)||new Function(D);J.push(N);break;default:Q=u[N],w[N]=Q&&"length"in Q?D?D.split(/\s*,\s*/):[]:Q instanceof Date?""==D?new Date(""):
"now"==D?new Date:b.fromISOString(D):Q instanceof e?n.baseUrl+D:v(D)}else w[N]=D}}for(A=0;A<J.length;A++)F=J[A].toLowerCase(),h.removeAttribute(F),h[F]=null;if(K)try{K=v.call(g.propsThis,"{"+K+"}"),l.mixin(w,K)}catch(R){throw Error(R.toString()+" in data-dojo-props\x3d'"+K+"'");}l.mixin(w,f);k||(k=a&&(a._noScript||u._noScript)?[]:q("\x3e script[type^\x3d'dojo/']",h));var O=[],V=[],H=[],S=[];if(k)for(E=0;E<k.length;E++)F=k[E],h.removeChild(F),f=F.getAttribute(m+"event")||F.getAttribute("event"),g=
F.getAttribute(m+"prop"),K=F.getAttribute(m+"method"),J=F.getAttribute(m+"advice"),A=F.getAttribute("type"),F=this._functionFromScript(F,m),f?"dojo/connect"==A?O.push({method:f,func:F}):"dojo/on"==A?S.push({event:f,func:F}):w[f]=F:"dojo/aspect"==A?O.push({method:K,advice:J,func:F}):"dojo/watch"==A?H.push({prop:g,func:F}):V.push(F);a=(k=a.markupFactory||u.markupFactory)?k(w,h,a):new a(w,h);return a.then?a.then(r):r(a)},scan:function(a,b){function c(a){if(!a.inherited){a.inherited={};var b=a.node,d=
c(a.parent),b={dir:b.getAttribute("dir")||d.dir,lang:b.getAttribute("lang")||d.lang,textDir:b.getAttribute(r)||d.textDir},e;for(e in b)b[e]&&(a.inherited[e]=b[e])}return a.inherited}var e=[],f=[],k={},m=(b.scope||n._scopeName)+"Type",l="data-"+(b.scope||n._scopeName)+"-",q=l+"type",r=l+"textdir",l=l+"mixins",t=a.firstChild,s=b.inherited;if(!s){var w=function(a,b){return a.getAttribute&&a.getAttribute(b)||a.parentNode&&w(a.parentNode,b)},s={dir:w(a,"dir"),lang:w(a,"lang"),textDir:w(a,r)},v;for(v in s)s[v]||
delete s[v]}for(var s={inherited:s},A,K;;)if(t)if(1!=t.nodeType)t=t.nextSibling;else if(A&&"script"==t.nodeName.toLowerCase())(N=t.getAttribute("type"))&&/^dojo\/\w/i.test(N)&&A.push(t),t=t.nextSibling;else if(K)t=t.nextSibling;else{var N=t.getAttribute(q)||t.getAttribute(m);v=t.firstChild;if(!N&&(!v||3==v.nodeType&&!v.nextSibling))t=t.nextSibling;else{K=null;if(N){var Q=t.getAttribute(l);A=Q?[N].concat(Q.split(/\s*,\s*/)):[N];try{K=u(A,b.contextRequire)}catch(R){}K||p.forEach(A,function(a){~a.indexOf("/")&&
!k[a]&&(k[a]=!0,f[f.length]=a)});Q=K&&!K.prototype._noScript?[]:null;s={types:A,ctor:K,parent:s,node:t,scripts:Q};s.inherited=c(s);e.push(s)}else s={node:t,scripts:A,parent:s};A=Q;K=t.stopParser||K&&K.prototype.stopParser&&!b.template;t=v}}else{if(!s||!s.node)break;t=s.node.nextSibling;K=!1;s=s.parent;A=s.scripts}var O=new h;f.length?(d("dojo-debug-messages")&&console.warn("WARNING: Modules being Auto-Required: "+f.join(", ")),(b.contextRequire||g)(f,function(){O.resolve(p.filter(e,function(a){if(!a.ctor)try{a.ctor=
u(a.types,b.contextRequire)}catch(c){}for(var d=a.parent;d&&!d.types;)d=d.parent;var e=a.ctor&&a.ctor.prototype;a.instantiateChildren=!(e&&e.stopParser&&!b.template);a.instantiate=!d||d.instantiate&&d.instantiateChildren;return a.instantiate}))})):O.resolve(e);return O.promise},_require:function(a,b){var c=v("{"+a.innerHTML+"}"),d=[],e=[],f=new h,k=b&&b.contextRequire||g,m;for(m in c)d.push(m),e.push(c[m]);k(e,function(){for(var a=0;a<d.length;a++)l.setObject(d[a],arguments[a]);f.resolve(arguments)});
return f.promise},_scanAmd:function(a,b){var c=new h,d=c.promise;c.resolve(!0);var e=this;q("script[type\x3d'dojo/require']",a).forEach(function(a){d=d.then(function(){return e._require(a,b)});a.parentNode.removeChild(a)});return d},parse:function(a,b){a&&("string"!=typeof a&&!("nodeType"in a))&&(b=a,a=b.rootNode);var c=a?f.byId(a):m.body();b=b||{};var d=b.template?{template:!0}:{},e=[],h=this,g=this._scanAmd(c,b).then(function(){return h.scan(c,b)}).then(function(a){return h._instantiate(a,d,b,!0)}).then(function(a){return e=
e.concat(a)}).otherwise(function(a){console.error("dojo/parser::parse() error",a);throw a;});l.mixin(e,g);return e}};n.parser=A;k.parseOnLoad&&r(100,A,"parse");return A})},"dojo/_base/url":function(){define(["./kernel"],function(g){var n=/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/,l=/^((([^\[:]+):)?([^@]+)@)?(\[([^\]]+)\]|([^\[:]*))(:([0-9]+))?$/,p=function(){for(var g=arguments,f=[g[0]],m=1;m<g.length;m++)if(g[m]){var e=new p(g[m]+""),f=new p(f[0]+"");if(""==e.path&&!e.scheme&&
!e.authority&&!e.query)null!=e.fragment&&(f.fragment=e.fragment),e=f;else if(!e.scheme&&(e.scheme=f.scheme,!e.authority&&(e.authority=f.authority,"/"!=e.path.charAt(0)))){for(var f=(f.path.substring(0,f.path.lastIndexOf("/")+1)+e.path).split("/"),c=0;c<f.length;c++)"."==f[c]?c==f.length-1?f[c]="":(f.splice(c,1),c--):0<c&&(!(1==c&&""==f[0])&&".."==f[c]&&".."!=f[c-1])&&(c==f.length-1?(f.splice(c,1),f[c-1]=""):(f.splice(c-1,2),c-=2));e.path=f.join("/")}f=[];e.scheme&&f.push(e.scheme,":");e.authority&&
f.push("//",e.authority);f.push(e.path);e.query&&f.push("?",e.query);e.fragment&&f.push("#",e.fragment)}this.uri=f.join("");g=this.uri.match(n);this.scheme=g[2]||(g[1]?"":null);this.authority=g[4]||(g[3]?"":null);this.path=g[5];this.query=g[7]||(g[6]?"":null);this.fragment=g[9]||(g[8]?"":null);null!=this.authority&&(g=this.authority.match(l),this.user=g[3]||null,this.password=g[4]||null,this.host=g[6]||g[7],this.port=g[9]||null)};p.prototype.toString=function(){return this.uri};return g._Url=p})},
"dojo/date/stamp":function(){define(["../_base/lang","../_base/array"],function(g,n){var l={};g.setObject("dojo.date.stamp",l);l.fromISOString=function(g,k){l._isoRegExp||(l._isoRegExp=/^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(.\d+)?)?((?:[+-](\d{2}):(\d{2}))|Z)?)?$/);var f=l._isoRegExp.exec(g),m=null;if(f){f.shift();f[1]&&f[1]--;f[6]&&(f[6]*=1E3);k&&(k=new Date(k),n.forEach(n.map("FullYear Month Date Hours Minutes Seconds Milliseconds".split(" "),function(a){return k["get"+
a]()}),function(a,b){f[b]=f[b]||a}));m=new Date(f[0]||1970,f[1]||0,f[2]||1,f[3]||0,f[4]||0,f[5]||0,f[6]||0);100>f[0]&&m.setFullYear(f[0]||1970);var e=0,c=f[7]&&f[7].charAt(0);"Z"!=c&&(e=60*(f[8]||0)+(Number(f[9])||0),"-"!=c&&(e*=-1));c&&(e-=m.getTimezoneOffset());e&&m.setTime(m.getTime()+6E4*e)}return m};l.toISOString=function(g,k){var f=function(a){return 10>a?"0"+a:a};k=k||{};var m=[],e=k.zulu?"getUTC":"get",c="";"time"!=k.selector&&(c=g[e+"FullYear"](),c=["0000".substr((c+"").length)+c,f(g[e+"Month"]()+
1),f(g[e+"Date"]())].join("-"));m.push(c);if("date"!=k.selector){c=[f(g[e+"Hours"]()),f(g[e+"Minutes"]()),f(g[e+"Seconds"]())].join(":");e=g[e+"Milliseconds"]();k.milliseconds&&(c+="."+(100>e?"0":"")+f(e));if(k.zulu)c+="Z";else if("time"!=k.selector)var e=g.getTimezoneOffset(),a=Math.abs(e),c=c+((0<e?"-":"+")+f(Math.floor(a/60))+":"+f(a%60));m.push(c)}return m.join("T")};return l})},"dijit/nls/loading":function(){define({root:{loadingState:"Loading...",errorState:"Sorry, an error occurred"},bs:!0,
mk:!0,sr:!0,zh:!0,"zh-tw":!0,uk:!0,tr:!0,th:!0,sv:!0,sl:!0,sk:!0,ru:!0,ro:!0,pt:!0,"pt-pt":!0,pl:!0,nl:!0,nb:!0,ko:!0,kk:!0,ja:!0,it:!0,id:!0,hu:!0,hr:!0,he:!0,fr:!0,fi:!0,eu:!0,es:!0,el:!0,de:!0,da:!0,cs:!0,ca:!0,bg:!0,az:!0,ar:!0})},"dijit/nls/th/loading":function(){define({loadingState:"\u0e01\u0e33\u0e25\u0e31\u0e07\u0e42\u0e2b\u0e25\u0e14...",errorState:"\u0e02\u0e2d\u0e2d\u0e20\u0e31\u0e22 \u0e40\u0e01\u0e34\u0e14\u0e02\u0e49\u0e2d\u0e1c\u0e34\u0e14\u0e1e\u0e25\u0e32\u0e14"})},"dijit/_DialogMixin":function(){define(["dojo/_base/declare",
"./a11y"],function(g,n){return g("dijit._DialogMixin",null,{actionBarTemplate:"",execute:function(){},onCancel:function(){},onExecute:function(){},_onSubmit:function(){this.onExecute();this.execute(this.get("value"))},_getFocusItems:function(){var g=n._getTabNavigable(this.domNode);this._firstFocusItem=g.lowest||g.first||this.closeButtonNode||this.domNode;this._lastFocusItem=g.last||g.highest||this._firstFocusItem}})})},"dijit/form/_FormMixin":function(){define("dojo/_base/array dojo/_base/declare dojo/_base/kernel dojo/_base/lang dojo/on dojo/window".split(" "),
function(g,n,l,p,k,f){return n("dijit.form._FormMixin",null,{state:"",_getDescendantFormWidgets:function(f){var e=[];g.forEach(f||this.getChildren(),function(c){"value"in c?e.push(c):e=e.concat(this._getDescendantFormWidgets(c.getChildren()))},this);return e},reset:function(){g.forEach(this._getDescendantFormWidgets(),function(f){f.reset&&f.reset()})},validate:function(){var k=!1;return g.every(g.map(this._getDescendantFormWidgets(),function(e){e._hasBeenBlurred=!0;var c=e.disabled||!e.validate||
e.validate();!c&&!k&&(f.scrollIntoView(e.containerNode||e.domNode),e.focus(),k=!0);return c}),function(e){return e})},setValues:function(f){l.deprecated(this.declaredClass+"::setValues() is deprecated. Use set('value', val) instead.","","2.0");return this.set("value",f)},_setValueAttr:function(f){var e={};g.forEach(this._getDescendantFormWidgets(),function(a){a.name&&(e[a.name]||(e[a.name]=[])).push(a)});for(var c in e)if(e.hasOwnProperty(c)){var a=e[c],b=p.getObject(c,!1,f);void 0!==b&&(b=[].concat(b),
"boolean"==typeof a[0].checked?g.forEach(a,function(a){a.set("value",-1!=g.indexOf(b,a._get("value")))}):a[0].multiple?a[0].set("value",b):g.forEach(a,function(a,c){a.set("value",b[c])}))}},getValues:function(){l.deprecated(this.declaredClass+"::getValues() is deprecated. Use get('value') instead.","","2.0");return this.get("value")},_getValueAttr:function(){var f={};g.forEach(this._getDescendantFormWidgets(),function(e){var c=e.name;if(c&&!e.disabled){var a=e.get("value");"boolean"==typeof e.checked?
/Radio/.test(e.declaredClass)?!1!==a?p.setObject(c,a,f):(a=p.getObject(c,!1,f),void 0===a&&p.setObject(c,null,f)):(e=p.getObject(c,!1,f),e||(e=[],p.setObject(c,e,f)),!1!==a&&e.push(a)):(e=p.getObject(c,!1,f),"undefined"!=typeof e?p.isArray(e)?e.push(a):p.setObject(c,[e,a],f):p.setObject(c,a,f))}});return f},isValid:function(){return""==this.state},onValidStateChange:function(){},_getState:function(){var f=g.map(this._descendants,function(e){return e.get("state")||""});return 0<=g.indexOf(f,"Error")?
"Error":0<=g.indexOf(f,"Incomplete")?"Incomplete":""},disconnectChildren:function(){},connectChildren:function(f){this._descendants=this._getDescendantFormWidgets();g.forEach(this._descendants,function(e){e._started||e.startup()});f||this._onChildChange()},_onChildChange:function(f){(!f||"state"==f||"disabled"==f)&&this._set("state",this._getState());if(!f||"value"==f||"disabled"==f||"checked"==f)this._onChangeDelayTimer&&this._onChangeDelayTimer.remove(),this._onChangeDelayTimer=this.defer(function(){delete this._onChangeDelayTimer;
this._set("value",this.get("value"))},10)},startup:function(){this.inherited(arguments);this._descendants=this._getDescendantFormWidgets();this.value=this.get("value");this.state=this._getState();var f=this;this.own(k(this.containerNode,"attrmodified-state, attrmodified-disabled, attrmodified-value, attrmodified-checked",function(e){e.target!=f.domNode&&f._onChildChange(e.type.replace("attrmodified-",""))}));this.watch("state",function(e,c,a){this.onValidStateChange(""==a)})},destroy:function(){this.inherited(arguments)}})})},
"dijit/_TemplatedMixin":function(){define("dojo/cache dojo/_base/declare dojo/dom-construct dojo/_base/lang dojo/on dojo/sniff dojo/string ./_AttachMixin".split(" "),function(g,n,l,p,k,f,m,e){var c=n("dijit._TemplatedMixin",e,{templateString:null,templatePath:null,_skipNodeCache:!1,searchContainerNode:!0,_stringRepl:function(a){var b=this.declaredClass,c=this;return m.substitute(a,this,function(a,e){"!"==e.charAt(0)&&(a=p.getObject(e.substr(1),!1,c));if("undefined"==typeof a)throw Error(b+" template:"+
e);return null==a?"":"!"==e.charAt(0)?a:this._escapeValue(""+a)},this)},_escapeValue:function(a){return a.replace(/["'<>&]/g,function(a){return{"\x26":"\x26amp;","\x3c":"\x26lt;","\x3e":"\x26gt;",'"':"\x26quot;","'":"\x26#x27;"}[a]})},buildRendering:function(){if(!this._rendered){this.templateString||(this.templateString=g(this.templatePath,{sanitize:!0}));var a=c.getCachedTemplate(this.templateString,this._skipNodeCache,this.ownerDocument),b;if(p.isString(a)){if(b=l.toDom(this._stringRepl(a),this.ownerDocument),
1!=b.nodeType)throw Error("Invalid template: "+a);}else b=a.cloneNode(!0);this.domNode=b}this.inherited(arguments);this._rendered||this._fillContent(this.srcNodeRef);this._rendered=!0},_fillContent:function(a){var b=this.containerNode;if(a&&b)for(;a.hasChildNodes();)b.appendChild(a.firstChild)}});c._templateCache={};c.getCachedTemplate=function(a,b,e){var d=c._templateCache,f=a,g=d[f];if(g){try{if(!g.ownerDocument||g.ownerDocument==(e||document))return g}catch(k){}l.destroy(g)}a=m.trim(a);if(b||a.match(/\$\{([^\}]+)\}/g))return d[f]=
a;b=l.toDom(a,e);if(1!=b.nodeType)throw Error("Invalid template: "+a);return d[f]=b};f("ie")&&k(window,"unload",function(){var a=c._templateCache,b;for(b in a){var e=a[b];"object"==typeof e&&l.destroy(e);delete a[b]}});return c})},"dojo/cache":function(){define(["./_base/kernel","./text"],function(g){return g.cache})},"dojo/text":function(){define(["./_base/kernel","require","./has","./request"],function(g,n,l,p){var k;k=function(a,b,c){p(a,{sync:!!b,headers:{"X-Requested-With":null}}).then(c)};var f=
{},m=function(a){if(a){a=a.replace(/^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,"");var b=a.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);b&&(a=b[1])}else a="";return a},e={},c={};g.cache=function(a,b,c){var d;"string"==typeof a?/\//.test(a)?(d=a,c=b):d=n.toUrl(a.replace(/\./g,"/")+(b?"/"+b:"")):(d=a+"",c=b);a=void 0!=c&&"string"!=typeof c?c.value:c;c=c&&c.sanitize;if("string"==typeof a)return f[d]=a,c?m(a):a;if(null===a)return delete f[d],null;d in f||k(d,!0,function(a){f[d]=a});return c?
m(f[d]):f[d]};return{dynamic:!0,normalize:function(a,b){var c=a.split("!"),d=c[0];return(/^\./.test(d)?b(d):d)+(c[1]?"!"+c[1]:"")},load:function(a,b,h){a=a.split("!");var d=1<a.length,g=a[0],l=b.toUrl(a[0]);a="url:"+l;var n=e,p=function(a){h(d?m(a):a)};g in f?n=f[g]:b.cache&&a in b.cache?n=b.cache[a]:l in f&&(n=f[l]);if(n===e)if(c[l])c[l].push(p);else{var t=c[l]=[p];k(l,!b.async,function(a){f[g]=f[l]=a;for(var b=0;b<t.length;)t[b++](a);delete c[l]})}else p(n)}}})},"dijit/_AttachMixin":function(){define("require dojo/_base/array dojo/_base/connect dojo/_base/declare dojo/_base/lang dojo/mouse dojo/on dojo/touch ./_WidgetBase".split(" "),
function(g,n,l,p,k,f,m,e,c){var a=k.delegate(e,{mouseenter:f.enter,mouseleave:f.leave,keypress:l._keypress}),b;l=p("dijit._AttachMixin",null,{constructor:function(){this._attachPoints=[];this._attachEvents=[]},buildRendering:function(){this.inherited(arguments);this._attachTemplateNodes(this.domNode);this._beforeFillContent()},_beforeFillContent:function(){},_attachTemplateNodes:function(a){for(var b=a;;)if(1==b.nodeType&&(this._processTemplateNode(b,function(a,b){return a.getAttribute(b)},this._attach)||
this.searchContainerNode)&&b.firstChild)b=b.firstChild;else{if(b==a)break;for(;!b.nextSibling;)if(b=b.parentNode,b==a)return;b=b.nextSibling}},_processTemplateNode:function(a,b,c){var e=!0,f=this.attachScope||this,g=b(a,"dojoAttachPoint")||b(a,"data-dojo-attach-point");if(g)for(var m=g.split(/\s*,\s*/);g=m.shift();)k.isArray(f[g])?f[g].push(a):f[g]=a,e="containerNode"!=g,this._attachPoints.push(g);if(b=b(a,"dojoAttachEvent")||b(a,"data-dojo-attach-event")){g=b.split(/\s*,\s*/);for(m=k.trim;b=g.shift();)if(b){var l=
null;-1!=b.indexOf(":")?(l=b.split(":"),b=m(l[0]),l=m(l[1])):b=m(b);l||(l=b);this._attachEvents.push(c(a,b,k.hitch(f,l)))}}return e},_attach:function(c,d,e){d=d.replace(/^on/,"").toLowerCase();d="dijitclick"==d?b||(b=g("./a11yclick")):a[d]||d;return m(c,d,e)},_detachTemplateNodes:function(){var a=this.attachScope||this;n.forEach(this._attachPoints,function(b){delete a[b]});this._attachPoints=[];n.forEach(this._attachEvents,function(a){a.remove()});this._attachEvents=[]},destroyRendering:function(){this._detachTemplateNodes();
this.inherited(arguments)}});k.extend(c,{dojoAttachEvent:"",dojoAttachPoint:""});return l})},"dijit/popup":function(){define("dojo/_base/array dojo/aspect dojo/_base/declare dojo/dom dojo/dom-attr dojo/dom-construct dojo/dom-geometry dojo/dom-style dojo/has dojo/keys dojo/_base/lang dojo/on ./place ./BackgroundIframe ./Viewport ./main dojo/touch".split(" "),function(g,n,l,p,k,f,m,e,c,a,b,h,d,q,s,r){function v(){this._popupWrapper&&(f.destroy(this._popupWrapper),delete this._popupWrapper)}l=l(null,
{_stack:[],_beginZIndex:1E3,_idGen:1,_repositionAll:function(){if(this._firstAroundNode){var a=this._firstAroundPosition,c=m.position(this._firstAroundNode,!0),d=c.x-a.x,a=c.y-a.y;if(d||a){this._firstAroundPosition=c;for(c=0;c<this._stack.length;c++){var e=this._stack[c].wrapper.style;e.top=parseFloat(e.top)+a+"px";"auto"==e.right?e.left=parseFloat(e.left)+d+"px":e.right=parseFloat(e.right)-d+"px"}}this._aroundMoveListener=setTimeout(b.hitch(this,"_repositionAll"),d||a?10:50)}},_createWrapper:function(a){var b=
a._popupWrapper,c=a.domNode;b||(b=f.create("div",{"class":"dijitPopup",style:{display:"none"},role:"region","aria-label":a["aria-label"]||a.label||a.name||a.id},a.ownerDocumentBody),b.appendChild(c),c=c.style,c.display="",c.visibility="",c.position="",c.top="0px",a._popupWrapper=b,n.after(a,"destroy",v,!0),"ontouchend"in document&&h(b,"touchend",function(a){/^(input|button|textarea)$/i.test(a.target.tagName)||a.preventDefault()}),b.dojoClick=!0);return b},moveOffScreen:function(a){var b=this._createWrapper(a);
a=m.isBodyLtr(a.ownerDocument);var c={visibility:"hidden",top:"-9999px",display:""};c[a?"left":"right"]="-9999px";c[a?"right":"left"]="auto";e.set(b,c);return b},hide:function(a){var b=this._createWrapper(a);e.set(b,{display:"none",height:"auto",overflowY:"visible",border:""});a=a.domNode;"_originalStyle"in a&&(a.style.cssText=a._originalStyle)},getTopPopup:function(){for(var a=this._stack,b=a.length-1;0<b&&a[b].parent===a[b-1].widget;b--);return a[b]},open:function(f){for(var g=this._stack,l=f.popup,
n=l.domNode,r=f.orient||["below","below-alt","above","above-alt"],v=f.parent?f.parent.isLeftToRight():m.isBodyLtr(l.ownerDocument),z=f.around,C=f.around&&f.around.id?f.around.id+"_dropdown":"popup_"+this._idGen++;g.length&&(!f.parent||!p.isDescendant(f.parent.domNode,g[g.length-1].widget.domNode));)this.close(g[g.length-1].widget);var B=this.moveOffScreen(l);l.startup&&!l._started&&l.startup();var G,L=m.position(n);if("maxHeight"in f&&-1!=f.maxHeight)G=f.maxHeight||Infinity;else{G=s.getEffectiveBox(this.ownerDocument);
var M=z?m.position(z,!1):{y:f.y-(f.padding||0),h:2*(f.padding||0)};G=Math.floor(Math.max(M.y,G.h-(M.y+M.h)))}L.h>G&&(L=e.getComputedStyle(n),e.set(B,{overflowY:"scroll",height:G+"px",border:L.borderLeftWidth+" "+L.borderLeftStyle+" "+L.borderLeftColor}),n._originalStyle=n.style.cssText,n.style.border="none");k.set(B,{id:C,style:{zIndex:this._beginZIndex+g.length},"class":"dijitPopup "+(l.baseClass||l["class"]||"").split(" ")[0]+"Popup",dijitPopupParent:f.parent?f.parent.id:""});0==g.length&&z&&(this._firstAroundNode=
z,this._firstAroundPosition=m.position(z,!0),this._aroundMoveListener=setTimeout(b.hitch(this,"_repositionAll"),50));c("config-bgIframe")&&!l.bgIframe&&(l.bgIframe=new q(B));C=l.orient?b.hitch(l,"orient"):null;r=z?d.around(B,z,r,v,C):d.at(B,f,"R"==r?["TR","BR","TL","BL"]:["TL","BL","TR","BR"],f.padding,C);B.style.visibility="visible";n.style.visibility="visible";n=[];n.push(h(B,"keydown",b.hitch(this,function(b){if(b.keyCode==a.ESCAPE&&f.onCancel)b.stopPropagation(),b.preventDefault(),f.onCancel();
else if(b.keyCode==a.TAB&&(b.stopPropagation(),b.preventDefault(),(b=this.getTopPopup())&&b.onCancel))b.onCancel()})));l.onCancel&&f.onCancel&&n.push(l.on("cancel",f.onCancel));n.push(l.on(l.onExecute?"execute":"change",b.hitch(this,function(){var a=this.getTopPopup();if(a&&a.onExecute)a.onExecute()})));g.push({widget:l,wrapper:B,parent:f.parent,onExecute:f.onExecute,onCancel:f.onCancel,onClose:f.onClose,handlers:n});if(l.onOpen)l.onOpen(r);return r},close:function(a){for(var b=this._stack;a&&g.some(b,
function(b){return b.widget==a})||!a&&b.length;){var c=b.pop(),d=c.widget,e=c.onClose;d.bgIframe&&(d.bgIframe.destroy(),delete d.bgIframe);if(d.onClose)d.onClose();for(var f;f=c.handlers.pop();)f.remove();d&&d.domNode&&this.hide(d);e&&e()}0==b.length&&this._aroundMoveListener&&(clearTimeout(this._aroundMoveListener),this._firstAroundNode=this._firstAroundPosition=this._aroundMoveListener=null)}});return r.popup=new l})},"dijit/place":function(){define("dojo/_base/array dojo/dom-geometry dojo/dom-style dojo/_base/kernel dojo/_base/window ./Viewport ./main".split(" "),
function(g,n,l,p,k,f,m){function e(a,b,c,d){var e=f.getEffectiveBox(a.ownerDocument);(!a.parentNode||"body"!=String(a.parentNode.tagName).toLowerCase())&&k.body(a.ownerDocument).appendChild(a);var m=null;g.some(b,function(b){var f=b.corner,g=b.pos,k=0,l={w:{L:e.l+e.w-g.x,R:g.x-e.l,M:e.w}[f.charAt(1)],h:{T:e.t+e.h-g.y,B:g.y-e.t,M:e.h}[f.charAt(0)]},p=a.style;p.left=p.right="auto";c&&(k=c(a,b.aroundCorner,f,l,d),k="undefined"==typeof k?0:k);var r=a.style,v=r.display,B=r.visibility;"none"==r.display&&
(r.visibility="hidden",r.display="");p=n.position(a);r.display=v;r.visibility=B;v={L:g.x,R:g.x-p.w,M:Math.max(e.l,Math.min(e.l+e.w,g.x+(p.w>>1))-p.w)}[f.charAt(1)];B={T:g.y,B:g.y-p.h,M:Math.max(e.t,Math.min(e.t+e.h,g.y+(p.h>>1))-p.h)}[f.charAt(0)];g=Math.max(e.l,v);r=Math.max(e.t,B);v=Math.min(e.l+e.w,v+p.w);B=Math.min(e.t+e.h,B+p.h);v-=g;B-=r;k+=p.w-v+(p.h-B);if(null==m||k<m.overflow)m={corner:f,aroundCorner:b.aroundCorner,x:g,y:r,w:v,h:B,overflow:k,spaceAvailable:l};return!k});m.overflow&&c&&c(a,
m.aroundCorner,m.corner,m.spaceAvailable,d);b=m.y;var p=m.x,v=k.body(a.ownerDocument);/relative|absolute/.test(l.get(v,"position"))&&(b-=l.get(v,"marginTop"),p-=l.get(v,"marginLeft"));v=a.style;v.top=b+"px";v.left=p+"px";v.right="auto";return m}var c={TL:"BR",TR:"BL",BL:"TR",BR:"TL"};return m.place={at:function(a,b,f,d,k){f=g.map(f,function(a){var e={corner:a,aroundCorner:c[a],pos:{x:b.x,y:b.y}};d&&(e.pos.x+="L"==a.charAt(1)?d.x:-d.x,e.pos.y+="T"==a.charAt(0)?d.y:-d.y);return e});return e(a,f,k)},
around:function(a,b,c,d,f){function k(a,b){B.push({aroundCorner:a,corner:b,pos:{x:{L:y,R:y+z,M:y+(z>>1)}[a.charAt(1)],y:{T:x,B:x+C,M:x+(C>>1)}[a.charAt(0)]}})}var m;if("string"==typeof b||"offsetWidth"in b||"ownerSVGElement"in b){if(m=n.position(b,!0),/^(above|below)/.test(c[0])){var v=n.getBorderExtents(b),t=b.firstChild?n.getBorderExtents(b.firstChild):{t:0,l:0,b:0,r:0},u=n.getBorderExtents(a),w=a.firstChild?n.getBorderExtents(a.firstChild):{t:0,l:0,b:0,r:0};m.y+=Math.min(v.t+t.t,u.t+w.t);m.h-=
Math.min(v.t+t.t,u.t+w.t)+Math.min(v.b+t.b,u.b+w.b)}}else m=b;if(b.parentNode){v="absolute"==l.getComputedStyle(b).position;for(b=b.parentNode;b&&1==b.nodeType&&"BODY"!=b.nodeName;){t=n.position(b,!0);u=l.getComputedStyle(b);/relative|absolute/.test(u.position)&&(v=!1);if(!v&&/hidden|auto|scroll/.test(u.overflow)){var w=Math.min(m.y+m.h,t.y+t.h),A=Math.min(m.x+m.w,t.x+t.w);m.x=Math.max(m.x,t.x);m.y=Math.max(m.y,t.y);m.h=w-m.y;m.w=A-m.x}"absolute"==u.position&&(v=!0);b=b.parentNode}}var y=m.x,x=m.y,
z="w"in m?m.w:m.w=m.width,C="h"in m?m.h:(p.deprecated("place.around: dijit/place.__Rectangle: { x:"+y+", y:"+x+", height:"+m.height+", width:"+z+" } has been deprecated.  Please use { x:"+y+", y:"+x+", h:"+m.height+", w:"+z+" }","","2.0"),m.h=m.height),B=[];g.forEach(c,function(a){var b=d;switch(a){case "above-centered":k("TM","BM");break;case "below-centered":k("BM","TM");break;case "after-centered":b=!b;case "before-centered":k(b?"ML":"MR",b?"MR":"ML");break;case "after":b=!b;case "before":k(b?
"TL":"TR",b?"TR":"TL");k(b?"BL":"BR",b?"BR":"BL");break;case "below-alt":b=!b;case "below":k(b?"BL":"BR",b?"TL":"TR");k(b?"BR":"BL",b?"TR":"TL");break;case "above-alt":b=!b;case "above":k(b?"TL":"TR",b?"BL":"BR");k(b?"TR":"TL",b?"BR":"BL");break;default:k(a.aroundCorner,a.corner)}});a=e(a,B,f,{w:z,h:C});a.aroundNodePos=m;return a}}})},"dijit/BackgroundIframe":function(){define("require ./main dojo/_base/config dojo/dom-construct dojo/dom-style dojo/_base/lang dojo/on dojo/sniff".split(" "),function(g,
n,l,p,k,f,m,e){e.add("config-bgIframe",e("ie")&&!/IEMobile\/10\.0/.test(navigator.userAgent)||e("trident")&&/Windows NT 6.[01]/.test(navigator.userAgent));var c=new function(){var a=[];this.pop=function(){var b;a.length?(b=a.pop(),b.style.display=""):(9>e("ie")?(b="\x3ciframe src\x3d'"+(l.dojoBlankHtmlUrl||g.toUrl("dojo/resources/blank.html")||'javascript:""')+"' role\x3d'presentation' style\x3d'position: absolute; left: 0px; top: 0px;z-index: -1; filter:Alpha(Opacity\x3d\"0\");'\x3e",b=document.createElement(b)):
(b=p.create("iframe"),b.src='javascript:""',b.className="dijitBackgroundIframe",b.setAttribute("role","presentation"),k.set(b,"opacity",0.1)),b.tabIndex=-1);return b};this.push=function(b){b.style.display="none";a.push(b)}};n.BackgroundIframe=function(a){if(!a.id)throw Error("no id");if(e("config-bgIframe")){var b=this.iframe=c.pop();a.appendChild(b);7>e("ie")||e("quirks")?(this.resize(a),this._conn=m(a,"resize",f.hitch(this,"resize",a))):k.set(b,{width:"100%",height:"100%"})}};f.extend(n.BackgroundIframe,
{resize:function(a){this.iframe&&k.set(this.iframe,{width:a.offsetWidth+"px",height:a.offsetHeight+"px"})},destroy:function(){this._conn&&(this._conn.remove(),this._conn=null);this.iframe&&(this.iframe.parentNode.removeChild(this.iframe),c.push(this.iframe),delete this.iframe)}});return n.BackgroundIframe})},"dgrid/ColumnSet":function(){define("dojo/_base/declare dojo/_base/lang dojo/dom-class dojo/dom-construct dojo/on dojo/aspect dojo/query dojo/has ./util/misc dojo/_base/sniff".split(" "),function(g,
n,l,p,k,f,m,e,c){function a(a,b){var c=a._columnSetScrollLefts;m(".dgrid-column-set",b).forEach(function(a){a.scrollLeft=c[a.getAttribute(q)]})}function b(a,b){1!==a.nodeType&&(a=a.parentNode);for(;a&&!m.matches(a,".dgrid-column-set["+q+"]",b);){if(b&&a===b||l.contains(a,"dgrid"))return null;a=a.parentNode}return a}function h(a){var b=e("pointer");return b?(a=s[a]||a,"MS"===b.slice(0,2)?"MSPointer"+a.slice(0,1).toUpperCase()+a.slice(1):"pointer"+a):"touch"+a}function d(a,b,c){b=b.getAttribute(q);
a=a._columnSetScrollers[b];c=a.scrollLeft+c;a.scrollLeft=0>c?0:c}e.add("event-mousewheel",function(a,b,c){return"onmousewheel"in c});e.add("event-wheel",function(a,b,c){return"onwheel"in c});var q="data-dgrid-column-set-id",s={start:"down",end:"up"},r=e("touch")&&function(a){return function(c,d){var e=[k(c,h("start"),function(d){if(!a._currentlyTouchedColumnSet){var e=b(d.target,c);if(e&&(!d.pointerType||"touch"===d.pointerType||2===d.pointerType))a._currentlyTouchedColumnSet=e,a._lastColumnSetTouchX=
d.clientX,a._lastColumnSetTouchY=d.clientY}}),k(c,h("move"),function(c){if(null!==a._currentlyTouchedColumnSet){var e=b(c.target);e&&(d.call(null,a,e,a._lastColumnSetTouchX-c.clientX),a._lastColumnSetTouchX=c.clientX,a._lastColumnSetTouchY=c.clientY)}}),k(c,h("end"),function(){a._currentlyTouchedColumnSet=null})];return{remove:function(){for(var a=e.length;a--;)e[a].remove()}}}},v=e("event-mousewheel")||e("event-wheel")?function(a){return function(c,d){return k(c,e("event-wheel")?"wheel":"mousewheel",
function(e){var f=b(e.target,c);f&&(e=e.deltaX||-e.wheelDeltaX/3)&&d.call(null,a,f,e)})}}:function(a){return function(b,c){return k(b,".dgrid-column-set["+q+"]:MozMousePixelScroll",function(b){1===b.axis&&c.call(null,a,this,b.detail)})}};return g(null,{postCreate:function(){var b=this;this.inherited(arguments);this.on(v(this),d);if(e("touch"))this.on(r(this),d);this.on(".dgrid-column-set:dgrid-cellfocusin",function(a){b._onColumnSetCellFocus(a,this)});"function"===typeof this.expand&&f.after(this,
"expand",function(c,d){c.then(function(){var c=b.row(d[0]);b._expanded[c.id]&&a(b,c.element.connected)});return c})},columnSets:[],createRowCells:function(a,b,c,d,e){for(var f=p.create("table",{className:"dgrid-row-table"}),h=p.create("tbody",null,f),h=p.create("tr",null,h),g=0,k=this.columnSets.length;g<k;g++){var m=p.create(a,{className:"dgrid-column-set-cell dgrid-column-set-"+g},h),m=p.create("div",{className:"dgrid-column-set"},m);m.setAttribute(q,g);var l;l=c||this.subRows;if(!l||!l.length)l=
void 0;else{for(var n=[],r=g+"-",s=0,v=l.length;s<v;s++){var F=l[s],E=[];E.className=F.className;for(var D=0,T=F.length;D<T;D++){var K=F[D];null!=K.id&&0===K.id.indexOf(r)&&E.push(K)}n.push(E)}l=n}m.appendChild(this.inherited(arguments,[a,b,l||this.columnSets[g],d,e]))}return f},renderArray:function(){for(var b=this.inherited(arguments),c=0;c<b.length;c++)a(this,b[c]);return b},insertRow:function(){var b=this.inherited(arguments);a(this,b);return b},renderHeader:function(){function a(){d._positionScrollers()}
this.inherited(arguments);var b=this.columnSets,c=this._columnSetScrollers,d=this,e;this._columnSetScrollerContents={};this._columnSetScrollLefts={};if(c)for(e in c)p.destroy(c[e]);else f.after(this,"resize",a,!0),f.after(this,"styleColumn",a,!0),this._columnSetScrollerNode=p.create("div",{className:"dgrid-column-set-scroller-container"},this.footerNode,"after");c=this._columnSetScrollers={};e=0;for(c=b.length;e<c;e++)this._putScroller(b[e],e);this._positionScrollers()},styleColumnSet:function(a,
b){var d=this.addCssRule("#"+c.escapeCssIdentifier(this.domNode.id)+" .dgrid-column-set-"+c.escapeCssIdentifier(a,"-"),b);this._positionScrollers();return d},configStructure:function(){this.columns={};this.subRows=[];for(var a=0,b=this.columnSets.length;a<b;a++)for(var c=this.columnSets[a],d=0;d<c.length;d++)c[d]=this._configColumns(a+"-"+d+"-",c[d]);this.inherited(arguments)},_positionScrollers:function(){var a=this.domNode,b=this._columnSetScrollers,c=this._columnSetScrollerContents,d=this.columnSets,
f=0,h=0,g,k;g=0;for(d=d.length;g<d;g++)k=m(".dgrid-column-set["+q+'\x3d"'+g+'"]',a)[0],f=k.offsetWidth,k=k.firstChild.offsetWidth,c[g].style.width=k+"px",b[g].style.width=f+"px",9>e("ie")&&(b[g].style.overflowX=k>f?"scroll":"auto"),k>f&&h++;this._columnSetScrollerNode.style.bottom=this.showFooter?this.footerNode.offsetHeight+"px":"0";this.bodyNode.style.bottom=h?e("dom-scrollbar-height")+(e("ie")?1:0)+"px":"0"},_putScroller:function(a,b){var c=this._columnSetScrollers[b]=p.create("span",{className:"dgrid-column-set-scroller dgrid-column-set-scroller-"+
b+(9>e("ie")?" dgrid-scrollbar-height":"")},this._columnSetScrollerNode);c.setAttribute(q,b);this._columnSetScrollerContents[b]=p.create("div",{className:"dgrid-column-set-scroller-content"},c);k(c,"scroll",n.hitch(this,"_onColumnSetScroll"))},_onColumnSetScroll:function(a){var b=a.target.scrollLeft;a=a.target.getAttribute(q);var c;this._columnSetScrollLefts[a]!==b&&(m(".dgrid-column-set["+q+'\x3d"'+a+'"],.dgrid-column-set-scroller['+q+'\x3d"'+a+'"]',this.domNode).forEach(function(a,d){a.scrollLeft=
b;d||(c=a.scrollLeft)}),this._columnSetScrollLefts[a]=c)},_setColumnSets:function(a){this._destroyColumns();this.columnSets=a;this._updateColumns()},_scrollColumnSet:function(a,b){var c=a.tagName?a.getAttribute(q):a;this._columnSetScrollers[c].scrollLeft=0>b?0:b},_onColumnSetCellFocus:function(a,b){var c=a.target,d=b.getAttribute(q),d=this._columnSetScrollers[d];(c.offsetLeft-d.scrollLeft+c.offsetWidth>b.offsetWidth||d.scrollLeft>c.offsetLeft)&&this._scrollColumnSet(b,c.offsetLeft)}})})},"dijit/_base/manager":function(){define(["dojo/_base/array",
"dojo/_base/config","dojo/_base/lang","../registry","../main"],function(g,n,l,p,k){var f={};g.forEach("byId getUniqueId findWidgets _destroyAll byNode getEnclosingWidget".split(" "),function(g){f[g]=p[g]});l.mixin(f,{defaultDuration:n.defaultDuration||200});l.mixin(k,f);return k})},"dijit/_base":function(){define("./main ./a11y ./WidgetSet ./_base/focus ./_base/manager ./_base/place ./_base/popup ./_base/scroll ./_base/sniff ./_base/typematic ./_base/wai ./_base/window".split(" "),function(g){return g._base})},
"dijit/WidgetSet":function(){define(["dojo/_base/array","dojo/_base/declare","dojo/_base/kernel","./registry"],function(g,n,l,p){var k=n("dijit.WidgetSet",null,{constructor:function(){this._hash={};this.length=0},add:function(f){if(this._hash[f.id])throw Error("Tried to register widget with id\x3d\x3d"+f.id+" but that id is already registered");this._hash[f.id]=f;this.length++},remove:function(f){this._hash[f]&&(delete this._hash[f],this.length--)},forEach:function(f,g){g=g||l.global;var e=0,c;for(c in this._hash)f.call(g,
this._hash[c],e++,this._hash);return this},filter:function(f,g){g=g||l.global;var e=new k,c=0,a;for(a in this._hash){var b=this._hash[a];f.call(g,b,c++,this._hash)&&e.add(b)}return e},byId:function(f){return this._hash[f]},byClass:function(f){var g=new k,e,c;for(e in this._hash)c=this._hash[e],c.declaredClass==f&&g.add(c);return g},toArray:function(){var f=[],g;for(g in this._hash)f.push(this._hash[g]);return f},map:function(f,k){return g.map(this.toArray(),f,k)},every:function(f,g){g=g||l.global;
var e=0,c;for(c in this._hash)if(!f.call(g,this._hash[c],e++,this._hash))return!1;return!0},some:function(f,g){g=g||l.global;var e=0,c;for(c in this._hash)if(f.call(g,this._hash[c],e++,this._hash))return!0;return!1}});g.forEach("forEach filter byClass map every some".split(" "),function(f){p[f]=k.prototype[f]});return k})},"dijit/_base/focus":function(){define("dojo/_base/array dojo/dom dojo/_base/lang dojo/topic dojo/_base/window ../focus ../selection ../main".split(" "),function(g,n,l,p,k,f,m,e){f.focus=
function(c){if(c){var a="node"in c?c.node:c,b=c.bookmark;c=c.openedForWindow;var h=b?b.isCollapsed:!1;if(a){var d="iframe"==a.tagName.toLowerCase()?a.contentWindow:a;if(d&&d.focus)try{d.focus()}catch(g){}f._onFocusNode(a)}if(b&&k.withGlobal(c||k.global,e.isCollapsed)&&!h){c&&c.focus();try{k.withGlobal(c||k.global,e.moveToBookmark,null,[b])}catch(m){}}}};f.watch("curNode",function(c,a,b){e._curFocus=b;e._prevFocus=a;b&&p.publish("focusNode",b)});f.watch("activeStack",function(c,a,b){e._activeStack=
b});f.on("widget-blur",function(c,a){p.publish("widgetBlur",c,a)});f.on("widget-focus",function(c,a){p.publish("widgetFocus",c,a)});l.mixin(e,{_curFocus:null,_prevFocus:null,isCollapsed:function(){return e.getBookmark().isCollapsed},getBookmark:function(){return(k.global==window?m:new m.SelectionManager(k.global)).getBookmark()},moveToBookmark:function(c){return(k.global==window?m:new m.SelectionManager(k.global)).moveToBookmark(c)},getFocus:function(c,a){var b=!f.curNode||c&&n.isDescendant(f.curNode,
c.domNode)?e._prevFocus:f.curNode;return{node:b,bookmark:b&&b==f.curNode&&k.withGlobal(a||k.global,e.getBookmark),openedForWindow:a}},_activeStack:[],registerIframe:function(c){return f.registerIframe(c)},unregisterIframe:function(c){c&&c.remove()},registerWin:function(c,a){return f.registerWin(c,a)},unregisterWin:function(c){c&&c.remove()}});return e})},"dijit/selection":function(){define("dojo/_base/array dojo/dom dojo/_base/lang dojo/sniff dojo/_base/window dijit/focus".split(" "),function(g,n,
l,p,k,f){var m=function(c){var a=c.document;this.getType=function(){if(a.getSelection){var b="text",e;try{e=c.getSelection()}catch(d){}e&&1==e.rangeCount&&(e=e.getRangeAt(0),e.startContainer==e.endContainer&&(1==e.endOffset-e.startOffset&&3!=e.startContainer.nodeType)&&(b="control"));return b}return a.selection.type.toLowerCase()};this.getSelectedText=function(){if(a.getSelection){var b=c.getSelection();return b?b.toString():""}return"control"==this.getType()?null:a.selection.createRange().text};
this.getSelectedHtml=function(){if(a.getSelection){var b=c.getSelection();if(b&&b.rangeCount){var e,d="";for(e=0;e<b.rangeCount;e++){var f=b.getRangeAt(e).cloneContents(),g=a.createElement("div");g.appendChild(f);d+=g.innerHTML}return d}return null}return"control"==this.getType()?null:a.selection.createRange().htmlText};this.getSelectedElement=function(){if("control"==this.getType()){if(a.getSelection){var b=c.getSelection();return b.anchorNode.childNodes[b.anchorOffset]}if((b=a.selection.createRange())&&
b.item)return a.selection.createRange().item(0)}return null};this.getParentElement=function(){if("control"==this.getType()){var b=this.getSelectedElement();if(b)return b.parentNode}else if(a.getSelection){if(b=a.getSelection()){for(b=b.anchorNode;b&&1!=b.nodeType;)b=b.parentNode;return b}}else return b=a.selection.createRange(),b.collapse(!0),b.parentElement();return null};this.hasAncestorElement=function(a){return null!=this.getAncestorElement.apply(this,arguments)};this.getAncestorElement=function(a){var c=
this.getSelectedElement()||this.getParentElement();return this.getParentOfType(c,arguments)};this.isTag=function(a,c){if(a&&a.tagName)for(var d=a.tagName.toLowerCase(),e=0;e<c.length;e++){var f=String(c[e]).toLowerCase();if(d==f)return f}return""};this.getParentOfType=function(a,c){for(;a;){if(this.isTag(a,c).length)return a;a=a.parentNode}return null};this.collapse=function(b){if(a.getSelection){var e=c.getSelection();e.removeAllRanges?b?e.collapseToStart():e.collapseToEnd():e.collapse(b)}else e=
a.selection.createRange(),e.collapse(b),e.select()};this.remove=function(){var b=a.selection;a.getSelection?(b=c.getSelection(),b.deleteFromDocument()):"none"!=b.type.toLowerCase()&&b.clear();return b};this.selectElementChildren=function(b,e){var d;b=n.byId(b);if(a.getSelection){var f=c.getSelection();p("opera")?(d=f.rangeCount?f.getRangeAt(0):a.createRange(),d.setStart(b,0),d.setEnd(b,3==b.nodeType?b.length:b.childNodes.length),f.addRange(d)):f.selectAllChildren(b)}else if(d=b.ownerDocument.body.createTextRange(),
d.moveToElementText(b),!e)try{d.select()}catch(g){}};this.selectElement=function(b,c){var d;b=n.byId(b);if(a.getSelection){var e=a.getSelection();d=a.createRange();e.removeAllRanges&&(p("opera")&&e.getRangeAt(0)&&(d=e.getRangeAt(0)),d.selectNode(b),e.removeAllRanges(),e.addRange(d))}else try{e=b.tagName?b.tagName.toLowerCase():"",d="img"===e||"table"===e?k.body(a).createControlRange():k.body(a).createRange(),d.addElement(b),c||d.select()}catch(f){this.selectElementChildren(b,c)}};this.inSelection=
function(b){if(b){var e,d;if(a.getSelection){var f=c.getSelection();f&&0<f.rangeCount&&(d=f.getRangeAt(0));if(d&&d.compareBoundaryPoints&&a.createRange)try{if(e=a.createRange(),e.setStart(b,0),1===d.compareBoundaryPoints(d.START_TO_END,e))return!0}catch(g){}}else{d=a.selection.createRange();try{e=b.ownerDocument.body.createTextRange(),e.moveToElementText(b)}catch(k){}if(d&&e&&1===d.compareEndPoints("EndToStart",e))return!0}}return!1};this.getBookmark=function(){var b,e,d=a.selection,g=f.curNode;if(a.getSelection){if(d=
c.getSelection())if(d.isCollapsed){if(b=g?g.tagName:"")if(b=b.toLowerCase(),"textarea"==b||"input"==b&&(!g.type||"text"==g.type.toLowerCase()))return d={start:g.selectionStart,end:g.selectionEnd,node:g,pRange:!0},{isCollapsed:d.end<=d.start,mark:d};b={isCollapsed:!0};d.rangeCount&&(b.mark=d.getRangeAt(0).cloneRange())}else e=d.getRangeAt(0),b={isCollapsed:!1,mark:e.cloneRange()}}else if(d){b=g?g.tagName:"";b=b.toLowerCase();if(g&&b&&("button"==b||"textarea"==b||"input"==b)){if(d.type&&"none"==d.type.toLowerCase())return{isCollapsed:!0,
mark:null};e=d.createRange();return{isCollapsed:e.text&&e.text.length?!1:!0,mark:{range:e,pRange:!0}}}b={};try{e=d.createRange(),b.isCollapsed=!("Text"==d.type?e.htmlText.length:e.length)}catch(k){return b.isCollapsed=!0,b}if("CONTROL"==d.type.toUpperCase())if(e.length){b.mark=[];d=0;for(g=e.length;d<g;)b.mark.push(e.item(d++))}else b.isCollapsed=!0,b.mark=null;else b.mark=e.getBookmark()}else console.warn("No idea how to store the current selection for this browser!");return b};this.moveToBookmark=
function(b){if(b=b.mark)if(a.getSelection){var e=c.getSelection();e&&e.removeAllRanges?b.pRange?(e=b.node,e.selectionStart=b.start,e.selectionEnd=b.end):(e.removeAllRanges(),e.addRange(b)):console.warn("No idea how to restore selection for this browser!")}else if(a.selection&&b){var d;b.pRange?d=b.range:l.isArray(b)?(d=a.body.createControlRange(),g.forEach(b,function(a){d.addElement(a)})):(d=a.body.createTextRange(),d.moveToBookmark(b));d.select()}};this.isCollapsed=function(){return this.getBookmark().isCollapsed}},
e=new m(window);e.SelectionManager=m;return e})},"dijit/_base/place":function(){define(["dojo/_base/array","dojo/_base/lang","dojo/window","../place","../main"],function(g,n,l,p,k){var f={getViewport:function(){return l.getBox()}};f.placeOnScreen=p.at;f.placeOnScreenAroundElement=function(f,e,c,a){var b;if(n.isArray(c))b=c;else{b=[];for(var g in c)b.push({aroundCorner:g,corner:c[g]})}return p.around(f,e,b,!0,a)};f.placeOnScreenAroundNode=f.placeOnScreenAroundElement;f.placeOnScreenAroundRectangle=
f.placeOnScreenAroundElement;f.getPopupAroundAlignment=function(f,e){var c={};g.forEach(f,function(a){var b=e;switch(a){case "after":c[e?"BR":"BL"]=e?"BL":"BR";break;case "before":c[e?"BL":"BR"]=e?"BR":"BL";break;case "below-alt":b=!b;case "below":c[b?"BL":"BR"]=b?"TL":"TR";c[b?"BR":"BL"]=b?"TR":"TL";break;case "above-alt":b=!b;default:c[b?"TL":"TR"]=b?"BL":"BR",c[b?"TR":"TL"]=b?"BR":"BL"}});return c};n.mixin(k,f);return k})},"dijit/_base/popup":function(){define(["dojo/dom-class","dojo/_base/window",
"../popup","../BackgroundIframe"],function(g,n,l){var p=l._createWrapper;l._createWrapper=function(f){f.declaredClass||(f={_popupWrapper:f.parentNode&&g.contains(f.parentNode,"dijitPopup")?f.parentNode:null,domNode:f,destroy:function(){},ownerDocument:f.ownerDocument,ownerDocumentBody:n.body(f.ownerDocument)});return p.call(this,f)};var k=l.open;l.open=function(f){if(f.orient&&"string"!=typeof f.orient&&!("length"in f.orient)){var g=[],e;for(e in f.orient)g.push({aroundCorner:e,corner:f.orient[e]});
f.orient=g}return k.call(this,f)};return l})},"dijit/_base/scroll":function(){define(["dojo/window","../main"],function(g,n){n.scrollIntoView=function(l,n){g.scrollIntoView(l,n)}})},"dijit/_base/sniff":function(){define(["dojo/uacss"],function(){})},"dijit/_base/typematic":function(){define(["../typematic"],function(){})},"dijit/typematic":function(){define("dojo/_base/array dojo/_base/connect dojo/_base/lang dojo/on dojo/sniff ./main".split(" "),function(g,n,l,p,k,f){var m=f.typematic={_fireEventAndReload:function(){this._timer=
null;this._callback(++this._count,this._node,this._evt);this._currentTimeout=Math.max(0>this._currentTimeout?this._initialDelay:1<this._subsequentDelay?this._subsequentDelay:Math.round(this._currentTimeout*this._subsequentDelay),this._minDelay);this._timer=setTimeout(l.hitch(this,"_fireEventAndReload"),this._currentTimeout)},trigger:function(e,c,a,b,f,d,g,k){if(f!=this._obj){this.stop();this._initialDelay=g||500;this._subsequentDelay=d||0.9;this._minDelay=k||10;this._obj=f;this._node=a;this._count=
this._currentTimeout=-1;this._callback=l.hitch(c,b);this._evt={faux:!0};for(var m in e)"layerX"!=m&&"layerY"!=m&&(c=e[m],"function"!=typeof c&&"undefined"!=typeof c&&(this._evt[m]=c));this._fireEventAndReload()}},stop:function(){this._timer&&(clearTimeout(this._timer),this._timer=null);this._obj&&(this._callback(-1,this._node,this._evt),this._obj=null)},addKeyListener:function(e,c,a,b,f,d,k){var s="keyCode"in c?"keyCode":"charCode"in c?"charCode":"charOrCode",r=[p(e,"keyCode"in c?"keydown":"charCode"in
c?"keypress":n._keypress,l.hitch(this,function(g){g[s]==c[s]&&(void 0===c.ctrlKey||c.ctrlKey==g.ctrlKey)&&(void 0===c.altKey||c.altKey==g.altKey)&&(void 0===c.metaKey||c.metaKey==(g.metaKey||!1))&&(void 0===c.shiftKey||c.shiftKey==g.shiftKey)?(g.stopPropagation(),g.preventDefault(),m.trigger(g,a,e,b,c,f,d,k)):m._obj==c&&m.stop()})),p(e,"keyup",l.hitch(this,function(){m._obj==c&&m.stop()}))];return{remove:function(){g.forEach(r,function(a){a.remove()})}}},addMouseListener:function(e,c,a,b,f,d){var n=
[p(e,"mousedown",l.hitch(this,function(g){g.preventDefault();m.trigger(g,c,e,a,e,b,f,d)})),p(e,"mouseup",l.hitch(this,function(a){this._obj&&a.preventDefault();m.stop()})),p(e,"mouseout",l.hitch(this,function(a){this._obj&&a.preventDefault();m.stop()})),p(e,"dblclick",l.hitch(this,function(g){g.preventDefault();9>k("ie")&&(m.trigger(g,c,e,a,e,b,f,d),setTimeout(l.hitch(this,m.stop),50))}))];return{remove:function(){g.forEach(n,function(a){a.remove()})}}},addListener:function(e,c,a,b,f,d,k,m){var l=
[this.addKeyListener(c,a,b,f,d,k,m),this.addMouseListener(e,b,f,d,k,m)];return{remove:function(){g.forEach(l,function(a){a.remove()})}}}};return m})},"dijit/_base/wai":function(){define(["dojo/dom-attr","dojo/_base/lang","../main","../hccss"],function(g,n,l){n.mixin(l,{hasWaiRole:function(g,k){var f=this.getWaiRole(g);return k?-1<f.indexOf(k):0<f.length},getWaiRole:function(l){return n.trim((g.get(l,"role")||"").replace("wairole:",""))},setWaiRole:function(l,k){g.set(l,"role",k)},removeWaiRole:function(l,
k){var f=g.get(l,"role");f&&(k?(f=n.trim((" "+f+" ").replace(" "+k+" "," ")),g.set(l,"role",f)):l.removeAttribute("role"))},hasWaiState:function(g,k){return g.hasAttribute?g.hasAttribute("aria-"+k):!!g.getAttribute("aria-"+k)},getWaiState:function(g,k){return g.getAttribute("aria-"+k)||""},setWaiState:function(g,k,f){g.setAttribute("aria-"+k,f)},removeWaiState:function(g,k){g.removeAttribute("aria-"+k)}});return l})},"dijit/_base/window":function(){define(["dojo/window","../main"],function(g,n){n.getDocumentWindow=
function(l){return g.get(l)}})},"url:dijit/templates/TooltipDialog.html":'\x3cdiv role\x3d"alertdialog" tabIndex\x3d"-1"\x3e\n\t\x3cdiv class\x3d"dijitTooltipContainer" role\x3d"presentation"\x3e\n\t\t\x3cdiv data-dojo-attach-point\x3d"contentsNode" class\x3d"dijitTooltipContents dijitTooltipFocusNode"\x3e\n\t\t\t\x3cdiv data-dojo-attach-point\x3d"containerNode"\x3e\x3c/div\x3e\n\t\t\t${!actionBarTemplate}\n\t\t\x3c/div\x3e\n\t\x3c/div\x3e\n\t\x3cdiv class\x3d"dijitTooltipConnector" role\x3d"presentation" data-dojo-attach-point\x3d"connectorNode"\x3e\x3c/div\x3e\n\x3c/div\x3e\n',
"*now":function(g){g(["dojo/i18n!*preload*dojo/nls/dojo*[]"])}}});(function(){var g=this.require;g({cache:{}});!g.async&&g(["dojo"]);g.boot&&g.apply(null,g.boot)})();
//# sourceMappingURL=dojo.js.map
;(function(global) {
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var QmlWeb = {};

global.QmlWeb = QmlWeb;

var objectIds = 0;

var QObject = function () {
  function QObject(parent) {
    _classCallCheck(this, QObject);

    this.$parent = parent;
    if (parent && parent.$tidyupList) {
      parent.$tidyupList.push(this);
    }

    // List of things to tidy up when deleting this object.
    this.$tidyupList = [];
    this.$properties = {};
    this.$signals = [];

    this.objectId = objectIds++;
  }

  _createClass(QObject, [{
    key: "$delete",
    value: function $delete() {
      if (this.$Component) {
        this.$Component.destruction();
      }

      while (this.$tidyupList.length > 0) {
        var item = this.$tidyupList[0];
        if (item.$delete) {
          // It's a QObject
          item.$delete();
        } else {
          // It must be a signal
          item.disconnect(this);
        }
      }

      for (var i in this.$properties) {
        var prop = this.$properties[i];
        while (prop.$tidyupList.length > 0) {
          prop.$tidyupList[0].disconnect(prop);
        }
      }

      if (this.$parent && this.$parent.$tidyupList) {
        var index = this.$parent.$tidyupList.indexOf(this);
        this.$parent.$tidyupList.splice(index, 1);
      }

      // must do this:
      // 1) parent will be notified and erase object from it's children.
      // 2) DOM node will be removed.
      this.parent = undefined;

      // Disconnect any slots connected to any of our signals. Do this after
      // clearing the parent, as that relies on parentChanged being handled.
      for (var _i in this.$signals) {
        this.$signals[_i].disconnect();
      }
    }

    // must have a `destroy` method
    // http://doc.qt.io/qt-5/qtqml-javascript-dynamicobjectcreation.html

  }, {
    key: "destroy",
    value: function destroy() {
      this.$delete();
    }
  }, {
    key: "$toString",
    value: function $toString() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return this.constructor.name + "(" + args.join(", ") + ")";
    }
  }]);

  return QObject;
}();

QmlWeb.QObject = QObject;

var JSItemModel = function () {
  function JSItemModel() {
    _classCallCheck(this, JSItemModel);

    this.roleNames = [];

    var Signal = QmlWeb.Signal;
    this.dataChanged = Signal.signal([{ type: "int", name: "startIndex" }, { type: "int", name: "endIndex" }]);
    this.rowsInserted = Signal.signal([{ type: "int", name: "startIndex" }, { type: "int", name: "endIndex" }]);
    this.rowsMoved = Signal.signal([{ type: "int", name: "sourceStartIndex" }, { type: "int", name: "sourceEndIndex" }, { type: "int", name: "destinationIndex" }]);
    this.rowsRemoved = Signal.signal([{ type: "int", name: "startIndex" }, { type: "int", name: "endIndex" }]);
    this.modelReset = Signal.signal();
  }

  _createClass(JSItemModel, [{
    key: "setRoleNames",
    value: function setRoleNames(names) {
      this.roleNames = names;
    }
  }]);

  return JSItemModel;
}();

var ItemModel = function (_JSItemModel) {
  _inherits(ItemModel, _JSItemModel);

  function ItemModel(items) {
    _classCallCheck(this, ItemModel);

    var _this = _possibleConstructorReturn(this, (ItemModel.__proto__ || Object.getPrototypeOf(ItemModel)).call(this));

    _this.items = items;
    return _this;
  }

  _createClass(ItemModel, [{
    key: "data",
    value: function data(index, role) {
      if (index > this.items.length) return undefined;
      return this.items[index][role];
    }
  }, {
    key: "get",
    value: function get(index) {
      if (index > this.items.length) return undefined;
      return this.items[index];
    }
  }, {
    key: "push",
    value: function push(item) {
      this.items.push(item);
      var roleNames = [];
      for (var i in item) {
        if (i !== "index") {
          roleNames.push(i);
        }
      }
      this.setRoleNames(roleNames);
      this.rowsInserted(this.items.length - 1, this.items.length);
    }
  }, {
    key: "insert",
    value: function insert(index, item) {
      this.items.splice(index, 0, item);
      var roleNames = [];
      for (var i in item) {
        if (i !== "index") {
          roleNames.push(i);
        }
      }
      this.setRoleNames(roleNames);
      this.rowsInserted(index, index + 1);
    }
  }, {
    key: "remove",
    value: function remove(index) {
      if (index < 0) return;
      this.items.splice(index, 1);
      this.rowsRemoved(index, index + 1);
    }
  }, {
    key: "rowCount",
    value: function rowCount() {
      return this.items.length;
    }
  }]);

  return ItemModel;
}(JSItemModel);

QmlWeb.JSItemModel = JSItemModel;
QmlWeb.ItemModel = ItemModel;

var QColor = function () {
  function QColor() {
    _classCallCheck(this, QColor);

    this.$changed = new QmlWeb.Signal();
    this.$r = this.$g = this.$b = 0;
    this.$a = 1;
    var val = arguments.length <= 0 ? undefined : arguments[0];
    if (arguments.length >= 3) {
      this.$r = arguments.length <= 0 ? undefined : arguments[0];
      this.$g = arguments.length <= 1 ? undefined : arguments[1];
      this.$b = arguments.length <= 2 ? undefined : arguments[2];
      if (arguments.length >= 4) {
        this.$a = arguments.length <= 3 ? undefined : arguments[3];
      }
    } else if (val instanceof QColor) {
      // Copy constructor
      this.$a = val.a;
      this.$r = val.r;
      this.$g = val.g;
      this.$b = val.b;
    } else if (typeof val === "string") {
      var lval = val.toLowerCase();
      if (QColor.colormap[lval]) {
        var rgb = QColor.colormap[lval];
        this.$r = rgb[0] / 255;
        this.$g = rgb[1] / 255;
        this.$b = rgb[2] / 255;
      } else if (lval === "transparent") {
        this.$a = 0;
      } else if (lval[0] === "#") {
        var hex = lval.substr(1);
        if (hex.length === 3) {
          this.$r = parseInt(hex[0], 16) / 15;
          this.$g = parseInt(hex[1], 16) / 15;
          this.$b = parseInt(hex[2], 16) / 15;
        } else {
          var _rgb = hex.match(/.{2}/g).map(function (x) {
            return parseInt(x, 16);
          });
          if (_rgb.length === 4) {
            this.$a = _rgb.shift() / 255;
          }
          this.$r = _rgb[0] / 255;
          this.$g = _rgb[1] / 255;
          this.$b = _rgb[2] / 255;
        }
      } else {
        throw new Error("Can not convert " + val + " to color");
      }
    } else if (typeof val !== "undefined") {
      throw new Error("Can not assign " + (typeof val === "undefined" ? "undefined" : _typeof(val)) + " to QColor");
    }
  }

  _createClass(QColor, [{
    key: "toString",
    value: function toString() {
      if (this.$string) return this.$string;
      var argb = [this.$a, this.$r, this.$g, this.$b].map(function (x) {
        return (Math.round(x * 255) + 0x100).toString(16).substr(-2);
      });
      if (argb[0] === "ff") {
        argb.shift(); // We don't need alpha if it's ff
      }
      this.$string = "#" + argb.join("");
      return "#" + argb.join("");
    }
  }, {
    key: "$css",
    get: function get() {
      if (this.$cssValue) return this.$cssValue;
      if (this.$a === 1) {
        this.$cssValue = this.toString();
      } else if (this.$a === 0) {
        this.$cssValue = "transparent";
      } else {
        var intr = Math.round(this.$r * 255);
        var intg = Math.round(this.$g * 255);
        var intb = Math.round(this.$b * 255);
        this.$cssValue = "rgba(" + intr + "," + intg + "," + intb + "," + this.$a + ")";
      }
      return this.$cssValue;
    }
  }, {
    key: "r",
    get: function get() {
      return this.$r;
    },
    set: function set(r) {
      this.$r = r;
      this.$string = this.$cssValue = null;
      this.$changed.execute();
    }
  }, {
    key: "g",
    get: function get() {
      return this.$g;
    },
    set: function set(g) {
      this.$g = g;
      this.$string = this.$cssValue = null;
      this.$changed.execute();
    }
  }, {
    key: "b",
    get: function get() {
      return this.$b;
    },
    set: function set(b) {
      this.$b = b;
      this.$string = this.$cssValue = null;
      this.$changed.execute();
    }
  }, {
    key: "a",
    get: function get() {
      return this.$a;
    },
    set: function set(a) {
      this.$a = a;
      this.$string = this.$cssValue = null;
      this.$changed.execute();
    }
  }, {
    key: "hsvHue",
    get: function get() {
      var v = this.hsvValue;
      var m = Math.min(this.$r, this.$g, this.$b);
      if (v === m) return -1;
      if (v === this.$r) return ((this.$g - this.$b) / (v - m) + 1) % 1 / 6;
      if (v === this.$g) return ((this.$b - this.$r) / (v - m) + 2) / 6;
      if (v === this.$b) return ((this.$r - this.$g) / (v - m) + 4) / 6;
      throw new Error();
    },
    set: function set(h) {
      var rgb = QColor.$hsv(h, this.hsvSaturation, this.hsvValue);
      this.$r = rgb[0];
      this.$g = rgb[1];
      this.$b = rgb[2];
      this.$string = this.$cssValue = null;
      this.$changed.execute();
    }
  }, {
    key: "hsvSaturation",
    get: function get() {
      var v = this.hsvValue;
      if (v === 0) return 0;
      return 1 - Math.min(this.$r, this.$g, this.$b) / v;
    },
    set: function set(s) {
      var rgb = QColor.$hsv(this.hsvHue, s, this.hsvValue);
      this.$r = rgb[0];
      this.$g = rgb[1];
      this.$b = rgb[2];
      this.$string = this.$cssValue = null;
      this.$changed.execute();
    }
  }, {
    key: "hsvValue",
    get: function get() {
      return Math.max(this.$r, this.$g, this.$b);
    },
    set: function set(v) {
      var rgb = QColor.$hsv(this.hsvHue, this.hsvSaturation, v);
      this.$r = rgb[0];
      this.$g = rgb[1];
      this.$b = rgb[2];
      this.$string = this.$cssValue = null;
      this.$changed.execute();
    }
  }, {
    key: "hslHue",
    get: function get() {
      return this.hsvHue;
    },
    set: function set(h) {
      var rgb = QColor.$hsl(h, this.hslSaturation, this.hslLightness);
      this.$r = rgb[0];
      this.$g = rgb[1];
      this.$b = rgb[2];
      this.$string = this.$cssValue = null;
      this.$changed.execute();
    }
  }, {
    key: "hslSaturation",
    get: function get() {
      var max = Math.max(this.$r, this.$g, this.$b);
      var min = Math.min(this.$r, this.$g, this.$b);
      if (max === min) return 0;
      return (max - min) / (1 - Math.abs(1 - max - min));
    },
    set: function set(s) {
      var rgb = QColor.$hsl(this.hslHue, s, this.hslLightness);
      this.$r = rgb[0];
      this.$g = rgb[1];
      this.$b = rgb[2];
      this.$string = this.$cssValue = null;
      this.$changed.execute();
    }
  }, {
    key: "hslLightness",
    get: function get() {
      var max = Math.max(this.$r, this.$g, this.$b);
      var min = Math.min(this.$r, this.$g, this.$b);
      return (max + min) / 2;
    },
    set: function set(l) {
      var rgb = QColor.$hsl(this.hslHue, this.hslSaturation, l);
      this.$r = rgb[0];
      this.$g = rgb[1];
      this.$b = rgb[2];
      this.$string = this.$cssValue = null;
      this.$changed.execute();
    }
  }], [{
    key: "$hsv",
    value: function $hsv(h, s, v) {
      var c = v * s;
      var m = v - c;
      return QColor.$hcma(h, c, m);
    }
  }, {
    key: "$hsl",
    value: function $hsl(h, s, l) {
      var c = (1 - Math.abs(2 * l - 1)) * s;
      var m = l - c / 2;
      return QColor.$hcma(h, c, m);
    }
  }, {
    key: "$hcma",
    value: function $hcma(h, c, m) {
      var hh = h > 0 ? h * 6 % 6 : 0;
      var x = c * (1 - Math.abs(hh % 2 - 1));
      var rgb = void 0;
      switch (Math.floor(hh)) {
        case 0:
          rgb = [c, x, 0];
          break;
        case 1:
          rgb = [x, c, 0];
          break;
        case 2:
          rgb = [0, c, x];
          break;
        case 3:
          rgb = [0, x, c];
          break;
        case 4:
          rgb = [x, 0, c];
          break;
        case 5:
          rgb = [c, 0, x];
          break;
      }
      return rgb.map(function (y) {
        return Math.min(1, y + m);
      });
    }
  }, {
    key: "darker",
    value: function darker(baseColor) {
      var factor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;

      var color = baseColor instanceof QColor ? baseColor : new QColor(baseColor);
      var v = color.hsvValue / factor;
      // Undocumented in Qt, but this matches the observed Qt behaviour
      var s = color.hsvSaturation - Math.max(0, v - 1);
      return QColor.hsva(color.hsvHue, Math.max(0, s), Math.min(1, v), color.a);
    }
  }, {
    key: "lighter",
    value: function lighter(baseColor) {
      var factor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.5;

      var color = baseColor instanceof QColor ? baseColor : new QColor(baseColor);
      var v = color.hsvValue * factor;
      // Undocumented in Qt, but this matches the observed Qt behaviour
      var s = color.hsvSaturation - Math.max(0, v - 1);
      return QColor.hsva(color.hsvHue, Math.max(0, s), Math.min(1, v), color.a);
    }
  }, {
    key: "equal",
    value: function equal(lhs, rhs) {
      var a = lhs instanceof QColor ? lhs : new QColor(lhs);
      var b = rhs instanceof QColor ? rhs : new QColor(rhs);
      return a.toString() === b.toString();
    }
  }]);

  return QColor;
}();

QColor.rgba = function (r, g, b) {
  var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  return new QColor(r, g, b, a);
};

QColor.hsva = function (h, s, v) {
  var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  return new (Function.prototype.bind.apply(QColor, [null].concat(_toConsumableArray(QColor.$hsv(h, s, v)), [a])))();
};

QColor.hsla = function (h, s, l) {
  var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  return new (Function.prototype.bind.apply(QColor, [null].concat(_toConsumableArray(QColor.$hsl(h, s, l)), [a])))();
};

QColor.colormap = { // https://www.w3.org/TR/SVG/types.html#ColorKeywords
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  grey: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};
QColor.nonNullableType = true;
QColor.requireConstructor = true;

QmlWeb.QColor = QColor;

var QFont = function (_QmlWeb$QObject) {
  _inherits(QFont, _QmlWeb$QObject);

  function QFont(parent) {
    _classCallCheck(this, QFont);

    var _this2 = _possibleConstructorReturn(this, (QFont.__proto__ || Object.getPrototypeOf(QFont)).call(this, parent));

    _this2.Font = QFont.Font;

    var Font = _this2.Font;

    QmlWeb.createProperties(_this2, {
      bold: "bool",
      capitalization: { type: "enum", initialValue: Font.MixedCase },
      family: { type: "string", initialValue: "sans-serif" },
      italic: "bool",
      letterSpacing: "real",
      pixelSize: { type: "int", initialValue: 13 },
      pointSize: { type: "real", initialValue: 10 },
      strikeout: "bool",
      underline: "bool",
      weight: { type: "enum", initialValue: Font.Normal },
      wordSpacing: "real"
    });

    _this2.$sizeLock = false;

    _this2.boldChanged.connect(_this2, _this2.$onBoldChanged);
    _this2.capitalizationChanged.connect(_this2, _this2.$onCapitalizationChanged);
    _this2.familyChanged.connect(_this2, _this2.$onFamilyChanged);
    _this2.italicChanged.connect(_this2, _this2.$onItalicChanged);
    _this2.letterSpacingChanged.connect(_this2, _this2.$onLetterSpacingChanged);
    _this2.pixelSizeChanged.connect(_this2, _this2.$onPixelSizeChanged);
    _this2.pointSizeChanged.connect(_this2, _this2.$onPointSizeChanged);
    _this2.strikeoutChanged.connect(_this2, _this2.$onStrikeoutChanged);
    _this2.underlineChanged.connect(_this2, _this2.$onUnderlineChanged);
    _this2.weightChanged.connect(_this2, _this2.$onWidthChanged);
    _this2.wordSpacingChanged.connect(_this2, _this2.$onWordSpacingChanged);
    return _this2;
  }

  _createClass(QFont, [{
    key: "$onBoldChanged",
    value: function $onBoldChanged(newVal) {
      var Font = this.Font;
      this.weight = newVal ? Font.Bold : Font.Normal;
    }
  }, {
    key: "$onCapitalizationChanged",
    value: function $onCapitalizationChanged(newVal) {
      var style = this.$parent.dom.firstChild.style;
      style.fontVariant = newVal === this.Font.SmallCaps ? "small-caps" : "none";
      style.textTransform = this.$capitalizationToTextTransform(newVal);
    }
  }, {
    key: "$onFamilyChanged",
    value: function $onFamilyChanged(newVal) {
      var style = this.$parent.dom.firstChild.style;
      style.fontFamily = newVal;
    }
  }, {
    key: "$onItalicChanged",
    value: function $onItalicChanged(newVal) {
      var style = this.$parent.dom.firstChild.style;
      style.fontStyle = newVal ? "italic" : "normal";
    }
  }, {
    key: "$onLetterSpacingChanged",
    value: function $onLetterSpacingChanged(newVal) {
      var style = this.$parent.dom.firstChild.style;
      style.letterSpacing = newVal !== undefined ? newVal + "px" : "";
    }
  }, {
    key: "$onPixelSizeChanged",
    value: function $onPixelSizeChanged(newVal) {
      if (!this.$sizeLock) {
        this.pointSize = newVal * 0.75;
      }
      var val = newVal + "px";
      this.$parent.dom.style.fontSize = val;
      this.$parent.dom.firstChild.style.fontSize = val;
    }
  }, {
    key: "$onPointSizeChanged",
    value: function $onPointSizeChanged(newVal) {
      this.$sizeLock = true;
      this.pixelSize = Math.round(newVal / 0.75);
      this.$sizeLock = false;
    }
  }, {
    key: "$onStrikeoutChanged",
    value: function $onStrikeoutChanged(newVal) {
      var style = this.$parent.dom.firstChild.style;
      style.textDecoration = newVal ? "line-through" : this.$parent.font.underline ? "underline" : "none";
    }
  }, {
    key: "$onUnderlineChanged",
    value: function $onUnderlineChanged(newVal) {
      var style = this.$parent.dom.firstChild.style;
      style.textDecoration = this.$parent.font.strikeout ? "line-through" : newVal ? "underline" : "none";
    }
  }, {
    key: "$onWidthChanged",
    value: function $onWidthChanged(newVal) {
      var style = this.$parent.dom.firstChild.style;
      style.fontWeight = this.$weightToCss(newVal);
    }
  }, {
    key: "$onWordSpacingChanged",
    value: function $onWordSpacingChanged(newVal) {
      var style = this.$parent.dom.firstChild.style;
      style.wordSpacing = newVal !== undefined ? newVal + "px" : "";
    }
  }, {
    key: "$weightToCss",
    value: function $weightToCss(weight) {
      var Font = this.Font;
      switch (weight) {
        case Font.Thin:
          return "100";
        case Font.ExtraLight:
          return "200";
        case Font.Light:
          return "300";
        case Font.Normal:
          return "400";
        case Font.Medium:
          return "500";
        case Font.DemiBold:
          return "600";
        case Font.Bold:
          return "700";
        case Font.ExtraBold:
          return "800";
        case Font.Black:
          return "900";
      }
      return "normal";
    }
  }, {
    key: "$capitalizationToTextTransform",
    value: function $capitalizationToTextTransform(capitalization) {
      var Font = this.Font;
      switch (capitalization) {
        case Font.AllUppercase:
          return "uppercase";
        case Font.AllLowercase:
          return "lowercase";
        case Font.Capitalize:
          return "capitalize";
      }
      return "none";
    }
  }]);

  return QFont;
}(QmlWeb.QObject);

QFont.Font = {
  // Capitalization
  MixedCase: 0,
  AllUppercase: 1,
  AllLowercase: 2,
  SmallCaps: 3,
  Capitalize: 4,
  // Weight
  Thin: 0,
  ExtraLight: 12,
  Light: 25,
  Normal: 50,
  Medium: 57,
  DemiBold: 63,
  Bold: 75,
  ExtraBold: 81,
  Black: 87
};
QFont.requireParent = true;


QmlWeb.QFont = QFont;
global.Font = QFont.Font; // HACK

var QMatrix4x4 = function (_QmlWeb$QObject2) {
  _inherits(QMatrix4x4, _QmlWeb$QObject2);

  function QMatrix4x4() {
    _classCallCheck(this, QMatrix4x4);

    var _this3 = _possibleConstructorReturn(this, (QMatrix4x4.__proto__ || Object.getPrototypeOf(QMatrix4x4)).call(this));

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var data = args;
    if (args.length === 0) {
      data = [];
      for (var row = 1; row <= 4; row++) {
        for (var col = 1; col <= 4; col++) {
          data.push(col === row ? 1 : 0);
        }
      }
    } else if (args.length === 1 && args[0] instanceof QMatrix4x4) {
      data = [];
      for (var _row = 1; _row <= 4; _row++) {
        for (var _col = 1; _col <= 4; _col++) {
          var name = "m" + _row + _col;
          data.push(args[0][name]);
        }
      }
    } else if (args.length !== 16) {
      throw new Error("Invalid arguments");
    }
    for (var _row2 = 1; _row2 <= 4; _row2++) {
      for (var _col2 = 1; _col2 <= 4; _col2++) {
        var _name = "m" + _row2 + _col2;
        var value = data[4 * (_row2 - 1) + _col2 - 1];
        QmlWeb.createProperty("real", _this3, _name, { initialValue: value });
      }
    }
    return _this3;
  }

  _createClass(QMatrix4x4, [{
    key: "toString",
    value: function toString() {
      return _get(QMatrix4x4.prototype.__proto__ || Object.getPrototypeOf(QMatrix4x4.prototype), "$toString", this).call(this, this.m11, this.m12, this.m13, this.m14, this.m21, this.m22, this.m23, this.m24, this.m31, this.m32, this.m33, this.m34, this.m41, this.m42, this.m43, this.m44);
    }
  }, {
    key: "times",
    value: function times(a) {
      if (a instanceof QmlWeb.QMatrix4x4) {
        var t = this;
        return new QmlWeb.QMatrix4x4(t.m11 * a.m11 + t.m12 * a.m21 + t.m13 * a.m31 + t.m14 * a.m41, t.m11 * a.m12 + t.m12 * a.m22 + t.m13 * a.m32 + t.m14 * a.m42, t.m11 * a.m13 + t.m12 * a.m23 + t.m13 * a.m33 + t.m14 * a.m43, t.m11 * a.m14 + t.m12 * a.m24 + t.m13 * a.m34 + t.m14 * a.m44, t.m21 * a.m11 + t.m22 * a.m21 + t.m23 * a.m31 + t.m24 * a.m41, t.m21 * a.m12 + t.m22 * a.m22 + t.m23 * a.m32 + t.m24 * a.m42, t.m21 * a.m13 + t.m22 * a.m23 + t.m23 * a.m33 + t.m24 * a.m43, t.m21 * a.m14 + t.m22 * a.m24 + t.m23 * a.m34 + t.m24 * a.m44, t.m31 * a.m11 + t.m32 * a.m21 + t.m33 * a.m31 + t.m34 * a.m41, t.m31 * a.m12 + t.m32 * a.m22 + t.m33 * a.m32 + t.m34 * a.m42, t.m31 * a.m13 + t.m32 * a.m23 + t.m33 * a.m33 + t.m34 * a.m43, t.m31 * a.m14 + t.m32 * a.m24 + t.m33 * a.m34 + t.m34 * a.m44, t.m41 * a.m11 + t.m42 * a.m21 + t.m43 * a.m31 + t.m44 * a.m41, t.m41 * a.m12 + t.m42 * a.m22 + t.m43 * a.m32 + t.m44 * a.m42, t.m41 * a.m13 + t.m42 * a.m23 + t.m43 * a.m33 + t.m44 * a.m43, t.m41 * a.m14 + t.m42 * a.m24 + t.m43 * a.m34 + t.m44 * a.m44);
      }
      if (a instanceof QmlWeb.QVector4D) {
        var _t = this;
        return new QmlWeb.QVector4D(_t.m11 * a.x + _t.m12 * a.y + _t.m13 * a.z + _t.m14 * a.w, _t.m21 * a.x + _t.m22 * a.y + _t.m23 * a.z + _t.m24 * a.w, _t.m31 * a.x + _t.m32 * a.y + _t.m33 * a.z + _t.m34 * a.w, _t.m41 * a.x + _t.m42 * a.y + _t.m43 * a.z + _t.m44 * a.w);
      }
      if (a instanceof QmlWeb.QVector3D) {
        var v = this.times(new QmlWeb.QVector4D(a.x, a.y, a.z, 1));
        return new QmlWeb.QVector3D(v.x / v.w, v.y / v.w, v.z / v.w);
      }
      return new QMatrix4x4(this.m11 * a, this.m12 * a, this.m13 * a, this.m14 * a, this.m21 * a, this.m22 * a, this.m23 * a, this.m24 * a, this.m31 * a, this.m32 * a, this.m33 * a, this.m34 * a, this.m41 * a, this.m42 * a, this.m43 * a, this.m44 * a);
    }
  }, {
    key: "plus",
    value: function plus(other) {
      var a = other instanceof QMatrix4x4 ? other : new QMatrix4x4();
      return new QMatrix4x4(this.m11 + a.m11, this.m12 + a.m12, this.m13 + a.m13, this.m14 + a.m14, this.m21 + a.m21, this.m22 + a.m22, this.m23 + a.m23, this.m24 + a.m24, this.m31 + a.m31, this.m32 + a.m32, this.m33 + a.m33, this.m34 + a.m34, this.m41 + a.m41, this.m42 + a.m42, this.m43 + a.m43, this.m44 + a.m44);
    }
  }, {
    key: "minus",
    value: function minus(other) {
      var a = other instanceof QMatrix4x4 ? other : new QMatrix4x4();
      return new QMatrix4x4(this.m11 - a.m11, this.m12 - a.m12, this.m13 - a.m13, this.m14 - a.m14, this.m21 - a.m21, this.m22 - a.m22, this.m23 - a.m23, this.m24 - a.m24, this.m31 - a.m31, this.m32 - a.m32, this.m33 - a.m33, this.m34 - a.m34, this.m41 - a.m41, this.m42 - a.m42, this.m43 - a.m43, this.m44 - a.m44);
    }
  }, {
    key: "row",
    value: function row(i) {
      var _this4 = this;

      var row = i + 1;
      var arr = [1, 2, 3, 4].map(function (col) {
        return _this4["m" + row + col];
      });
      return new (Function.prototype.bind.apply(QmlWeb.QVector4D, [null].concat(_toConsumableArray(arr))))();
    }
  }, {
    key: "column",
    value: function column(i) {
      var _this5 = this;

      var col = i + 1;
      var arr = [1, 2, 3, 4].map(function (row) {
        return _this5["m" + row + col];
      });
      return new (Function.prototype.bind.apply(QmlWeb.QVector4D, [null].concat(_toConsumableArray(arr))))();
    }
  }, {
    key: "determinant",
    value: function determinant() {
      // Laplace expansion
      var t = this;
      var s0 = t.m11 * t.m22 - t.m12 * t.m21;
      var c5 = t.m33 * t.m44 - t.m34 * t.m43;
      var s1 = t.m11 * t.m23 - t.m13 * t.m21;
      var c4 = t.m32 * t.m44 - t.m34 * t.m42;
      var s2 = t.m11 * t.m24 - t.m14 * t.m21;
      var c3 = t.m32 * t.m43 - t.m33 * t.m42;
      var s3 = t.m12 * t.m23 - t.m13 * t.m22;
      var c2 = t.m31 * t.m44 - t.m34 * t.m41;
      var s4 = t.m12 * t.m24 - t.m14 * t.m22;
      var c1 = t.m31 * t.m43 - t.m33 * t.m41;
      var s5 = t.m13 * t.m24 - t.m14 * t.m23;
      var c0 = t.m31 * t.m42 - t.m32 * t.m41;
      return s0 * c5 - s1 * c4 + s2 * c3 + s3 * c2 - s4 * c1 + s5 * c0;
    }
  }, {
    key: "inverted",
    value: function inverted() {
      // Laplace expansion
      var t = this;
      var s0 = t.m11 * t.m22 - t.m12 * t.m21;
      var c5 = t.m33 * t.m44 - t.m34 * t.m43;
      var s1 = t.m11 * t.m23 - t.m13 * t.m21;
      var c4 = t.m32 * t.m44 - t.m34 * t.m42;
      var s2 = t.m11 * t.m24 - t.m14 * t.m21;
      var c3 = t.m32 * t.m43 - t.m33 * t.m42;
      var s3 = t.m12 * t.m23 - t.m13 * t.m22;
      var c2 = t.m31 * t.m44 - t.m34 * t.m41;
      var s4 = t.m12 * t.m24 - t.m14 * t.m22;
      var c1 = t.m31 * t.m43 - t.m33 * t.m41;
      var s5 = t.m13 * t.m24 - t.m14 * t.m23;
      var c0 = t.m31 * t.m42 - t.m32 * t.m41;
      var det = s0 * c5 - s1 * c4 + s2 * c3 + s3 * c2 - s4 * c1 + s5 * c0;
      var adj = [+t.m22 * c5 - t.m23 * c4 + t.m24 * c3, -t.m12 * c5 + t.m13 * c4 - t.m14 * c3, +t.m42 * s5 - t.m43 * s4 + t.m44 * s3, -t.m32 * s5 + t.m33 * s4 - t.m34 * s3, -t.m21 * c5 + t.m23 * c2 - t.m24 * c1, +t.m11 * c5 - t.m13 * c2 + t.m14 * c1, -t.m41 * s5 + t.m43 * s2 - t.m44 * s1, +t.m31 * s5 - t.m33 * s2 + t.m34 * s1, +t.m21 * c4 - t.m22 * c2 + t.m24 * c0, -t.m11 * c4 + t.m12 * c2 - t.m14 * c0, +t.m41 * s4 - t.m42 * s2 + t.m44 * s0, -t.m31 * s4 + t.m32 * s2 - t.m34 * s0, -t.m21 * c3 + t.m22 * c1 - t.m23 * c0, +t.m11 * c3 - t.m12 * c1 + t.m13 * c0, -t.m41 * s3 + t.m42 * s1 - t.m43 * s0, +t.m31 * s3 - t.m32 * s1 + t.m33 * s0];
      return new (Function.prototype.bind.apply(QMatrix4x4, [null].concat(_toConsumableArray(adj.map(function (x) {
        return x / det;
      })))))();
    }
  }, {
    key: "transposed",
    value: function transposed() {
      return new QMatrix4x4(this.m11, this.m21, this.m31, this.m41, this.m12, this.m22, this.m32, this.m42, this.m13, this.m23, this.m33, this.m43, this.m14, this.m24, this.m34, this.m44);
    }
  }, {
    key: "fuzzyEquals",
    value: function fuzzyEquals(a) {
      var epsilon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.00001;

      for (var row = 1; row <= 4; row++) {
        for (var col = 1; col <= 4; col++) {
          var name = "m" + row + col;
          if (Math.abs(this[name] - a[name]) > epsilon) {
            return false;
          }
        }
      }
      return true;
    }
  }]);

  return QMatrix4x4;
}(QmlWeb.QObject);

QMatrix4x4.nonNullableType = true;
QMatrix4x4.requireConstructor = true;


QmlWeb.QMatrix4x4 = QMatrix4x4;

var QPointF = function (_QmlWeb$QObject3) {
  _inherits(QPointF, _QmlWeb$QObject3);

  function QPointF() {
    _classCallCheck(this, QPointF);

    var _this6 = _possibleConstructorReturn(this, (QPointF.__proto__ || Object.getPrototypeOf(QPointF)).call(this));

    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    var data = args;
    if (args.length === 0) {
      data = [0, 0];
    } else if (args.length === 1 && typeof args[0] === "string") {
      data = args[0].split(",").map(function (x) {
        return parseFloat(x.trim(), 10);
      });
      if (data.length !== 2) throw new Error("point expected");
    } else if (args.length === 1 && args[0] instanceof QPointF) {
      data = [args[0].x, args[0].y];
    } else if (args.length !== 2) {
      throw new Error("Invalid arguments");
    }
    QmlWeb.createProperties(_this6, {
      x: { type: "real", initialValue: data[0] },
      y: { type: "real", initialValue: data[1] }
    });
    return _this6;
  }

  _createClass(QPointF, [{
    key: "toString",
    value: function toString() {
      return _get(QPointF.prototype.__proto__ || Object.getPrototypeOf(QPointF.prototype), "$toString", this).call(this, this.x, this.y);
    }
  }]);

  return QPointF;
}(QmlWeb.QObject);

QPointF.nonNullableType = true;
QPointF.requireConstructor = true;


QmlWeb.QPointF = QPointF;

var QQuaternion = function (_QmlWeb$QObject4) {
  _inherits(QQuaternion, _QmlWeb$QObject4);

  function QQuaternion() {
    _classCallCheck(this, QQuaternion);

    var _this7 = _possibleConstructorReturn(this, (QQuaternion.__proto__ || Object.getPrototypeOf(QQuaternion)).call(this));

    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    var data = args;
    if (args.length === 1 && typeof args[0] === "string") {
      data = args[0].split(",").map(function (x) {
        return parseFloat(x.trim(), 10);
      });
      if (data.length !== 4) data = [];
    } else if (args.length === 1 && args[0] instanceof QQuaternion) {
      data = [args[0].scalar, args[0].x, args[0].y, args[0].z];
    }
    if (data.length === 0) {
      data = [1, 0, 0, 0];
    } else if (data.length !== 4) {
      throw new Error("Invalid arguments");
    }
    QmlWeb.createProperties(_this7, {
      scalar: { type: "real", initialValue: data[0] },
      x: { type: "real", initialValue: data[1] },
      y: { type: "real", initialValue: data[2] },
      z: { type: "real", initialValue: data[3] }
    });
    return _this7;
  }

  _createClass(QQuaternion, [{
    key: "toString",
    value: function toString() {
      return _get(QQuaternion.prototype.__proto__ || Object.getPrototypeOf(QQuaternion.prototype), "$toString", this).call(this, this.scalar, this.x, this.y, this.z);
    }
  }]);

  return QQuaternion;
}(QmlWeb.QObject);

QQuaternion.nonNullableType = true;
QQuaternion.requireConstructor = true;


QmlWeb.QQuaternion = QQuaternion;

var QRectF = function (_QmlWeb$QObject5) {
  _inherits(QRectF, _QmlWeb$QObject5);

  function QRectF() {
    _classCallCheck(this, QRectF);

    var _this8 = _possibleConstructorReturn(this, (QRectF.__proto__ || Object.getPrototypeOf(QRectF)).call(this));

    for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    var data = args;
    if (args.length === 0) {
      data = [0, 0, 0, 0];
    } else if (args.length === 1 && typeof args[0] === "string") {
      var mask = /^\s*[-\d.]+\s*,\s*[-\d.]+\s*,\s*[-\d.]+\s*x\s*[-\d.]+\s*$/;
      if (!args[0].match(mask)) throw new Error("rect expected");
      data = args[0].replace("x", ",").split(",").map(function (x) {
        return parseFloat(x.trim(), 10);
      });
    } else if (args.length === 1 && args[0] instanceof QRectF) {
      data = [args[0].x, args[0].y, args[0].z, args[0].width];
    } else if (args.length !== 4) {
      throw new Error("Invalid arguments");
    }
    QmlWeb.createProperties(_this8, {
      x: { type: "real", initialValue: data[0] },
      y: { type: "real", initialValue: data[1] },
      width: { type: "real", initialValue: data[2] },
      height: { type: "real", initialValue: data[3] }
    });
    return _this8;
  }

  _createClass(QRectF, [{
    key: "toString",
    value: function toString() {
      return _get(QRectF.prototype.__proto__ || Object.getPrototypeOf(QRectF.prototype), "$toString", this).call(this, this.x, this.y, this.width, this.height);
    }
  }]);

  return QRectF;
}(QmlWeb.QObject);

QRectF.nonNullableType = true;
QRectF.requireConstructor = true;


QmlWeb.QRectF = QRectF;

var QSizeF = function (_QmlWeb$QObject6) {
  _inherits(QSizeF, _QmlWeb$QObject6);

  function QSizeF() {
    _classCallCheck(this, QSizeF);

    var _this9 = _possibleConstructorReturn(this, (QSizeF.__proto__ || Object.getPrototypeOf(QSizeF)).call(this));

    for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }

    var data = args;
    if (args.length === 0) {
      data = [-1, -1];
    } else if (args.length === 1 && typeof args[0] === "string") {
      data = args[0].split("x").map(function (x) {
        return parseFloat(x.trim(), 10);
      });
      if (data.length !== 2) throw new Error("size expected");
    } else if (args.length === 1 && args[0] instanceof QSizeF) {
      data = [args[0].width, args[0].height];
    } else if (args.length !== 2) {
      throw new Error("Invalid arguments");
    }
    QmlWeb.createProperties(_this9, {
      width: { type: "real", initialValue: data[0] },
      height: { type: "real", initialValue: data[1] }
    });
    return _this9;
  }

  _createClass(QSizeF, [{
    key: "toString",
    value: function toString() {
      return _get(QSizeF.prototype.__proto__ || Object.getPrototypeOf(QSizeF.prototype), "$toString", this).call(this, this.width, this.height);
    }
  }]);

  return QSizeF;
}(QmlWeb.QObject);

QSizeF.nonNullableType = true;
QSizeF.requireConstructor = true;


QmlWeb.QSizeF = QSizeF;

var QVector2D = function (_QmlWeb$QObject7) {
  _inherits(QVector2D, _QmlWeb$QObject7);

  function QVector2D() {
    _classCallCheck(this, QVector2D);

    var _this10 = _possibleConstructorReturn(this, (QVector2D.__proto__ || Object.getPrototypeOf(QVector2D)).call(this));

    for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }

    var data = args;
    if (args.length === 1 && typeof args[0] === "string") {
      data = args[0].split(",").map(function (x) {
        return parseFloat(x.trim(), 10);
      });
      if (data.length !== 2) data = [];
    } else if (args.length === 1 && args[0] instanceof QVector2D) {
      data = [args[0].x, args[0].y];
    }
    if (data.length === 0) {
      data = [0, 0];
    } else if (data.length !== 2) {
      throw new Error("Invalid arguments");
    }
    QmlWeb.createProperties(_this10, {
      x: { type: "real", initialValue: data[0] },
      y: { type: "real", initialValue: data[1] }
    });
    return _this10;
  }

  _createClass(QVector2D, [{
    key: "toString",
    value: function toString() {
      return _get(QVector2D.prototype.__proto__ || Object.getPrototypeOf(QVector2D.prototype), "$toString", this).call(this, this.x, this.y);
    }
  }, {
    key: "dotProduct",
    value: function dotProduct(a) {
      if (a instanceof QVector2D) {
        return a.x * this.x + a.y * this.y;
      }
      return 0;
    }
  }, {
    key: "times",
    value: function times(a) {
      if (a instanceof QVector2D) {
        return new QVector2D(this.x * a.x, this.y * a.y);
      }
      return new QVector2D(this.x * a, this.y * a);
    }
  }, {
    key: "plus",
    value: function plus(a) {
      if (a instanceof QVector2D) {
        return new QVector2D(this.x + a.x, this.y + a.y);
      }
      return new QVector2D(this.x, this.y);
    }
  }, {
    key: "minus",
    value: function minus(a) {
      if (a instanceof QVector2D) {
        return new QVector2D(this.x - a.x, this.y - a.y);
      }
      return new QVector2D(this.x, this.y);
    }
  }, {
    key: "normalized",
    value: function normalized() {
      var length = this.length();
      return this.times(1 / (length === 0 ? 1 : length));
    }
  }, {
    key: "length",
    value: function length() {
      return Math.sqrt(this.dotProduct(this));
    }
  }, {
    key: "toVector3d",
    value: function toVector3d() {
      return new QmlWeb.QVector3D(this.x, this.y, 0);
    }
  }, {
    key: "toVector4d",
    value: function toVector4d() {
      return new QmlWeb.QVector4D(this.x, this.y, 0, 0);
    }
  }, {
    key: "fuzzyEquals",
    value: function fuzzyEquals(a) {
      var epsilon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.00001;

      return [this.x - a.x, this.y - a.y].every(function (delta) {
        return Math.abs(delta) <= epsilon;
      });
    }
  }]);

  return QVector2D;
}(QmlWeb.QObject);

QVector2D.nonNullableType = true;
QVector2D.requireConstructor = true;


QmlWeb.QVector2D = QVector2D;

var QVector3D = function (_QmlWeb$QObject8) {
  _inherits(QVector3D, _QmlWeb$QObject8);

  function QVector3D() {
    _classCallCheck(this, QVector3D);

    var _this11 = _possibleConstructorReturn(this, (QVector3D.__proto__ || Object.getPrototypeOf(QVector3D)).call(this));

    for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      args[_key8] = arguments[_key8];
    }

    var data = args;
    if (args.length === 1 && typeof args[0] === "string") {
      data = args[0].split(",").map(function (x) {
        return parseFloat(x.trim(), 10);
      });
      if (data.length !== 3) data = [];
    } else if (args.length === 1 && args[0] instanceof QVector3D) {
      data = [args[0].x, args[0].y, args[0].z];
    }
    if (data.length === 0) {
      data = [0, 0, 0];
    } else if (data.length !== 3) {
      throw new Error("Invalid arguments");
    }
    QmlWeb.createProperties(_this11, {
      x: { type: "real", initialValue: data[0] },
      y: { type: "real", initialValue: data[1] },
      z: { type: "real", initialValue: data[2] }
    });
    return _this11;
  }

  _createClass(QVector3D, [{
    key: "toString",
    value: function toString() {
      return _get(QVector3D.prototype.__proto__ || Object.getPrototypeOf(QVector3D.prototype), "$toString", this).call(this, this.x, this.y, this.z);
    }
  }, {
    key: "crossProduct",
    value: function crossProduct(a) {
      if (a instanceof QVector3D) {
        return new QVector3D(this.y * a.z - this.z * a.y, this.z * a.x - this.x * a.z, this.x * a.y - this.y * a.x);
      }
      return new QVector3D();
    }
  }, {
    key: "dotProduct",
    value: function dotProduct(a) {
      if (a instanceof QVector3D) {
        return a.x * this.x + a.y * this.y + a.z * this.z;
      }
      return 0;
    }
  }, {
    key: "times",
    value: function times(a) {
      if (a instanceof QmlWeb.QMatrix4x4) {
        var v = new QmlWeb.QVector4D(this.x, this.y, this.z, 1).times(a);
        return new QVector3D(v.x / v.w, v.y / v.w, v.z / v.w);
      }
      if (a instanceof QVector3D) {
        return new QVector3D(this.x * a.x, this.y * a.y, this.z * a.z);
      }
      return new QVector3D(this.x * a, this.y * a, this.z * a);
    }
  }, {
    key: "plus",
    value: function plus(a) {
      if (a instanceof QVector3D) {
        return new QVector3D(this.x + a.x, this.y + a.y, this.z + a.z);
      }
      return new QVector3D(this.x, this.y, this.z);
    }
  }, {
    key: "minus",
    value: function minus(a) {
      if (a instanceof QVector3D) {
        return new QVector3D(this.x - a.x, this.y - a.y, this.z - a.z);
      }
      return new QVector3D(this.x, this.y, this.z);
    }
  }, {
    key: "normalized",
    value: function normalized() {
      var length = this.length();
      return this.times(1 / (length === 0 ? 1 : length));
    }
  }, {
    key: "length",
    value: function length() {
      return Math.sqrt(this.dotProduct(this));
    }
  }, {
    key: "toVector2d",
    value: function toVector2d() {
      return new QmlWeb.QVector2D(this.x, this.y);
    }
  }, {
    key: "toVector4d",
    value: function toVector4d() {
      return new QmlWeb.QVector4D(this.x, this.y, this.z, 0);
    }
  }, {
    key: "fuzzyEquals",
    value: function fuzzyEquals(a) {
      var epsilon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.00001;

      return [this.x - a.x, this.y - a.y, this.z - a.z].every(function (delta) {
        return Math.abs(delta) <= epsilon;
      });
    }
  }]);

  return QVector3D;
}(QmlWeb.QObject);

QVector3D.nonNullableType = true;
QVector3D.requireConstructor = true;


QmlWeb.QVector3D = QVector3D;

var QVector4D = function (_QmlWeb$QObject9) {
  _inherits(QVector4D, _QmlWeb$QObject9);

  function QVector4D() {
    _classCallCheck(this, QVector4D);

    var _this12 = _possibleConstructorReturn(this, (QVector4D.__proto__ || Object.getPrototypeOf(QVector4D)).call(this));

    for (var _len9 = arguments.length, args = Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      args[_key9] = arguments[_key9];
    }

    var data = args;
    if (args.length === 1 && typeof args[0] === "string") {
      data = args[0].split(",").map(function (x) {
        return parseFloat(x.trim(), 10);
      });
      if (data.length !== 4) data = [];
    } else if (args.length === 1 && args[0] instanceof QVector4D) {
      data = [args[0].x, args[0].y, args[0].z, args[0].w];
    }
    if (data.length === 0) {
      data = [0, 0, 0, 0];
    } else if (data.length !== 4) {
      throw new Error("Invalid arguments");
    }
    QmlWeb.createProperties(_this12, {
      x: { type: "real", initialValue: data[0] },
      y: { type: "real", initialValue: data[1] },
      z: { type: "real", initialValue: data[2] },
      w: { type: "real", initialValue: data[3] }
    });
    return _this12;
  }

  _createClass(QVector4D, [{
    key: "toString",
    value: function toString() {
      return _get(QVector4D.prototype.__proto__ || Object.getPrototypeOf(QVector4D.prototype), "$toString", this).call(this, this.x, this.y, this.z, this.w);
    }
  }, {
    key: "dotProduct",
    value: function dotProduct(a) {
      if (a instanceof QVector4D) {
        return a.x * this.x + a.y * this.y + a.z * this.z + a.w * this.w;
      }
      return 0;
    }
  }, {
    key: "times",
    value: function times(a) {
      if (a instanceof QmlWeb.QMatrix4x4) {
        var t = this;
        return new QVector4D(t.x * a.m11 + t.y * a.m21 + t.z * a.m31 + t.w * a.m41, t.x * a.m12 + t.y * a.m22 + t.z * a.m32 + t.w * a.m42, t.x * a.m13 + t.y * a.m23 + t.z * a.m33 + t.w * a.m43, t.x * a.m14 + t.y * a.m24 + t.z * a.m34 + t.w * a.m44);
      }
      if (a instanceof QVector4D) {
        var _t2 = this;
        return new QVector4D(_t2.x * a.x, _t2.y * a.y, _t2.z * a.z, _t2.w * a.w);
      }
      return new QVector4D(this.x * a, this.y * a, this.z * a, this.w * a);
    }
  }, {
    key: "plus",
    value: function plus(a) {
      if (a instanceof QVector4D) {
        var t = this;
        return new QVector4D(t.x + a.x, t.y + a.y, t.z + a.z, t.w + a.w);
      }
      return new QVector4D(this.x, this.y, this.z, this.w);
    }
  }, {
    key: "minus",
    value: function minus(a) {
      if (a instanceof QVector4D) {
        var t = this;
        return new QVector4D(t.x - a.x, t.y - a.y, t.z - a.z, t.w - a.w);
      }
      return new QVector4D(this.x, this.y, this.z, this.w);
    }
  }, {
    key: "normalized",
    value: function normalized() {
      var length = this.length();
      return this.times(1 / (length === 0 ? 1 : length));
    }
  }, {
    key: "length",
    value: function length() {
      return Math.sqrt(this.dotProduct(this));
    }
  }, {
    key: "toVector2d",
    value: function toVector2d() {
      return new QmlWeb.QVector2D(this.x, this.y);
    }
  }, {
    key: "toVector3d",
    value: function toVector3d() {
      return new QmlWeb.QVector3D(this.x, this.y, this.z);
    }
  }, {
    key: "fuzzyEquals",
    value: function fuzzyEquals(a) {
      var epsilon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.00001;

      return [this.x - a.x, this.y - a.y, this.z - a.z, this.w - a.w].every(function (delta) {
        return Math.abs(delta) <= epsilon;
      });
    }
  }]);

  return QVector4D;
}(QmlWeb.QObject);

QVector4D.nonNullableType = true;
QVector4D.requireConstructor = true;


QmlWeb.QVector4D = QVector4D;

var Signal = function () {
  function Signal() {
    var _this13 = this;

    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Signal);

    this.connectedSlots = [];
    this.obj = options.obj;
    this.options = options;

    this.signal = function () {
      return _this13.execute.apply(_this13, arguments);
    };
    this.signal.parameters = params;
    this.signal.connect = this.connect.bind(this);
    this.signal.disconnect = this.disconnect.bind(this);
    this.signal.isConnected = this.isConnected.bind(this);

    // TODO Fix Keys that don't have an obj for the signal
    if (this.obj && this.obj.$signals !== undefined) {
      this.obj.$signals.push(this.signal);
    }
  }

  _createClass(Signal, [{
    key: "execute",
    value: function execute() {
      QmlWeb.QMLProperty.pushEvalStack();

      for (var _len10 = arguments.length, args = Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        args[_key10] = arguments[_key10];
      }

      for (var i in this.connectedSlots) {
        var desc = this.connectedSlots[i];
        if (desc.type & Signal.QueuedConnection) {
          Signal.$addQueued(desc, args);
        } else {
          Signal.$execute(desc, args);
        }
      }
      QmlWeb.QMLProperty.popEvalStack();
    }
  }, {
    key: "connect",
    value: function connect() {
      var type = Signal.AutoConnection;

      for (var _len11 = arguments.length, args = Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
        args[_key11] = arguments[_key11];
      }

      if (typeof args[args.length - 1] === "number") {
        type = args.pop();
      }
      if (type & Signal.UniqueConnection) {
        if (this.isConnected.apply(this, args)) {
          return;
        }
      }
      if (args.length === 1) {
        this.connectedSlots.push({ thisObj: global, slot: args[0], type: type });
      } else if (typeof args[1] === "string" || args[1] instanceof String) {
        if (args[0].$tidyupList && args[0] !== this.obj) {
          args[0].$tidyupList.push(this.signal);
        }
        var slot = args[0][args[1]];
        this.connectedSlots.push({ thisObj: args[0], slot: slot, type: type });
      } else {
        if (args[0].$tidyupList && (!this.obj || args[0] !== this.obj && args[0] !== this.obj.$parent)) {
          args[0].$tidyupList.push(this.signal);
        }
        this.connectedSlots.push({ thisObj: args[0], slot: args[1], type: type });
      }

      // Notify object of connect
      if (this.options.obj && this.options.obj.$connectNotify) {
        this.options.obj.$connectNotify(this.options);
      }
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      for (var _len12 = arguments.length, args = Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
        args[_key12] = arguments[_key12];
      }

      // type meaning:
      //  1 = function, 2 = string
      //  3 = object with string method,  4 = object with function
      // No args means disconnect everything connected to this signal
      var callType = args.length === 1 ? args[0] instanceof Function ? 1 : 2 : typeof args[1] === "string" || args[1] instanceof String ? 3 : 4;
      for (var i = 0; i < this.connectedSlots.length; i++) {
        var _connectedSlots$i = this.connectedSlots[i],
            slot = _connectedSlots$i.slot,
            thisObj = _connectedSlots$i.thisObj;

        if (args.length === 0 || callType === 1 && slot === args[0] || callType === 2 && thisObj === args[0] || callType === 3 && thisObj === args[0] && slot === args[0][args[1]] || thisObj === args[0] && slot === args[1]) {
          if (thisObj) {
            var index = thisObj.$tidyupList.indexOf(this.signal);
            if (index >= 0) {
              thisObj.$tidyupList.splice(index, 1);
            }
          }
          this.connectedSlots.splice(i, 1);
          // We have removed an item from the list so the indexes shifted one
          // backwards
          i--;
        }
      }

      // Notify object of disconnect
      if (this.options.obj && this.options.obj.$disconnectNotify) {
        this.options.obj.$disconnectNotify(this.options);
      }
    }
  }, {
    key: "isConnected",
    value: function isConnected() {
      for (var _len13 = arguments.length, args = Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
        args[_key13] = arguments[_key13];
      }

      var callType = args.length === 1 ? 1 : typeof args[1] === "string" || args[1] instanceof String ? 2 : 3;
      for (var i in this.connectedSlots) {
        var _connectedSlots$i2 = this.connectedSlots[i],
            slot = _connectedSlots$i2.slot,
            thisObj = _connectedSlots$i2.thisObj;

        if (callType === 1 && slot === args[0] || callType === 2 && thisObj === args[0] && slot === args[0][args[1]] || thisObj === args[0] && slot === args[1]) {
          return true;
        }
      }
      return false;
    }
  }], [{
    key: "signal",
    value: function signal() {
      for (var _len14 = arguments.length, args = Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
        args[_key14] = arguments[_key14];
      }

      return new (Function.prototype.bind.apply(Signal, [null].concat(args)))().signal;
    }
  }, {
    key: "$execute",
    value: function $execute(desc, args) {
      try {
        desc.slot.apply(desc.thisObj, args);
      } catch (err) {
        console.error("Signal slot error:", err.message, err, Function.prototype.toString.call(desc.slot));
      }
    }
  }, {
    key: "$addQueued",
    value: function $addQueued(desc, args) {
      if (Signal.$queued.length === 0) {
        if (global.setImmediate) {
          global.setImmediate(Signal.$executeQueued);
        } else {
          global.setTimeout(Signal.$executeQueued, 0);
        }
      }
      Signal.$queued.push([desc, args]);
    }
  }, {
    key: "$executeQueued",
    value: function $executeQueued() {
      // New queued signals should be executed on next tick of the event loop
      var queued = Signal.$queued;
      Signal.$queued = [];

      QmlWeb.QMLProperty.pushEvalStack();
      for (var i in queued) {
        Signal.$execute.apply(Signal, _toConsumableArray(queued[i]));
      }
      QmlWeb.QMLProperty.popEvalStack();
    }
  }]);

  return Signal;
}();

Signal.$queued = [];
Signal.AutoConnection = 0;
Signal.DirectConnection = 1;
Signal.QueuedConnection = 2;
Signal.UniqueConnection = 128;


QmlWeb.Signal = Signal;

var Qt = {
  openUrlExternally: function openUrlExternally(url) {
    var page = window.open(url, "_blank");
    page.focus();
  },
  // Load file, parse and construct as Component (.qml)
  createComponent: function createComponent(name) {
    var engine = QmlWeb.engine;

    var file = engine.$resolvePath(name);

    // If "name" was a full URL, "file" will be equivalent to name and this
    // will try and load the Component from the full URL, otherwise, this
    // doubles as checking for the file in the current directory.
    var tree = engine.loadComponent(file);

    // If the Component is not found, and it is not a URL, look for "name" in
    // this context's importSearchPaths
    if (!tree) {
      var nameIsUrl = engine.$parseURI(name) !== undefined;
      if (!nameIsUrl) {
        var moreDirs = engine.importSearchPaths(QmlWeb.executionContext.importContextId);
        for (var i = 0; i < moreDirs.length; i++) {
          file = "" + moreDirs[i] + name;
          tree = engine.loadComponent(file);
          if (tree) break;
        }
      }
    }

    if (!tree) {
      return undefined;
    }

    var QMLComponent = QmlWeb.getConstructor("QtQml", "2.0", "Component");
    var component = new QMLComponent({
      object: tree,
      context: QmlWeb.executionContext
    });
    component.$basePath = engine.extractBasePath(file);
    component.$imports = tree.$imports;
    component.$file = file; // just for debugging

    engine.loadImports(tree.$imports, component.$basePath, component.importContextId);

    return component;
  },

  createQmlObject: function createQmlObject(src, parent, file) {
    var tree = QmlWeb.parseQML(src, file);

    // Create and initialize objects

    var QMLComponent = QmlWeb.getConstructor("QtQml", "2.0", "Component");
    var component = new QMLComponent({
      object: tree,
      parent: parent,
      context: QmlWeb.executionContext
    });

    var engine = QmlWeb.engine;
    engine.loadImports(tree.$imports, undefined, component.importContextId);

    var resolvedFile = file || Qt.resolvedUrl("createQmlObject_function");
    component.$basePath = engine.extractBasePath(resolvedFile);
    component.$imports = tree.$imports; // for later use
    // not just for debugging, but for basepath too, see above
    component.$file = resolvedFile;

    var obj = component.createObject(parent);

    var QMLOperationState = QmlWeb.QMLOperationState;
    if (engine.operationState !== QMLOperationState.Init && engine.operationState !== QMLOperationState.Idle) {
      // We don't call those on first creation, as they will be called
      // by the regular creation-procedures at the right time.
      engine.$initializePropertyBindings();

      engine.callCompletedSignals();
    }

    return obj;
  },

  // Returns url resolved relative to the URL of the caller.
  // http://doc.qt.io/qt-5/qml-qtqml-qt.html#resolvedUrl-method
  resolvedUrl: function resolvedUrl(url) {
    return QmlWeb.qmlUrl(url);
  },

  // Basic QML types constructors
  point: function point() {
    for (var _len15 = arguments.length, args = Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
      args[_key15] = arguments[_key15];
    }

    return new (Function.prototype.bind.apply(QmlWeb.QPointF, [null].concat(args)))();
  },
  rect: function rect() {
    for (var _len16 = arguments.length, args = Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
      args[_key16] = arguments[_key16];
    }

    return new (Function.prototype.bind.apply(QmlWeb.QRectF, [null].concat(args)))();
  },
  size: function size() {
    for (var _len17 = arguments.length, args = Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {
      args[_key17] = arguments[_key17];
    }

    return new (Function.prototype.bind.apply(QmlWeb.QSizeF, [null].concat(args)))();
  },
  vector2d: function vector2d() {
    for (var _len18 = arguments.length, args = Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {
      args[_key18] = arguments[_key18];
    }

    return new (Function.prototype.bind.apply(QmlWeb.QVector2D, [null].concat(args)))();
  },
  vector3d: function vector3d() {
    for (var _len19 = arguments.length, args = Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {
      args[_key19] = arguments[_key19];
    }

    return new (Function.prototype.bind.apply(QmlWeb.QVector3D, [null].concat(args)))();
  },
  vector4d: function vector4d() {
    for (var _len20 = arguments.length, args = Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {
      args[_key20] = arguments[_key20];
    }

    return new (Function.prototype.bind.apply(QmlWeb.QVector4D, [null].concat(args)))();
  },
  quaternion: function quaternion() {
    for (var _len21 = arguments.length, args = Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {
      args[_key21] = arguments[_key21];
    }

    return new (Function.prototype.bind.apply(QmlWeb.QQuaternion, [null].concat(args)))();
  },
  matrix4x4: function matrix4x4() {
    for (var _len22 = arguments.length, args = Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {
      args[_key22] = arguments[_key22];
    }

    return new (Function.prototype.bind.apply(QmlWeb.QMatrix4x4, [null].concat(args)))();
  },

  // Colors
  rgba: function rgba() {
    var _QmlWeb$QColor;

    return (_QmlWeb$QColor = QmlWeb.QColor).rgba.apply(_QmlWeb$QColor, arguments);
  },
  hsla: function hsla() {
    var _QmlWeb$QColor2;

    return (_QmlWeb$QColor2 = QmlWeb.QColor).hsla.apply(_QmlWeb$QColor2, arguments);
  },
  hsva: function hsva() {
    var _QmlWeb$QColor3;

    return (_QmlWeb$QColor3 = QmlWeb.QColor).hsva.apply(_QmlWeb$QColor3, arguments);
  },
  colorEqual: function colorEqual() {
    var _QmlWeb$QColor4;

    return (_QmlWeb$QColor4 = QmlWeb.QColor).equal.apply(_QmlWeb$QColor4, arguments);
  },
  darker: function darker() {
    var _QmlWeb$QColor5;

    return (_QmlWeb$QColor5 = QmlWeb.QColor).darker.apply(_QmlWeb$QColor5, arguments);
  },
  lighter: function lighter() {
    var _QmlWeb$QColor6;

    return (_QmlWeb$QColor6 = QmlWeb.QColor).lighter.apply(_QmlWeb$QColor6, arguments);
  },

  include: function include(path) {
    var engine = QmlWeb.engine;

    var uri = engine.$resolvePath(path);

    /* Handle recursive includes */
    if (QmlWeb.executionContext.$qmlJsIncludes === undefined) {
      QmlWeb.executionContext.$qmlJsIncludes = [];
    }

    if (QmlWeb.executionContext.$qmlJsIncludes.indexOf(uri) >= 0) {
      return;
    }

    QmlWeb.executionContext.$qmlJsIncludes.push(uri);

    var js = engine.loadJS(uri);

    if (!js) {
      console.error("Unable to load JavaScript module:", uri, path);
      return;
    }

    QmlWeb.importJavascriptInContext(js, QmlWeb.executionContext);
  },


  platform: {
    os: "qmlweb"
  },

  // Buttons masks
  LeftButton: 1,
  RightButton: 2,
  MiddleButton: 4,
  // Modifiers masks
  NoModifier: 0,
  ShiftModifier: 1,
  ControlModifier: 2,
  AltModifier: 4,
  MetaModifier: 8,
  KeypadModifier: 16, // Note: Not available in web
  // Layout directions
  LeftToRight: 0,
  RightToLeft: 1,
  // Orientations
  Vertical: 0,
  Horizontal: 1,
  // Keys
  Key_Escape: 27,
  Key_Tab: 9,
  Key_Backtab: 245,
  Key_Backspace: 8,
  Key_Return: 13,
  Key_Enter: 13,
  Key_Insert: 45,
  Key_Delete: 46,
  Key_Pause: 19,
  Key_Print: 42,
  Key_SysReq: 0,
  Key_Clear: 12,
  Key_Home: 36,
  Key_End: 35,
  Key_Left: 37,
  Key_Up: 38,
  Key_Right: 39,
  Key_Down: 40,
  Key_PageUp: 33,
  Key_PageDown: 34,
  Key_Shift: 16,
  Key_Control: 17,
  Key_Meta: 91,
  Key_Alt: 18,
  Key_AltGr: 0,
  Key_CapsLock: 20,
  Key_NumLock: 144,
  Key_ScrollLock: 145,
  Key_F1: 112, Key_F2: 113, Key_F3: 114, Key_F4: 115, Key_F5: 116, Key_F6: 117,
  Key_F7: 118, Key_F8: 119, Key_F9: 120, Key_F10: 121, Key_F11: 122,
  Key_F12: 123, Key_F13: 124, Key_F14: 125, Key_F15: 126, Key_F16: 127,
  Key_F17: 128, Key_F18: 129, Key_F19: 130, Key_F20: 131, Key_F21: 132,
  Key_F22: 133, Key_F23: 134, Key_F24: 135,
  Key_F25: 0, Key_F26: 0, Key_F27: 0, Key_F28: 0, Key_F29: 0, Key_F30: 0,
  Key_F31: 0, Key_F32: 0, Key_F33: 0, Key_F34: 0, Key_F35: 0,
  Key_Super_L: 0,
  Key_Super_R: 0,
  Key_Menu: 0,
  Key_Hyper_L: 0,
  Key_Hyper_R: 0,
  Key_Help: 6,
  Key_Direction_L: 0,
  Key_Direction_R: 0,
  Key_Space: 32,
  Key_Any: 32,
  Key_Exclam: 161,
  Key_QuoteDbl: 162,
  Key_NumberSign: 163,
  Key_Dollar: 164,
  Key_Percent: 165,
  Key_Ampersant: 166,
  Key_Apostrophe: 222,
  Key_ParenLeft: 168,
  Key_ParenRight: 169,
  Key_Asterisk: 170,
  Key_Plus: 171,
  Key_Comma: 188,
  Key_Minus: 173,
  Key_Period: 190,
  Key_Slash: 191,
  Key_0: 48, Key_1: 49, Key_2: 50, Key_3: 51, Key_4: 52,
  Key_5: 53, Key_6: 54, Key_7: 55, Key_8: 56, Key_9: 57,
  Key_Colon: 58,
  Key_Semicolon: 59,
  Key_Less: 60,
  Key_Equal: 61,
  Key_Greater: 62,
  Key_Question: 63,
  Key_At: 64,
  Key_A: 65, Key_B: 66, Key_C: 67, Key_D: 68, Key_E: 69, Key_F: 70, Key_G: 71,
  Key_H: 72, Key_I: 73, Key_J: 74, Key_K: 75, Key_L: 76, Key_M: 77, Key_N: 78,
  Key_O: 79, Key_P: 80, Key_Q: 81, Key_R: 82, Key_S: 83, Key_T: 84, Key_U: 85,
  Key_V: 86, Key_W: 87, Key_X: 88, Key_Y: 89, Key_Z: 90,
  Key_BracketLeft: 219,
  Key_Backslash: 220,
  Key_BracketRight: 221,
  Key_AsciiCircum: 160,
  Key_Underscore: 167,
  Key_QuoteLeft: 0,
  Key_BraceLeft: 174,
  Key_Bar: 172,
  Key_BraceRight: 175,
  Key_AsciiTilde: 176,
  Key_Back: 0,
  Key_Forward: 0,
  Key_Stop: 0,
  Key_VolumeDown: 182,
  Key_VolumeUp: 183,
  Key_VolumeMute: 181,
  Key_multiply: 106,
  Key_add: 107,
  Key_substract: 109,
  Key_divide: 111,
  Key_News: 0,
  Key_OfficeHome: 0,
  Key_Option: 0,
  Key_Paste: 0,
  Key_Phone: 0,
  Key_Calendar: 0,
  Key_Reply: 0,
  Key_Reload: 0,
  Key_RotateWindows: 0,
  Key_RotationPB: 0,
  Key_RotationKB: 0,
  Key_Save: 0,
  Key_Send: 0,
  Key_Spell: 0,
  Key_SplitScreen: 0,
  Key_Support: 0,
  Key_TaskPane: 0,
  Key_Terminal: 0,
  Key_Tools: 0,
  Key_Travel: 0,
  Key_Video: 0,
  Key_Word: 0,
  Key_Xfer: 0,
  Key_ZoomIn: 0,
  Key_ZoomOut: 0,
  Key_Away: 0,
  Key_Messenger: 0,
  Key_WebCam: 0,
  Key_MailForward: 0,
  Key_Pictures: 0,
  Key_Music: 0,
  Key_Battery: 0,
  Key_Bluetooth: 0,
  Key_WLAN: 0,
  Key_UWB: 0,
  Key_AudioForward: 0,
  Key_AudioRepeat: 0,
  Key_AudioRandomPlay: 0,
  Key_Subtitle: 0,
  Key_AudioCycleTrack: 0,
  Key_Time: 0,
  Key_Hibernate: 0,
  Key_View: 0,
  Key_TopMenu: 0,
  Key_PowerDown: 0,
  Key_Suspend: 0,
  Key_ContrastAdjust: 0,
  Key_MediaLast: 0,
  Key_unknown: -1,
  Key_Call: 0,
  Key_Camera: 0,
  Key_CameraFocus: 0,
  Key_Context1: 0,
  Key_Context2: 0,
  Key_Context3: 0,
  Key_Context4: 0,
  Key_Flip: 0,
  Key_Hangup: 0,
  Key_No: 0,
  Key_Select: 93,
  Key_Yes: 0,
  Key_ToggleCallHangup: 0,
  Key_VoiceDial: 0,
  Key_LastNumberRedial: 0,
  Key_Execute: 43,
  Key_Printer: 42,
  Key_Play: 250,
  Key_Sleep: 95,
  Key_Zoom: 251,
  Key_Cancel: 3,
  // Align
  AlignLeft: 0x0001,
  AlignRight: 0x0002,
  AlignHCenter: 0x0004,
  AlignJustify: 0x0008,
  AlignTop: 0x0020,
  AlignBottom: 0x0040,
  AlignVCenter: 0x0080,
  AlignCenter: 0x0084,
  AlignBaseline: 0x0100,
  AlignAbsolute: 0x0010,
  AlignLeading: 0x0001,
  AlignTrailing: 0x0002,
  AlignHorizontal_Mask: 0x001f,
  AlignVertical_Mask: 0x01e0,
  // Screen
  PrimaryOrientation: 0,
  PortraitOrientation: 1,
  LandscapeOrientation: 2,
  InvertedPortraitOrientation: 4,
  InvertedLandscapeOrientation: 8,
  // CursorShape
  ArrowCursor: 0,
  UpArrowCursor: 1,
  CrossCursor: 2,
  WaitCursor: 3,
  IBeamCursor: 4,
  SizeVerCursor: 5,
  SizeHorCursor: 6,
  SizeBDiagCursor: 7,
  SizeFDiagCursor: 8,
  SizeAllCursor: 9,
  BlankCursor: 10,
  SplitVCursor: 11,
  SplitHCursor: 12,
  PointingHandCursor: 13,
  ForbiddenCursor: 14,
  WhatsThisCursor: 15,
  BusyCursor: 16,
  OpenHandCursor: 17,
  ClosedHandCursor: 18,
  DragCopyCursor: 19,
  DragMoveCursor: 20,
  DragLinkCursor: 21,
  LastCursor: 21, //DragLinkCursor,
  BitmapCursor: 24,
  CustomCursor: 25,
  // ScrollBar Policy
  ScrollBarAsNeeded: 0,
  ScrollBarAlwaysOff: 1,
  ScrollBarAlwaysOn: 2
};

QmlWeb.Qt = Qt;

var QMLBinding = function () {
  /**
   * Create QML binding.
   * @param {Variant} val Sourcecode or function representing the binding
   * @param {Array} tree Parser tree of the binding
   * @return {Object} Object representing the binding
   */
  function QMLBinding(val, tree) {
    _classCallCheck(this, QMLBinding);

    // this.isFunction states whether the binding is a simple js statement or a
    // function containing a return statement. We decide this on whether it is a
    // code block or not. If it is, we require a return statement. If it is a
    // code block it could though also be a object definition, so we need to
    // check that as well (it is, if the content is labels).
    this.isFunction = tree && tree[0] === "block" && tree[1][0] && tree[1][0][0] !== "label";
    this.src = val;
    this.compiled = false;
  }

  _createClass(QMLBinding, [{
    key: "toJSON",
    value: function toJSON() {
      return {
        src: this.src,
        deps: JSON.stringify(this.deps),
        tree: JSON.stringify(this.tree)
      };
    }
  }, {
    key: "eval",
    value: function _eval(object, context, basePath) {
      QmlWeb.executionContext = context;
      if (basePath) {
        QmlWeb.engine.$basePath = basePath;
      }
      // .call is needed for `this` support
      return this.impl.call(object, object, context);
    }

    /**
     * Compile binding. Afterwards you may call binding.eval to evaluate.
     */

  }, {
    key: "compile",
    value: function compile() {
      this.src = this.src.trim();
      this.impl = QMLBinding.bindSrc(this.src, this.isFunction);
      this.compiled = true;
    }
  }], [{
    key: "bindSrc",
    value: function bindSrc(src, isFunction) {
      return new Function("__executionObject", "__executionContext", "\n      with(QmlWeb) with(__executionContext) with(__executionObject) {\n        " + (isFunction ? "" : "return") + " " + src + "\n      }\n    ");
    }
  }]);

  return QMLBinding;
}();

QmlWeb.QMLBinding = QMLBinding;

function QMLBoolean(val) {
  return !!val;
}
QMLBoolean.plainType = true;
QmlWeb.qmlBoolean = QMLBoolean;

// There can only be one running QMLEngine.
// This variable points to the currently running engine.
QmlWeb.engine = null;

QmlWeb.useShadowDom = false;

var geometryProperties = ["width", "height", "fill", "x", "y", "left", "right", "top", "bottom"];

// QML engine. EXPORTED.

var QMLEngine = function () {
  function QMLEngine(element) {
    _classCallCheck(this, QMLEngine);

    //----------Public Members----------

    this.fps = 60;
    // Math.floor, causes bugs to timing?
    this.$interval = Math.floor(1000 / this.fps);
    this.dom = element || document.body;

    // Target for the DOM children
    this.domTarget = this.dom;
    if (QmlWeb.useShadowDom && this.dom.attachShadow) {
      this.domTarget = this.dom.attachShadow({ mode: "open" });
    }

    // Cached component trees (post-QmlWeb.convertToEngine)
    this.components = {};

    // Cached parsed JS files (post-QmlWeb.jsparse)
    this.js = {};

    // List of Component.completed signals
    this.completedSignals = [];

    // Current operation state of the engine (Idle, init, etc.)
    this.operationState = 1;

    // List of properties whose values are bindings. For internal use only.
    this.bindedProperties = [];

    // List of operations to perform later after init. For internal use only.
    this.pendingOperations = [];

    // Root object of the engine
    this.rootObject = null;

    // Base path of qml engine (used for resource loading)
    this.$basePath = "";

    // Module import paths overrides
    this.userAddedModulePaths = {};

    // Stores data for setImportPathList(), importPathList(), and addImportPath
    this.userAddedImportPaths = [];

    //----------Private Members---------

    // Ticker resource id and ticker callbacks
    this._tickers = [];
    this._lastTick = Date.now();

    // Callbacks for stopping or starting the engine
    this._whenStop = [];
    this._whenStart = [];

    // Keyboard management
    this.$initKeyboard();

    //----------Construct----------
  }

  //---------- Public Methods ----------

  // Start the engine


  _createClass(QMLEngine, [{
    key: "start",
    value: function start() {
      QmlWeb.engine = this;
      var QMLOperationState = QmlWeb.QMLOperationState;
      if (this.operationState !== QMLOperationState.Running) {
        this.operationState = QMLOperationState.Running;
        this._tickerId = setInterval(this._tick.bind(this), this.$interval);
        this._whenStart.forEach(function (callback) {
          return callback();
        });
      }
    }

    // Stop the engine

  }, {
    key: "stop",
    value: function stop() {
      var QMLOperationState = QmlWeb.QMLOperationState;
      if (this.operationState === QMLOperationState.Running) {
        clearInterval(this._tickerId);
        this.operationState = QMLOperationState.Idle;
        this._whenStop.forEach(function (callback) {
          return callback();
        });
      }
    }

    // eslint-disable-next-line max-len
    /** from http://docs.closure-library.googlecode.com/git/local_closure_goog_uri_uri.js.source.html
     *
     * Removes dot segments in given path component, as described in
     * RFC 3986, section 5.2.4.
     *
     * @param {string} path A non-empty path component.
     * @return {string} Path component with removed dot segments.
     */

  }, {
    key: "removeDotSegments",
    value: function removeDotSegments(path) {
      // path.startsWith("/") is not supported in some browsers
      var leadingSlash = path && path[0] === "/";
      var segments = path.split("/");
      var out = [];

      for (var pos = 0; pos < segments.length;) {
        var segment = segments[pos++];

        if (segment === ".") {
          if (leadingSlash && pos === segments.length) {
            out.push("");
          }
        } else if (segment === "..") {
          if (out.length > 1 || out.length === 1 && out[0] !== "") {
            out.pop();
          }
          if (leadingSlash && pos === segments.length) {
            out.push("");
          }
        } else {
          out.push(segment);
          leadingSlash = true;
        }
      }

      return out.join("/");
    }
  }, {
    key: "extractBasePath",
    value: function extractBasePath(file) {
      // work both in url ("/") and windows ("\", from file://d:\test\) notation
      var basePath = file.split(/[/\\]/);
      basePath[basePath.length - 1] = "";
      return basePath.join("/");
    }
  }, {
    key: "extractFileName",
    value: function extractFileName(file) {
      return file.split(/[/\\]/).pop();
    }

    // Load file, parse and construct (.qml or .qml.js)

  }, {
    key: "loadFile",
    value: function loadFile(file) {
      var parentComponent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      // Create an anchor element to get the absolute path from the DOM
      if (!this.$basePathA) {
        this.$basePathA = document.createElement("a");
      }
      this.$basePathA.href = this.extractBasePath(file);
      this.$basePath = this.$basePathA.href;
      var fileName = this.extractFileName(file);
      var tree = this.loadComponent(this.$resolvePath(fileName));
      return this.loadQMLTree(tree, parentComponent, file);
    }

    // parse and construct qml
    // file is not required; only for debug purposes
    // This function is only used by the QmlWeb tests

  }, {
    key: "loadQML",
    value: function loadQML(src) {
      var parentComponent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var file = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

      return this.loadQMLTree(QmlWeb.parseQML(src, file), parentComponent, file);
    }
  }, {
    key: "loadQMLTree",
    value: function loadQMLTree(tree) {
      var parentComponent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var file = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

      QmlWeb.engine = this;

      // Create and initialize objects
      var QMLComponent = QmlWeb.getConstructor("QtQml", "2.0", "Component");
      var component = new QMLComponent({
        object: tree,
        parent: parentComponent
      });

      this.loadImports(tree.$imports, undefined, component.importContextId);
      component.$basePath = this.$basePath;
      component.$imports = tree.$imports; // for later use
      component.$file = file; // just for debugging

      this.rootObject = component.$createObject(parentComponent);
      if (this.rootObject.dom) {
        this.domTarget.appendChild(this.rootObject.dom);
      }
      this.$initializePropertyBindings();

      this.start();

      this.firstCallCompleted = false;
      this.callCompletedSignals();
      this.firstCallCompleted = true;

      return component;
    }
  }, {
    key: "rootContext",
    value: function rootContext() {
      return this.rootObject.$context;
    }

    // next 3 methods used in Qt.createComponent for qml files lookup
    // http://doc.qt.io/qt-5/qqmlengine.html#addImportPath

  }, {
    key: "addImportPath",
    value: function addImportPath(dirpath) {
      this.userAddedImportPaths.push(dirpath);
    }

    /* Add this dirpath to be checked for components. This is the result of
     * something like:
     *
     * import "SomeDir/AnotherDirectory"
     *
     * The importContextId ensures it is only accessible from the file in which
     * it was imported. */

  }, {
    key: "addComponentImportPath",
    value: function addComponentImportPath(importContextId, dirpath, qualifier) {
      if (!this.componentImportPaths) {
        this.componentImportPaths = {};
      }
      if (!this.componentImportPaths[importContextId]) {
        this.componentImportPaths[importContextId] = {};
      }

      var paths = this.componentImportPaths[importContextId];

      if (qualifier) {
        if (!paths.qualified) {
          paths.qualified = {};
        }
        paths.qualified[qualifier] = dirpath;
      } else {
        if (!paths.unqualified) {
          paths.unqualified = [];
        }
        paths.unqualified.push(dirpath);
      }
    }
  }, {
    key: "importSearchPaths",
    value: function importSearchPaths(importContextId) {
      if (!this.componentImportPaths) {
        return [];
      }
      var paths = this.componentImportPaths[importContextId];
      if (!paths) {
        return [];
      }
      return paths.unqualified || [];
    }
  }, {
    key: "qualifiedImportPath",
    value: function qualifiedImportPath(importContextId, qualifier) {
      if (!this.componentImportPaths) {
        return "";
      }
      var paths = this.componentImportPaths[importContextId];
      if (!paths || !paths.qualified) {
        return "";
      }
      return paths.qualified[qualifier] || "";
    }
  }, {
    key: "setImportPathList",
    value: function setImportPathList(arrayOfDirs) {
      this.userAddedImportPaths = arrayOfDirs;
    }
  }, {
    key: "importPathList",
    value: function importPathList() {
      return this.userAddedImportPaths;
    }

    // `addModulePath` defines conrete path for module lookup
    // e.g. addModulePath("QtQuick.Controls", "http://example.com/controls")
    // will force system to `import QtQuick.Controls` module from
    // `http://example.com/controls/qmldir`

  }, {
    key: "addModulePath",
    value: function addModulePath(moduleName, dirPath) {
      // Keep the mapping. It will be used in loadImports() function.
      // Remove trailing slash as it required for `readQmlDir`.
      this.userAddedModulePaths[moduleName] = dirPath.replace(/\/$/, "");
    }
  }, {
    key: "registerProperty",
    value: function registerProperty(obj, propName) {
      var dependantProperties = [];
      var value = obj[propName];

      var getter = function getter() {
        var QMLProperty = QmlWeb.QMLProperty;
        if (QMLProperty.evaluatingProperty && dependantProperties.indexOf(QMLProperty.evaluatingProperty) === -1) {
          dependantProperties.push(QMLProperty.evaluatingProperty);
        }
        return value;
      };

      var setter = function setter(newVal) {
        value = newVal;
        for (var i in dependantProperties) {
          dependantProperties[i].update();
        }
      };

      QmlWeb.setupGetterSetter(obj, propName, getter, setter);
    }
  }, {
    key: "loadImports",
    value: function loadImports(importsArray) {
      var currentFileDir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.$basePath;
      var importContextId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

      if (!this.qmldirsContents) {
        this.qmldirsContents = {}; // cache

        // putting initial keys in qmldirsContents - is a hack. We should find a
        // way to explain to qmlweb, is this built-in module or qmldir-style
        // module.
        for (var module in QmlWeb.modules) {
          if (module !== "Main") {
            this.qmldirsContents[module] = {};
          }
        }
      }

      if (!this.qmldirs) {
        this.qmldirs = {}; // resulting components lookup table
      }

      if (!importsArray || importsArray.length === 0) {
        return;
      }

      for (var i = 0; i < importsArray.length; i++) {
        this.loadImport(importsArray[i], currentFileDir, importContextId);
      }
    }
  }, {
    key: "loadImport",
    value: function loadImport(entry, currentFileDir, importContextId) {
      var name = entry[1];
      var alias = entry[3];

      // is it url to remote resource
      var nameIsUrl = name.indexOf("//") === 0 || name.indexOf("://") >= 0;
      // is it a module name, e.g. QtQuick, QtQuick.Controls, etc
      var nameIsQualifiedModuleName = entry[4];
      // is it a js file
      var nameIsJs = name.slice(-3) === ".js";
      // local [relative] dir
      var nameIsDir = !nameIsQualifiedModuleName && !nameIsUrl && !nameIsJs;

      if (nameIsDir) {
        name = this.$resolvePath(name, currentFileDir);
        if (name[name.length - 1] === "/") {
          // remove trailing slash as it required for `readQmlDir`
          name = name.substr(0, name.length - 1);
        }
      }

      var content = this.qmldirsContents[name];
      // check if we have already loaded that qmldir file
      if (!content) {
        if (nameIsQualifiedModuleName && this.userAddedModulePaths[name]) {
          // 1. we have qualified module and user had configured path for that
          // module with this.addModulePath
          content = QmlWeb.readQmlDir(this.userAddedModulePaths[name]);
        } else if (nameIsUrl || nameIsDir) {
          // 2. direct load
          // nameIsUrl => url do not need dirs
          // nameIsDir => already computed full path above
          content = QmlWeb.readQmlDir(name);
        } else if (nameIsJs) {
          // 3. Js file, don't need qmldir
        } else {
          // 4. qt-style lookup for qualified module
          var probableDirs = [currentFileDir].concat(this.importPathList());
          var diredName = name.replace(/\./g, "/");

          for (var k = 0; k < probableDirs.length; k++) {
            var file = probableDirs[k] + diredName;
            content = QmlWeb.readQmlDir(file);
            if (content) {
              break;
            }
          }
        }
        this.qmldirsContents[name] = content;
      }

      /* If there is no qmldir, add these directories to the list of places to
        * search for components (within this import scope). "noqmldir" is
        * inserted into the qmldir cache to avoid future attempts at fetching
        * the qmldir file, but we always need to the call to
        * "addComponentImportPath" for these sorts of directories. */
      if (!content || content === "noqmldir") {
        if (nameIsDir) {
          if (alias) {
            /* Use entry[1] directly, as we don't want to include the
              * basePath, otherwise it gets prepended twice in
              * createComponent. */
            this.addComponentImportPath(importContextId, entry[1] + "/", alias);
          } else {
            this.addComponentImportPath(importContextId, name + "/");
          }
        }

        this.qmldirsContents[name] = "noqmldir";
        return;
      }

      // copy founded externals to global var
      // TODO actually we have to copy it to current component
      for (var attrname in content.externals) {
        var prefix = void 0;
        if (alias) {
          prefix = alias + ".";
        } else {
          prefix = "";
        }
        this.qmldirs[prefix + attrname] = content.externals[attrname];
      }

      // keep already loaded qmldir files
      this.qmldirsContents[name] = content;
    }
  }, {
    key: "size",
    value: function size() {
      return {
        width: this.rootObject.getWidth(),
        height: this.rootObject.getHeight()
      };
    }
  }, {
    key: "focusedElement",
    value: function focusedElement() {
      return this.rootContext().activeFocus;
    }

    //---------- Private Methods ----------

  }, {
    key: "$initKeyboard",
    value: function $initKeyboard() {
      var _this14 = this;

      document.onkeypress = function (e) {
        var focusedElement = _this14.focusedElement();
        var event = QmlWeb.eventToKeyboard(e || window.event);
        var eventName = QmlWeb.keyboardSignals[event.key];

        while (focusedElement && !event.accepted) {
          var backup = focusedElement.$context.event;
          focusedElement.$context.event = event;
          focusedElement.Keys.pressed(event);
          if (eventName) {
            focusedElement.Keys[eventName](event);
          }
          focusedElement.$context.event = backup;
          if (event.accepted) {
            e.preventDefault();
          } else {
            focusedElement = focusedElement.$parent;
          }
        }
      };

      document.onkeyup = function (e) {
        var focusedElement = _this14.focusedElement();
        var event = QmlWeb.eventToKeyboard(e || window.event);

        while (focusedElement && !event.accepted) {
          var backup = focusedElement.$context.event;
          focusedElement.$context.event = event;
          focusedElement.Keys.released(event);
          focusedElement.$context.event = backup;
          if (event.accepted) {
            e.preventDefault();
          } else {
            focusedElement = focusedElement.$parent;
          }
        }
      };
    }
  }, {
    key: "_tick",
    value: function _tick() {
      var now = Date.now();
      var elapsed = now - this._lastTick;
      this._lastTick = now;
      this._tickers.forEach(function (ticker) {
        return ticker(now, elapsed);
      });
    }

    // Load resolved file, parse and construct as Component (.qml)

  }, {
    key: "loadComponent",
    value: function loadComponent(file) {
      if (file in this.components) {
        return this.components[file];
      }

      var uri = this.$parseURI(file);
      if (!uri) {
        return undefined;
      }

      var tree = void 0;
      if (uri.scheme === "qrc://") {
        tree = QmlWeb.qrc[uri.path];
        if (!tree) {
          return undefined;
        }
        // QmlWeb.qrc contains pre-parsed Component objects, but they still need
        // convertToEngine called on them.
        tree = QmlWeb.convertToEngine(tree);
      } else {
        var src = QmlWeb.getUrlContents(file, true);
        if (!src) {
          console.error("QMLEngine.loadComponent: Failed to load:", file);
          return undefined;
        }

        console.log("QMLEngine.loadComponent: Loading file:", file);
        tree = QmlWeb.parseQML(src, file);
      }

      if (!tree) {
        return undefined;
      }

      if (tree.$children.length !== 1) {
        console.error("QMLEngine.loadComponent: Failed to load:", file, ": A QML component must only contain one root element!");
        return undefined;
      }

      tree.$file = file;
      this.components[file] = tree;
      return tree;
    }

    // Load resolved file and parse as JavaScript

  }, {
    key: "loadJS",
    value: function loadJS(file) {
      if (file in this.js) {
        return this.js[file];
      }

      var uri = this.$parseURI(file);
      if (!uri) {
        return undefined;
      }

      var jsData = void 0;
      if (uri.scheme === "qrc://") {
        jsData = QmlWeb.qrc[uri.path];
      } else {
        QmlWeb.loadParser();
        jsData = QmlWeb.jsparse(QmlWeb.getUrlContents(file));
      }

      if (!jsData) {
        return undefined;
      }

      // Remove any ".pragma" statements, as they are not valid JavaScript
      jsData.source = jsData.source.replace(/\.pragma.*(?:\r\n|\r|\n)/, "\n");

      var contextSetter = new Function("$context", "\n      with(QmlWeb) with ($context) {\n        " + jsData.source + "\n      }\n      " + jsData.exports.map(function (sym) {
        return "$context." + sym + " = " + sym + ";";
      }).join("") + "\n    ");

      this.js[file] = contextSetter;

      return contextSetter;
    }
  }, {
    key: "$registerStart",
    value: function $registerStart(f) {
      this._whenStart.push(f);
    }
  }, {
    key: "$registerStop",
    value: function $registerStop(f) {
      this._whenStop.push(f);
    }
  }, {
    key: "$addTicker",
    value: function $addTicker(t) {
      this._tickers.push(t);
    }
  }, {
    key: "$removeTicker",
    value: function $removeTicker(t) {
      var index = this._tickers.indexOf(t);
      if (index !== -1) {
        this._tickers.splice(index, 1);
      }
    }
  }, {
    key: "$initializePropertyBindings",
    value: function $initializePropertyBindings() {
      // Initialize property bindings
      // we use `while`, because $initializePropertyBindings may be called
      // recursive (because of Loader and/or createQmlObject )
      while (this.bindedProperties.length > 0) {
        var property = this.bindedProperties.shift();

        if (!property.binding) {
          // Probably, the binding was overwritten by an explicit value. Ignore.
          continue;
        }

        if (property.needsUpdate) {
          property.update();
        } else if (geometryProperties.indexOf(property.name) >= 0) {
          // It is possible that bindings with these names was already evaluated
          // during eval of other bindings but in that case $updateHGeometry and
          // $updateVGeometry could be blocked during their eval.
          // So we call them explicitly, just in case.
          var obj = property.obj,
              changed = property.changed;

          if (obj.$updateHGeometry && changed.isConnected(obj, obj.$updateHGeometry)) {
            obj.$updateHGeometry(property.val, property.val, property.name);
          }
          if (obj.$updateVGeometry && changed.isConnected(obj, obj.$updateVGeometry)) {
            obj.$updateVGeometry(property.val, property.val, property.name);
          }
        }
      }

      this.$initializeAliasSignals();
    }

    // This parses the full URL into scheme, authority and path

  }, {
    key: "$parseURI",
    value: function $parseURI(uri) {
      var match = uri.match(/^([^/]*?:\/\/)(.*?)(\/.*)$/);
      if (match) {
        return {
          scheme: match[1],
          authority: match[2],
          path: match[3]
        };
      }
      return undefined;
    }

    // Return a path to load the file

  }, {
    key: "$resolvePath",
    value: function $resolvePath(file) {
      var basePath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.$basePath;

      // probably, replace :// with :/ ?
      if (!file || file.indexOf("://") !== -1) {
        return file;
      }

      var schemes = ["data:", "blob:", "about:"];
      for (var i = 0; i < schemes.length; i++) {
        if (file.lastIndexOf(schemes[i], 0) === 0) {
          return file;
        }
      }

      var basePathURI = this.$parseURI(basePath);
      if (!basePathURI) {
        return file;
      }

      var path = basePathURI.path;
      if (file.indexOf("/") === 0) {
        path = file;
      } else {
        path = "" + path + file;
      }

      // Remove duplicate slashes and dot segments in the path
      path = this.removeDotSegments(path.replace(/([^:]\/)\/+/g, "$1"));

      return "" + basePathURI.scheme + basePathURI.authority + path;
    }

    // Return a DOM-valid path to load the image (fileURL is an already-resolved
    // URL)

  }, {
    key: "$resolveImageURL",
    value: function $resolveImageURL(fileURL) {
      var uri = this.$parseURI(fileURL);
      // If we are within the resource system, look up a "real" path that can be
      // used by the DOM. If not found, return the path itself without the
      // "qrc://" scheme.
      if (uri && uri.scheme === "qrc://") {
        return QmlWeb.qrc[uri.path] || uri.path;
      }

      // Something we can't parse, just pass it through
      return fileURL;
    }
  }, {
    key: "$initializeAliasSignals",
    value: function $initializeAliasSignals() {
      // Perform pending operations. Now we use it only to init alias's "changed"
      // handlers, that's why we have such strange function name.
      while (this.pendingOperations.length > 0) {
        var op = this.pendingOperations.shift();
        op[0](op[1], op[2], op[3]);
      }
      this.pendingOperations = [];
    }
  }, {
    key: "callCompletedSignals",
    value: function callCompletedSignals() {
      // the while loop is better than for..in loop, because completedSignals
      // array might change dynamically when some completed signal handlers will
      // create objects dynamically via createQmlObject or Loader
      while (this.completedSignals.length > 0) {
        var handler = this.completedSignals.shift();
        handler();
      }
    }
  }]);

  return QMLEngine;
}();

QmlWeb.QMLEngine = QMLEngine;

function QMLInteger(val) {
  return val | 0;
}
QMLInteger.plainType = true;
QmlWeb.qmlInteger = QMLInteger;

function QMLList(meta) {
  var list = [];
  if (meta.object instanceof Array) {
    for (var i in meta.object) {
      list.push(QmlWeb.construct({
        object: meta.object[i],
        parent: meta.parent,
        context: meta.context
      }));
    }
  } else if (meta.object instanceof QmlWeb.QMLMetaElement) {
    list.push(QmlWeb.construct({
      object: meta.object,
      parent: meta.parent,
      context: meta.context
    }));
  }

  return list;
}
QMLList.plainType = true;
QmlWeb.qmlList = QMLList;

function QMLNumber(val) {
  return +val;
}
QMLNumber.plainType = true;
QmlWeb.qmlNumber = QMLNumber;

var QMLOperationState = {
  Idle: 1,
  Init: 2,
  Running: 3
};

QmlWeb.QMLOperationState = QMLOperationState;

var QMLProperty = function () {
  function QMLProperty(type, obj, name) {
    _classCallCheck(this, QMLProperty);

    this.obj = obj;
    this.name = name;
    this.changed = QmlWeb.Signal.signal([], { obj: obj });
    this.binding = null;
    this.objectScope = null;
    this.componentScope = null;
    this.value = undefined;
    this.type = type;
    this.animation = null;
    this.needsUpdate = true;

    // This list contains all signals that hold references to this object.
    // It is needed when deleting, as we need to tidy up all references to this
    // object.
    this.$tidyupList = [];
  }

  // Called by update and set to actually set this.val, performing any type
  // conversion required.


  _createClass(QMLProperty, [{
    key: "$setVal",
    value: function $setVal(val, componentScope) {
      var _this15 = this;

      var constructors = QmlWeb.constructors;
      if (constructors[this.type] === QmlWeb.qmlList) {
        this.val = QmlWeb.qmlList({
          object: val,
          parent: this.obj,
          context: componentScope
        });
      } else if (val instanceof QmlWeb.QMLMetaElement) {
        var _QMLComponent = QmlWeb.getConstructor("QtQml", "2.0", "Component");
        if (constructors[val.$class] === _QMLComponent || constructors[this.type] === _QMLComponent) {
          this.val = new _QMLComponent({
            object: val,
            parent: this.obj,
            context: componentScope
          });
          /* $basePath must be set here so that Components that are assigned to
           * properties (e.g. Repeater delegates) can properly resolve child
           * Components that live in the same directory in
           * Component.createObject. */
          this.val.$basePath = componentScope.$basePath;
        } else {
          this.val = QmlWeb.construct({
            object: val,
            parent: this.obj,
            context: componentScope
          });
        }
      } else if (!constructors[this.type]) {
        this.val = val;
      } else if (constructors[this.type].requireParent) {
        this.val = new constructors[this.type](this.obj, val);
      } else if (val === undefined && constructors[this.type].nonNullableType) {
        this.val = new constructors[this.type]();
      } else if (constructors[this.type].requireConstructor) {
        this.val = new constructors[this.type](val);
      } else if (val instanceof Object || val === undefined || val === null) {
        this.val = val;
      } else if (constructors[this.type].plainType) {
        this.val = constructors[this.type](val);
      } else {
        this.val = new constructors[this.type](val);
      }
      if (this.val && this.val.$changed) {
        this.val.$changed.connect(function () {
          var oldVal = _this15.val; // TODO
          _this15.changed(_this15.val, oldVal, _this15.name);
        });
      } else if (this.val && this.val.$properties) {
        Object.keys(this.val.$properties).forEach(function (pname) {
          var prop = _this15.val.$properties[pname];
          if (!prop || !prop.connect) return;
          // TODO: oldVal
          prop.connect(function () {
            return _this15.changed(_this15.val, _this15.val, _this15.name);
          });
        });
      }
    }

    // Updater recalculates the value of a property if one of the dependencies
    // changed

  }, {
    key: "update",
    value: function update() {
      this.needsUpdate = false;

      if (!this.binding) {
        return;
      }

      var oldVal = this.val;

      try {
        QMLProperty.pushEvaluatingProperty(this);
        if (!this.binding.compiled) {
          this.binding.compile();
        }
        this.$setVal(this.binding.eval(this.objectScope, this.componentScope, this.componentScopeBasePath), this.componentScope);
      } catch (e) {
        var objLocation = '';
        if (this.obj.id) {
          objLocation = " of object id: \"" + this.obj.id + "\"";
        }
        var tmp = '',
            obj = this.obj;
        while (obj) {
          tmp = ' > ' + obj.$class + tmp;
          obj = obj.$parent;
        }
        objLocation += " at location:\n " + tmp;
        console.error("Cannot evaluate property \"" + this.name + "\"" + objLocation + "\nExpression: " + this.binding.src);
        console.log("QMLProperty.update binding error:", e, Function.prototype.toString.call(this.binding.eval));
      } finally {
        QMLProperty.popEvaluatingProperty();
      }

      if (this.animation) {
        this.animation.$actions = [{
          target: this.animation.target || this.obj,
          property: this.animation.property || this.name,
          from: this.animation.from || oldVal,
          to: this.animation.to || this.val
        }];
        this.animation.restart();
      }

      if (this.val !== oldVal) {
        this.changed(this.val, oldVal, this.name);
      }
    }

    // Define getter

  }, {
    key: "get",
    value: function get() {
      //if (this.needsUpdate && !QMLProperty.evaluatingPropertyPaused) {
      if (this.needsUpdate && QmlWeb.engine.operationState !== QmlWeb.QMLOperationState.Init) {
        this.update();
      }

      // If this call to the getter is due to a property that is dependant on this
      // one, we need it to take track of changes
      if (QMLProperty.evaluatingProperty) {
        //console.log(this,QMLProperty.evaluatingPropertyStack.slice(0),this.val);
        this.changed.connect(QMLProperty.evaluatingProperty, QMLProperty.prototype.update, QmlWeb.Signal.UniqueConnection);
      }

      return this.val;
    }
    // Define setter

  }, {
    key: "set",
    value: function set(newVal, reason, objectScope, componentScope) {
      var oldVal = this.val;

      var val = newVal;
      if (val instanceof QmlWeb.QMLBinding) {
        if (!objectScope || !componentScope) {
          throw new Error("Internal error: binding assigned without scope");
        }
        this.binding = val;
        this.objectScope = objectScope;
        this.componentScope = componentScope;
        this.componentScopeBasePath = componentScope.$basePath;

        if (QmlWeb.engine.operationState !== QmlWeb.QMLOperationState.Init) {
          if (!val.compiled) {
            val.compile();
          }
          try {
            QMLProperty.pushEvaluatingProperty(this);
            this.needsUpdate = false;
            val = this.binding.eval(objectScope, componentScope, this.componentScopeBasePath);
          } finally {
            QMLProperty.popEvaluatingProperty();
          }
        } else {
          QmlWeb.engine.bindedProperties.push(this);
          return;
        }
      } else {
        if (reason !== QMLProperty.ReasonAnimation) {
          this.binding = null;
        }
        if (val instanceof Array) {
          val = val.slice(); // Copies the array
        }
      }

      if (reason === QMLProperty.ReasonInit && typeof val === "undefined") {
        if (QMLProperty.typeInitialValues.hasOwnProperty(this.type)) {
          val = QMLProperty.typeInitialValues[this.type];
        }
      }

      this.$setVal(val, componentScope);

      if (this.val !== oldVal) {
        if (this.animation && reason === QMLProperty.ReasonUser) {
          this.animation.running = false;
          this.animation.$actions = [{
            target: this.animation.target || this.obj,
            property: this.animation.property || this.name,
            from: this.animation.from || oldVal,
            to: this.animation.to || this.val
          }];
          this.animation.running = true;
        }
        if (this.obj.$syncPropertyToRemote instanceof Function && reason === QMLProperty.ReasonUser) {
          // is a remote object from e.g. a QWebChannel
          this.obj.$syncPropertyToRemote(this.name, val);
        } else {
          this.changed(this.val, oldVal, this.name);
        }
      }
    }
  }], [{
    key: "pushEvalStack",
    value: function pushEvalStack() {
      QMLProperty.evaluatingPropertyStackOfStacks.push(QMLProperty.evaluatingPropertyStack);
      QMLProperty.evaluatingPropertyStack = [];
      QMLProperty.evaluatingProperty = undefined;
      //  console.log("evaluatingProperty=>undefined due to push stck ");
    }
  }, {
    key: "popEvalStack",
    value: function popEvalStack() {
      QMLProperty.evaluatingPropertyStack = QMLProperty.evaluatingPropertyStackOfStacks.pop() || [];
      QMLProperty.evaluatingProperty = QMLProperty.evaluatingPropertyStack[QMLProperty.evaluatingPropertyStack.length - 1];
    }
  }, {
    key: "pushEvaluatingProperty",
    value: function pushEvaluatingProperty(prop) {
      // TODO say warnings if already on stack. This means binding loop.
      // BTW actually we do not loop because needsUpdate flag is reset before
      // entering update again.
      if (QMLProperty.evaluatingPropertyStack.indexOf(prop) >= 0) {
        console.error("Property binding loop detected for property", prop.name, [prop].slice(0));
      }
      QMLProperty.evaluatingProperty = prop;
      QMLProperty.evaluatingPropertyStack.push(prop); //keep stack of props
    }
  }, {
    key: "popEvaluatingProperty",
    value: function popEvaluatingProperty() {
      QMLProperty.evaluatingPropertyStack.pop();
      QMLProperty.evaluatingProperty = QMLProperty.evaluatingPropertyStack[QMLProperty.evaluatingPropertyStack.length - 1];
    }
  }]);

  return QMLProperty;
}();

// Property that is currently beeing evaluated. Used to get the information
// which property called the getter of a certain other property for
// evaluation and is thus dependant on it.


QMLProperty.evaluatingProperty = undefined;
QMLProperty.evaluatingPropertyPaused = false;
QMLProperty.evaluatingPropertyStack = [];
QMLProperty.evaluatingPropertyStackOfStacks = [];

QMLProperty.typeInitialValues = {
  int: 0,
  real: 0,
  double: 0,
  string: "",
  bool: false,
  list: [],
  enum: 0,
  url: ""
};

QMLProperty.ReasonUser = 0;
QMLProperty.ReasonInit = 1;
QMLProperty.ReasonAnimation = 2;

QmlWeb.QMLProperty = QMLProperty;

function QMLString(val) {
  return "" + val;
}
QMLString.plainType = true;
QmlWeb.qmlString = QMLString;

function QMLUrl(val) {
  return QmlWeb.engine.$resolvePath("" + val);
}
QMLUrl.plainType = true;
QmlWeb.qmlUrl = QMLUrl;

function QMLVariant(val) {
  return val;
}
QMLVariant.plainType = true;
QmlWeb.qmlVariant = QMLVariant;

window.addEventListener("load", function () {
  var metaTags = document.getElementsByTagName("body");
  for (var i = 0; i < metaTags.length; ++i) {
    var metaTag = metaTags[i];
    var source = metaTag.getAttribute("data-qml");
    if (source) {
      QmlWeb.qmlEngine = new QmlWeb.QMLEngine();
      QmlWeb.qmlEngine.loadFile(source);
      QmlWeb.qmlEngine.start();
      break;
    }
  }
});

var anchorNames = ["left", "right", "top", "bottom", "verticalCenter", "horizontalCenter"];

var ignoreProps = ["x", "y", "z", "scale", "rotation", "implicitWidth", "implicitHeight"];

function getProperties(file) {
  // TODO: implement a cleaner way

  var div = document.createElement("div");
  var engine = new QmlWeb.QMLEngine(div);
  engine.loadFile(file);

  var qml = engine.rootObject;
  var properties = Object.keys(qml.$properties).filter(function (name) {
    // Invalid names
    if (!name.match(/^[a-z]+$/i) || name === "is") return false;

    // We don't need anchors
    if (anchorNames.indexOf(name) !== -1) return false;

    // These properties are not supported in a good way on top-level items
    if (ignoreProps.indexOf(name) !== -1) return false;

    var type = qml.$properties[name].type;
    return ["real", "color", "int", "bool", "string"].indexOf(type) !== -1;
  });

  engine.stop();
  return properties;
}

function registerElement(name, file) {
  // Delay until the document is fully loaded
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", function () {
      registerElement(name, file);
    });
    return;
  }

  // Bail out if Custom Elements v1 are not present
  if (!window.customElements) {
    throw new Error("window.customElements are not supported. Consider installing a polyfill.");
  }

  // We need attributes list at this point, those form a static property
  var properties = getProperties(file);
  var attributes = properties.map(function (pname) {
    return pname.toLowerCase();
  });
  var attr2prop = properties.reduce(function (map, pname) {
    map[pname.toLowerCase()] = pname;
    return map;
  }, {});

  var QmlElement = function (_HTMLElement) {
    _inherits(QmlElement, _HTMLElement);

    function QmlElement() {
      _classCallCheck(this, QmlElement);

      return _possibleConstructorReturn(this, (QmlElement.__proto__ || Object.getPrototypeOf(QmlElement)).apply(this, arguments));
    }

    _createClass(QmlElement, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        var _this17 = this;

        // Default wrapper display is inline-block to support native width/height
        var computedStyle = window.getComputedStyle(this);
        if (computedStyle.display === "inline") {
          this.style.display = "inline-block";
        }

        var engine = this.engine = new QmlWeb.QMLEngine(this);
        engine.loadFile(file);
        engine.start();
        var qml = this.qml = engine.rootObject;

        // Bind attributes
        attributes.forEach(function (attr) {
          var pname = attr2prop[attr] || attr;
          var val = _this17.getAttribute(attr);
          if (typeof val === "string") {
            qml[pname] = val;
          }
          _this17.applyAttribute(attr);
          Object.defineProperty(_this17, attr, {
            get: function get() {
              return this.qml[pname];
            },
            set: function set(value) {
              this.qml[pname] = value;
              this.applyAttribute(attr);
            }
          });
          qml.$properties[pname].changed.connect(function () {
            return _this17.applyAttribute(attr);
          });
        });

        // Set and update wrapper width/height
        this.style.width = qml.width + "px";
        this.style.height = qml.height + "px";
        qml.$properties.width.changed.connect(function (width) {
          _this17.style.width = width + "px";
        });
        qml.$properties.height.changed.connect(function (height) {
          _this17.style.height = height + "px";
        });
      }
    }, {
      key: "attributeChangedCallback",
      value: function attributeChangedCallback(attr, oldValue, newValue) {
        if (!this.qml) return;
        var pname = attr2prop[attr] || attr;
        var prop = this.qml.$properties[pname];
        if (!prop) return;
        switch (prop.type) {
          case "bool":
            this.qml[pname] = typeof newValue === "string";
            break;
          default:
            this.qml[pname] = newValue;
        }
      }
    }, {
      key: "applyAttribute",
      value: function applyAttribute(attr) {
        var pname = attr2prop[attr] || attr;
        var prop = this.qml.$properties[pname];
        if (!prop) {
          this.deleteAttribute(attr);
          return;
        }
        var value = this.qml[pname];
        switch (prop.type) {
          case "bool":
            if (value) {
              this.setAttribute(attr, "");
            } else {
              this.removeAttribute(attr);
            }
            break;
          default:
            this.setAttribute(attr, this.qml[pname]);
        }
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return attributes;
      }
    }]);

    return QmlElement;
  }(HTMLElement);

  window.customElements.define(name, QmlElement);
}

QmlWeb.registerElement = registerElement;

var Easing = {
  Linear: 1,
  InQuad: 2, OutQuad: 3, InOutQuad: 4, OutInQuad: 5,
  InCubic: 6, OutCubic: 7, InOutCubic: 8, OutInCubic: 9,
  InQuart: 10, OutQuart: 11, InOutQuart: 12, OutInQuart: 13,
  InQuint: 14, OutQuint: 15, InOutQuint: 16, OutInQuint: 17,
  InSine: 18, OutSine: 19, InOutSine: 20, OutInSine: 21,
  InExpo: 22, OutExpo: 23, InOutExpo: 24, OutInExpo: 25,
  InCirc: 26, OutCirc: 27, InOutCirc: 28, OutInCirc: 29,
  InElastic: 30, OutElastic: 31, InOutElastic: 32, OutInElastic: 33,
  InBack: 34, OutBack: 35, InOutBack: 36, OutInBack: 37,
  InBounce: 38, OutBounce: 39, InOutBounce: 40, OutInBounce: 41
};

// eslint-disable-next-line complexity
QmlWeb.$ease = function (type, period, amplitude, overshoot, t) {
  switch (type) {
    // Linear
    case Easing.Linear:
      return t;

    // Quad
    case Easing.InQuad:
      return Math.pow(t, 2);
    case Easing.OutQuad:
      return -Math.pow(t - 1, 2) + 1;
    case Easing.InOutQuad:
      if (t < 0.5) {
        return 2 * Math.pow(t, 2);
      }
      return -2 * Math.pow(t - 1, 2) + 1;
    case Easing.OutInQuad:
      if (t < 0.5) {
        return -2 * Math.pow(t - 0.5, 2) + 0.5;
      }
      return 2 * Math.pow(t - 0.5, 2) + 0.5;

    // Cubic
    case Easing.InCubic:
      return Math.pow(t, 3);
    case Easing.OutCubic:
      return Math.pow(t - 1, 3) + 1;
    case Easing.InOutCubic:
      if (t < 0.5) {
        return 4 * Math.pow(t, 3);
      }
      return 4 * Math.pow(t - 1, 3) + 1;
    case Easing.OutInCubic:
      return 4 * Math.pow(t - 0.5, 3) + 0.5;

    // Quart
    case Easing.InQuart:
      return Math.pow(t, 4);
    case Easing.OutQuart:
      return -Math.pow(t - 1, 4) + 1;
    case Easing.InOutQuart:
      if (t < 0.5) {
        return 8 * Math.pow(t, 4);
      }
      return -8 * Math.pow(t - 1, 4) + 1;
    case Easing.OutInQuart:
      if (t < 0.5) {
        return -8 * Math.pow(t - 0.5, 4) + 0.5;
      }
      return 8 * Math.pow(t - 0.5, 4) + 0.5;

    // Quint
    case Easing.InQuint:
      return Math.pow(t, 5);
    case Easing.OutQuint:
      return Math.pow(t - 1, 5) + 1;
    case Easing.InOutQuint:
      if (t < 0.5) {
        return 16 * Math.pow(t, 5);
      }
      return 16 * Math.pow(t - 1, 5) + 1;
    case Easing.OutInQuint:
      if (t < 0.5) {
        return 16 * Math.pow(t - 0.5, 5) + 0.5;
      }
      return 16 * Math.pow(t - 0.5, 5) + 0.5;

    // Sine
    case Easing.InSine:
      return -Math.cos(0.5 * Math.PI * t) + 1;
    case Easing.OutSine:
      return Math.sin(0.5 * Math.PI * t);
    case Easing.InOutSine:
      return -0.5 * Math.cos(Math.PI * t) + 0.5;
    case Easing.OutInSine:
      if (t < 0.5) {
        return 0.5 * Math.sin(Math.PI * t);
      }
      return -0.5 * Math.sin(Math.PI * t) + 1;

    // Expo
    case Easing.InExpo:
      return 1 / 1023 * (Math.pow(2, 10 * t) - 1);
    case Easing.OutExpo:
      return -1024 / 1023 * (Math.pow(2, -10 * t) - 1);
    case Easing.InOutExpo:
      if (t < 0.5) {
        return 1 / 62 * (Math.pow(2, 10 * t) - 1);
      }
      return -512 / 31 * Math.pow(2, -10 * t) + 63 / 62;
    case Easing.OutInExpo:
      if (t < 0.5) {
        return -16 / 31 * (Math.pow(2, -10 * t) - 1);
      }
      return 1 / 1984 * Math.pow(2, 10 * t) + 15 / 31;

    // Circ
    case Easing.InCirc:
      return 1 - Math.sqrt(1 - t * t);
    case Easing.OutCirc:
      return Math.sqrt(1 - Math.pow(t - 1, 2));
    case Easing.InOutCirc:
      if (t < 0.5) {
        return 0.5 * (1 - Math.sqrt(1 - 4 * t * t));
      }
      return 0.5 * (Math.sqrt(1 - 4 * Math.pow(t - 1, 2)) + 1);
    case Easing.OutInCirc:
      if (t < 0.5) {
        return 0.5 * Math.sqrt(1 - Math.pow(2 * t - 1, 2));
      }
      return 0.5 * (2 - Math.sqrt(1 - Math.pow(2 * t - 1, 2)));

    // Elastic
    case Easing.InElastic:
      return -amplitude * Math.pow(2, 10 * t - 10) * Math.sin(2 * t * Math.PI / period - Math.asin(1 / amplitude));
    case Easing.OutElastic:
      return amplitude * Math.pow(2, -10 * t) * Math.sin(2 * t * Math.PI / period - Math.asin(1 / amplitude)) + 1;
    case Easing.InOutElastic:
      if (t < 0.5) {
        return -0.5 * amplitude * Math.pow(2, 20 * t - 10) * Math.sin(4 * t * Math.PI / period - Math.asin(1 / amplitude));
      }
      return -0.5 * amplitude * Math.pow(2, -20 * t + 10) * Math.sin(4 * t * Math.PI / period + Math.asin(1 / amplitude)) + 1;
    case Easing.OutInElastic:
      if (t < 0.5) {
        return 0.5 * amplitude * Math.pow(2, -20 * t) * Math.sin(4 * t * Math.PI / period - Math.asin(1 / amplitude)) + 0.5;
      }
      return -0.5 * amplitude * Math.pow(2, 20 * t - 20) * Math.sin(4 * t * Math.PI / period - Math.asin(1 / amplitude)) + 0.5;

    // Back
    case Easing.InBack:
      return (overshoot + 1) * Math.pow(t, 3) - overshoot * Math.pow(t, 2);
    case Easing.OutBack:
      return (overshoot + 1) * Math.pow(t - 1, 3) + overshoot * Math.pow(t - 1, 2) + 1;
    case Easing.InOutBack:
      if (t < 0.5) {
        return 4 * (overshoot + 1) * Math.pow(t, 3) - 2 * overshoot * Math.pow(t, 2);
      }
      return 0.5 * (overshoot + 1) * Math.pow(2 * t - 2, 3) + overshoot / 2 * Math.pow(2 * t - 2, 2) + 1;
    case Easing.OutInBack:
      if (t < 0.5) {
        return 0.5 * ((overshoot + 1) * Math.pow(2 * t - 1, 3) + overshoot * Math.pow(2 * t - 1, 2) + 1);
      }
      return 4 * (overshoot + 1) * Math.pow(t - 0.5, 3) - 2 * overshoot * Math.pow(t - 0.5, 2) + 0.5;
    // Bounce
    case Easing.InBounce:
      if (t < 1 / 11) {
        return -amplitude * 121 / 16 * (t * t - 1 / 11 * t);
      } else if (t < 3 / 11) {
        return -amplitude * 121 / 16 * (t * t - 4 / 11 * t + 3 / 121);
      } else if (t < 7 / 11) {
        return -amplitude * 121 / 16 * (t * t - 10 / 11 * t + 21 / 121);
      }
      return -(121 / 16) * (t * t - 2 * t + 1) + 1;
    case Easing.OutBounce:
      if (t < 4 / 11) {
        return 121 / 16 * t * t;
      } else if (t < 8 / 11) {
        return amplitude * (121 / 16) * (t * t - 12 / 11 * t + 32 / 121) + 1;
      } else if (t < 10 / 11) {
        return amplitude * (121 / 16) * (t * t - 18 / 11 * t + 80 / 121) + 1;
      }
      return amplitude * (121 / 16) * (t * t - 21 / 11 * t + 10 / 11) + 1;
    case Easing.InOutBounce:
      if (t < 1 / 22) {
        return -amplitude * 121 / 8 * (t * t - 1 / 22 * t);
      } else if (t < 3 / 22) {
        return -amplitude * 121 / 8 * (t * t - 2 / 11 * t + 3 / 484);
      } else if (t < 7 / 22) {
        return -amplitude * 121 / 8 * (t * t - 5 / 11 * t + 21 / 484);
      } else if (t < 11 / 22) {
        return -121 / 8 * (t * t - t + 0.25) + 0.5;
      } else if (t < 15 / 22) {
        return 121 / 8 * (t * t - t) + 137 / 32;
      } else if (t < 19 / 22) {
        return amplitude * 121 / 8 * (t * t - 17 / 11 * t + 285 / 484) + 1;
      } else if (t < 21 / 22) {
        return amplitude * 121 / 8 * (t * t - 20 / 11 * t + 399 / 484) + 1;
      }
      return amplitude * 121 / 8 * (t * t - 43 / 22 * t + 21 / 22) + 1;
    case Easing.OutInBounce:
      if (t < 4 / 22) {
        return 121 / 8 * t * t;
      } else if (t < 8 / 22) {
        return -amplitude * 121 / 8 * (t * t - 6 / 11 * t + 8 / 121) + 0.5;
      } else if (t < 10 / 22) {
        return -amplitude * 121 / 8 * (t * t - 9 / 11 * t + 20 / 121) + 0.5;
      } else if (t < 11 / 22) {
        return -amplitude * 121 / 8 * (t * t - 21 / 22 * t + 5 / 22) + 0.5;
      } else if (t < 12 / 22) {
        return amplitude * 121 / 8 * (t * t - 23 / 22 * t + 3 / 11) + 0.5;
      } else if (t < 14 / 22) {
        return amplitude * 121 / 8 * (t * t - 13 / 11 * t + 42 / 121) + 0.5;
      } else if (t < 18 / 22) {
        return amplitude * 121 / 8 * (t * t - 16 / 11 * t + 63 / 121) + 0.5;
      }
      return -121 / 8 * (t * t - 2 * t + 117 / 121) + 0.5;

    // Default
    default:
      console.error("Unsupported animation type: ", type);
      return t;
  }
};

QmlWeb.Easing = Easing;

/* eslint accessor-pairs: 0 */

function setupGetter(obj, propName, func) {
  Object.defineProperty(obj, propName, {
    get: func,
    configurable: true,
    enumerable: true
  });
}

function setupSetter(obj, propName, func) {
  Object.defineProperty(obj, propName, {
    set: func,
    configurable: true,
    enumerable: false
  });
}

function setupGetterSetter(obj, propName, getter, setter) {
  Object.defineProperty(obj, propName, {
    get: getter,
    set: setter,
    configurable: true,
    enumerable: false
  });
}

QmlWeb.setupGetter = setupGetter;
QmlWeb.setupSetter = setupSetter;
QmlWeb.setupGetterSetter = setupGetterSetter;

var QmlWebHelpers = function () {
  function QmlWebHelpers() {
    _classCallCheck(this, QmlWebHelpers);
  }

  _createClass(QmlWebHelpers, null, [{
    key: "arrayFindIndex",
    value: function arrayFindIndex(array, callback) {
      // Note: does not support thisArg, we don't need that
      if (!Array.prototype.findIndex) {
        for (var _key23 in array) {
          if (callback(array[_key23], _key23, array)) {
            return _key23;
          }
        }
        return -1;
      }
      return Array.prototype.findIndex.call(array, callback);
    }
  }, {
    key: "mergeObjects",
    value: function mergeObjects() {
      var merged = {};

      for (var _len23 = arguments.length, args = Array(_len23), _key24 = 0; _key24 < _len23; _key24++) {
        args[_key24] = arguments[_key24];
      }

      for (var i in args) {
        var arg = args[i];
        if (!arg) {
          continue;
        }
        for (var _key25 in arg) {
          merged[_key25] = arg[_key25];
        }
      }
      return merged;
    }
  }]);

  return QmlWebHelpers;
}();

QmlWeb.helpers = QmlWebHelpers;

/* @license

MIT License

Copyright (c) 2011 Lauri Paimen <lauri@paimen.info>
Copyright (c) 2015 Pavel Vasev <pavel.vasev@gmail.com> - initial and working
                                                         import implementation.
Copyright (c) 2016 QmlWeb contributors

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

/**
 * Get URL contents.
 * @param url {String} Url to fetch.
 * @param skipExceptions {bool} when turned on, ignore exeptions and return
 *        false. This feature is used by readQmlDir.
 * @private
 * @return {mixed} String of contents or false in errors.
 */
function getUrlContents(url, skipExceptions) {
  if (typeof QmlWeb.urlContentCache[url] === "undefined") {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url, false);

    if (skipExceptions) {
      try {
        xhr.send(null);
      } catch (e) {
        return false;
      }
      // it is OK to not have logging here, because DeveloperTools already will
      // have red log record
    } else {
      xhr.send(null);
    }

    if (xhr.status !== 200 && xhr.status !== 0) {
      // 0 if accessing with file://
      console.log("Retrieving " + url + " failed: " + xhr.responseText, xhr);
      return false;
    }
    QmlWeb.urlContentCache[url] = xhr.responseText;
  }
  return QmlWeb.urlContentCache[url];
}
if (typeof QmlWeb.urlContentCache === "undefined") {
  QmlWeb.urlContentCache = {};
}

/**
 * Read qmldir spec file at directory.
 * @param url Url of the directory
 * @return {Object} Object, where .internals lists qmldir internal references
 *                          and .externals lists qmldir external references.
 */

/*  Note on how importing works.

parseQML gives us `tree.$imports` variable, which contains information from
`import` statements.

After each call to parseQML, we call engine.loadImports(tree.$imports).
It in turn invokes readQmlDir() calls for each import, with respect to current
component base path and engine.importPathList().

We keep all component names from all qmldir files in global variable
`engine.qmldir`.

In construct() function, we use `engine.qmldir` for component url lookup.

Reference import info: http://doc.qt.io/qt-5/qtqml-syntax-imports.html
Also please look at notes and TODO's in qtcore.js::loadImports() and
qtcore.js::construct() methods.
*/

function readQmlDir(url) {
  // in case 'url' is empty, do not attach "/"
  // Q1: when this happen?
  var qmldirFileUrl = url.length > 0 ? url + "/qmldir" : "qmldir";

  var parsedUrl = QmlWeb.engine.$parseURI(qmldirFileUrl);

  var qmldir = void 0;
  if (parsedUrl.scheme === "qrc://") {
    qmldir = QmlWeb.qrc[parsedUrl.path];
  } else {
    qmldir = getUrlContents(qmldirFileUrl, true) || undefined;
  }

  var internals = {};
  var externals = {};

  if (qmldir === undefined) {
    return false;
  }

  // we have to check for "://"
  // In that case, item path is meant to be absolute, and we have no need to
  // prefix it with base url
  function makeurl(path) {
    if (path.indexOf("://") > 0) {
      return path;
    }
    return url + "/" + path;
  }

  var lines = qmldir.split(/\r?\n/);
  for (var i = 0; i < lines.length; i++) {
    // trim
    var line = lines[i].replace(/^\s+|\s+$/g, "");
    if (!line.length || line[0] === "#") {
      // Empty line or comment
      continue;
    }
    var match = line.split(/\s+/);
    if (match.length === 2 || match.length === 3) {
      if (match[0] === "plugin") {
        console.log(url + ": qmldir plugins are not supported!");
      } else if (match[0] === "internal") {
        internals[match[1]] = { url: makeurl(match[2]) };
      } else if (match.length === 2) {
        externals[match[0]] = { url: makeurl(match[1]) };
      } else {
        externals[match[0]] = { url: makeurl(match[2]), version: match[1] };
      }
    } else {
      console.log(url + ": unmatched: " + line);
    }
  }
  return { internals: internals, externals: externals };
}

QmlWeb.getUrlContents = getUrlContents;
QmlWeb.readQmlDir = readQmlDir;

function importJavascriptInContext(contextSetter, $context) {
  /* Set the QmlWeb.executionContext so that any internal calls to Qt.include
   * will have the proper context */
  var oldExecutionContext = QmlWeb.executionContext;
  QmlWeb.executionContext = $context;
  contextSetter($context);
  QmlWeb.executionContext = oldExecutionContext;
}

QmlWeb.importJavascriptInContext = importJavascriptInContext;

QmlWeb.keyCodeToQt = function (e) {
  var Qt = QmlWeb.Qt;
  e.keypad = e.keyCode >= 96 && e.keyCode <= 111;
  if (e.keyCode === Qt.Key_Tab && e.shiftKey) {
    return Qt.Key_Backtab;
  }
  if (e.keyCode >= 97 && e.keyCode <= 122) {
    return e.keyCode - (97 - Qt.Key_A);
  }
  return e.keyCode;
};

QmlWeb.eventToKeyboard = function (e) {
  return {
    accepted: false,
    count: 1,
    isAutoRepeat: false,
    key: QmlWeb.keyCodeToQt(e),
    modifiers: e.ctrlKey * QmlWeb.Qt.CtrlModifier | e.altKey * QmlWeb.Qt.AltModifier | e.shiftKey * QmlWeb.Qt.ShiftModifier | e.metaKey * QmlWeb.Qt.MetaModifier | e.keypad * QmlWeb.Qt.KeypadModifier,
    text: String.fromCharCode(e.charCode)
  };
};

QmlWeb.keyboardSignals = {};
["asterisk", "back", "backtab", "call", "cancel", "delete", "escape", "flip", 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "hangup", "menu", "no", "return", "select", "space", "tab", "volumeDown", "volumeUp", "yes", "up", "right", "down", "left"].forEach(function (key) {
  var name = key.toString();
  var qtName = "Key_" + name[0].toUpperCase() + name.slice(1);
  var prefix = typeof key === "number" ? "digit" : "";
  QmlWeb.keyboardSignals[QmlWeb.Qt[qtName]] = "" + prefix + name + "Pressed";
});

QmlWeb.executionContext = null;

var modules = {
  Main: {
    int: QmlWeb.qmlInteger,
    real: QmlWeb.qmlNumber,
    double: QmlWeb.qmlNumber,
    string: QmlWeb.qmlString,
    bool: QmlWeb.qmlBoolean,
    list: QmlWeb.qmlList,
    color: QmlWeb.QColor,
    font: QmlWeb.QFont,
    size: QmlWeb.QSizeF,
    point: QmlWeb.QPointF,
    rect: QmlWeb.QRectF,
    vector2d: QmlWeb.QVector2D,
    vector3d: QmlWeb.QVector3D,
    vector4d: QmlWeb.QVector4D,
    quaternion: QmlWeb.QQuaternion,
    matrix4x4: QmlWeb.QMatrix4x4,
    enum: QmlWeb.qmlNumber,
    url: QmlWeb.qmlUrl,
    variant: QmlWeb.qmlVariant,
    var: QmlWeb.qmlVariant
  }
};

// All object constructors
QmlWeb.constructors = modules.Main;

var dependants = {};

var perImportContextConstructors = {};
var importContextIds = 0;

// Helper. Adds a type to the constructor list
function registerGlobalQmlType(name, type) {
  QmlWeb[type.name] = type;
  QmlWeb.constructors[name] = type;
  modules.Main[name] = type;
}

// Helper. Register a type to a module
function registerQmlType(options, constructor) {
  if (constructor !== undefined) {
    options.constructor = constructor;
  }

  if (typeof options.baseClass === "string") {
    // TODO: Does not support version specification (yet?)
    var baseModule = void 0;
    var baseName = void 0;
    var dot = options.baseClass.lastIndexOf(".");
    if (dot === -1) {
      baseModule = options.module;
      baseName = options.baseClass;
    } else {
      baseModule = options.baseClass.substring(0, dot);
      baseName = options.baseClass.substring(dot + 1);
    }
    var found = (modules[baseModule] || []).filter(function (descr) {
      return descr.name === baseName;
    });
    if (found.length > 0) {
      // Ok, we found our base class
      options.baseClass = found[0].constructor;
    } else {
      // Base class not found, delay the loading
      var baseId = [baseModule, baseName].join(".");
      if (!dependants.hasOwnProperty(baseId)) {
        dependants[baseId] = [];
      }
      dependants[baseId].push(options);
      return;
    }
  }

  var descriptor = typeof options === "function" ? {
    module: options.module,
    name: options.element,
    versions: options.versions,
    baseClass: options.baseClass,
    enums: options.enums,
    signals: options.signals,
    defaultProperty: options.defaultProperty,
    properties: options.properties,
    constructor: options
  } : options;

  descriptor.constructor.$qmlTypeInfo = {
    enums: descriptor.enums,
    signals: descriptor.signals,
    defaultProperty: descriptor.defaultProperty,
    properties: descriptor.properties
  };

  if (descriptor.global) {
    registerGlobalQmlType(descriptor.name, descriptor.constructor);
  }

  var moduleDescriptor = {
    name: descriptor.name,
    versions: descriptor.versions,
    constructor: descriptor.constructor
  };

  if (typeof modules[descriptor.module] === "undefined") {
    modules[descriptor.module] = [];
  }
  modules[descriptor.module].push(moduleDescriptor);

  if (typeof descriptor.baseClass !== "undefined") {
    inherit(descriptor.constructor, descriptor.baseClass);
  }

  var id = [descriptor.module, descriptor.name].join(".");
  if (dependants.hasOwnProperty(id)) {
    dependants[id].forEach(function (opt) {
      return registerQmlType(opt);
    });
    dependants[id].length = 0;
  }

  // TODO: Move to module initialization?
  /*
    http://doc.qt.io/qt-5/qtqml-syntax-objectattributes.html#attached-properties-and-attached-signal-handlers
     Some object treated as Attached. For example, Component.
    Here, we set property to object `QMLBaseObject.prototype` with name of that
    object, and with specific getter func.
    E.g., we create "someitem.Component" here.
    Later, if somebody will read that property, the getter will be invoked.
    Here all getters are set to `getAttachedObject` only, which is actually
    dedicated for Component attached object.
    The code of `getAttachedObject` checks whether $Component internal
    variable exist, and creates it if it absent.
    Then, `getAttachedObject` adds self "completed" signal to global
    `engine.completedSignals`.
    That is how completed handlers gathered into global list. This list then
    is called by `engine.callCompletedSignals`.
     p.s. At the moment, Repeater and Loader manually call
    `Component.completed` signals on objects they create.
    At the same time, those signals are still pushed to
    `engine.completedSignals` by getAttachedObject.
  */
  if (descriptor.constructor.getAttachedObject) {
    var QMLBaseObject = QmlWeb.getConstructor("QtQml", "2.0", "QtObject");
    QmlWeb.setupGetter(QMLBaseObject.prototype, descriptor.name, descriptor.constructor.getAttachedObject);
  }
}

function getConstructor(moduleName, version, name) {
  if (typeof modules[moduleName] !== "undefined") {
    for (var i = 0; i < modules[moduleName].length; ++i) {
      var type = modules[moduleName][i];
      if (type.name === name && type.versions.test(version)) {
        return type.constructor;
      }
    }
  }
  return null;
}

function getModuleConstructors(moduleName, version) {
  var constructors = {};
  if (typeof modules[moduleName] === "undefined") {
    console.warn("module \"" + moduleName + "\" not found");
    return constructors;
  }
  for (var i = 0; i < modules[moduleName].length; ++i) {
    var module = modules[moduleName][i];
    if (module.versions.test(version)) {
      constructors[module.name] = module.constructor;
    }
  }
  return constructors;
}

function loadImports(self, imports) {
  var mergeObjects = QmlWeb.helpers.mergeObjects;
  var constructors = mergeObjects(modules.Main);
  if (imports.filter(function (row) {
    return row[1] === "QtQml";
  }).length === 0 && imports.filter(function (row) {
    return row[1] === "QtQuick";
  }).length === 1) {
    imports.push(["qmlimport", "QtQml", 2, "", true]);
  }
  for (var i = 0; i < imports.length; ++i) {
    var _imports$i = _slicedToArray(imports[i], 4),
        moduleName = _imports$i[1],
        moduleVersion = _imports$i[2],
        moduleAlias = _imports$i[3];

    if (typeof moduleVersion !== "number") continue;
    var versionString = moduleVersion % 1 === 0 ? moduleVersion.toFixed(1) : moduleVersion.toString();
    var moduleConstructors = getModuleConstructors(moduleName, versionString);

    if (moduleAlias !== "") {
      constructors[moduleAlias] = mergeObjects(constructors[moduleAlias], moduleConstructors);
    } else {
      constructors = mergeObjects(constructors, moduleConstructors);
    }
  }
  self.importContextId = importContextIds++;
  perImportContextConstructors[self.importContextId] = constructors;
  QmlWeb.constructors = constructors; // TODO: why do we need this?
}

function inherit(constructor, baseClass) {
  var oldProto = constructor.prototype;
  constructor.prototype = Object.create(baseClass.prototype);
  Object.getOwnPropertyNames(oldProto).forEach(function (prop) {
    constructor.prototype[prop] = oldProto[prop];
  });
  constructor.prototype.constructor = baseClass;
}

function callSuper(self, meta) {
  var info = meta.super.$qmlTypeInfo || {};
  meta.super = meta.super.prototype.constructor;
  meta.super.call(self, meta);

  if (info.enums) {
    // TODO: not exported to the whole file scope yet
    Object.keys(info.enums).forEach(function (name) {
      self[name] = info.enums[name];

      if (!global[name]) {
        global[name] = self[name]; // HACK
      }
    });
  }
  if (info.properties) {
    QmlWeb.createProperties(self, info.properties);
  }
  if (info.signals) {
    Object.keys(info.signals).forEach(function (name) {
      var params = info.signals[name];
      self[name] = QmlWeb.Signal.signal(params);
    });
  }
  if (info.defaultProperty) {
    self.$defaultProperty = info.defaultProperty;
  }
}

/**
 * QML Object constructor.
 * @param {Object} meta Meta information about the object and the creation
 *                      context
 * @return {Object} New qml object
 */
function construct(meta) {
  var item = void 0;

  var constructors = perImportContextConstructors[meta.context.importContextId];

  var classComponents = meta.object.$class.split(".");
  for (var ci = 0; ci < classComponents.length; ++ci) {
    var c = classComponents[ci];
    constructors = constructors[c];
    if (constructors === undefined) {
      break;
    }
  }

  if (constructors !== undefined) {
    var _constructor = constructors;
    meta.super = _constructor;
    item = new _constructor(meta);
    meta.super = undefined;
  } else {
    // Load component from file. Please look at import.js for main notes.
    // Actually, we have to use that order:
    // 1) try to load component from current basePath
    // 2) from importPathList
    // 3) from directories in imports statements and then
    // 4) from qmldir files
    // Currently we support only 1,2 and 4 and use order: 4,1,2
    // TODO: engine.qmldirs is global for all loaded components.
    //       That's not qml's original behaviour.
    var qdirInfo = QmlWeb.engine.qmldirs[meta.object.$class];
    // Are we have info on that component in some imported qmldir files?

    /* This will also be set in applyProperties, but needs to be set here
     * for Qt.createComponent to have the correct context. */
    QmlWeb.executionContext = meta.context;

    var filePath = void 0;
    if (qdirInfo) {
      filePath = qdirInfo.url;
    } else if (classComponents.length === 2) {
      var qualified = QmlWeb.engine.qualifiedImportPath(meta.context.importContextId, classComponents[0]);
      filePath = "" + qualified + classComponents[1] + ".qml";
    } else {
      filePath = classComponents[0] + ".qml";
    }

    var component = QmlWeb.Qt.createComponent(filePath);

    if (!component) {
      throw new Error("No constructor found for " + meta.object.$class);
    }

    item = component.$createObject(meta.parent);
    // Handle default properties
  }

  // id
  if (meta.object.id) {
    QmlWeb.setupGetterSetter(meta.context, meta.object.id, function () {
      return item;
    }, function () {});
  }

  // keep path in item for probale use it later in Qt.resolvedUrl
  item.$context.$basePath = QmlWeb.engine.$basePath; //gut

  // We want to use the item's scope, but this Component's imports
  item.$context.importContextId = meta.context.importContextId;

  // Apply properties (Bindings won't get evaluated, yet)
  QmlWeb.applyProperties(meta.object, item, item, item.$context);

  return item;
}

QmlWeb.modules = modules;
QmlWeb.registerGlobalQmlType = registerGlobalQmlType;
QmlWeb.registerQmlType = registerQmlType;
QmlWeb.getConstructor = getConstructor;
QmlWeb.loadImports = loadImports;
QmlWeb.callSuper = callSuper;
QmlWeb.construct = construct;

/**
 * Create property getters and setters for object.
 * @param {Object} obj Object for which gsetters will be set
 * @param {String} propName Property name
 * @param {Object} [options] Options that allow finetuning of the property
 */
function createProperty(type, obj, propName) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  var QMLProperty = QmlWeb.QMLProperty;
  var prop = new QMLProperty(type, obj, propName);
  obj[propName + "Changed"] = prop.changed;
  obj.$properties[propName] = prop;
  obj.$properties[propName].set(options.initialValue, QMLProperty.ReasonInit);

  var getter = function getter() {
    return obj.$properties[propName].get();
  };
  var setter = void 0;
  if (options.readOnly) {
    setter = function setter(newVal) {
      if (!obj.$canEditReadOnlyProperties) {
        throw new Error("property '" + propName + "' has read only access");
      }
      obj.$properties[propName].set(newVal, QMLProperty.ReasonUser);
    };
  } else {
    setter = function setter(newVal) {
      obj.$properties[propName].set(newVal, QMLProperty.ReasonUser);
    };
  }
  QmlWeb.setupGetterSetter(obj, propName, getter, setter);
  if (obj.$isComponentRoot) {
    var skip = false;
    if (options.noContextOverride) {
      // Don't override context properties if options.noContextOverride is on
      var descr = Object.getOwnPropertyDescriptor(obj.$context, propName);
      skip = descr && (descr.get || descr.set);
    }
    if (!skip) {
      QmlWeb.setupGetterSetter(obj.$context, propName, getter, setter);
    }
  }
}

/**
 * Create property getters and setters for object.
 * @param {Object} obj Object for which gsetters will be set
 * @param {Object} properties An object containing properties descriptors
 */
function createProperties(obj, properties) {
  Object.keys(properties).forEach(function (name) {
    var desc = properties[name];
    if (typeof desc === "string") {
      desc = { type: desc };
    }
    createProperty(desc.type, obj, name, desc);
  });
}

/**
 * Apply properties from metaObject to item.
 * @param {Object} metaObject Source of properties
 * @param {Object} item Target of property apply
 * @param {Object} objectScope Scope in which properties should be evaluated
 * @param {Object} componentScope Component scope in which properties should be
 *                 evaluated
 */
function applyProperties(metaObject, item, objectScopeIn, componentScope) {
  var QMLProperty = QmlWeb.QMLProperty;
  var objectScope = objectScopeIn || item;
  QmlWeb.executionContext = componentScope;

  if (metaObject.$children && metaObject.$children.length !== 0) {
    if (item.$defaultProperty) {
      item.$properties[item.$defaultProperty].set(metaObject.$children, QMLProperty.ReasonInit, objectScope, componentScope);
    } else {
      throw new Error("Cannot assign to unexistant default property");
    }
  }
  // We purposefully set the default property AFTER using it, in order to only
  // have it applied for instanciations of this component, but not for its
  // internal children
  if (metaObject.$defaultProperty) {
    item.$defaultProperty = metaObject.$defaultProperty;
  }

  for (var i in metaObject) {
    var value = metaObject[i];
    if (i === "id" || i === "$class") {
      // keep them
      item[i] = value;
      continue;
    }

    // skip global id's and internal values
    if (i === "id" || i[0] === "$") {
      // TODO: what? See above.
      continue;
    }

    // slots
    if (i.indexOf("on") === 0 && i.length > 2 && /[A-Z]/.test(i[2])) {
      var signalName = i[2].toLowerCase() + i.slice(3);
      if (connectSignal(item, signalName, value, objectScope, componentScope)) {
        continue;
      }
      if (item.$setCustomSlot) {
        item.$setCustomSlot(signalName, value, objectScope, componentScope);
        continue;
      }
    }

    if (value instanceof Object) {
      if (applyProperty(item, i, value, objectScope, componentScope)) {
        continue;
      }
    }

    if (item.$properties && i in item.$properties) {
      item.$properties[i].set(value, QMLProperty.ReasonInit, objectScope, componentScope);
    } else if (i in item) {
      item[i] = value;
    } else if (item.$setCustomData) {
      item.$setCustomData(i, value);
    } else {
      console.warn("Cannot assign to non-existent property \"" + i + "\". Ignoring assignment.");
    }
  }
}

function applyProperty(item, i, value, objectScope, componentScope) {
  var QMLProperty = QmlWeb.QMLProperty;

  if (value instanceof QmlWeb.QMLSignalDefinition) {
    item[i] = QmlWeb.Signal.signal(value.parameters);
    if (item.$isComponentRoot) {
      componentScope[i] = item[i];
    }
    return true;
  }

  if (value instanceof QmlWeb.QMLMethod) {
    value.compile();
    item[i] = value.eval(objectScope, componentScope, componentScope.$basePath);
    if (item.$isComponentRoot) {
      componentScope[i] = item[i];
    }
    return true;
  }

  if (value instanceof QmlWeb.QMLAliasDefinition) {
    // TODO
    // 1. Alias must be able to point to prop or id of local object,
    //    eg: property alias q: t
    // 2. Alias may have same name as id it points to: property alias
    //    someid: someid
    // 3. Alias proxy (or property proxy) to proxy prop access to selected
    //    incapsulated object. (think twice).
    createProperty("alias", item, i, { noContextOverride: true });
    item.$properties[i].componentScope = componentScope;
    item.$properties[i].componentScopeBasePath = componentScope.$basePath;
    item.$properties[i].val = value;
    item.$properties[i].get = function () {
      var obj = this.componentScope[this.val.objectName];
      var propertyName = this.val.propertyName;
      return propertyName ? obj.$properties[propertyName].get() : obj;
    };
    item.$properties[i].set = function (newVal, reason, _objectScope, _componentScope) {
      if (!this.val.propertyName) {
        throw new Error("Cannot set alias property pointing to an QML object.");
      }
      var obj = this.componentScope[this.val.objectName];
      var prop = obj.$properties[this.val.propertyName];
      prop.set(newVal, reason, _objectScope, _componentScope);
    };

    if (value.propertyName) {
      var con = function con(prop) {
        var obj = prop.componentScope[prop.val.objectName];
        if (!obj) {
          console.error("qtcore: target object ", prop.val.objectName, " not found for alias ", prop);
          return;
        }
        var targetProp = obj.$properties[prop.val.propertyName];
        if (!targetProp) {
          console.error("qtcore: target property [", prop.val.objectName, "].", prop.val.propertyName, " not found for alias ", prop.name);
          return;
        }
        // targetProp.changed.connect( prop.changed );
        // it is not sufficient to connect to `changed` of source property
        // we have to propagate own changed to it too
        // seems the best way to do this is to make them identical?..
        // prop.changed = targetProp.changed;
        // obj[`${i}Changed`] = prop.changed;
        // no. because those object might be destroyed later.
        var loopWatchdog = false;
        targetProp.changed.connect(item, function () {
          for (var _len24 = arguments.length, args = Array(_len24), _key26 = 0; _key26 < _len24; _key26++) {
            args[_key26] = arguments[_key26];
          }

          if (loopWatchdog) return;
          loopWatchdog = true;
          prop.changed.apply(item, args);
          loopWatchdog = false;
        });
        prop.changed.connect(obj, function () {
          for (var _len25 = arguments.length, args = Array(_len25), _key27 = 0; _key27 < _len25; _key27++) {
            args[_key27] = arguments[_key27];
          }

          if (loopWatchdog) return;
          loopWatchdog = true;
          targetProp.changed.apply(obj, args);
          loopWatchdog = false;
        });
      };
      QmlWeb.engine.pendingOperations.push([con, item.$properties[i]]);
    }
    return true;
  }

  if (value instanceof QmlWeb.QMLPropertyDefinition) {
    createProperty(value.type, item, i);
    item.$properties[i].set(value.value, QMLProperty.ReasonInit, objectScope, componentScope);
    return true;
  }

  if (item[i] && value instanceof QmlWeb.QMLMetaPropertyGroup) {
    // Apply properties one by one, otherwise apply at once
    applyProperties(value, item[i], objectScope, componentScope);
    return true;
  }

  return false;
}

function connectSignal(item, signalName, value, objectScope, componentScope) {
  if (!item[signalName]) {
    console.warn("No signal called " + signalName + " found!");
    return undefined;
  } else if (typeof item[signalName].connect !== "function") {
    console.warn(signalName + " is not a signal!");
    return undefined;
  }

  if (!value.compiled) {
    var params = [];
    for (var j in item[signalName].parameters) {
      params.push(item[signalName].parameters[j].name);
    }
    // Wrap value.src in IIFE in case it includes a "return"
    value.src = "(\n      function(" + params.join(", ") + ") {\n        QmlWeb.executionContext = __executionContext;\n        QmlWeb.engine.$oldBasePath = QmlWeb.engine.$basePath;\n        QmlWeb.engine.$basePath = \"" + componentScope.$basePath + "\";\n        try {\n          (function() {\n            " + value.src + "\n          })();\n        } finally {\n          QmlWeb.engine.$basePath = QmlWeb.engine.$oldBasePath;\n        }\n      }\n    )";
    value.isFunction = false;
    value.compile();
  }
  // Don't pass in __basePath argument, as QMLEngine.$basePath is set in the
  // value.src, as we need it set at the time the slot is called.
  var slot = value.eval(objectScope, componentScope);
  item[signalName].connect(item, slot);
  return slot;
}

QmlWeb.createProperty = createProperty;
QmlWeb.createProperties = createProperties;
QmlWeb.applyProperties = applyProperties;
QmlWeb.connectSignal = connectSignal;

/* @license

MIT License

Copyright (c) 2011 Lauri Paimen <lauri@paimen.info>
Copyright (c) 2013 Anton Kreuzkamp <akreuzkamp@web.de>
Copyright (c) 2016 QmlWeb contributors

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

var QMLMethod = function (_QmlWeb$QMLBinding) {
  _inherits(QMLMethod, _QmlWeb$QMLBinding);

  function QMLMethod() {
    _classCallCheck(this, QMLMethod);

    return _possibleConstructorReturn(this, (QMLMethod.__proto__ || Object.getPrototypeOf(QMLMethod)).apply(this, arguments));
  }

  return QMLMethod;
}(QmlWeb.QMLBinding);

/**
 * Create an object representing a QML property definition.
 * @param {String} type The type of the property
 * @param {Array} value The default value of the property
 * @return {Object} Object representing the defintion
 */


var QMLPropertyDefinition = function QMLPropertyDefinition(type, value) {
  _classCallCheck(this, QMLPropertyDefinition);

  this.type = type;
  this.value = value;
};

var QMLAliasDefinition = function QMLAliasDefinition(objName, propName) {
  _classCallCheck(this, QMLAliasDefinition);

  this.objectName = objName;
  this.propertyName = propName;
};

/**
 * Create an object representing a QML signal definition.
 * @param {Array} params The parameters the signal ships
 * @return {Object} Object representing the defintion
 */


var QMLSignalDefinition = function QMLSignalDefinition(params) {
  _classCallCheck(this, QMLSignalDefinition);

  this.parameters = params;
};

/**
 * Create an object representing a group of QML properties (like anchors).
 * @return {Object} Object representing the group
 */


var QMLMetaPropertyGroup = function QMLMetaPropertyGroup() {
  _classCallCheck(this, QMLMetaPropertyGroup);
};

/**
 * Create an object representing a QML element.
 * @param {String} type Type of the element
 * @param {String} onProp Name of the property specified with the "on" keyword
 */


var QMLMetaElement = function QMLMetaElement(type, onProp) {
  _classCallCheck(this, QMLMetaElement);

  this.$class = type;
  this.$children = [];
  this.$on = onProp;
};

// Convert parser tree to the format understood by engine


function convertToEngine(tree) {
  return convertToEngine.walk(tree);
}

function stringifyDots(elem) {
  var sub = elem;
  var path = [];
  while (sub[0] === "dot") {
    path.push(sub[1]);
    sub = sub[2];
  }
  path.push(sub);
  return path.join(".");
}

function applyProp(item, name, val) {
  var curr = item; // output structure
  var sub = name; // input structure
  while (sub[0] === "dot") {
    if (!curr[sub[1]]) {
      curr[sub[1]] = new QMLMetaPropertyGroup();
    }
    curr = curr[sub[1]];
    sub = sub[2];
  }
  curr[sub] = val;
}

convertToEngine.walkers = {
  toplevel: function toplevel(imports, statement) {
    var item = { $class: "Component" };
    item.$imports = imports;
    item.$children = [convertToEngine.walk(statement)];
    return item;
  },
  qmlelem: function qmlelem(elem, onProp, statements) {
    var item = new QMLMetaElement(stringifyDots(elem), onProp);

    for (var i in statements) {
      var statement = statements[i];
      var name = statement[1];
      var val = convertToEngine.walk(statement);
      switch (statement[0]) {
        case "qmldefaultprop":
          item.$defaultProperty = name;
          item[name] = val;
          break;
        case "qmlprop":
        case "qmlpropdef":
        case "qmlaliasdef":
        case "qmlmethod":
        case "qmlsignaldef":
          applyProp(item, name, val);
          break;
        case "qmlelem":
          item.$children.push(val);
          break;
        case "qmlobjdef":
          throw new Error("qmlobjdef support was removed, update qmlweb-parser to ^0.3.0.");
        case "qmlobj":
          // Create object to item
          item[name] = item[name] || new QMLMetaPropertyGroup();
          for (var j in val) {
            item[name][j] = val[j];
          }
          break;
        default:
          console.log("Unknown statement", statement);
      }
    }
    // Make $children be either a single item or an array, if it's more than one
    if (item.$children.length === 1) {
      item.$children = item.$children[0];
    }

    return item;
  },
  qmlprop: function qmlprop(name, tree, src) {
    if (name === "id") {
      // id property
      return tree[1][1];
    }
    return convertToEngine.bindout(tree, src);
  },
  qmlobjdef: function qmlobjdef(name, property, tree, src) {
    return convertToEngine.bindout(tree, src);
  },
  qmlobj: function qmlobj(elem, statements) {
    var item = {};
    for (var i in statements) {
      var statement = statements[i];
      var name = statement[1];
      var val = convertToEngine.walk(statement);
      if (statement[0] === "qmlprop") {
        applyProp(item, name, val);
      }
    }
    return item;
  },
  qmlmethod: function qmlmethod(name, tree, src) {
    return new QMLMethod(src);
  },
  qmlpropdef: function qmlpropdef(name, type, tree, src) {
    return new QMLPropertyDefinition(type, tree ? convertToEngine.bindout(tree, src) : undefined);
  },
  qmlaliasdef: function qmlaliasdef(name, objName, propName) {
    return new QMLAliasDefinition(objName, propName);
  },
  qmlsignaldef: function qmlsignaldef(name, params) {
    return new QMLSignalDefinition(params);
  },
  qmldefaultprop: function qmldefaultprop(tree) {
    return convertToEngine.walk(tree);
  },
  name: function name(src) {
    if (src === "true" || src === "false") {
      return src === "true";
    } else if (typeof src === "boolean") {
      // TODO: is this needed? kept for compat with ==
      return src;
    }
    return new QmlWeb.QMLBinding(src, ["name", src]);
  },
  num: function num(src) {
    return +src;
  },
  string: function string(src) {
    return String(src);
  },
  array: function array(tree, src) {
    var a = [];
    var isList = false;
    var hasBinding = false;
    for (var i in tree) {
      var val = convertToEngine.bindout(tree[i]);
      a.push(val);

      if (val instanceof QMLMetaElement) {
        isList = true;
      } else if (val instanceof QmlWeb.QMLBinding) {
        hasBinding = true;
      }
    }

    if (hasBinding) {
      if (isList) {
        throw new TypeError("An array may either contain bindings or Element definitions.");
      }
      return new QmlWeb.QMLBinding(src, tree);
    }

    return a;
  }
};

convertToEngine.walk = function (tree) {
  var type = tree[0];
  var walker = convertToEngine.walkers[type];
  if (!walker) {
    console.log("No walker for " + type);
    return undefined;
  }
  return walker.apply(type, tree.slice(1));
};

// Try to bind out tree and return static variable instead of binding
convertToEngine.bindout = function (statement, binding) {
  // We want to process the content of the statement
  // (but still handle the case, we get the content directly)
  var tree = statement[0] === "stat" ? statement[1] : statement;

  var type = tree[0];
  var walker = convertToEngine.walkers[type];
  if (walker) {
    return walker.apply(type, tree.slice(1));
  }
  return new QmlWeb.QMLBinding(binding, tree);
};

// Help logger
convertToEngine.amIn = function (str, tree) {
  console.log(str);
  if (tree) console.log(JSON.stringify(tree, null, "  "));
};

function loadParser() {
  if (typeof QmlWeb.parse !== "undefined") {
    return;
  }

  console.log("Loading parser...");
  var tags = document.getElementsByTagName("script");
  for (var i in tags) {
    if (tags[i].src && tags[i].src.indexOf("/qt.") !== -1) {
      var src = tags[i].src.replace("/qt.", "/qmlweb.parser.");
      // TODO: rewrite to async loading
      var xhr = new XMLHttpRequest();
      xhr.open("GET", src, false);
      xhr.send(null);
      if (xhr.status !== 200 && xhr.status !== 0) {
        // xhr.status === 0 if accessing with file://
        throw new Error("Could not load QmlWeb parser!");
      }
      new Function(xhr.responseText)();
      QmlWeb.parse = QmlWeb.parse;
      QmlWeb.jsparse = QmlWeb.jsparse;
      return;
    }
  }
}

// Function to parse qml and output tree expected by engine
function parseQML(src, file) {
  loadParser();
  QmlWeb.parse.nowParsingFile = file;
  var parsetree = QmlWeb.parse(src, QmlWeb.parse.QmlDocument);
  return convertToEngine(parsetree);
}

QmlWeb.QMLMethod = QMLMethod;
QmlWeb.QMLPropertyDefinition = QMLPropertyDefinition;
QmlWeb.QMLAliasDefinition = QMLAliasDefinition;
QmlWeb.QMLSignalDefinition = QMLSignalDefinition;
QmlWeb.QMLMetaPropertyGroup = QMLMetaPropertyGroup;
QmlWeb.QMLMetaElement = QMLMetaElement;
QmlWeb.convertToEngine = convertToEngine;
QmlWeb.loadParser = loadParser;
QmlWeb.parseQML = parseQML;

/*

QmlWeb.qrc is analogous to the Qt Resource System. It is expected to map a path
within the resource system to the following pieces of data:

1) For a QML Component, it is the return value of QmlWeb.parse
2) For a JavaScript file, it is the return value of QmlWeb.jsparse
2) For an image, it is any URL that an <img> tag can accept (e.g. a standard
   URL to an image resource, or a "data:" URI). If there is no entry for a
   given qrc image path, it will fall back to passing the path right through to
   the DOM. This is mainly a convenience until support for images is added to
   gulp-qmlweb.

The "data-qml" tag on <body> can be set to a "qrc://" URL like
"qrc:///root.qml" to use a pre-parsed "/root.qml" from QmlWeb.qrc.

Since relative URLs are resolved relative to the URL of the containing
component, any relative URL set within a file in the resource system will also
resolve within the resource system. To access a Component, JavaScript or image
file that is stored outside of the resources system from within the resource
system, a full URL must be used (e.g. "http://www.example.com/images/foo.png").

Vice-versa, in order to access a Component, JavaScript or image file that is
stored within the resource system from outside of the resource system, a full
"qrc://" URL must be used (e.g. "qrc:///images/foo.png").

More details here: http://doc.qt.io/qt-5/qml-url.html

*/
QmlWeb.qrc = {};

{
  var BACKGROUNDCOLOR = ['red', 'orange', 'yellow', 'olive', 'green', 'teal', 'blue', 'violet', 'purple', 'pink', 'brown', 'grey', 'black'];

  QmlWeb.registerQmlType({
    module: "DGrid",
    name: "DButtonColumn",
    versions: /.*/,
    baseClass: "DGrid.DColumn", // no UI
    properties: {},
    signals: {
      clicked: [{ name: 'row', type: 'var' }]
    }
  }, function () {
    function _class(meta) {
      var _this19 = this;

      _classCallCheck(this, _class);

      QmlWeb.callSuper(this, meta);
      this.doc_auto_input = true;
      this.doc_type = "Button";
      this.renderCell = function (object) {
        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        var node = arguments[2];
        var options = arguments[3];

        var field = _this19.grid.cell(node).column.field,
            icon = object[field + "_icon"],
            backgroundColor = object[field + "_backgroundColor"];

        _this19.button = document.createElement('button');
        _this19.button.style.display = "block";
        _this19.button.style.marginLeft = "auto";
        _this19.button.style.marginRight = "auto";
        _this19.button.classList.add("ui", "button");
        _this19.button.onclick = function () {
          _this19.clicked(object);
        };

        if (icon) {
          var _classList;

          var classList = void 0,
              iconNode = void 0;
          iconNode = document.createElement("i");
          classList = iconNode.classList;
          (_classList = classList).add.apply(_classList, _toConsumableArray(icon.split(" ").concat(["icon"])));
          _this19.button.innerHTML = "";
          _this19.button.appendChild(iconNode);
          _this19.button.classList.add("icon");
        }

        if (value) {
          _this19.button.appendChild(document.createTextNode(value));
        }

        if (backgroundColor) {
          _this19.button.style.backgroundColor = "";
          _this19.button.classList.remove(_this19._backgroundColor);
          if (BACKGROUNDCOLOR.includes(backgroundColor)) {
            _this19.button.classList.add(backgroundColor);
          } else {
            _this19.button.style.backgroundColor = backgroundColor;
          }
          _this19._backgroundColor = backgroundColor;
        }

        node.appendChild(_this19.button);

        if (typeof _this19.style === 'string') {
          node.style = _this19.style;
        }
        if (_typeof(_this19.style) === 'object') {
          $(node).css(_this19.style);
        }
      };
    }

    _createClass(_class, [{
      key: "validateProperty",
      value: function validateProperty(prop) {
        prop = prop.toLowerCase();
        if (backgroundColor.includes(prop)) return [true, "" + prop];
        return [false, ""];
      }
    }]);

    return _class;
  }());
}

QmlWeb.registerQmlType({
  module: "DGrid",
  name: "DCheckBoxColumn",
  versions: /.*/,
  baseClass: "DGrid.DColumn", // no UI
  properties: {
    readOnly: "bool"
  },
  signals: {
    changed: [{ type: 'bool', name: 'checked' }]
  }
}, function () {
  function _class2(meta) {
    var _this20 = this;

    _classCallCheck(this, _class2);

    QmlWeb.callSuper(this, meta);
    this.renderCell = function (object, value, node, options) {
      var container = document.createElement('div');
      var label = document.createElement('label');
      _this20.checkbox = document.createElement('input');
      _this20.checkbox.type = "checkbox";
      _this20.checkbox.checked = value;
      _this20.checkbox.addEventListener('change', function (event) {
        _this20.changed(event.target.checked);
      });
      label.style.padding = '10px';
      container.style.display = 'flex';
      container.style.justifyContent = 'center';
      container.classList.add('ui', 'checkbox');
      container.appendChild(_this20.checkbox);
      container.appendChild(label);
      $(container).checkbox();
      node.appendChild(container);

      if (_this20.readOnly) {
        container.classList.add('read-only');
      }
      if (typeof _this20.style === 'string') {
        node.style = _this20.style;
      }
      if (_typeof(_this20.style) === 'object') {
        $(node).css(_this20.style);
      }
    };
  }

  return _class2;
}());

QmlWeb.registerQmlType({
  module: "DGrid",
  name: "DColumn",
  versions: /.*/,
  baseClass: "QtQml.QtObject", // no UI
  properties: {
    field: "string",
    //id need to be null, unless CompoundColumns bug
    id: { type: "string", initialValue: null },
    children: "var",
    label: "string",
    className: "var", // CSS class or function
    colSpan: "var",
    rowSpan: "var",
    sortable: { type: "bool", initialValue: true },
    get: { type: "var", initialValue: null }, // function
    set: { type: "var", initialValue: null },
    formatter: { type: "var", initialValue: null },
    renderCell: "var",
    style: 'string',
    //*** Do not uncomment this line!! ***
    // renderHeaderCell cause CompoundColumns bug
    // renderHeaderCell: { type: "var", initialValue: null },
    width: "int",
    hidden: "bool",
    renderExpando: "bool",
    doc_label: "string",
    doc_mandatory: "bool",
    doc_auto_input: "bool",
    doc_read_only: "bool",
    doc_condition: "string",
    doc_remark: "string",
    doc_skip: { type: "bool", initialValue: false },
    doc_type: "string" // override this if you renderCell
  },
  signals: {}
}, function () {
  function _class3(meta) {
    var _this21 = this;

    _classCallCheck(this, _class3);

    QmlWeb.callSuper(this, meta);
    this.styleChanged.connect(this, this.$onStyleChanged);

    this.renderCell = function (object) {
      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
      var node = arguments[2];
      var options = arguments[3];

      if (_this21.formatter) {
        node.innerHTML = _this21.formatter(value, object, node);
      } else {
        node.innerHTML = value;
      }
      if (typeof _this21.style === 'string') {
        node.style = _this21.style;
      }
      if (_typeof(_this21.style) === 'object') {
        $(node).css(_this21.style);
      }
    };
  }

  _createClass(_class3, [{
    key: "$onStyleChanged",
    value: function $onStyleChanged() {
      var _this22 = this;

      if (!this.grid) return;
      var columnSelector = "td[class*=field-" + this.field + "]";
      $.each($(this.grid.contentNode).find(columnSelector), function (i, dom) {
        if (typeof _this22.style === 'string') {
          dom.style = _this22.style;
        }
        if (_typeof(_this22.style) === 'object') {
          $(dom).css(_this22.style);
        }
      });
    }
  }]);

  return _class3;
}());

QmlWeb.registerQmlType({
  module: "DGrid",
  name: "DComboBoxColumn",
  versions: /.*/,
  baseClass: "DGrid.DColumn", // no UI
  properties: {
    model: { type: "var", initialValue: { "default": [{ name: "", id: "" }] } },
    readOnly: { type: "bool", initialValue: false }
  },
  signals: {
    changed: [{ name: "value", type: "var" }, { name: "text", type: "var" }]
  }
}, function () {
  function _class4(meta) {
    var _this23 = this;

    _classCallCheck(this, _class4);

    QmlWeb.callSuper(this, meta);
    this.modelChanged.connect(this, this.$onModelChanged);
    this.readOnlyChanged.connect(this, this.$onReadOnlyChanged);
    this.renderCell = function (object) {
      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
      var node = arguments[2];
      var options = arguments[3];

      var store = _this23.getStore(object, node);

      var dropdownNode = document.createElement("div");
      _this23.inputNode = document.createElement("input");
      _this23.iconNode = document.createElement("i");
      _this23.defaultTextNode = document.createElement("div");
      _this23.menuNode = document.createElement("div");

      dropdownNode.classList.add("ui", "fluid", "selection", "dropdown");
      _this23.inputNode.type = "hidden";
      _this23.inputNode.name = _this23.name;
      _this23.iconNode.classList.add("dropdown", "icon");
      _this23.defaultTextNode.classList.add("default", "text");
      _this23.defaultTextNode.innerHTML = "";
      _this23.menuNode.classList.add("menu");

      store.forEach(function (item) {
        var itemNode = document.createElement("div");
        itemNode.classList.add("item");
        itemNode.setAttribute("data-value", item['id']);
        itemNode.innerHTML = item['name'];
        _this23.menuNode.appendChild(itemNode);
      });

      dropdownNode.appendChild(_this23.inputNode);
      dropdownNode.appendChild(_this23.iconNode);
      dropdownNode.appendChild(_this23.defaultTextNode);
      dropdownNode.appendChild(_this23.menuNode);
      node.appendChild(dropdownNode);

      $(document).ready(function () {
        _this23.dropdown = $(dropdownNode).dropdown();
        _this23.dropdown.dropdown("set selected", value);
        if (_this23.readOnly) {
          _this23.dropdown.dropdown('hide');
          dropdownNode.style.pointerEvents = 'none';
        }
      });

      dropdownNode.addEventListener("change", function () {
        _this23.changed(_this23.dropdown.dropdown("get value"), _this23.dropdown.dropdown("get text"));
      });

      if (typeof _this23.style === 'string') {
        node.style = _this23.style;
      }
      if (_typeof(_this23.style) === 'object') {
        $(node).css(_this23.style);
      }

      node.style.overflow = "visible";
    };
  }

  _createClass(_class4, [{
    key: "getStore",
    value: function getStore(object, node) {
      var field = this.grid.cell(node).column.field,
          store = this.modelMap.get(object[field + "_model"]);
      return store;
    }
  }, {
    key: "extractMap",
    value: function extractMap(value) {
      var splitted = void 0,
          res = {},
          map = value.split(";");

      map = map.filter(function (val) {
        return val && //val is not empty
        val.split(":").length === 2 && //length of splitted val is 2 
        val.split(":")[0] && //the first part of splitted val is not empty
        val.split(":")[1]; //the second part of splitted val is not empty
      });

      map.forEach(function (val) {
        splitted = val.split(":");
        splitted[0] = splitted[0].replace("'", '').trim();
        splitted[1] = splitted[1].replace("'", '').trim();
        res[splitted[0]] = splitted[1];
      });

      return res;
    }
  }, {
    key: "$onModelChanged",
    value: function $onModelChanged() {
      var _this24 = this;

      this.modelMap = new Map();
      this.model.forEach(function (model, index) {
        var modelName = void 0,
            _model = [];
        model.forEach(function (item) {
          //collect items in this model
          if (typeof item !== "string") _model.push(item
          //get the name of this model
          );else if (typeof item === "string") modelName = item;
        });
        //map model name to its model item
        _this24.modelMap.set(modelName, _model);
      });
    }
  }, {
    key: "$onReadOnlyChanged",
    value: function $onReadOnlyChanged() {
      if (!this.dropdown) return;
      if (this.readOnly) {
        this.dropdown.dropdown('hide');
        this.dropdown[0].style.pointerEvents = 'none';
      } else {
        this.dropdown[0].style.pointerEvents = 'auto';
      }
    }
  }]);

  return _class4;
}());

QmlWeb.registerQmlType({
  module: "DGrid",
  name: "DCompoundColumn",
  versions: /.*/,
  baseClass: "QtQml.QtObject", // no UI
  properties: {
    field: "string",
    label: "string",
    children: "list",
    doc_label: "string",
    doc_mandatory: "bool",
    doc_auto_input: "bool",
    doc_read_only: "bool",
    doc_condition: "string",
    doc_remark: "string",
    doc_skip: { type: "bool", initialValue: false },
    doc_type: "string" // override this if you renderCell
  },
  signals: {}
}, function () {
  function _class5(meta) {
    _classCallCheck(this, _class5);

    QmlWeb.callSuper(this, meta);
  }

  return _class5;
}());

/**
 * DCustomColumn allows you to put custom QML in DGrid
 * 
 * <p>you can read row data from `modelData` property, e.g. modelData.id</p>
 * @overview
 */
QmlWeb.registerQmlType({
  module: "DGrid",
  name: "DCustomColumn",
  versions: /.*/,
  baseClass: "DGrid.DColumn", // no UI
  properties: {
    content: "Component"
  },
  defaultProperty: "content",
  signals: {
    dblclicked: []
  }
}, function () {
  function _class6(meta) {
    var _this25 = this;

    _classCallCheck(this, _class6);

    QmlWeb.callSuper(this, meta);
    //keep reference of rendered item
    this.items = {};

    this.renderCell = function (object) {
      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
      var node = arguments[2];
      var options = arguments[3];

      var key = object.hasOwnProperty('storekey') ? object['storekey'] : object['id'];
      _this25.$removeChildren(key);
      _this25.items[key] = _this25.$initialComponent(object);
      node.appendChild(_this25.items[key].dom);
      if (typeof _this25.style === 'string') {
        node.style = _this25.style;
      }
      if (_typeof(_this25.style) === 'object') {
        $(node).css(_this25.style);
      }
      node.ondblclick = function () {
        _this25.dblclicked();
      };
    };
  }

  _createClass(_class6, [{
    key: "$onRemoveRow",
    value: function $onRemoveRow(row) {
      var index = row.id.split('-')[2];
      this.$removeChildren(index);
    }
  }, {
    key: "$initialComponent",
    value: function $initialComponent(object) {
      var QMLOperationState = QmlWeb.QMLOperationState;
      var createProperty = QmlWeb.createProperty;
      var newItem = this.content.$createObject();

      // To properly import JavaScript in the context of a component
      this.content.finalizeImports();

      if (typeof newItem.$properties.modelData === "undefined") {
        createProperty("variant", newItem, "modelData");
      }

      newItem.$properties.modelData.set(object, QmlWeb.QMLProperty.ReasonInit, newItem, null);

      if (QmlWeb.engine.operationState !== QMLOperationState.Init && QmlWeb.engine.operationState !== QMLOperationState.Idle) {
        this.$callOnCompleted(newItem);
      }

      if (QmlWeb.engine.operationState !== QMLOperationState.Init) {
        QmlWeb.engine.$initializePropertyBindings();
      }

      return newItem;
    }
  }, {
    key: "$removeChildren",
    value: function $removeChildren(index) {
      var item = this.items[index];
      if (item) {
        item.$delete();
        this.$removeChildProperties(item);
        delete this.items[index];
      }
    }
  }, {
    key: "$removeChildProperties",
    value: function $removeChildProperties(child) {
      var signals = QmlWeb.engine.completedSignals;
      signals.splice(signals.indexOf(child.Component.completed), 1);
      for (var i = 0; i < child.children.length; i++) {
        this.$removeChildProperties(child.children[i]);
      }
    }
  }, {
    key: "$callOnCompleted",
    value: function $callOnCompleted(child) {
      child.Component.completed();
      var QMLBaseObject = QmlWeb.getConstructor("QtQml", "2.0", "QtObject");
      for (var i = 0; i < child.$tidyupList.length; i++) {
        if (child.$tidyupList[i] instanceof QMLBaseObject) {
          this.$callOnCompleted(child.$tidyupList[i]);
        }
      }
    }
  }]);

  return _class6;
}());

QmlWeb.registerQmlType({
  module: "DGrid",
  name: "DEditorColumn",
  versions: /.*/,
  baseClass: "DGrid.DColumn", // no UI
  properties: {
    editor: { type: "string", initialValue: "text" },
    editOn: { type: "string", initialValue: "click" },
    autoSave: { type: "bool", initialValue: true },
    canEdit: "var"
  },
  signals: {
    dataChanged: []
  }
}, function () {
  function _class7(meta) {
    _classCallCheck(this, _class7);

    QmlWeb.callSuper(this, meta);
    this.Component.completed.connect(this, this.Component$onCompleted);
  }

  _createClass(_class7, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      var _this26 = this;

      this.grid.on('dgrid-datachange', function (event) {
        if (event.cell.column.field === _this26.field) {
          _this26.dataChanged(event);
        }
      });
    }
  }]);

  return _class7;
}());

require(["dojo/_base/declare", "dgrid/Grid", "dgrid/OnDemandGrid", "dgrid/Selection", "dgrid/extensions/ColumnResizer", "dgrid/Keyboard", "dgrid/extensions/ColumnHider", "dojo/aspect", "dojo/dom-class", "dojo/dom-construct", "dojo/dom-style", "dgrid/Editor", "dstore/Memory", "dgrid/extensions/CompoundColumns"], function (declare, dgrid, OnDemandGrid, Selection, ColumnResizer, Keyboard, ColumnHider, aspect, domClass, domConstruct, domStyle, Editor, Memory, CompoundColumns) {

  QmlWeb.registerQmlType({
    module: "DGrid",
    name: "DGrid",
    versions: /.*/,
    baseClass: "Semantic.Html.Dom",
    properties: {
      width: "int",
      height: "int",
      columns: "list",
      enabled: { type: "bool", initialValue: true },
      model: { type: "var", initialValue: [] },
      selectedRow: { type: "var", initialValue: {} },
      showHeader: { type: "bool", initialValue: true },
      cellNavigation: { type: "bool", initialValue: true },
      isSelected: { type: "bool", initialValue: false }
    },
    signals: {
      selected: [{ type: "var", name: "event" }, { type: "var", name: "data" }], // dgrid event
      deselected: [{ type: "var", name: "event" }], // dgrid deselect event
      entered: [],
      selectedCell: [{ type: "var", name: "cell" }], // dgrid deselect event
      reloaded: []
    }
  }, function () {
    function _class8(meta) {
      _classCallCheck(this, _class8);

      QmlWeb.callSuper(this, meta);
      this.Component.completed.connect(this, this.Component$onCompleted);
      this.modelChanged.connect(this, this.$onModelChanged);
      this.widthChanged.connect(this, this.$onWidthChanged);
      this.heightChanged.connect(this, this.$onHeightChanged);
      this.dojoUtil = {};
      this.dojoUtil.domClass = domClass;
      this.dojoUtil.domConstruct = domConstruct;
      this.dojoUtil.domStyle = domStyle;
      this.baseClass = "";
    }

    _createClass(_class8, [{
      key: "$onModelChanged",
      value: function $onModelChanged(newModel, oldModel, propName) {
        if (oldModel.toString() && oldModel.fetched) {
          oldModel.fetched.disconnect(this, this.$onModelFetched);
        }
        if (this.model.fetched) {
          this.model.fetched.connect(this, this.$onModelFetched);
        }
        if (this.widget) {
          this.widget.refresh();
          this.setStore();
          // this.widget.renderArray(this.model);
          this.selectedRow = {};
        }
        this.reloaded();
      }
    }, {
      key: "$onModelFetched",
      value: function $onModelFetched() {
        if (!this.widget) return;

        this.widget.set("collection", this.model.currentStore);
        this.widget.resize();
      }
    }, {
      key: "$onHeightChanged",
      value: function $onHeightChanged() {
        this.dom.style.height = this.height + "px";
      }
    }, {
      key: "$onWidthChanged",
      value: function $onWidthChanged() {
        this.dom.style.width = this.width + "px";
      }
    }, {
      key: "Component$onCompleted",
      value: function Component$onCompleted() {
        var _this27 = this;

        // DGrid is a special case, we need all children to complete parsing first
        //  so all definition of columns are ready for us to render grid
        var columns = this.columns;
        var grid_setting = [OnDemandGrid, Selection, ColumnResizer, Keyboard, ColumnHider, Editor];
        var grid_columns = this.columns;

        // CompoundColumn checking, add into grid setting and clean grid columns
        if (this.isCompoundColumn(columns)) {
          grid_setting.push(CompoundColumns);
          grid_columns = this.makeColumn(this.columns);
        }
        var CustomGrid = declare(grid_setting, {
          removeRow: function removeRow(rowElement, preserveDom) {
            this.inherited(arguments);
            columns.forEach(function (column) {
              if (column.$onRemoveRow) {
                column.$onRemoveRow(rowElement);
              }
            });
          }
        });

        this.widget = new CustomGrid({
          columns: grid_columns,
          selectionMode: "single",
          cellNavigation: this.cellNavigation,
          adjustLastColumn: false,
          keepScrollPosition: true,
          noColumnHider: false,
          showHeader: this.showHeader,
          loadingMessage: 'LOADING . . .',
          noDataMessage: 'ไม่มีข้อมูล',
          minRowsPerPage: 40
        }, this.dom);

        // need to call startup
        // incase grid is in Accordion or Tab
        this.widget.startup();

        this.selectedRow = {};
        this.widget.on('dgrid-select', function (event) {
          //Event Ref: https://github.com/SitePen/dgrid/blob/master/doc/components/mixins/Selection.md
          _this27.selectedRow = _this27.getFirstRowData(event);
          _this27.isSelected = true;
          _this27.selected(event, _this27.selectedRow);
        });

        this.widget.on('dgrid-deselect', function (event) {
          _this27.selectedRow = {};
          _this27.isSelected = false;
          _this27.deselected(event, _this27.getFirstRowData(event));
        });
        this.widget.on('.dgrid-row:dblclick', function () {
          return _this27.entered();
        });
        this.widget.on('dgrid-refresh-complete', function (event) {
          for (key in _this27.widget.selection) {
            if (_this27.widget.selection.hasOwnProperty(key) && _this27.widget.selection[key]) {
              _this27.selectedRow = _this27.widget.row(key).data;
              return;
            }
          }
        });
        this.widget.on('keypress', function () {
          if (event.keyCode === Qt.Key_Enter) {
            _this27.entered();
          }
        });
        this.widget.on('.dgrid-content .dgrid-cell:click', function (evt) {
          _this27.selectedCell(_this27.widget.cell(evt));
        });

        aspect.after(this.widget, "renderRow", function (row, args) {
          if (_this27.renderRow) {
            return _this27.renderRow(row, args, _this27.dojoUtil);
          }
          return row;
        });

        this.setStore();

        this.widget.addKeyHandler(40, function (event) {
          if (_this27.selectedRow['skip_selection']) {
            _this27._downOrIdle(event);
          }
        });

        this.widget.addKeyHandler(38, function (event) {
          if (_this27.selectedRow['skip_selection']) {
            _this27._upOrIdle(event);
          }
        });

        document.body.addEventListener("resizeDgrid", function (evt) {
          // evt.detail.dom: for dom detail;
          //check if evet.detail.dom is a parent or ancestor of this.dom

          //For Accordion, Modal, Tab
          var isParent = evt.detail.dom.contains(_this27.dom);
          isParent && _this27.widget.resize();
        });
      }
    }, {
      key: "_upOrIdle",
      value: function _upOrIdle(event) {
        var lastSelectedRow;
        var currentRow;
        for (var row in this.widget.selection) {
          currentRow = parseInt(row);
          lastSelectedRow = currentRow;
        }
        while (currentRow >= 0) {
          if (!this.widget.row(currentRow).data['skip_selection']) {
            break;
          }
          currentRow -= 1;
        }
        var steps = currentRow >= 0 ? currentRow - lastSelectedRow : 0;
        Keyboard.moveFocusVertical.call(this.widget, event, steps);
      }
    }, {
      key: "_downOrIdle",
      value: function _downOrIdle(event) {
        var lastSelectedRow;
        var currentRow;
        for (var row in this.widget.selection) {
          currentRow = parseInt(row);
          lastSelectedRow = currentRow;
        }
        while (currentRow < this.widget.get('total')) {
          if (!this.widget.row(currentRow).data['skip_selection']) {
            break;
          }
          currentRow += 1;
        }
        var steps = currentRow < this.widget.get('total') ? currentRow - lastSelectedRow : -1;
        Keyboard.moveFocusVertical.call(this.widget, event, steps);
      }
    }, {
      key: "isCompoundColumn",
      value: function isCompoundColumn(columns) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = columns[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            column = _step.value;

            if (column.$class == "DCompoundColumn") {
              return true;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return false;
      }
    }, {
      key: "makeColumn",
      value: function makeColumn(columns) {
        var result = [];
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = columns[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            column = _step2.value;

            if (column.$class == "DCompoundColumn") {
              result.push({
                label: column.label,
                children: this.makeColumn(column.children)
              });
            } else {
              result.push({
                field: column.field,
                label: column.label,
                width: column.width,
                editor: column.editor,
                editOn: column.editOn,
                style: column.style,
                renderCell: column.renderCell,
                renderRow: column.renderRow,
                canEdit: column.canEdit
              });
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        return result;
      }
    }, {
      key: "setStore",
      value: function setStore() {
        if (_typeof(this.model.currentStore) === "object") {
          if (!this.model.target) return;
          if (!this.model.hasQuery) return;
          this.widget.set("collection", this.model.currentStore);
          this.widget.resize();
          return;
        }
        this.model.forEach(function (item, index) {
          item.storekey = index;
        });

        var store = new Memory({
          data: {
            items: this.model,
            identifier: 'storekey'
          }
        });
        this.widget.set("collection", store);
        this.widget.refresh();
        this.widget.resize();
      }
    }, {
      key: "getFirstRowData",
      value: function getFirstRowData(event) {
        if (event.rows.length > 0) return event.rows[0].data;
        return {};
      }
    }, {
      key: "deselectCurrentRow",
      value: function deselectCurrentRow() {
        var currentRow = -1;
        if (!this.widget) return;
        for (var row in this.widget.selection) {
          currentRow = parseInt(row);
        }
        this.widget.deselect(currentRow);
      }
    }, {
      key: "down",
      value: function down() {
        this.go('DOWN');
      }
    }, {
      key: "up",
      value: function up() {
        this.go('UP');
      }
    }, {
      key: "go",
      value: function go(direction) {
        var currentRowID = 1;
        var curRowDom = null;
        var gotoRowDom = null;
        var gotoRowID = -1;
        for (var row in this.widget.selection) {
          currentRowID = parseInt(row);
        }
        this.widget.deselect(currentRowID);
        curRowDom = this.widget.row(currentRowID);

        if (direction === 'UP') {
          gotoRowDom = this.widget.up(curRowDom);
        }
        if (direction === 'DOWN') {
          gotoRowDom = this.widget.down(curRowDom);
        }
        // getIdentity only works with rest store
        // this.widget.collection.getIdentity(gotoRowDom)
        gotoRowID = gotoRowDom.element.id.split('-row-')[1];
        this.widget.select(gotoRowID);
        gotoRowDom.element.scrollIntoViewIfNeeded();
      }
    }, {
      key: "selectRow",
      value: function selectRow(rowID) {
        this.widget.select(rowID);
      }
    }, {
      key: "clear",
      value: function clear() {
        this.widget.cleanup();
      }
    }, {
      key: "clearSelection",
      value: function clearSelection() {
        this.widget.clearSelection();
      }
    }, {
      key: "selectFirstRow",
      value: function selectFirstRow() {
        if (this.widget.contentNode['firstChild']) {
          var firstRow = this.widget.contentNode['firstChild']['nextSibling'];
          var identity = firstRow.id;
          identity && this.widget.select(identity.split('-row-')[1]);
        }
      }
    }, {
      key: "resize",
      value: function resize() {
        this.widget.resize();
      }
    }, {
      key: "toggleColumnHiddenState",
      value: function toggleColumnHiddenState(field, hidden) {
        var _this28 = this;

        if (typeof field === 'number') {
          this.widget.toggleColumnHiddenState(field, hidden);
        } else {
          this.columns.forEach(function (col, index) {
            if (col.field === field) {
              _this28.widget.toggleColumnHiddenState(index, hidden);
            }
          });
        }
      }

      //warning this method will style column's header as well

    }, {
      key: "styleColumn",
      value: function styleColumn(field, style) {
        var _this29 = this;

        if (typeof field === 'number') {
          this.widget.styleColumn(field, style);
        } else {
          this.columns.forEach(function (col, index) {
            if (col.field === field) {
              _this29.widget.styleColumn(index, style);
            }
          });
        }
      }

      //style only column's body

    }, {
      key: "styleCell",
      value: function styleCell(field, style) {
        this.columns.forEach(function (col, index) {
          if (col.field === field) {
            col.style = style;
          }
        });
      }
    }]);

    return _class8;
  }());
});
require(["dojo/_base/declare", "dgrid/Grid", "dgrid/OnDemandGrid", "dgrid/Selection", "dgrid/extensions/ColumnResizer", "dgrid/Keyboard", "dgrid/extensions/ColumnHider", "dojo/aspect", "dojo/dom-class", "dojo/dom-construct", "dojo/dom-style", "dgrid/Editor", "dgrid/ColumnSet", "dstore/Memory", "dstore/Trackable", "dstore/Tree", "dgrid/Tree"], function (declare, dgrid, OnDemandGrid, Selection, ColumnResizer, Keyboard, ColumnHider, aspect, domClass, domConstruct, domStyle, Editor, ColumnSet, Memory, Trackable, TreeStoreMixin, Tree) {

  QmlWeb.registerQmlType({
    module: "DGrid",
    name: "DGridColumnSet",
    versions: /.*/,
    baseClass: "Semantic.Html.Dom",
    properties: {
      width: "int",
      height: "int",
      columnSets: "var",
      enabled: { type: "bool", initialValue: true },
      model: { type: "var", initialValue: [] },
      selectedRow: { type: "var", initialValue: {} },
      showHeader: { type: "bool", initialValue: true },
      cellNavigation: { type: "bool", initialValue: true },
      tree: { type: "bool", initialValue: false }
    },
    signals: {
      selected: [{ type: "var", name: "event" }, { type: "var", name: "data" }], // dgrid event
      deselected: [{ type: "var", name: "event" }], // dgrid deselect event
      entered: [],
      selectedCell: [{ type: "var", name: "cell" }] // dgrid deselect event
    }
  }, function () {
    function _class9(meta) {
      _classCallCheck(this, _class9);

      QmlWeb.callSuper(this, meta);
      this.Component.completed.connect(this, this.Component$onCompleted);
      this.modelChanged.connect(this, this.$onModelChanged);
      this.widthChanged.connect(this, this.$onWidthChanged);
      this.heightChanged.connect(this, this.$onHeightChanged);
      this.dojoUtil = {};
      this.dojoUtil.domClass = domClass;
      this.dojoUtil.domConstruct = domConstruct;
      this.dojoUtil.domStyle = domStyle;
      this.baseClass = "";
    }

    _createClass(_class9, [{
      key: "$onModelChanged",
      value: function $onModelChanged(newModel, oldModel, propName) {
        if (oldModel.toString() && oldModel.fetched) {
          oldModel.fetched.disconnect(this, this.$onModelFetched);
        }
        if (this.model.fetched) {
          this.model.fetched.connect(this, this.$onModelFetched);
        }
        if (this.widget) {
          this.widget.refresh();
          this.setStore();
          // this.widget.renderArray(this.model);
          this.selectedRow = {};
        }
      }
    }, {
      key: "$onModelFetched",
      value: function $onModelFetched() {
        if (!this.widget) return;

        this.widget.set("collection", this.model.currentStore);
        this.widget.resize();
      }
    }, {
      key: "$onHeightChanged",
      value: function $onHeightChanged() {
        this.dom.style.height = this.height + "px";
      }
    }, {
      key: "$onWidthChanged",
      value: function $onWidthChanged() {
        this.dom.style.width = this.width + "px";
      }
    }, {
      key: "Component$onCompleted",
      value: function Component$onCompleted() {
        var _this30 = this;

        // DGrid is a special case, we need all children to complete parsing first
        //  so all definition of columnSets are ready for us to render grid
        var columnSets = this.columnSets;
        var grid_setting = void 0;
        if (this.tree) {
          grid_setting = [OnDemandGrid, ColumnSet, Selection, Keyboard, ColumnHider, Editor, Tree];
        } else {
          grid_setting = [OnDemandGrid, ColumnSet, Selection, Keyboard, ColumnHider, Editor];
        }

        var CustomGrid = declare(grid_setting, {
          removeRow: function removeRow(rowElement, preserveDom) {
            this.inherited(arguments);
            columnSets.forEach(function (column) {
              if (column.$onRemoveRow) {
                column.$onRemoveRow(rowElement);
              }
            });
          }
        });

        this.widget = new CustomGrid({
          columnSets: columnSets,
          selectionMode: "single",
          cellNavigation: this.cellNavigation,
          keepScrollPosition: true,
          noColumnHider: false,
          showHeader: this.showHeader,
          loadingMessage: 'LOADING . . .',
          noDataMessage: 'ไม่มีข้อมูล',
          minRowsPerPage: 40
        }, this.dom);

        // need to call startup
        // incase grid is in Accordion or Tab
        this.widget.startup();

        this.selectedRow = {};
        this.widget.on('dgrid-select', function (event) {
          //Event Ref: https://github.com/SitePen/dgrid/blob/master/doc/components/mixins/Selection.md
          _this30.selectedRow = _this30.getFirstRowData(event);
          _this30.selected(event, _this30.selectedRow);
        });

        this.widget.on('dgrid-deselect', function (event) {
          return _this30.deselected(event, _this30.getFirstRowData(event));
        });
        this.widget.on('.dgrid-row:dblclick', function () {
          return _this30.entered();
        });
        this.widget.on('dgrid-refresh-complete', function (event) {
          for (key in _this30.widget.selection) {
            if (_this30.widget.selection.hasOwnProperty(key) && _this30.widget.selection[key]) {
              _this30.selectedRow = _this30.widget.row(key).data;
              return;
            }
          }
        });
        this.widget.on('keypress', function () {
          if (event.keyCode === Qt.Key_Enter) {
            _this30.entered();
          }
        });
        this.widget.on('.dgrid-content .dgrid-cell:click', function (evt) {
          _this30.selectedCell(_this30.widget.cell(evt));
        });

        aspect.after(this.widget, "renderRow", function (row, args) {
          if (_this30.renderRow) {
            return _this30.renderRow(row, args, _this30.dojoUtil);
          }
          return row;
        });

        this.setStore();

        this.widget.addKeyHandler(40, function (event) {
          if (_this30.selectedRow['skip_selection']) {
            _this30._downOrIdle(event);
          }
        });

        this.widget.addKeyHandler(38, function (event) {
          if (_this30.selectedRow['skip_selection']) {
            _this30._upOrIdle(event);
          }
        });

        document.body.addEventListener("resizeDgrid", function (evt) {
          // evt.detail.dom: for dom detail;
          //check if evet.detail.dom is a parent or ancestor of this.dom

          //For Accordion, Modal, Tab
          var isParent = evt.detail.dom.contains(_this30.dom);
          isParent && _this30.widget.resize();
        });

        if (this.id) {
          this.dom.classList.add(this.id);
        }
      }
    }, {
      key: "_upOrIdle",
      value: function _upOrIdle(event) {
        var lastSelectedRow;
        var currentRow;
        for (var row in this.widget.selection) {
          currentRow = parseInt(row);
          lastSelectedRow = currentRow;
        }
        while (currentRow >= 0) {
          if (!this.widget.row(currentRow).data['skip_selection']) {
            break;
          }
          currentRow -= 1;
        }
        var steps = currentRow >= 0 ? currentRow - lastSelectedRow : 0;
        Keyboard.moveFocusVertical.call(this.widget, event, steps);
      }
    }, {
      key: "_downOrIdle",
      value: function _downOrIdle(event) {
        var lastSelectedRow;
        var currentRow;
        for (var row in this.widget.selection) {
          currentRow = parseInt(row);
          lastSelectedRow = currentRow;
        }
        while (currentRow < this.widget.get('total')) {
          if (!this.widget.row(currentRow).data['skip_selection']) {
            break;
          }
          currentRow += 1;
        }
        var steps = currentRow < this.widget.get('total') ? currentRow - lastSelectedRow : -1;
        Keyboard.moveFocusVertical.call(this.widget, event, steps);
      }
    }, {
      key: "findChildren",
      value: function findChildren(items, parent_id, index) {
        var _this31 = this;

        if (parent_id === false) {
          items.id = index;
        } else {
          items.id = parent_id + '_' + index;
        }
        if ('children' in items && _typeof(items.children) === "object") {
          items.hasChildren = true;
          items.children.forEach(function (child, i) {
            child = _this31.findChildren(child, items.id, i);
          });
        }
        return items;
      }
    }, {
      key: "setStore",
      value: function setStore() {
        var _this32 = this;

        if (_typeof(this.model.store) === "object") {
          if (!this.model.target) return;
          this.widget.set("collection", this.model.store);
          this.widget.resize();
          return;
        }
        var store = void 0;
        if (this.tree) {
          this.model.forEach(function (items, index) {
            items = _this32.findChildren(items, false, index);
          });

          store = new (declare([Memory, Trackable, TreeStoreMixin]))({
            data: this.model,
            getChildren: function getChildren(parent) {
              return new Memory({
                data: parent.children
              });
            },
            mayHaveChildren: function mayHaveChildren(object) {
              return 'hasChildren' in object ? object.hasChildren : false;
            }
          });
        } else {
          this.model.forEach(function (item, index) {
            item.storekey = index;
          });

          store = new Memory({
            data: {
              items: this.model,
              identifier: 'storekey'
            }
          });
        }

        this.widget.set("collection", store);
        this.widget.refresh();
        this.widget.resize();
      }
    }, {
      key: "clear",
      value: function clear() {
        this.widget.cleanup();
      }
    }, {
      key: "clearSelection",
      value: function clearSelection() {
        this.widget.clearSelection();
      }
    }, {
      key: "getFirstRowData",
      value: function getFirstRowData(event) {
        if (event.rows.length > 0) return event.rows[0].data;
        return {};
      }
    }, {
      key: "deselectCurrentRow",
      value: function deselectCurrentRow() {
        var currentRow = -1;
        for (var row in this.widget.selection) {
          currentRow = parseInt(row);
        }
        this.widget.deselect(currentRow);
        this.selectedRow = {};
      }
    }, {
      key: "down",
      value: function down() {
        var currentRow = -1;
        for (var row in this.widget.selection) {
          currentRow = parseInt(row);
        }
        this.widget.deselect(currentRow);
        if (this.widget._total == currentRow + 1) {
          currentRow -= 1;
        }
        this.widget.select(currentRow + 1);
        curRow = this.widget.row(currentRow + 1);

        if (curRow.element) curRow.element.scrollIntoViewIfNeeded();
      }
    }, {
      key: "up",
      value: function up() {
        var currentRow = 1;
        for (var row in this.widget.selection) {
          currentRow = parseInt(row);
        }
        this.widget.deselect(currentRow);
        if (currentRow == 0) {
          currentRow = 1;
        }
        this.widget.select(currentRow - 1);
        curRow = this.widget.row(currentRow - 1);

        if (curRow.element) curRow.element.scrollIntoViewIfNeeded();
      }
    }, {
      key: "selectRow",
      value: function selectRow(rowID) {
        this.widget.select(rowID);
      }
    }, {
      key: "resize",
      value: function resize() {
        this.widget.resize();
      }
    }]);

    return _class9;
  }());
});
require(['dojo/_base/declare', 'dgrid/OnDemandGrid'], function (declare, OnDemandGrid) {

  QmlWeb.registerQmlType({
    module: 'DGrid',
    name: 'DGridRepeater',
    versions: /.*/,
    baseClass: 'DGrid.DGrid',
    properties: {
      content: 'Component',
      layout: { type: 'string', initialValue: '' }
    },
    defaultProperty: 'content'
  }, function () {
    function _class10(meta) {
      _classCallCheck(this, _class10);

      QmlWeb.callSuper(this, meta);
      this.layoutChanged.connect(this, this.$onLayoutChanged);
      this.items = {};
      this.contentClass = '';
      this.containerClass = '';
    }

    _createClass(_class10, [{
      key: "Component$onCompleted",
      value: function Component$onCompleted() {
        var _this33 = this;

        var mixins = [OnDemandGrid];
        var onRemoveRow = this.$onRemoveRow.bind(this);
        var CustomGrid = declare(mixins, {
          removeRow: function removeRow(rowElement, preserveDom) {
            this.inherited(arguments);
            onRemoveRow(rowElement);
          }
        });

        this.widget = new CustomGrid({
          columns: [{ label: ' ', field: '___' }],
          keepScrollPosition: true,
          showHeader: false,
          loadingMessage: 'LOADING . . .',
          noDataMessage: 'ไม่มีข้อมูล',
          minRowsPerPage: 40
        }, this.dom);

        this.widget.domNode.classList.add('grid-repeater');
        this.widget.renderRow = this.renderRow.bind(this);
        this.widget.startup();

        this.completed = true;
        this.$onLayoutChanged();
        this.$onStyleChanged();

        this.setStore();

        document.body.addEventListener('resizeDgrid', function (evt) {
          var isParent = evt.detail.dom.contains(_this33.dom);
          isParent && _this33.widget.resize();
        });
      }
    }, {
      key: "renderRow",
      value: function renderRow(row) {
        var key = row['storekey'] || row['id'],
            rowNode;
        this.$removeChildren(key);
        this.items[key] = this.$initialComponent(row);
        rowNode = this.items[key] ? this.items[key].dom : document.createElement('div');

        if (this.contentClass) {
          rowNode.classList.add(this.contentClass);
        }

        return rowNode;
      }
    }, {
      key: "$onLayoutChanged",
      value: function $onLayoutChanged() {
        if (!this.completed) return;
        if (!this.layout) return;

        if (this.layout === '') {
          this.containerClass = '';
          this.contentClass = '';
          this.widget.contentNode.classList.remove('grid-view');
          this.widget.contentNode.classList.remove('list-view');
        }
        if (this.layout === 'list') {
          this.containerClass = 'list-view';
          this.contentClass = 'list-view';
        }
        if (this.layout === 'grid') {
          this.containerClass = 'grid-view';
          this.contentClass = 'grid-view';
        }
        if (this.containerClass) {
          this.widget.contentNode.classList.add(this.containerClass);
        }

        this.widget.refresh();
      }
    }, {
      key: "$onStyleChanged",
      value: function $onStyleChanged() {
        if (!this.completed) return;
        if (!this.style) return;

        if (typeof this.style === 'string') {
          this.widget.contentNode.style = this.style;
        }
        if (_typeof(this.style) === 'object') {
          $(this.widget.contentNode).css(this.style);
        }

        this.widget.contentNode.classList.remove('grid-view');
        this.widget.contentNode.classList.remove('list-view');

        if (this.containerClass) {
          this.widget.contentNode.classList.add(this.containerClass);
        }
      }
    }, {
      key: "$onRemoveRow",
      value: function $onRemoveRow(row) {
        var index = row.id.split('-')[2];
        this.$removeChildren(index);
      }
    }, {
      key: "$initialComponent",
      value: function $initialComponent(object) {
        if (!this.content) return false;

        var QMLOperationState = QmlWeb.QMLOperationState;
        var createProperty = QmlWeb.createProperty;
        var newItem = this.content.$createObject();

        this.content.finalizeImports();

        if (typeof newItem.$properties.modelData === 'undefined') {
          createProperty('variant', newItem, 'modelData');
        }

        newItem.$properties.modelData.set(object, QmlWeb.QMLProperty.ReasonInit, newItem, null);

        newItem.parent = this;

        if (QmlWeb.engine.operationState !== QMLOperationState.Init && QmlWeb.engine.operationState !== QMLOperationState.Idle) {
          this.$callOnCompleted(newItem);
        }

        if (QmlWeb.engine.operationState !== QMLOperationState.Init) {
          QmlWeb.engine.$initializePropertyBindings();
        }

        return newItem;
      }
    }, {
      key: "$removeChildren",
      value: function $removeChildren(index) {
        var item = this.items[index];
        if (item) {
          item.$delete();
          item.parent = undefined;
          this.$removeChildProperties(item);
          item = undefined;
          delete this.items[index];
        }
      }
    }, {
      key: "$removeChildProperties",
      value: function $removeChildProperties(child) {
        var signals = QmlWeb.engine.completedSignals;
        signals.splice(signals.indexOf(child.Component.completed), 1);
        for (var i = 0; i < child.children.length; i++) {
          this.$removeChildProperties(child.children[i]);
        }
      }
    }, {
      key: "$callOnCompleted",
      value: function $callOnCompleted(child) {
        child.Component.completed();
        var QMLBaseObject = QmlWeb.getConstructor('QtQml', '2.0', 'QtObject');
        for (var i = 0; i < child.$tidyupList.length; i++) {
          if (child.$tidyupList[i] instanceof QMLBaseObject) {
            this.$callOnCompleted(child.$tidyupList[i]);
          }
        }
      }
    }]);

    return _class10;
  }());
});
QmlWeb.registerQmlType({
  module: "DGrid",
  name: "DSimpleComboBoxColumn",
  versions: /.*/,
  baseClass: "DComboBoxColumn", // no UI
  properties: {
    model: {
      type: "var",
      initialValue: {
        "default": [{ name: "", id: "" }]
      }
    }
  },
  signals: {
    changed: [{ name: 'value', type: 'var' }, { name: 'text', type: 'var' }]
  }
}, function () {
  function _class11(meta) {
    _classCallCheck(this, _class11);

    QmlWeb.callSuper(this, meta);
  }

  _createClass(_class11, [{
    key: "getStore",
    value: function getStore() {
      return this.model;
    }
  }, {
    key: "extractMap",
    value: function extractMap() {}
  }, {
    key: "$onModelChanged",
    value: function $onModelChanged() {}
  }]);

  return _class11;
}());

require(["dojo/_base/declare", "dstore/Request", "dstore/Rest", "dstore/Trackable", "dstore/SimpleQuery"], function (declare, Request, Rest, SimpleQuery, Trackable) {
  var TrackableRest = declare([Rest, SimpleQuery, Trackable], {
    _getTarget: function _getTarget(id) {
      // normalize URL for resource, e.g., /apis/REG/patient/1/ (always have the trailing slash)
      var target = this.target;
      if (target.slice(-1) == '/') {
        return target + id + '/';
      } else {
        return target + '/' + id + '/';
      }
    }
  });
  QmlWeb.registerQmlType({
    module: "DGrid",
    name: "RestStore",
    versions: /.*/,
    baseClass: "QtQml.QtObject", // no UI
    properties: {
      //id need to be null, unless CompoundColumns bug
      id: { type: "string", initialValue: null },
      target: "string",
      rangeStartParam: { type: "string", initialValue: "offset" },
      rangeCountParam: { type: "string", initialValue: "limit" },
      sortParam: { type: "string", initialValue: "sort" },
      readOnly: { type: "bool", initialValue: true },
      query: { type: "var", initialValue: {} }
    },
    signals: {
      fetched: []
    }
  }, function () {
    function _class12(meta) {
      _classCallCheck(this, _class12);

      QmlWeb.callSuper(this, meta);
      this.Component.completed.connect(this, this.Component$onCompleted);
      this.rangeStartParamChanged.connect(this, this.$onRangeStartParamChanged);
      this.rangeCountParamChanged.connect(this, this.$onRangeCountParamChanged);
      this.targetChanged.connect(this, this.$onTargetChanged);
      this.readOnlyChanged.connect(this, this.$onReadOnlyChanged);
      this.queryChanged.connect(this, this.$onQueryChanged);
      this.createStore();
    }

    _createClass(_class12, [{
      key: "createStore",
      value: function createStore() {
        var StoreClass = this.readOnly ? Request : TrackableRest;
        this.store = new StoreClass({
          target: this.target,
          rangeStartParam: this.rangeStartParam,
          rangeCountParam: this.rangeCountParam,
          sortParam: this.sortParam,
          headers: { 'X-CSRFToken': this.getCookie('csrftoken') }
        });
        this.currentStore = this.store;
        this.hasQuery = false;
      }
    }, {
      key: "_setCollection",
      value: function _setCollection() {
        if (this.hasQuery) {
          this.fetched();
        }
      }
    }, {
      key: "filter",
      value: function filter(query) {
        // query Example 
        // query = {
        // 	name1 : value1,
        // 	name2 : value2,
        // }
        this.bySystem = true;
        this.query = query;
        this.bySystem = false;
        this.currentStore = this.store.filter(query);
        this.hasQuery = true;
        this._setCollection();
      }
    }, {
      key: "Component$onCompleted",
      value: function Component$onCompleted() {}
    }, {
      key: "$onQueryChanged",
      value: function $onQueryChanged() {
        if (this.bySystem) {
          return;
        }
        this.filter(this.query);
      }
    }, {
      key: "$onReadOnlyChanged",
      value: function $onReadOnlyChanged() {
        this.createStore();
        this._setCollection();
      }
    }, {
      key: "$onRangeStartParamChanged",
      value: function $onRangeStartParamChanged() {
        this.store.rangeStartParam = this.rangeStartParam;
        this.currentStore = this.store;
      }
    }, {
      key: "$onRangeCountParamChanged",
      value: function $onRangeCountParamChanged() {
        this.store.rangeCountParam = this.rangeCountParam;
        this.currentStore = this.store;
      }
    }, {
      key: "$onTargetChanged",
      value: function $onTargetChanged() {
        this.store.target = this.target;
        this._setCollection();
      }
    }, {
      key: "addRow",
      value: function addRow(object) {
        return this.store.add(object);
      }
    }, {
      key: "editRow",
      value: function editRow(object) {
        if (object.id === undefined) {
          throw new Error("object must contains 'id' to edit row");
        }
        return this.store.put(object);
      }
    }, {
      key: "removeRow",
      value: function removeRow(id) {
        return this.store.remove(id);
      }
    }, {
      key: "getRow",
      value: function getRow(id) {
        return this.store.get(id);
      }
    }, {
      key: "getCookie",
      value: function getCookie(name) {
        var cookieValue = null;
        if (document.cookie && document.cookie != '') {
          var cookies = document.cookie.split(';');
          for (var i = 0; i < cookies.length; i++) {
            var cookie = cookies[i].trim();
            // Does this cookie string begin with the name we want?
            if (cookie.substring(0, name.length + 1) == name + '=') {
              cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
              break;
            }
          }
        }
        return cookieValue;
      }
    }]);

    return _class12;
  }());
});

require(["dojo/_base/declare", 'dgrid/OnDemandGrid', "dgrid/Selection", "dgrid/extensions/ColumnResizer", "dgrid/Keyboard", "dgrid/extensions/ColumnHider", "dojo/aspect", "dojo/dom-class", "dojo/dom-construct", "dojo/dom-style", 'dgrid/Editor', 'dstore/Memory', 'dstore/Trackable', 'dstore/Tree', 'dgrid/Tree'], function (declare, OnDemandGrid, Selection, ColumnResizer, Keyboard, ColumnHider, aspect, domClass, domConstruct, domStyle, Editor, Memory, Trackable, TreeStoreMixin, Tree) {

  QmlWeb.registerQmlType({
    module: "DGrid",
    name: "Tree",
    versions: /.*/,
    baseClass: "Semantic.Html.Dom",
    properties: {
      width: "int",
      height: "int",
      columns: "list",
      enabled: { type: "bool", initialValue: true },
      model: { type: "var", initialValue: [] },
      selectedRow: { type: "var", initialValue: {} },
      expand: "bool",
      collapseOnRefresh: "bool",
      shouldExpand: "var" //function(row, level, previouslyExpanded)
    },
    signals: {
      selected: [{ type: "var", name: "event" }, { type: "var", name: "data" }], // dgrid event
      deselected: [{ type: "var", name: "event" }], // dgrid deselect event
      entered: []
    }
  }, function () {
    function _class13(meta) {
      _classCallCheck(this, _class13);

      QmlWeb.callSuper(this, meta);
      this.Component.completed.connect(this, this.Component$onCompleted);
      this.modelChanged.connect(this, this.$onModelChanged);
      this.widthChanged.connect(this, this.$onWidthChanged);
      this.heightChanged.connect(this, this.$onHeightChanged);
    }

    _createClass(_class13, [{
      key: "Component$onCompleted",
      value: function Component$onCompleted() {
        var _this34 = this;

        // DGrid is a special case, we need all children to complete parsing first
        //  so all definition of columns are ready for us to render grid
        var columns = this.columns;
        var CustomGrid = declare([OnDemandGrid, Keyboard, Selection, Tree, ColumnResizer, ColumnHider], {
          removeRow: function removeRow(rowElement, preserveDom) {
            this.inherited(arguments);
            columns.forEach(function (column) {
              if (column.$onRemoveRow) {
                column.$onRemoveRow(rowElement);
              }
            });
          }
        });
        var tree = this;
        // this.columns[0].renderExpando = true
        this.widget = new CustomGrid({
          columns: this.columns,
          selectionMode: "single",
          cellNavigation: true,
          adjustLastColumn: false,
          keepScrollPosition: true,
          noColumnHider: false,
          showHeader: true,
          shouldExpand: this.shouldExpand,
          collapseOnRefresh: this.collapseOnRefresh,
          loadingMessage: 'LOADING . . .',
          noDataMessage: 'ไม่มีข้อมูล'
          // shouldExpand: function(object){
          //   return (tree.expand !== undefined) ? tree.expand : true
          // }
        }, this.dom);
        this.widget.startup();

        this.selectedRow = {};
        this.widget.on('dgrid-select', function (event) {
          //Event Ref: https://github.com/SitePen/dgrid/blob/master/doc/components/mixins/Selection.md
          _this34.selectedRow = _this34.getFirstRowData(event);
          _this34.selected(event, _this34.selectedRow);
        });

        aspect.after(this.widget, "renderRow", function (row, args) {
          if (_this34.renderRow) {
            return _this34.renderRow(row, args, _this34.dojoUtil);
          }
          return row;
        });

        this.setStore();

        document.body.addEventListener("resizeDgrid", function (evt) {
          // evt.detail.dom: for dom detail;
          //check if evet.detail.dom is a parent or ancestor of this.dom

          //For Accordion, Modal, Tab
          var isParent = evt.detail.dom.contains(_this34.dom);
          isParent && _this34.widget.resize();
        });
      }
    }, {
      key: "$onHeightChanged",
      value: function $onHeightChanged() {
        this.dom.style.height = this.height + "px";
      }
    }, {
      key: "$onWidthChanged",
      value: function $onWidthChanged() {
        this.dom.style.width = this.width + "px";
      }
    }, {
      key: "$onModelChanged",
      value: function $onModelChanged() {
        if (this.widget) {
          this.widget.refresh();
          this.setStore();
          // this.widget.renderArray(this.model);
          this.selectedRow = {};
        }
      }
    }, {
      key: "getFirstRowData",
      value: function getFirstRowData(event) {
        if (event.rows.length > 0) return event.rows[0].data;
        return {};
      }
    }, {
      key: "findChildren",
      value: function findChildren(items, parent_id, index) {
        var _this35 = this;

        if (parent_id === false) {
          items.id = index;
        } else {
          items.id = parent_id + '_' + index;
        }
        if ('children' in items && _typeof(items.children) === "object") {
          items.hasChildren = true;
          items.children.forEach(function (child, i) {
            child = _this35.findChildren(child, items.id, i);
          });
        }
        return items;
      }
    }, {
      key: "setStore",
      value: function setStore() {
        var _this36 = this;

        this.model.forEach(function (items, index) {
          items = _this36.findChildren(items, false, index);
        });
        var store = new (declare([Memory, Trackable, TreeStoreMixin]))({
          data: this.model,
          getChildren: function getChildren(parent) {
            return new Memory({
              data: parent.children
            });
          },
          mayHaveChildren: function mayHaveChildren(object) {
            return 'hasChildren' in object ? object.hasChildren : false;
          }
        });
        this.widget.set("collection", store);
        this.widget.refresh();
        this.widget.resize();
      }
    }, {
      key: "resize",
      value: function resize() {
        this.widget.resize();
      }
    }]);

    return _class13;
  }());
});
QmlWeb.registerQmlType({
  module: "QmlWeb.Dom",
  name: "DomElement",
  versions: /.*/,
  baseClass: "QtQuick.Item",
  properties: {
    tagName: { type: "string", initialValue: "div" }
  }
}, function () {
  function _class14(meta) {
    _classCallCheck(this, _class14);

    meta.tagName = meta.object.tagName;
    QmlWeb.callSuper(this, meta);

    // TODO: support properties, styles, perhaps changing the tagName
  }

  return _class14;
}());

;
QmlWeb.deepEqual = function () {
  // adapted from 'deep-equal 1.0.1'
  // https://github.com/substack/node-deep-equal

  var supportsArgumentsClass = function () {
    return Object.prototype.toString.call(arguments);
  }() == '[object Arguments]';

  var isArguments;
  if (supportsArgumentsClass) {
    isArguments = function isArguments(object) {
      return Object.prototype.toString.call(object) == '[object Arguments]';
    };
  } else {
    isArguments = function isArguments(object) {
      return object && (typeof object === "undefined" ? "undefined" : _typeof(object)) == 'object' && typeof object.length == 'number' && Object.prototype.hasOwnProperty.call(object, 'callee') && !Object.prototype.propertyIsEnumerable.call(object, 'callee') || false;
    };
  }

  var objectKeys;
  if (typeof Object.keys === 'function') {
    objectKeys = Object.keys;
  } else {
    objectKeys = function objectKeys(obj) {
      var keys = [];
      for (var key in obj) {
        keys.push(key);
      }return keys;
    };
  }

  var pSlice = Array.prototype.slice;

  var deepEqual = function deepEqual(actual, expected, opts) {
    if (!opts) opts = {};
    // 7.1. All identical values are equivalent, as determined by ===.
    if (actual === expected) {
      return true;
    } else if (actual instanceof Date && expected instanceof Date) {
      return actual.getTime() === expected.getTime();

      // 7.3. Other pairs that do not both pass typeof value == 'object',
      // equivalence is determined by ==.
    } else if (!actual || !expected || (typeof actual === "undefined" ? "undefined" : _typeof(actual)) != 'object' && (typeof expected === "undefined" ? "undefined" : _typeof(expected)) != 'object') {
      return opts.strict ? actual === expected : actual == expected;

      // 7.4. For all other Object pairs, including Array objects, equivalence is
      // determined by having the same number of owned properties (as verified
      // with Object.prototype.hasOwnProperty.call), the same set of keys
      // (although not necessarily the same order), equivalent values for every
      // corresponding key, and an identical 'prototype' property. Note: this
      // accounts for both named and indexed properties on Arrays.
    } else {
      return objEquiv(actual, expected, opts);
    }
  };

  var isUndefinedOrNull = function isUndefinedOrNull(value) {
    return value === null || value === undefined;
  };

  var isBuffer = function isBuffer(x) {
    if (!x || (typeof x === "undefined" ? "undefined" : _typeof(x)) !== 'object' || typeof x.length !== 'number') return false;
    if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
      return false;
    }
    if (x.length > 0 && typeof x[0] !== 'number') return false;
    return true;
  };

  var objEquiv = function objEquiv(a, b, opts) {
    var i, key;
    if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return false;
    // an identical 'prototype' property.
    if (a.prototype !== b.prototype) return false;
    //~~~I've managed to break Object.keys through screwy arguments passing.
    //   Converting to array solves the problem.
    if (isArguments(a)) {
      if (!isArguments(b)) {
        return false;
      }
      a = pSlice.call(a);
      b = pSlice.call(b);
      return deepEqual(a, b, opts);
    }
    if (isBuffer(a)) {
      if (!isBuffer(b)) {
        return false;
      }
      if (a.length !== b.length) return false;
      for (i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) return false;
      }
      return true;
    }
    try {
      var ka = objectKeys(a),
          kb = objectKeys(b);
    } catch (e) {
      //happens when one is a string literal and the other isn't
      return false;
    }
    // having the same number of owned properties (keys incorporates
    // hasOwnProperty)
    if (ka.length != kb.length) return false;
    //the same set of keys (although not necessarily the same order),
    ka.sort();
    kb.sort();
    //~~~cheap key test
    for (i = ka.length - 1; i >= 0; i--) {
      if (ka[i] != kb[i]) return false;
    }
    //equivalent values for every corresponding key, and
    //~~~possibly expensive deep test
    for (i = ka.length - 1; i >= 0; i--) {
      key = ka[i];
      if (!deepEqual(a[key], b[key], opts)) return false;
    }
    return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b));
  };
  return deepEqual;
}();
require(['dstore/Memory', 'dstore/RequestMemory', "dstore/Cache", 'dstore/Request'], function (Memory, RequestMemory, Cache, Request) {

  QmlWeb.registerQmlType({
    module: "QmlWeb",
    name: "RequestMemory",
    versions: /.*/,
    baseClass: "QtQml.QtObject",
    properties: {
      url: "string"
    },
    signals: {
      fetched: []
    }
  }, function () {
    function _class15(meta) {
      _classCallCheck(this, _class15);

      QmlWeb.callSuper(this, meta);
      this.Component.completed.connect(this, this.Component$onCompleted);
    }

    _createClass(_class15, [{
      key: "Component$onCompleted",
      value: function Component$onCompleted() {
        this.fetch();
      }
    }, {
      key: "getItem",
      value: function getItem(value) {
        var data = [];
        this.store.get(value).then(function (object) {
          data.push(object);
        });
        return data;
      }
    }, {
      key: "getItems",
      value: function getItems() {
        var data = [];
        this.store.forEach(function (object) {
          data.push(object);
        });
        return data;
      }

      // use this method to set a queryset for filter()

    }, {
      key: "getFilter",
      value: function getFilter() {
        // Operator

        // eq: Property values must equal the filter value argument.
        // ne: Property values must not equal the filter value argument.
        // lt: Property values must be less than the filter value argument.
        // lte: Property values must be less than or equal to the filter value argument.
        // gt: Property values must be greater than the filter value argument.
        // gte: Property values must be greater than or equal to the filter value argument.
        // in: An array should be passed in as the second argument, and property values must be equal to one of the values in the array.
        // match: Property values must match the provided regular expression.
        // contains: Filters for objects where the specified property's value is an array and the array contains any value that equals the provided value or satisfies the provided expression.

        // and: This takes two arguments that are other filter objects, that both must be true.
        // or: This takes two arguments that are other filter objects, where one of the two must be true.

        // more at https://github.com/SitePen/dstore/blob/master/docs/Collection.md

        return this.store.Filter();
      }
    }, {
      key: "filter",
      value: function filter(queryset) {
        var data = [];
        this.store.filter(queryset).forEach(function (object) {
          data.push(object);
        });
        return data;
      }
    }, {
      key: "fetch",
      value: function fetch() {
        var _this37 = this;

        if (this.url == "") {
          console.error("Request Memory : fetch error URL is not defined");
          return;
        }

        this.store = new RequestMemory({
          target: this.url
        });

        this.store.fetchRequest.response.then(function () {
          _this37.getItems();
          _this37.fetched();
        });
      }
    }]);

    return _class15;
  }());
});

/***
 * Original code come from QmlWeb.RestModel
 * 
 * We should improve various aspect of this Component to
 *     best match DjangoRestFramework Convention
 * 
 * 1. HTTP POST = Create new object            /patient/
 * 2. HTTP PUT  = Update existing object       /patient/ID/
 * 3. HTTP GET  = List all patients            /patient/
 *    HTTP GET  = List all patients matching criteria   /patient/?firstname=XXXX
 * 4. HTTP DELETE = Delete object              /patient/ID/
 */
QmlWeb.registerQmlType({
  module: "QmlWeb",
  name: "RestModel",
  versions: /.*/,
  baseClass: "QtQml.QtObject", // no UI
  properties: {
    url: "string",
    isLoading: "bool",
    mimeType: { type: "string", initialValue: "application/json" }, // receiving data from server
    queryMimeType: { // sending data to server
      type: "string",
      initialValue: "application/json"
    },
    query: "var",
    merge: "var",
    hierarchy: "var",
    //ignore property when generate body for post query
    ignore: { type: "var", initialValue: [] }
  },
  signals: {
    fetched: [{ name: "xhr", type: "var" }],
    saved: [{ name: "xhr", type: "var" }],
    destroy: [],
    failed: [{ name: "error", type: "var" }, { name: "xhr", type: "var" }] //TODO(natt): may be we should abstract failed error
  }
}, function () {
  function _class16(meta) {
    _classCallCheck(this, _class16);

    QmlWeb.callSuper(this, meta);
    this.attributes = this.getAttributes();
    this.runningRequests = 0;
  }

  _createClass(_class16, [{
    key: "fetch",
    value: function fetch() {
      var _this38 = this;

      return this.$ajax({
        method: "GET",
        mimeType: this.mimetype,
        query: this.query,
        success: function success(xhr) {
          _this38.$xhrReadResponse(xhr);
          _this38.fetched(JSON.parse(xhr.response));
        },
        failure: function failure(xhr) {
          _this38.$propagateFailSignal(xhr);
        }
      });
    }
  }, {
    key: "remove",
    value: function remove() {
      var _this39 = this;

      return this.$ajax({
        method: "DELETE",
        success: function success() {
          _this39.destroy();
        },
        failure: function failure(xhr) {
          _this39.$propagateFailSignal(xhr);
        }
      });
    }
  }, {
    key: "create",
    value: function create() {
      return this.$sendToServer("POST");
    }
  }, {
    key: "save",
    value: function save() {
      return this.$sendToServer("PUT");
    }
  }, {
    key: "$sendToServer",
    value: function $sendToServer(method) {
      var _this40 = this;

      return this.$ajax({
        method: method,
        mimeType: this.queryMimeType,
        body: this.$generateBodyForPostQuery(),
        success: function success(xhr) {
          _this40.$xhrReadResponse(xhr);
          _this40.saved(xhr);
        },
        failure: function failure(xhr) {
          console.log("FAILED: xhr status code = " + xhr.status);
          _this40.$propagateFailSignal(xhr);
        }
      });
    }
  }, {
    key: "$propagateFailSignal",
    value: function $propagateFailSignal(xhr) {
      /**
      When XHR failed, propagate failed to all nested RestModel (in merge, and hierarchy)
      All RestModel's onFailed will be fired
      **/
      if (xhr.status === 500) {
        alert("Internal Server Error 500\n" + xhr.response);
        this.failed(error, xhr);
        return;
      }
      var error;
      try {
        error = JSON.parse(xhr.response);
      } catch (err) {
        if (err instanceof SyntaxError) {
          error = {};
          console.warn('JSON parse error');
        } else {
          throw err;
        }
      }
      if (this.merge) {
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = this.merge[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var child = _step3.value;

            child.$propagateFailSignal(xhr);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }
      if (this.hierarchy) {
        for (var _key28 in this.hierarchy) {
          this.hierarchy[_key28].$propagateFailSignal(xhr);
        }
      }
      this.failed(error, xhr);
    }
  }, {
    key: "transform_attr_to_server",
    value: function transform_attr_to_server(attr) {
      if (attr === '_id') return 'id';
      return attr;
    }
  }, {
    key: "transform_attr_from_server",
    value: function transform_attr_from_server(attr) {
      if (attr === 'id') return '_id';
      return attr;
    }
  }, {
    key: "$generateBody",
    value: function $generateBody() {
      var object = {};
      var Repeater = QmlWeb.getConstructor("Semantic.Html", "1.0", "Repeater");
      for (var i = 0; i < this.attributes.length; i++) {
        if (this.ignore.includes(this.attributes[i])) continue;

        var _key29 = this.transform_attr_to_server(this.attributes[i]);
        object[_key29] = this.$properties[this.attributes[i]].get();
        var prop = this.$properties[this.attributes[i]];
        if (prop.val && prop.val.objectName) {
          var target_object = this.$context[prop.val.objectName];
          if (target_object instanceof Repeater && target_object.model instanceof QmlWeb.ItemModel) {
            var array = [];
            for (var j = 0; j < target_object.$items.length; j++) {
              var restObject = {};
              restObject = this.convertRestModelToObject(target_object.$items[j].model);
              array.push(restObject);
            }
            object[this.attributes[i]] = array;
          }
        }
      }
      if (this.merge) {
        this.mergeData(object, this.merge);
      }
      if (this.hierarchy) {
        this.hierarchyData(object, this.hierarchy);
      }
      return object;
    }
  }, {
    key: "$generateBodyForPostQuery",
    value: function $generateBodyForPostQuery() {
      var object = this.$generateBody();
      switch (this.queryMimeType) {
        case "application/json":
        case "text/json":
          return JSON.stringify(object);
        case "application/x-www-urlencoded":
          return this.$objectToUrlEncoded(object);
      }
      return undefined;
    }
  }, {
    key: "convertRestModelToObject",
    value: function convertRestModelToObject(restModel) {
      var object = {};
      for (var i = 0; i < restModel.attributes.length; i++) {
        var _key30 = this.transform_attr_to_server(restModel.attributes[i]);
        object[_key30] = restModel.$properties[restModel.attributes[i]].get();
      }
      return object;
    }
  }, {
    key: "mergeData",
    value: function mergeData(object, data) {
      for (var j = 0; j < data.length; j++) {
        for (var i = 0; i < data[j].$attributes.length; i++) {
          if (object.hasOwnProperty(data[j].$attributes[i])) {
            var error = "Property of RestModel has duplicate name = '" + data[j].$attributes[i] + "'";
            throw new Error(error);
          }
          object[data[j].$attributes[i]] = data[j].$properties[data[j].$attributes[i]].get();
        }
        if (data[j].merge) {
          this.mergeData(object, data[j].merge);
        }
        if (data[j].hierarchy) {
          this.hierarchyData(object, data[j].hierarchy);
        }
      }
    }
  }, {
    key: "hierarchyData",
    value: function hierarchyData(object, data) {
      for (var index in data) {
        var newObject = {};
        for (var i = 0; i < data[index].attributes.length; i++) {
          newObject[data[index].attributes[i]] = data[index].$properties[data[index].attributes[i]].get();
        }
        object[index] = newObject;
        if (data[index].merge) {
          this.mergeData(newObject, data[index].merge);
        }
        if (data[index].hierarchy) {
          this.hierarchyData(newObject, data[index].hierarchy);
        }
      }
    }
  }, {
    key: "$objectToUrlEncoded",
    value: function $objectToUrlEncoded(object, prefix) {
      var parts = [];
      for (var _key31 in object) {
        if (object.hasOwnProperty(_key31) && object[_key31] !== undefined) {
          var value = object[_key31];
          if (typeof prefix !== "undefined") {
            _key31 = prefix + "[" + _key31 + "]";
          }
          if ((typeof value === "undefined" ? "undefined" : _typeof(value)) === "object") {
            parts.push(this.$objectToUrlEncoded(value, _key31));
          } else {
            var ekey = this.$myEncodeURIComponent(_key31);
            var evalue = this.$myEncodeURIComponent(value);
            parts.push(ekey + "=" + evalue);
          }
        }
      }
      return parts.join("&");
    }
  }, {
    key: "$myEncodeURIComponent",
    value: function $myEncodeURIComponent(str) {
      return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
        return "%" + c.charCodeAt(0).toString(16);
      });
    }
  }, {
    key: "$ajax",
    value: function $ajax(options) {
      var _this41 = this;

      return new Promise(function (resolve, reject) {
        var csrftoken = _this41.getCookie('csrftoken');
        var queryString = "";
        if (options.query) {
          queryString = '?' + _this41.$objectToUrlEncoded(options.query);
        }
        var xhr = new XMLHttpRequest();
        xhr.overrideMimeType(_this41.mimeType);
        xhr.onreadystatechange = function () {
          if (xhr.readyState === XMLHttpRequest.DONE) {
            if (xhr.status === 200 || xhr.status === 201 || xhr.status === 204) {
              options.success(xhr);
              resolve(xhr);
            } else {
              try {
                options.failure(xhr);
              } catch (err) {
                if (err instanceof SyntaxError) {
                  console.warn('JSON parse error');
                } else {
                  throw err;
                }
              }
              reject(xhr);
            }
            _this41.runningRequests -= 1;
            if (_this41.runningRequests <= 0) {
              _this41.isLoading = false;
            }
          }
        };
        xhr.open(options.method, _this41.url + queryString, true);
        // send CSRF token by headers
        xhr.setRequestHeader('X-CSRFToken', csrftoken);

        if (typeof options.body !== "undefined") {
          xhr.setRequestHeader("Content-Type", _this41.queryMimeType);
          xhr.send(options.body);
        } else {
          xhr.send(null);
        }
        _this41.runningRequests += 1;
        _this41.isLoading = true;
      });
    }
  }, {
    key: "$xhrReadResponse",
    value: function $xhrReadResponse(xhr) {
      var responseObject = void 0;
      if (this.mimeType === "application/json" || this.mimeType === "text/json") {
        this.responseObject = JSON.parse(xhr.responseText);
      }
      this.$updatePropertiesFromResponseObject(this.responseObject);
    }
  }, {
    key: "$updatePropertiesFromResponseObject",
    value: function $updatePropertiesFromResponseObject(responseObject) {
      var QMLProperty = QmlWeb.QMLProperty;
      var Repeater = QmlWeb.getConstructor("Semantic.Html", "1.0", "Repeater");
      for (var _key32 in responseObject) {
        // for Repeater
        var prop = this.$properties[_key32];
        if (prop && prop.type == "alias") {
          var target_object = this.$context[prop.val.objectName];
          if (target_object instanceof Repeater) {
            var newMod = new QmlWeb.ItemModel(responseObject[_key32]);
            var roleNames = [];
            for (var i in responseObject[_key32][0]) {
              if (i !== "index") {
                roleNames.push(i);
              }
              if (i !== "id") {
                roleNames.push("_" + i);
              }
            }
            newMod.setRoleNames(roleNames);
            this.$properties[_key32].set(newMod, QMLProperty.ReasonUser);
            continue;
          }
        }
        //

        if (responseObject.hasOwnProperty(_key32) && this.$hasProperty(_key32) || _key32 === "id" && this.$hasProperty("_id")) {
          if (_key32 === "id" && this.$hasProperty("_id")) {
            this.$properties["_id"].set(responseObject[_key32], QMLProperty.ReasonUser);
          } else {
            this.$properties[_key32].set(responseObject[_key32], QMLProperty.ReasonUser);
          }
        }
      }
      if (this.merge) {
        this.updateMergeData(responseObject, this.merge);
      }
      if (this.hierarchy) {
        this.updateHierarchyData(responseObject, this.hierarchy);
      }
    }
  }, {
    key: "$updatePropertiesFromRepeater",
    value: function $updatePropertiesFromRepeater(responseObject) {
      var QMLProperty = QmlWeb.QMLProperty;
      var Repeater = QmlWeb.getConstructor("Semantic.Html", "1.0", "Repeater");
      for (var _key33 in responseObject) {
        if (responseObject.hasOwnProperty(_key33) && this.$hasProperty(_key33) || _key33 === "id" && this.$hasProperty("_id")) {
          if (_key33 === "id" && this.$hasProperty("_id")) {
            this.$properties["_id"].set(responseObject[_key33], QMLProperty.ReasonUser);
          } else {
            this.$properties[_key33].set(responseObject[_key33], QMLProperty.ReasonUser);
          }
        }
      }
      if (this.merge) {
        this.updateMergeData(responseObject, this.merge);
      }
      if (this.hierarchy) {
        this.updateHierarchyData(responseObject, this.hierarchy);
      }
    }
  }, {
    key: "updateMergeData",
    value: function updateMergeData(responseObject, data) {
      var QMLProperty = QmlWeb.QMLProperty;
      for (var i = 0; i < data.length; i++) {
        for (var _key34 in responseObject) {
          if (responseObject.hasOwnProperty(_key34) && typeof data[i].$properties[_key34] !== "undefined") {
            data[i].$properties[_key34].set(responseObject[_key34], QMLProperty.ReasonUser);
          }
        }
        if (data[i].merge) {
          this.updateMergeData(responseObject, data[i].merge);
        }
        if (data[i].hierarchy) {
          this.updateHierarchyData(responseObject, data[i].hierarchy);
        }
      }
    }
  }, {
    key: "updateHierarchyData",
    value: function updateHierarchyData(responseObject, data) {
      var QMLProperty = QmlWeb.QMLProperty;
      for (var index in data) {
        for (var _key35 in responseObject) {
          if (index == _key35 && _typeof(responseObject[_key35]) === "object") {
            for (var keyData in responseObject[_key35]) {
              if (responseObject[_key35].hasOwnProperty(keyData) && typeof data[index].$properties[keyData] !== "undefined") {
                data[index].$properties[keyData].set(responseObject[_key35][keyData], QMLProperty.ReasonUser);
              }
            }

            if (data[index].merge) {
              this.updateMergeData(responseObject[_key35], data[index].merge);
            }
            if (data[index].hierarchy) {
              this.updateHierarchyData(responseObject[_key35], data[index].hierarchy);
            }
          }
        }
      }
    }
  }, {
    key: "$hasProperty",
    value: function $hasProperty(name) {
      return typeof this.$properties[name] !== "undefined";
    }
  }, {
    key: "getCookie",
    value: function getCookie(name) {
      var cookieValue = null;
      if (document.cookie && document.cookie != '') {
        var cookies = document.cookie.split(';');
        for (var i = 0; i < cookies.length; i++) {
          var cookie = cookies[i].trim();
          // Does this cookie string begin with the name we want?
          if (cookie.substring(0, name.length + 1) == name + '=') {
            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
            break;
          }
        }
      }
      return cookieValue;
    }
  }, {
    key: "saveState",
    value: function saveState() {
      this.state = this.$generateBody();
    }
    /**
     * return {bool} wheter this rest model is dirty, compare to savedState
     */

  }, {
    key: "isDirty",
    value: function isDirty() {
      return !QmlWeb.deepEqual(this.state, this.$generateBody());
    }
  }, {
    key: "getProperty",
    value: function getProperty(property) {
      return this.$properties[property].val;
    }
  }, {
    key: "setProperty",
    value: function setProperty(property, value) {
      this.$properties[property].set(value);
    }
  }]);

  return _class16;
}());
QmlWeb.registerQmlType({
  module: "QmlWeb",
  name: "Utility",
  versions: /.*/,
  baseClass: "QtQml.QtObject", // no UI
  properties: {}
}, function () {
  function _class17(meta) {
    _classCallCheck(this, _class17);

    QmlWeb.callSuper(this, meta);
  }

  _createClass(_class17, [{
    key: "setCookie",
    value: function setCookie(cname, cvalue, exdays) {
      var d = new Date();
      d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1000);
      var expires = "expires=" + d.toUTCString();
      document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
    }
  }, {
    key: "getCookie",
    value: function getCookie(cname) {
      var name = cname + "=";
      var decodedCookie = decodeURIComponent(document.cookie);
      var ca = decodedCookie.split(';');
      for (var i = 0; i < ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0) == ' ') {
          c = c.substring(1);
        }
        if (c.indexOf(name) == 0) {
          return c.substring(name.length, c.length);
        }
      }
      return "";
    }
  }]);

  return _class17;
}());

QmlWeb.registerQmlType({
  module: "Qt.labs.settings",
  name: "Settings",
  versions: /.*/,
  baseClass: "QtQuick.Item",
  properties: {
    category: "string"
  }
}, function () {
  function _class18(meta) {
    _classCallCheck(this, _class18);

    QmlWeb.callSuper(this, meta);

    if (typeof window.localStorage === "undefined") {
      return;
    }

    this.Component.completed.connect(this, this.Component$onCompleted);
  }

  _createClass(_class18, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      this.$loadProperties();
      this.$initializeProperties();
    }
  }, {
    key: "$getKey",
    value: function $getKey(attrName) {
      return this.category + "/" + attrName;
    }
  }, {
    key: "$loadProperties",
    value: function $loadProperties() {
      var _this42 = this;

      this.$attributes.forEach(function (attrName) {
        if (!_this42.$properties[attrName]) return;

        var key = _this42.$getKey(attrName);
        _this42[attrName] = localStorage.getItem(key);
      });
    }
  }, {
    key: "$initializeProperties",
    value: function $initializeProperties() {
      var _this43 = this;

      this.$attributes.forEach(function (attrName) {
        if (!_this43.$properties[attrName]) return;

        var emitter = _this43;
        var signalName = attrName + "Changed";

        if (_this43.$properties[attrName].type === "alias") {
          emitter = _this43.$context[_this43.$properties[attrName].val.objectName];
          signalName = _this43.$properties[attrName].val.propertyName + "Changed";
        }

        emitter[signalName].connect(_this43, function () {
          localStorage.setItem(_this43.$getKey(attrName), _this43[attrName]);
        });
      });
    }
  }]);

  return _class18;
}());

QmlWeb.registerQmlType({
  module: "QtGraphicalEffects",
  name: "FastBlur",
  versions: /.*/,
  baseClass: "QtQuick.Item",
  properties: {
    radius: "real",
    source: { type: "var", initialValue: null }
  }
}, function () {
  function _class19(meta) {
    _classCallCheck(this, _class19);

    QmlWeb.callSuper(this, meta);

    this.$previousSource = null;
    this.$filterObject = undefined;

    this.radiusChanged.connect(this, this.$onRadiusChanged);
    this.sourceChanged.connect(this, this.$onSourceChanged);
  }

  _createClass(_class19, [{
    key: "$onRadiusChanged",
    value: function $onRadiusChanged() {
      this.$updateEffect(this.source);
    }
  }, {
    key: "$onSourceChanged",
    value: function $onSourceChanged() {
      this.$updateEffect(this.source);
    }
  }, {
    key: "$updateFilterObject",
    value: function $updateFilterObject() {
      this.$filterObject = {
        transformType: "filter",
        operation: "blur",
        parameters: this.radius + "px"
      };
    }
  }, {
    key: "$updateEffect",
    value: function $updateEffect(source) {
      console.log("updating effect");
      if (this.$previousSource) {
        var index = this.$previousSource.transform.indexOf(this.$filterObject);
        this.$previousSource.transform.splice(index, 1);
        this.$previousSource.$updateTransform();
      }
      if (source && source.transform) {
        this.$updateFilterObject();
        console.log("updating effect:", this.$filterObject, source);
        source.transform.push(this.$filterObject);
        source.$updateTransform();
        this.$previousSource = source;
      } else {
        this.$previousSource = null;
      }
    }
  }]);

  return _class19;
}());

QmlWeb.registerQmlType({
  module: "QtMobility",
  name: "GeoLocation",
  versions: /.*/,
  baseClass: "QtQuick.Item",
  properties: {
    accuracy: "double",
    altitude: "double",
    altitudeAccuracy: "double",
    heading: "double",
    latitude: "double",
    longitude: "double",
    speed: "double",
    timestamp: "date",
    label: "string"
  }
}, function () {
  function _class20(meta) {
    var _this44 = this;

    _classCallCheck(this, _class20);

    QmlWeb.callSuper(this, meta);

    if (!navigator.geolocation) {
      return;
    }

    navigator.geolocation.getCurrentPosition(function (pos) {
      return _this44.$updatePosition(pos);
    });
    navigator.geolocation.watchPosition(function (pos) {
      return _this44.$updatePosition(pos);
    });
  }

  _createClass(_class20, [{
    key: "$updatePosition",
    value: function $updatePosition(position) {
      this.accuracy = position.coords.accuracy;
      this.altitude = position.coords.altitude;
      this.altitudeAccuracy = position.coords.altitudeAccuracy;
      this.heading = position.coords.heading;
      this.latitude = position.coords.latitude;
      this.longitude = position.coords.longitude;
      this.speed = position.coords.speed;
      this.timestamp = position.timestamp;
    }
  }]);

  return _class20;
}());

QmlWeb.registerQmlType({
  module: "QtMultimedia",
  name: "Video",
  versions: /^5\./,
  baseClass: "QtQuick.Item",
  enums: {
    MediaPlayer: {
      NoError: 0, ResourceError: 1, FormatError: 2, NetworkError: 4,
      AccessDenied: 8, ServiceMissing: 16,

      StoppedState: 0, PlayingState: 1, PausedState: 2,

      NoMedia: 0, Loading: 1, Loaded: 2, Buffering: 4, Stalled: 8,
      EndOfMedia: 16, InvalidMedia: 32, UnknownStatus: 64
    },
    VideoOutput: { PreserveAspectFit: 0, PreserveAspectCrop: 1, Stretch: 2 }
  },
  properties: {
    source: "string",
    duration: "int",
    position: "int",
    autoPlay: "bool",
    muted: "bool",
    volume: "real",
    playbackRate: "real",
    playbackState: "enum", // MediaPlayer.StoppedState
    fillMode: "enum", // VideoOutput.PreserveAspectFit
    status: "enum", // MediaPlayer.NoMedia
    error: "enum" // MediaPlayer.NoError
  },
  signals: {
    paused: [],
    playing: [],
    stopped: []
  }
}, function () {
  function _class21(meta) {
    var _this45 = this;

    _classCallCheck(this, _class21);

    QmlWeb.callSuper(this, meta);

    this.$runningEventListener = 0;

    this.impl = document.createElement("video");
    this.impl.style.width = this.impl.style.height = "100%";
    this.impl.style.margin = "0";
    this.dom.appendChild(this.impl);

    this.volume = this.impl.volume;
    this.duration = this.impl.duration;

    this.impl.addEventListener("play", function () {
      _this45.playing();
      _this45.playbackState = _this45.MediaPlayer.PlayingState;
    });

    this.impl.addEventListener("pause", function () {
      _this45.paused();
      _this45.playbackState = _this45.MediaPlayer.PausedState;
    });

    this.impl.addEventListener("timeupdate", function () {
      _this45.$runningEventListener++;
      _this45.position = _this45.impl.currentTime * 1000;
      _this45.$runningEventListener--;
    });

    this.impl.addEventListener("ended", function () {
      _this45.stopped();
      _this45.playbackState = _this45.MediaPlayer.StoppedState;
    });

    this.impl.addEventListener("progress", function () {
      if (_this45.impl.buffered.length > 0) {
        _this45.progress = _this45.impl.buffered.end(0) / _this45.impl.duration;
        _this45.status = _this45.progress < 1 ? _this45.MediaPlayer.Buffering : _this45.MediaPlayer.Buffered;
      }
    });

    this.impl.addEventListener("stalled", function () {
      _this45.status = _this45.MediaPlayer.Stalled;
    });

    this.impl.addEventListener("canplaythrough", function () {
      _this45.status = _this45.MediaPlayer.Buffered;
    });

    this.impl.addEventListener("loadstart", function () {
      _this45.status = _this45.MediaPlayer.Loading;
    });

    this.impl.addEventListener("durationchanged", function () {
      _this45.duration = _this45.impl.duration;
    });

    this.impl.addEventListener("volumechanged", function () {
      _this45.$runningEventListener++;
      _this45.volume = _this45.impl.volume;
      _this45.$runningEventListener--;
    });

    this.impl.addEventListener("suspend", function () {
      _this45.error |= _this45.MediaPlayer.NetworkError;
    });

    this.impl.addEventListener("error", function () {
      _this45.error |= _this45.MediaPlayer.ResourceError;
    });

    this.impl.addEventListener("ratechange", function () {
      _this45.$runningEventListener++;
      _this45.playbackRate = _this45.impl.playbackRate;
      _this45.$runningEventListener--;
    });

    this.autoPlayChanged.connect(this, this.$onAutoPlayChanged);
    this.sourceChanged.connect(this, this.$onSourceChanged);
    this.positionChanged.connect(this, this.$onPositionChanged);
    this.volumeChanged.connect(this, this.$onVolumeChanged);
    this.playbackRateChanged.connect(this, this.$onPlaybackRateChanged);
    this.mutedChanged.connect(this, this.$onMutedChanged);
    this.fillModeChanged.connect(this, this.$onFillModeChanged);
  }

  _createClass(_class21, [{
    key: "$onAutoPlayChanged",
    value: function $onAutoPlayChanged(newVal) {
      this.impl.autoplay = newVal;
    }
  }, {
    key: "$onSourceChanged",
    value: function $onSourceChanged(source) {
      var parts = source.split(".");
      var extension = parts[parts.length - 1].toLowerCase();
      var mime = this.mimetypeFromExtension(extension);
      this.impl.src = source;
      if (!this.impl.canPlayType(mime)) {
        this.error |= this.MediaPlayer.FormatError;
      }
    }
  }, {
    key: "$onPositionChanged",
    value: function $onPositionChanged(currentTime) {
      if (this.$runningEventListener > 0) return;
      this.impl.currentTime = currentTime / 1000;
    }
  }, {
    key: "$onVolumeChanged",
    value: function $onVolumeChanged(volume) {
      if (this.$runningEventListener > 0) return;
      this.impl.volume = volume;
    }
  }, {
    key: "$onPlaybackRateChanged",
    value: function $onPlaybackRateChanged(playbackRate) {
      if (this.$runningEventListener > 0) return;
      this.impl.playbackRate = playbackRate;
    }
  }, {
    key: "$onMutedChanged",
    value: function $onMutedChanged(newValue) {
      if (newValue) {
        this.$volulmeBackup = this.impl.volume;
        this.volume = 0;
      } else {
        this.volume = this.$volumeBackup;
      }
    }
  }, {
    key: "$onFillModeChanged",
    value: function $onFillModeChanged(newValue) {
      switch (newValue) {
        case this.VideoOutput.Stretch:
          this.impl.style.objectFit = "fill";
          break;
        case this.VideoOutput.PreserveAspectFit:
          this.impl.style.objectFit = "";
          break;
        case this.VideoOutput.PreserveAspectCrop:
          this.impl.style.objectFit = "cover";
          break;
      }
    }
  }, {
    key: "pause",
    value: function pause() {
      this.impl.pause();
    }
  }, {
    key: "play",
    value: function play() {
      this.impl.play();
    }
  }, {
    key: "seek",
    value: function seek(offset) {
      this.impl.currentTime = offset * 1000;
    }
  }, {
    key: "stop",
    value: function stop() {}
  }, {
    key: "mimetypeFromExtension",
    value: function mimetypeFromExtension(extension) {
      var mimetypes = {
        ogg: "video/ogg",
        ogv: "video/ogg",
        ogm: "video/ogg",
        mp4: "video/mp4",
        webm: "video/webm"
      };
      return mimetypes[extension] || "";
    }
  }]);

  return _class21;
}());

QmlWeb.registerQmlType({
  module: "QtQml",
  name: "Binding",
  versions: /.*/,
  baseClass: "QtQml.QtObject",
  properties: {
    target: { type: "QtObject", initialValue: null },
    property: { type: "string", initialValue: "" },
    value: { type: "var", initialValue: undefined },
    when: { type: "bool", initialValue: true }
  }
}, function () {
  function _class22(meta) {
    _classCallCheck(this, _class22);

    QmlWeb.callSuper(this, meta);

    this.$property = undefined;

    this.valueChanged.connect(this, this.$onValueChanged);
    this.targetChanged.connect(this, this.$updateBinding);
    this.propertyChanged.connect(this, this.$updateBinding);
    this.whenChanged.connect(this, this.$updateBinding);
  }

  _createClass(_class22, [{
    key: "$updateBinding",
    value: function $updateBinding() {
      if (!this.when || !this.target || !this.target.hasOwnProperty(this.property) || this.value === undefined) {
        this.$property = undefined;
        return;
      }
      this.$property = this.target.$properties[this.property];
      this.$onValueChanged(this.value); // trigger value update
    }
  }, {
    key: "$onValueChanged",
    value: function $onValueChanged(value) {
      if (value !== undefined && this.$property) {
        this.$property.set(value);
      }
    }
  }]);

  return _class22;
}());

var QMLContext = function () {
  function QMLContext() {
    _classCallCheck(this, QMLContext);
  }

  _createClass(QMLContext, [{
    key: "nameForObject",
    value: function nameForObject(obj) {
      for (var name in this) {
        if (this[name] === obj) {
          return name;
        }
      }
      return undefined;
    }
  }]);

  return QMLContext;
}();

var QMLComponent = function () {
  function QMLComponent(meta) {
    var _this46 = this;

    _classCallCheck(this, QMLComponent);

    if (QmlWeb.constructors[meta.object.$class] === QMLComponent) {
      this.$metaObject = meta.object.$children[0];
    } else {
      this.$metaObject = meta.object;
    }
    this.$context = meta.context;

    this.$jsImports = [];

    if (meta.object.$imports instanceof Array) {
      var moduleImports = [];
      var loadImport = function loadImport(importDesc) {
        if (/\.js$/.test(importDesc[1])) {
          _this46.$jsImports.push(importDesc);
        } else {
          moduleImports.push(importDesc);
        }
      };

      for (var i = 0; i < meta.object.$imports.length; ++i) {
        loadImport(meta.object.$imports[i]);
      }
      QmlWeb.loadImports(this, moduleImports);
    }

    /* If this Component does not have any imports, it is likely one that was
     * created within another Component file. It should inherit the
     * importContextId of the Component file it was created within. */
    if (this.importContextId === undefined) {
      this.importContextId = meta.context.importContextId;
    }
  }

  _createClass(QMLComponent, [{
    key: "finalizeImports",
    value: function finalizeImports($context) {
      var engine = QmlWeb.engine;
      for (var i = 0; i < this.$jsImports.length; ++i) {
        var importDesc = this.$jsImports[i];
        var js = engine.loadJS(engine.$resolvePath(importDesc[1]));

        if (!js) {
          console.log("Component.finalizeImports: failed to import JavaScript", importDesc[1]);
          continue;
        }

        if (importDesc[3] !== "") {
          $context[importDesc[3]] = {};
          QmlWeb.importJavascriptInContext(js, $context[importDesc[3]]);
        } else {
          QmlWeb.importJavascriptInContext(js, $context);
        }
      }
    }
  }, {
    key: "$createObject",
    value: function $createObject(parent) {
      var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.$context;

      var engine = QmlWeb.engine;
      var oldState = engine.operationState;
      engine.operationState = QmlWeb.QMLOperationState.Init;
      // change base path to current component base path
      var bp = engine.$basePath;
      engine.$basePath = this.$basePath ? this.$basePath : engine.$basePath;

      var newContext = context ? Object.create(context) : new QMLContext();

      if (this.importContextId !== undefined) {
        newContext.importContextId = this.importContextId;
      }

      var item = QmlWeb.construct({
        object: this.$metaObject,
        parent: parent,
        context: newContext,
        isComponentRoot: true
      });

      this.finalizeImports(item.$context);

      Object.keys(properties).forEach(function (propname) {
        item[propname] = properties.propname;
      });

      // provide _qmlClass to help debug large page
      if (typeof item.dom !== "undefined") {
        if (this.$file !== undefined && parent !== null) {
          var classComponents = this.$file.split('/');
          item._qmlClass = " " + classComponents[classComponents.length - 1].replace('.qml', '');
          if (item.$onClassNameChanged) {
            item.$onClassNameChanged();
          }
        }
      }

      // change base path back
      // TODO looks a bit hacky
      engine.$basePath = bp;

      engine.operationState = oldState;
      return item;
    }
  }, {
    key: "createObject",
    value: function createObject(parent) {
      var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var item = this.$createObject(parent, properties);
      var QMLItem = QmlWeb.getConstructor("QtQuick", "2.0", "Item");

      if (item instanceof QMLItem) {
        item.$properties.parent.set(parent, QmlWeb.QMLProperty.ReasonInit);
      }

      return item;
    }
  }], [{
    key: "getAttachedObject",
    value: function getAttachedObject() {
      // see QMLEngine.js for explanation how it is used.
      if (!this.$Component) {
        this.$Component = new QmlWeb.QObject(this);
        this.$Component.completed = QmlWeb.Signal.signal([]);
        QmlWeb.engine.completedSignals.push(this.$Component.completed);

        this.$Component.destruction = QmlWeb.Signal.signal([]);
      }
      return this.$Component;
    }
  }]);

  return QMLComponent;
}();

QmlWeb.registerQmlType({
  global: true,
  module: "QtQml",
  name: "Component",
  versions: /.*/,
  baseClass: "QtObject",
  constructor: QMLComponent
});

QmlWeb.registerQmlType({
  module: "QtQml",
  name: "Connections",
  versions: /.*/,
  baseClass: "QtObject",
  properties: {
    target: "QtObject",
    ignoreUnknownSignals: "bool"
  }
}, function () {
  function _class23(meta) {
    _classCallCheck(this, _class23);

    QmlWeb.callSuper(this, meta);
    this.target = this.$parent;
    this.$connections = {};

    this.$old_target = this.target;
    this.targetChanged.connect(this, this.$onTargetChanged);
    this.Component.completed.connect(this, this.Component$onCompleted);
  }

  _createClass(_class23, [{
    key: "$onTargetChanged",
    value: function $onTargetChanged() {
      this.$reconnectTarget();
    }
  }, {
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      this.$reconnectTarget();
    }
  }, {
    key: "$reconnectTarget",
    value: function $reconnectTarget() {
      var old_target = this.$old_target;
      for (var i in this.$connections) {
        var c = this.$connections[i];
        if (c._currentConnection && old_target && old_target[i] && typeof old_target[i].disconnect === "function") {
          old_target[i].disconnect(c._currentConnection);
        }
        if (this.target) {
          c._currentConnection = QmlWeb.connectSignal(this.target, i, c.value, c.objectScope, c.componentScope);
        }
      }
      this.$old_target = this.target;
    }
  }, {
    key: "$setCustomSlot",
    value: function $setCustomSlot(propName, value, objectScope, componentScope) {
      this.$connections[propName] = { value: value, objectScope: objectScope, componentScope: componentScope };
    }
  }]);

  return _class23;
}());

// Base object for all qml elements

QmlWeb.registerQmlType({
  module: "QtQml",
  name: "QtObject",
  versions: /.*/
}, function (_QmlWeb$QObject10) {
  _inherits(_class24, _QmlWeb$QObject10);

  function _class24(meta) {
    _classCallCheck(this, _class24);

    var _this47 = _possibleConstructorReturn(this, (_class24.__proto__ || Object.getPrototypeOf(_class24)).call(this, meta.parent));

    _this47.$isComponentRoot = meta.isComponentRoot;
    _this47.$context = meta.context;

    // Component get own properties
    _this47.$attributes = [];
    for (var _key36 in meta.object) {
      if (!meta.object.hasOwnProperty(_key36) || !meta.object[_key36]) {
        continue;
      }
      var name = meta.object[_key36].__proto__.constructor.name;
      if (name === "QMLPropertyDefinition" || name === "QMLAliasDefinition") {
        _this47.$attributes.push(_key36);
      }
    }

    var Signal = QmlWeb.Signal;

    _this47.Keys = new QmlWeb.QObject(_this47);
    _this47.Keys.asteriskPresed = Signal.signal();
    _this47.Keys.backPressed = Signal.signal();
    _this47.Keys.backtabPressed = Signal.signal();
    _this47.Keys.callPressed = Signal.signal();
    _this47.Keys.cancelPressed = Signal.signal();
    _this47.Keys.deletePressed = Signal.signal();
    for (var i = 0; i < 10; ++i) {
      _this47.Keys["digit" + i + "Pressed"] = Signal.signal();
    }
    _this47.Keys.escapePressed = Signal.signal();
    _this47.Keys.flipPressed = Signal.signal();
    _this47.Keys.hangupPressed = Signal.signal();
    _this47.Keys.leftPressed = Signal.signal();
    _this47.Keys.menuPressed = Signal.signal();
    _this47.Keys.noPressed = Signal.signal();
    _this47.Keys.pressed = Signal.signal();
    _this47.Keys.released = Signal.signal();
    _this47.Keys.returnPressed = Signal.signal();
    _this47.Keys.rightPressed = Signal.signal();
    _this47.Keys.selectPressed = Signal.signal();
    _this47.Keys.spacePressed = Signal.signal();
    _this47.Keys.tabPressed = Signal.signal();
    _this47.Keys.upPressed = Signal.signal();
    _this47.Keys.volumeDownPressed = Signal.signal();
    _this47.Keys.volumeUpPressed = Signal.signal();
    _this47.Keys.yesPressed = Signal.signal();
    return _this47;
  }

  _createClass(_class24, [{
    key: "getAttributes",
    value: function getAttributes() {
      return this.$attributes;
    }
  }]);

  return _class24;
}(QmlWeb.QObject));

QmlWeb.registerQmlType({
  module: "QtQml",
  name: "Timer",
  versions: /.*/,
  baseClass: "QtObject",
  properties: {
    interval: { type: "int", initialValue: 1000 },
    parent: { type: "QtObject", readOnly: true },
    repeat: "bool",
    running: "bool",
    triggeredOnStart: "bool"
  },
  signals: {
    triggered: []
  }
}, function () {
  function _class25(meta) {
    var _this48 = this;

    _classCallCheck(this, _class25);

    QmlWeb.callSuper(this, meta);

    this.$properties.parent.set(this.$parent, QmlWeb.QMLProperty.ReasonInit);

    /* This ensures that if the user toggles the "running" property manually,
     * the timer will trigger. */
    this.runningChanged.connect(this, this.$onRunningChanged);

    QmlWeb.engine.$addTicker(function () {
      return _this48.$ticker.apply(_this48, arguments);
    });

    QmlWeb.engine.$registerStart(function () {
      if (_this48.running) {
        _this48.restart();
      }
    });

    QmlWeb.engine.$registerStop(function () {
      return _this48.stop();
    });
  }

  _createClass(_class25, [{
    key: "start",
    value: function start() {
      this.running = true;
    }
  }, {
    key: "stop",
    value: function stop() {
      this.running = false;
    }
  }, {
    key: "restart",
    value: function restart() {
      this.stop();
      this.start();
    }
  }, {
    key: "$ticker",
    value: function $ticker(now) {
      if (!this.running) return;
      if (now - this.$prevTrigger >= this.interval) {
        this.$prevTrigger = now;
        this.$trigger();
      }
    }
  }, {
    key: "$onRunningChanged",
    value: function $onRunningChanged() {
      if (this.running) {
        this.$prevTrigger = Date.now();
        if (this.triggeredOnStart) {
          this.$trigger();
        }
      }
    }
  }, {
    key: "$trigger",
    value: function $trigger() {
      if (!this.repeat) {
        // We set the value directly in order to be able to emit the
        // runningChanged signal after triggered, like Qt does it.
        this.$properties.running.val = false;
      }

      // Trigger this.
      this.triggered();

      if (!this.repeat) {
        // Emit changed signal manually after setting the value manually above.
        this.runningChanged();
      }
    }
  }]);

  return _class25;
}());

QmlWeb.registerQmlType({
  module: "QtQuick.Controls",
  name: "Button",
  versions: /.*/,
  baseClass: "QtQuick.Item",
  properties: {
    text: "string",
    enabled: { type: "bool", initialValue: true }
  },
  signals: {
    clicked: []
  }
}, function () {
  function _class26(meta) {
    var _this49 = this;

    _classCallCheck(this, _class26);

    QmlWeb.callSuper(this, meta);

    this.Component.completed.connect(this, this.Component$onCompleted);
    this.textChanged.connect(this, this.$onTextChanged);
    this.enabledChanged.connect(this, this.$onEnabledChanged);

    var button = this.impl = document.createElement("button");
    button.style.pointerEvents = "auto";
    this.dom.appendChild(button);

    button.onclick = function () {
      _this49.clicked();
    };
  }

  _createClass(_class26, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      this.implicitWidth = this.impl.offsetWidth;
      this.implicitHeight = this.impl.offsetHeight;
    }
  }, {
    key: "$onTextChanged",
    value: function $onTextChanged(newVal) {
      this.impl.textContent = newVal;
      //TODO: Replace those statically sized borders
      this.implicitWidth = this.impl.offsetWidth;
      this.implicitHeight = this.impl.offsetHeight;
    }
  }, {
    key: "$onEnabledChanged",
    value: function $onEnabledChanged(newVal) {
      this.impl.disabled = !newVal;
    }
  }]);

  return _class26;
}());

QmlWeb.registerQmlType({
  module: "QtQuick.Controls",
  name: "CheckBox",
  versions: /.*/,
  baseClass: "QtQuick.Item",
  properties: {
    text: "string",
    font: "font",
    checked: "bool",
    color: "color"
  }
}, function () {
  function _class27(meta) {
    var _this50 = this;

    _classCallCheck(this, _class27);

    QmlWeb.callSuper(this, meta);

    this.impl = document.createElement("label");
    this.impl.style.pointerEvents = "auto";

    var checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.style.verticalAlign = "text-bottom";
    checkbox.addEventListener("change", function () {
      _this50.checked = checkbox.checked;
    });
    this.impl.appendChild(checkbox);

    var span = document.createElement("span");
    this.impl.appendChild(span);

    this.dom.appendChild(this.impl);

    this.Component.completed.connect(this, this.Component$onCompleted);
    this.textChanged.connect(this, this.$onTextChanged);
    this.colorChanged.connect(this, this.$onColorChanged);
    this.checkedChanged.connect(this, this.$onCheckedChanged);
  }

  _createClass(_class27, [{
    key: "$onTextChanged",
    value: function $onTextChanged(newVal) {
      this.impl.children[1].innerHTML = newVal;
      this.implicitHeight = this.impl.offsetHeight;
      this.implicitWidth = this.impl.offsetWidth > 0 ? this.impl.offsetWidth + 4 : 0;
    }
  }, {
    key: "$onColorChanged",
    value: function $onColorChanged(newVal) {
      this.impl.children[1].style.color = newVal.$css;
    }
  }, {
    key: "$onCheckedChanged",
    value: function $onCheckedChanged() {
      this.impl.children[0].checked = this.checked;
    }
  }, {
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      this.implicitHeight = this.impl.offsetHeight;
      this.implicitWidth = this.impl.offsetWidth > 0 ? this.impl.offsetWidth + 4 : 0;
    }
  }]);

  return _class27;
}());

QmlWeb.registerQmlType({
  module: "QtQuick.Controls",
  name: "ComboBox",
  versions: /.*/,
  baseClass: "QtQuick.Item",
  properties: {
    count: "int",
    currentIndex: "int",
    currentText: "string",
    menu: { type: "array", initialValue: [] },
    model: { type: "array", initialValue: [] },
    pressed: "bool"
  },
  signals: {
    accepted: [],
    activated: [{ type: "int", name: "index" }]
  }
}, function () {
  function _class28(meta) {
    var _this51 = this;

    _classCallCheck(this, _class28);

    QmlWeb.callSuper(this, meta);

    this.dom.style.pointerEvents = "auto";
    this.name = "QMLComboBox";

    this.Component.completed.connect(this, this.Component$onCompleted);
    this.modelChanged.connect(this, this.$onModelChanged);

    this.dom.onclick = function () {
      var index = _this51.dom.firstChild.selectedIndex;
      _this51.currentIndex = index;
      _this51.currentText = _this51.model[index];
      _this51.accepted();
      _this51.activated(index);
    };
  }

  _createClass(_class28, [{
    key: "find",
    value: function find(text) {
      return this.model.indexOf(text);
    }
  }, {
    key: "selectAll",
    value: function selectAll() {
      // TODO
    }
  }, {
    key: "textAt",
    value: function textAt(index) {
      return this.model[index];
    }
  }, {
    key: "$updateImpl",
    value: function $updateImpl() {
      this.currentIndex = 0;
      this.count = this.model.length;
      var entries = [];
      for (var i = 0; i < this.count; i++) {
        var elt = this.model[i];
        //if (elt instanceof Array) { // TODO - optgroups? update model !
        //    var count_i = elt.length;
        //    for (var j = 0; j < count_i; j++)
        //        html += "<option>" + elt[j] + "</option>";
        //}
        //else
        entries.push("<option>" + elt + "</option>");
      }
      // TODO: remove innerHTML, port to DOM
      this.dom.innerHTML = "<select>" + entries.join("") + "</select>";
      this.impl = this.dom.firstChild;
    }
  }, {
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      this.$updateImpl();
      this.implicitWidth = this.impl.offsetWidth;
      this.implicitHeight = this.impl.offsetHeight;
    }
  }, {
    key: "$onModelChanged",
    value: function $onModelChanged() {
      this.$updateImpl();
    }
  }]);

  return _class28;
}());

QmlWeb.registerQmlType({
  module: "QtQuick.Controls",
  name: "ScrollView",
  versions: /.*/,
  baseClass: "QtQuick.Item",
  properties: {
    contentItem: "Item",
    flickableItem: "Item", // TODO  0) implement it  1) make it read-only
    viewport: "Item", // TODO
    frameVisible: "bool",
    highlightOnFocus: "bool", // TODO test
    verticalScrollBarPolicy: "enum",
    horizontalScrollBarPolicy: "enum",
    style: "Component" // TODO
  },
  defaultProperty: "contentItem"
}, function () {
  function _class29(meta) {
    _classCallCheck(this, _class29);

    QmlWeb.callSuper(this, meta);

    this.css.pointerEvents = "auto";
    this.setupFocusOnDom(this.dom);

    this.contentItemChanged.connect(this, this.$onContentItemChanged);
    this.flickableItemChanged.connect(this, this.$onFlickableItemChanged);
    this.viewportChanged.connect(this, this.$onViewportChanged);
    this.frameVisibleChanged.connect(this, this.$onFrameVisibleChanged);
    this.highlightOnFocusChanged.connect(this, this.$onHighlightOnFocusChanged);
    this.horizontalScrollBarPolicyChanged.connect(this, this.$onHorizontalScrollBarPolicyChanged);
    this.verticalScrollBarPolicyChanged.connect(this, this.$onVerticalScrollBarPolicyChanged);
    this.styleChanged.connect(this, this.$onStyleChanged);
    this.childrenChanged.connect(this, this.$onChildrenChanged);
    this.focusChanged.connect(this, this.$onFocusChanged);

    this.width = this.implicitWidth = 240; // default QML ScrollView width
    this.height = this.implicitHeight = 150; // default QML ScrollView height
    this.width = this.implicitWidth;
    this.height = this.implicitHeight;

    var Qt = QmlWeb.Qt;
    this.contentItem = undefined;
    this.flickableItem = undefined;
    this.viewport = undefined;
    this.frameVisible = false;
    this.highlightOnFocus = false;
    this.verticalScrollBarPolicy = Qt.ScrollBarAsNeeded;
    this.horizontalScrollBarPolicy = Qt.ScrollBarAsNeeded;
    this.style = undefined;
  }

  _createClass(_class29, [{
    key: "$onContentItemChanged",
    value: function $onContentItemChanged(newItem) {
      if ((typeof newItem === "undefined" ? "undefined" : _typeof(newItem)) !== undefined) {
        newItem.parent = this;
      }
    }
  }, {
    key: "$onFlickableItemChanged",
    value: function $onFlickableItemChanged() {}
  }, {
    key: "$onHighlightOnFocusChanged",
    value: function $onHighlightOnFocusChanged() {}
  }, {
    key: "$onViewportChanged",
    value: function $onViewportChanged() {}
  }, {
    key: "$onFocusChanged",
    value: function $onFocusChanged(focus) {
      this.css.outline = this.highlight && focus ? "outline: lightblue solid 2px;" : "";
    }
  }, {
    key: "$onFrameVisibleChanged",
    value: function $onFrameVisibleChanged(visible) {
      this.css.border = visible ? "1px solid gray" : "hidden";
    }
  }, {
    key: "$onHorizontalScrollBarPolicyChanged",
    value: function $onHorizontalScrollBarPolicyChanged(newPolicy) {
      this.css.overflowX = this.$scrollBarPolicyToCssOverflow(newPolicy);
    }
  }, {
    key: "$onVerticalScrollBarPolicyChanged",
    value: function $onVerticalScrollBarPolicyChanged(newPolicy) {
      this.css.overflowY = this.$scrollBarPolicyToCssOverflow(newPolicy);
    }
  }, {
    key: "$onStyleChanged",
    value: function $onStyleChanged() {}
  }, {
    key: "$onChildrenChanged",
    value: function $onChildrenChanged() {
      if (typeof this.contentItem === "undefined" && this.children.length === 1) {
        this.contentItem = this.children[0];
      }
    }
  }, {
    key: "$scrollBarPolicyToCssOverflow",
    value: function $scrollBarPolicyToCssOverflow(policy) {
      var Qt = QmlWeb.Qt;
      switch (policy) {
        case Qt.ScrollBarAsNeeded:
          return "auto";
        case Qt.ScrollBarAlwaysOff:
          return "hidden";
        case Qt.ScrollBarAlwaysOn:
          return "scroll";
      }
      return "auto";
    }
  }]);

  return _class29;
}());

QmlWeb.registerQmlType({
  module: "QtQuick.Controls",
  name: "TextArea",
  versions: /.*/,
  baseClass: "QtQuick.TextEdit"
}, function () {
  function _class30(meta) {
    _classCallCheck(this, _class30);

    QmlWeb.callSuper(this, meta);
    var textarea = this.impl;
    textarea.style.padding = "5px";
    textarea.style.borderWidth = "1px";
    textarea.style.backgroundColor = "#fff";
  }

  return _class30;
}());

/**
 *
 * TextField is used to accept a line of text input.
 * Input constraints can be placed on a TextField item
 * (for example, through a validator or inputMask).
 * Setting echoMode to an appropriate value enables TextField
 * to be used for a password input field.
 *
 * Valid entries for echoMode and alignment are defined in TextInput.
 *
 */

QmlWeb.registerQmlType({
  module: "QtQuick.Controls",
  name: "TextField",
  versions: /.*/,
  baseClass: "QtQuick.Item",
  enums: {
    TextInput: { Normal: 0, Password: 1, NoEcho: 2, PasswordEchoOnEdit: 3 }
  },
  properties: {
    text: "string",
    font: "font",
    maximumLength: { type: "int", initialValue: -1 },
    readOnly: "bool",
    validator: "var",
    echoMode: "enum" // TextInput.Normal
  },
  signals: {
    accepted: []
  }
}, function () {
  function _class31(meta) {
    var _this52 = this;

    _classCallCheck(this, _class31);

    QmlWeb.callSuper(this, meta);

    var input = this.impl = document.createElement("input");
    input.type = "text";
    input.disabled = true;
    input.style.pointerEvents = "auto";
    input.style.margin = "0";
    input.style.width = "100%";
    this.dom.appendChild(input);
    this.setupFocusOnDom(input);
    input.disabled = false;

    this.Component.completed.connect(this, this.Component$onCompleted);
    this.textChanged.connect(this, this.$onTextChanged);
    this.echoModeChanged.connect(this, this.$onEchoModeChanged);
    this.maximumLengthChanged.connect(this, this.$onMaximumLengthChanged);
    this.readOnlyChanged.connect(this, this.$onReadOnlyChanged);
    this.Keys.pressed.connect(this, this.Keys$onPressed);

    this.impl.addEventListener("input", function () {
      return _this52.$updateValue();
    });
  }

  _createClass(_class31, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      this.implicitWidth = this.impl.offsetWidth;
      this.implicitHeight = this.impl.offsetHeight;
    }
  }, {
    key: "$onTextChanged",
    value: function $onTextChanged(newVal) {
      // See TextInput for comments
      if (this.impl.value !== newVal) {
        this.impl.value = newVal;
      }
    }
  }, {
    key: "$onEchoModeChanged",
    value: function $onEchoModeChanged(newVal) {
      var TextInput = this.TextInput;
      var input = this.impl;
      switch (newVal) {
        case TextInput.Normal:
          input.type = "text";
          break;
        case TextInput.Password:
          input.type = "password";
          break;
        case TextInput.NoEcho:
          // Not supported, use password, that's nearest
          input.type = "password";
          break;
        case TextInput.PasswordEchoOnEdit:
          // Not supported, use password, that's nearest
          input.type = "password";
          break;
      }
    }
  }, {
    key: "$onMaximumLengthChanged",
    value: function $onMaximumLengthChanged(newVal) {
      this.impl.maxLength = newVal < 0 ? null : newVal;
    }
  }, {
    key: "$onReadOnlyChanged",
    value: function $onReadOnlyChanged(newVal) {
      this.impl.disabled = newVal;
    }
  }, {
    key: "Keys$onPressed",
    value: function Keys$onPressed(e) {
      var Qt = QmlWeb.Qt;
      var submit = e.key === Qt.Key_Return || e.key === Qt.Key_Enter;
      if (submit && this.$testValidator()) {
        this.accepted();
        e.accepted = true;
      }
    }
  }, {
    key: "$testValidator",
    value: function $testValidator() {
      if (this.validator) {
        return this.validator.validate(this.text);
      }
      return true;
    }
  }, {
    key: "$updateValue",
    value: function $updateValue() {
      if (this.text !== this.impl.value) {
        this.$canEditReadOnlyProperties = true;
        this.text = this.impl.value;
        this.$canEditReadOnlyProperties = false;
      }
    }
  }]);

  return _class31;
}());

QmlWeb.registerQmlType({
  module: "QtQuick.Window",
  name: "Screen",
  versions: /.*/,
  baseClass: "QtQuick.Item",
  properties: {
    name: "string",
    orientation: "enum",
    orientationUpdateMask: "enum",
    primaryOrientation: "enum",
    pixelDensity: "real",
    devicePixelRatio: "real",
    desktopAvailableHeight: "int",
    desktopAvailableWidth: "int",
    height: "int",
    width: "int"
  }
}, function () {
  function _class32(meta) {
    _classCallCheck(this, _class32);

    QmlWeb.callSuper(this, meta);

    // TODO: rewrite as an attached object and forbid constructing
    this.Component.completed.connect(this, this.Component$onCompleted);
  }

  _createClass(_class32, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      var Qt = QmlWeb.Qt;
      this.desktopAvailableHeight = window.outerHeight;
      this.desktopAvailableWidth = window.outerWidth;
      this.devicePixelRatio = window.devicePixelRatio;
      this.height = window.innerHeight;
      this.name = this.name;
      this.orientation = Qt.PrimaryOrientation;
      this.orientationUpdateMask = 0;
      this.pixelDensity = 100.0; // TODO
      this.primaryOrientation = Qt.PrimaryOrientation;
      this.width = window.innerWidth;
    }
  }]);

  return _class32;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "AnimatedImage",
  versions: /.*/,
  baseClass: "Image"
}, function () {
  function _class33(meta) {
    _classCallCheck(this, _class33);

    QmlWeb.callSuper(this, meta);
  }

  return _class33;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "Animation",
  versions: /.*/,
  baseClass: "QtQml.QtObject",
  enums: {
    Animation: { Infinite: -1 },
    Easing: QmlWeb.Easing
  },
  properties: {
    alwaysRunToEnd: "bool",
    loops: { type: "int", initialValue: 1 },
    paused: "bool",
    running: "bool"
  }
}, function () {
  function _class34(meta) {
    _classCallCheck(this, _class34);

    QmlWeb.callSuper(this, meta);
  }

  _createClass(_class34, [{
    key: "restart",
    value: function restart() {
      this.stop();
      this.start();
    }
  }, {
    key: "start",
    value: function start() {
      this.running = true;
    }
  }, {
    key: "stop",
    value: function stop() {
      this.running = false;
    }
  }, {
    key: "pause",
    value: function pause() {
      this.paused = true;
    }
  }, {
    key: "resume",
    value: function resume() {
      this.paused = false;
    }
  }, {
    key: "complete",
    value: function complete() {
      // To be overridden
      console.log("Unbound method for", this);
    }
  }]);

  return _class34;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "Animator",
  versions: /^2\./,
  baseClass: "Animation",
  properties: {
    duration: { type: "int", initialValue: 250 },
    from: "real",
    target: "Item",
    to: "real"
  }
}, function () {
  function _class35(meta) {
    _classCallCheck(this, _class35);

    QmlWeb.callSuper(this, meta);

    this.easing = new QmlWeb.QObject(this);
    QmlWeb.createProperties(this.easing, {
      type: { type: "enum", initialValue: this.Easing.Linear },
      amplitude: { type: "real", initialValue: 1 },
      overshoot: { type: "real", initialValue: 1.70158 },
      period: { type: "real", initialValue: 0.3 },
      bezierCurve: "list"
    });
  }

  return _class35;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "Behavior",
  versions: /.*/,
  baseClass: "QtQml.QtObject",
  properties: {
    animation: "Animation",
    enabled: { type: "bool", initialValue: true }
  },
  defaultProperty: "animation"
}, function () {
  function _class36(meta) {
    _classCallCheck(this, _class36);

    QmlWeb.callSuper(this, meta);
    this.$on = meta.object.$on;

    this.animationChanged.connect(this, this.$onAnimationChanged);
    this.enabledChanged.connect(this, this.$onEnabledChanged);
  }

  _createClass(_class36, [{
    key: "$onAnimationChanged",
    value: function $onAnimationChanged(newVal) {
      newVal.target = this.$parent;
      newVal.property = this.$on;
      this.$parent.$properties[this.$on].animation = newVal;
    }
  }, {
    key: "$onEnabledChanged",
    value: function $onEnabledChanged(newVal) {
      this.$parent.$properties[this.$on].animation = newVal ? this.animation : null;
    }
  }]);

  return _class36;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "BorderImage",
  versions: /.*/,
  baseClass: "Item",
  enums: {
    BorderImage: {
      Stretch: "stretch", Repeat: "repeat", Round: "round",
      Null: 1, Ready: 2, Loading: 3, Error: 4
    }
  },
  properties: {
    source: "url",
    smooth: { type: "bool", initialValue: true },
    // BorderImage.Stretch
    horizontalTileMode: { type: "enum", initialValue: "stretch" },
    // BorderImage.Stretch
    verticalTileMode: { type: "enum", initialValue: "stretch" },
    progress: "real",
    status: { type: "enum", initialValue: 1 // BorderImage.Null
    } }
}, function () {
  function _class37(meta) {
    var _this53 = this;

    _classCallCheck(this, _class37);

    QmlWeb.callSuper(this, meta);

    this.border = new QmlWeb.QObject(this);
    QmlWeb.createProperties(this.border, {
      left: "int",
      right: "int",
      top: "int",
      bottom: "int"
    });

    var bg = this.impl = document.createElement("div");
    bg.style.pointerEvents = "none";
    bg.style.height = "100%";
    bg.style.boxSizing = "border-box";
    this.dom.appendChild(bg);

    this.$img = new Image();
    this.$img.addEventListener("load", function () {
      _this53.progress = 1;
      _this53.status = _this53.BorderImage.Ready;
    });
    this.$img.addEventListener("error", function () {
      _this53.status = _this53.BorderImage.Error;
    });

    this.sourceChanged.connect(this, this.$onSourceChanged);
    this.border.leftChanged.connect(this, this.$updateBorder);
    this.border.rightChanged.connect(this, this.$updateBorder);
    this.border.topChanged.connect(this, this.$updateBorder);
    this.border.bottomChanged.connect(this, this.$updateBorder);
    this.horizontalTileModeChanged.connect(this, this.$updateBorder);
    this.verticalTileModeChanged.connect(this, this.$updateBorder);
    this.smoothChanged.connect(this, this.$onSmoothChanged);
  }

  _createClass(_class37, [{
    key: "$onSourceChanged",
    value: function $onSourceChanged(source) {
      this.progress = 0;
      this.status = this.BorderImage.Loading;
      var style = this.impl.style;
      var imageURL = QmlWeb.engine.$resolveImageURL(source);
      style.OBorderImageSource = "url(\"" + imageURL + "\")";
      style.borderImageSource = "url(\"" + imageURL + "\")";
      this.$img.src = imageURL;
      if (this.$img.complete) {
        this.progress = 1;
        this.status = this.BorderImage.Ready;
      }
    }
  }, {
    key: "$updateBorder",
    value: function $updateBorder() {
      var style = this.impl.style;
      var _border = this.border,
          right = _border.right,
          left = _border.left,
          top = _border.top,
          bottom = _border.bottom;

      var slice = top + " " + right + " " + bottom + " " + left + " fill";
      var width = top + "px " + right + "px " + bottom + "px " + left + "px";
      var repeat = this.horizontalTileMode + " " + this.verticalTileMode;
      style.OBorderImageSlice = slice;
      style.OBorderImageRepeat = repeat;
      style.OBorderImageWidth = width;
      style.borderImageSlice = slice;
      style.borderImageRepeat = repeat;
      style.borderImageWidth = width;
    }
  }, {
    key: "$onSmoothChanged",
    value: function $onSmoothChanged(val) {
      var style = this.impl.style;
      if (val) {
        style.imageRendering = "auto";
      } else {
        style.imageRendering = "-webkit-optimize-contrast";
        style.imageRendering = "-moz-crisp-edges";
        style.imageRendering = "crisp-edges";
        style.imageRendering = "pixelated";
      }
    }
  }]);

  return _class37;
}());

// TODO
// Currently only a skeleton implementation

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "Canvas",
  versions: /.*/,
  baseClass: "Item",
  properties: {
    available: { type: "bool", initialValue: true },
    canvasSize: { type: "var", initialValue: [0, 0] },
    canvasWindow: { type: "var", initialValue: [0, 0, 0, 0] },
    context: { type: "var", initialValue: {} },
    contextType: { type: "string", initialValue: "contextType" },
    renderStrategy: "enum",
    renderTarget: "enum",
    tileSize: { type: "var", initialValue: [0, 0] }
  },
  signals: {
    imageLoaded: [],
    paint: [{ type: "var", name: "region" }],
    painted: []
  }
}, function () {
  function _class38(meta) {
    _classCallCheck(this, _class38);

    QmlWeb.callSuper(this, meta);
  }

  _createClass(_class38, [{
    key: "cancelRequestAnimationFrame",
    value: function cancelRequestAnimationFrame() /*handle*/{
      return false;
    }
  }, {
    key: "getContext",
    value: function getContext() /*context_id, ...args*/{
      return {};
    }
  }, {
    key: "isImageError",
    value: function isImageError() /*image*/{
      return true;
    }
  }, {
    key: "isImageLoaded",
    value: function isImageLoaded() /*image*/{
      return false;
    }
  }, {
    key: "isImageLoading",
    value: function isImageLoading() /*image*/{
      return false;
    }
  }, {
    key: "loadImage",
    value: function loadImage(image) {
      //loadImageAsync(image);
      if (this.isImageLoaded(image)) {
        this.imageLoaded();
      }
    }
  }, {
    key: "markDirty",
    value: function markDirty(area) {
      // if dirty
      this.paint(area);
    }
  }, {
    key: "requestAnimationFrame",
    value: function requestAnimationFrame() /*callback*/{
      return 0;
    }
  }, {
    key: "requestPaint",
    value: function requestPaint() {}
  }, {
    key: "save",
    value: function save() /*file_name*/{
      return false;
    }
  }, {
    key: "toDataURL",
    value: function toDataURL() /*mime_type*/{
      return "";
    }
  }, {
    key: "unloadImage",
    value: function unloadImage() /*image*/{}
  }]);

  return _class38;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "Column",
  versions: /.*/,
  baseClass: "Positioner"
}, function () {
  function _class39(meta) {
    _classCallCheck(this, _class39);

    QmlWeb.callSuper(this, meta);
  }

  _createClass(_class39, [{
    key: "layoutChildren",
    value: function layoutChildren() {
      var curPos = 0;
      var maxWidth = 0;
      for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i];
        if (!child.visible || !child.width || !child.height) {
          continue;
        }
        maxWidth = child.width > maxWidth ? child.width : maxWidth;
        child.y = curPos;
        curPos += child.height + this.spacing;
      }
      this.implicitWidth = maxWidth;
      this.implicitHeight = curPos - this.spacing;
      // We want no spacing at the bottom side
    }
  }]);

  return _class39;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "DoubleValidator",
  versions: /.*/,
  baseClass: "Item",
  enums: {
    DoubleValidator: { StandardNotation: 1, ScientificNotation: 2 }
  },
  properties: {
    bottom: { type: "real", initialValue: -Infinity },
    top: { type: "real", initialValue: Infinity },
    decimals: { type: "int", initialValue: 1000 },
    // DoubleValidator.ScientificNotation
    notation: { type: "enum", initialValue: 2 }
  }
}, function () {
  function _class40(meta) {
    _classCallCheck(this, _class40);

    QmlWeb.callSuper(this, meta);
    this.$standardRegExp = /^(-|\+)?\s*[0-9]+(\.[0-9]+)?$/;
    this.$scientificRegExp = /^(-|\+)?\s*[0-9]+(\.[0-9]+)?(E(-|\+)?[0-9]+)?$/;
  }

  _createClass(_class40, [{
    key: "getRegExpForNotation",
    value: function getRegExpForNotation(notation) {
      switch (notation) {
        case this.DoubleValidator.ScientificNotation:
          return this.$scientificRegExp;
        case this.DoubleValidator.StandardNotation:
          return this.$standardRegExp;
      }
      return null;
    }
  }, {
    key: "$getDecimalsForNumber",
    value: function $getDecimalsForNumber(number) {
      if (Math.round(number) === number) {
        return 0;
      }
      var str = "" + number;
      return (/\d*$/.exec(str)[0].length
      );
    }
  }, {
    key: "validate",
    value: function validate(string) {
      var regExp = this.getRegExpForNotation(this.notation);
      if (!regExp.test(string.trim())) {
        return false;
      }
      var value = parseFloat(string);
      return this.bottom <= value && this.top >= value && this.$getDecimalsForNumber(value) <= this.decimals;
    }
  }]);

  return _class40;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "Flow",
  versions: /.*/,
  baseClass: "Positioner",
  enums: {
    Flow: { LeftToRight: 0, TopToBottom: 1 }
  },
  properties: {
    flow: "enum", // Flow.LeftToRight
    layoutDirection: "enum" // Flow.LeftToRight
  }
}, function () {
  function _class41(meta) {
    _classCallCheck(this, _class41);

    QmlWeb.callSuper(this, meta);

    this.flowChanged.connect(this, this.layoutChildren);
    this.layoutDirectionChanged.connect(this, this.layoutChildren);
    this.widthChanged.connect(this, this.layoutChildren);
    this.heightChanged.connect(this, this.layoutChildren);
    this.layoutChildren();
  }

  _createClass(_class41, [{
    key: "layoutChildren",
    value: function layoutChildren() {
      if (this.flow === undefined) {
        // Flow has not been fully initialized yet
        return;
      }

      var curHPos = 0;
      var curVPos = 0;
      var rowSize = 0;
      for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i];
        if (!child.visible || !child.width || !child.height) {
          continue;
        }

        if (this.flow === this.Flow.LeftToRight) {
          if (!this.$isUsingImplicitWidth && curHPos + child.width > this.width) {
            curHPos = 0;
            curVPos += rowSize + this.spacing;
            rowSize = 0;
          }
          rowSize = child.height > rowSize ? child.height : rowSize;
          child.x = this.layoutDirection === this.Flow.TopToBottom ? this.width - curHPos - child.width : curHPos;
          child.y = curVPos;
          curHPos += child.width + this.spacing;
        } else {
          // Flow.TopToBottom
          if (!this.$isUsingImplicitHeight && curVPos + child.height > this.height) {
            curVPos = 0;
            curHPos += rowSize + this.spacing;
            rowSize = 0;
          }
          rowSize = child.width > rowSize ? child.width : rowSize;
          child.x = this.layoutDirection === this.Flow.TopToBottom ? this.width - curHPos - child.width : curHPos;
          child.y = curVPos;
          curVPos += child.height + this.spacing;
        }
      }

      if (this.flow === this.Flow.LeftToRight) {
        this.implicitWidth = curHPos - this.spacing;
        this.implicitHeight = curVPos + rowSize;
      } else {
        // Flow.TopToBottom
        this.implicitWidth = curHPos + rowSize;
        this.implicitHeight = curVPos - this.spacing;
      }
    }
  }]);

  return _class41;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "FocusScope",
  versions: /.*/,
  baseClass: "Item"
}, function () {
  function _class42(meta) {
    _classCallCheck(this, _class42);

    QmlWeb.callSuper(this, meta);

    // TODO
  }

  return _class42;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "FontLoader",
  versions: /.*/,
  baseClass: "QtQml.QtObject",
  enums: {
    FontLoader: { Null: 0, Ready: 1, Loading: 2, Error: 3 }
  },
  properties: {
    name: "string",
    source: "url",
    status: "enum" // FontLoader.Null
  }
}, function () {
  function _class43(meta) {
    _classCallCheck(this, _class43);

    QmlWeb.callSuper(this, meta);

    this.$lastName = "";
    this.$inTouchName = false;

    /*
      Maximum timeout is the maximum time for a font to load. If font isn't
      loaded in this time, the status is set to Error.
      For both cases (with and without FontLoader.js) if the font takes more
      than the maximum timeout to load, dimensions recalculations for elements
      that are using this font will not be triggered or will have no effect.
       FontLoader.js uses only the last timeout. The state and name properties
      are set immediately when the font loads. If the font could not be loaded,
      the Error status will be set only when this timeout expires. If the font
      loading takes more than the timeout, the name property is set, but the
      status is set to Error.
       Fallback sets the font name immediately and touches it several times to
      trigger dimensions recalcuations. The status is set to Error and should
      not be used.
    */
    // 15 seconds maximum
    this.$timeouts = [20, 50, 100, 300, 500, 1000, 3000, 5000, 10000, 15000];

    this.sourceChanged.connect(this, this.$onSourceChanged);
    this.nameChanged.connect(this, this.$onNameChanged);
  }

  _createClass(_class43, [{
    key: "$loadFont",
    value: function $loadFont(fontName, fontFace) {
      var _this54 = this;

      /* global FontLoader */
      if (this.$lastName === fontName || this.$inTouchName) {
        return;
      }
      this.$lastName = fontName;

      if (!fontName) {
        this.status = this.FontLoader.Null;
        return;
      }
      this.status = this.FontLoader.Loading;

      var promise = void 0;
      if (fontFace) {
        promise = fontFace.loaded;
      } else if (document.fonts && document.fonts.load) {
        promise = document.fonts.load(fontName);
      }

      if (promise) {
        promise.then(function () {
          if (_this54.$lastName !== fontName) return;
          _this54.name = fontName;
          _this54.status = _this54.FontLoader.Ready;
        }, function () {
          if (_this54.$lastName !== fontName) return;
          _this54.status = _this54.FontLoader.Error;
        });
      } else if (typeof FontLoader === "function") {
        var fontLoader = new FontLoader([fontName], {
          fontsLoaded: function fontsLoaded(error) {
            if (error !== null) {
              if (_this54.$lastName === fontName && error.notLoadedFontFamilies[0] === fontName) {
                // Set the name for the case of font loading after the timeout.
                _this54.name = fontName;
                _this54.status = _this54.FontLoader.Error;
              }
            }
          },
          fontLoaded: function fontLoaded(fontFamily) {
            if (_this54.$lastName === fontName && fontFamily === fontName) {
              _this54.name = fontName;
              _this54.status = _this54.FontLoader.Ready;
            }
          }
        }, this.$timeouts[this.$timeouts.length - 1]);
        // Else I get problems loading multiple fonts (FontLoader.js bug?)
        FontLoader.testDiv = null;
        fontLoader.loadFonts();
      } else {
        console.warn("FontLoader.js library is not loaded.\nYou should load FontLoader.js if you want to use QtQuick FontLoader elements.\nRefs: https://github.com/smnh/FontLoader.");
        // You should not rely on 'status' property without FontLoader.js.
        this.status = this.FontLoader.Error;
        this.name = fontName;
        this.$cycleTouchName(fontName, 0);
      }
    }
  }, {
    key: "$cycleTouchName",
    value: function $cycleTouchName(fontName, i) {
      var _this55 = this;

      if (this.$lastName !== fontName) {
        return;
      }
      if (i > 0) {
        var name = this.name;
        this.$inTouchName = true;
        // Calling this.nameChanged() is not enough, we have to actually change
        // the value to flush the bindings.
        this.name = "sans-serif";
        this.name = name;
        this.$inTouchName = false;
      }
      if (i < this.$timeouts.length) {
        setTimeout(function () {
          _this55.$cycleTouchName(fontName, i + 1);
        }, this.$timeouts[i] - (i > 0 ? this.$timeouts[i - 1] : 0));
      }
    }
  }, {
    key: "$onSourceChanged",
    value: function $onSourceChanged(font_src) {
      // Load font by source url
      var rand = Math.round(Math.random() * 1e15);
      var fontName = "font_" + Date.now().toString(36) + "_" + rand.toString(36);
      if ((typeof FontFace === "undefined" ? "undefined" : _typeof(FontFace)) !== undefined && document.fonts && document.fonts.add) {
        var fontFace = new FontFace(fontName, "url('" + font_src + "')");
        document.fonts.add(fontFace);
        fontFace.load();
        this.$loadFont(fontName, fontFace);
        return;
      }
      if (!this.$domStyle) {
        this.$domStyle = document.createElement("style");
      }
      this.$domStyle.innerHTML = "@font-face {\n      font-family: " + fontName + ";\n      src: url('" + font_src + "');\n    }";
      document.getElementsByTagName("head")[0].appendChild(this.$domStyle);
      this.$loadFont(fontName);
    }
  }, {
    key: "$onNameChanged",
    value: function $onNameChanged(fontName) {
      // Load font by the name
      this.$loadFont(fontName);
    }
  }]);

  return _class43;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "Grid",
  versions: /.*/,
  baseClass: "Positioner",
  enums: {
    Grid: { LeftToRight: 0, TopToBottom: 1 }
  },
  properties: {
    columns: "int",
    rows: "int",
    flow: "enum",
    layoutDirection: "enum"
  }
}, function () {
  function _class44(meta) {
    _classCallCheck(this, _class44);

    QmlWeb.callSuper(this, meta);

    this.columnsChanged.connect(this, this.layoutChildren);
    this.rowsChanged.connect(this, this.layoutChildren);
    this.flowChanged.connect(this, this.layoutChildren);
    this.layoutDirectionChanged.connect(this, this.layoutChildren);
    this.layoutChildren();
  }

  _createClass(_class44, [{
    key: "layoutChildren",
    value: function layoutChildren() {
      // How many items are actually visible?
      var visibleItems = this.$getVisibleItems();

      // How many rows and columns do we need?

      var _$calculateSize = this.$calculateSize(visibleItems.length),
          _$calculateSize2 = _slicedToArray(_$calculateSize, 2),
          c = _$calculateSize2[0],
          r = _$calculateSize2[1];

      // How big are the colums/rows?


      var _$calculateGrid = this.$calculateGrid(visibleItems, c, r),
          _$calculateGrid2 = _slicedToArray(_$calculateGrid, 2),
          colWidth = _$calculateGrid2[0],
          rowHeight = _$calculateGrid2[1];

      // Do actual positioning
      // When layoutDirection is RightToLeft we need oposite order of coumns


      var step = this.layoutDirection === 1 ? -1 : 1;
      var startingPoint = this.layoutDirection === 1 ? c - 1 : 0;
      var endPoint = this.layoutDirection === 1 ? -1 : c;
      var curHPos = 0;
      var curVPos = 0;
      if (this.flow === 0) {
        for (var i = 0; i < r; i++) {
          for (var j = startingPoint; j !== endPoint; j += step) {
            var item = visibleItems[i * c + j];
            if (!item) {
              break;
            }
            item.x = curHPos;
            item.y = curVPos;

            curHPos += colWidth[j] + this.spacing;
          }
          curVPos += rowHeight[i] + this.spacing;
          curHPos = 0;
        }
      } else {
        for (var _i2 = startingPoint; _i2 !== endPoint; _i2 += step) {
          for (var _j = 0; _j < r; _j++) {
            var _item = visibleItems[_i2 * r + _j];
            if (!_item) {
              break;
            }
            _item.x = curHPos;
            _item.y = curVPos;

            curVPos += rowHeight[_j] + this.spacing;
          }
          curHPos += colWidth[_i2] + this.spacing;
          curVPos = 0;
        }
      }

      // Set implicit size
      var gridWidth = -this.spacing;
      var gridHeight = -this.spacing;
      for (var _i3 in colWidth) {
        gridWidth += colWidth[_i3] + this.spacing;
      }
      for (var _i4 in rowHeight) {
        gridHeight += rowHeight[_i4] + this.spacing;
      }
      this.implicitWidth = gridWidth;
      this.implicitHeight = gridHeight;
    }
  }, {
    key: "$getVisibleItems",
    value: function $getVisibleItems() {
      return this.children.filter(function (child) {
        return child.visible && child.width && child.height;
      });
    }
  }, {
    key: "$calculateSize",
    value: function $calculateSize(length) {
      var cols = void 0;
      var rows = void 0;
      if (!this.columns && !this.rows) {
        cols = 4;
        rows = Math.ceil(length / cols);
      } else if (!this.columns) {
        rows = this.rows;
        cols = Math.ceil(length / rows);
      } else {
        cols = this.columns;
        rows = Math.ceil(length / cols);
      }
      return [cols, rows];
    }
  }, {
    key: "$calculateGrid",
    value: function $calculateGrid(visibleItems, cols, rows) {
      var colWidth = [];
      var rowHeight = [];

      if (this.flow === 0) {
        for (var i = 0; i < rows; i++) {
          for (var j = 0; j < cols; j++) {
            var item = visibleItems[i * cols + j];
            if (!item) {
              break;
            }
            if (!colWidth[j] || item.width > colWidth[j]) {
              colWidth[j] = item.width;
            }
            if (!rowHeight[i] || item.height > rowHeight[i]) {
              rowHeight[i] = item.height;
            }
          }
        }
      } else {
        for (var _i5 = 0; _i5 < cols; _i5++) {
          for (var _j2 = 0; _j2 < rows; _j2++) {
            var _item2 = visibleItems[_i5 * rows + _j2];
            if (!_item2) {
              break;
            }
            if (!rowHeight[_j2] || _item2.height > rowHeight[_j2]) {
              rowHeight[_j2] = _item2.height;
            }
            if (!colWidth[_i5] || _item2.width > colWidth[_i5]) {
              colWidth[_i5] = _item2.width;
            }
          }
        }
      }

      return [colWidth, rowHeight];
    }
  }]);

  return _class44;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "Image",
  versions: /.*/,
  baseClass: "Item",
  enums: {
    Image: {
      Stretch: 1, PreserveAspectFit: 2, PreserveAspectCrop: 3,
      Tile: 4, TileVertically: 5, TileHorizontally: 6,

      Null: 1, Ready: 2, Loading: 3, Error: 4
    }
  },
  properties: {
    asynchronous: { type: "bool", initialValue: true },
    cache: { type: "bool", initialValue: true },
    smooth: { type: "bool", initialValue: true },
    fillMode: { type: "enum", initialValue: 1 }, // Image.Stretch
    mirror: "bool",
    progress: "real",
    source: "url",
    status: { type: "enum", initialValue: 1 // Image.Null
    } }
}, function () {
  function _class45(meta) {
    var _this56 = this;

    _classCallCheck(this, _class45);

    QmlWeb.callSuper(this, meta);

    this.sourceSize = new QmlWeb.QObject(this);
    QmlWeb.createProperties(this.sourceSize, {
      width: "int",
      height: "int"
    });

    var bg = this.impl = document.createElement("div");
    bg.style.pointerEvents = "none";
    bg.style.height = "100%";
    this.dom.appendChild(bg);

    this.$img = new Image();
    this.$img.addEventListener("load", function () {
      var w = _this56.$img.naturalWidth;
      var h = _this56.$img.naturalHeight;
      _this56.sourceSize.width = w;
      _this56.sourceSize.height = h;
      _this56.implicitWidth = w;
      _this56.implicitHeight = h;
      _this56.progress = 1;
      _this56.status = _this56.Image.Ready;
    });
    this.$img.addEventListener("error", function () {
      _this56.status = _this56.Image.Error;
    });

    this.sourceChanged.connect(this, this.$onSourceChanged);
    this.mirrorChanged.connect(this, this.$onMirrorChanged);
    this.fillModeChanged.connect(this, this.$onFillModeChanged);
    this.smoothChanged.connect(this, this.$onSmoothChanged);
  }

  _createClass(_class45, [{
    key: "$updateFillMode",
    value: function $updateFillMode() {
      var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.fillMode;

      var style = this.impl.style;
      switch (val) {
        default:
        case this.Image.Stretch:
          style.backgroundRepeat = "auto";
          style.backgroundSize = "100% 100%";
          style.backgroundPosition = "auto";
          break;
        case this.Image.Tile:
          style.backgroundRepeat = "auto";
          style.backgroundSize = "auto";
          style.backgroundPosition = "center";
          break;
        case this.Image.PreserveAspectFit:
          style.backgroundRepeat = "no-repeat";
          style.backgroundSize = "contain";
          style.backgroundPosition = "center";
          break;
        case this.Image.PreserveAspectCrop:
          style.backgroundRepeat = "no-repeat";
          style.backgroundSize = "cover";
          style.backgroundPosition = "center";
          break;
        case this.Image.TileVertically:
          style.backgroundRepeat = "repeat-y";
          style.backgroundSize = "100% auto";
          style.backgroundPosition = "auto";
          break;
        case this.Image.TileHorizontally:
          style.backgroundRepeat = "repeat-x";
          style.backgroundSize = "auto 100%";
          style.backgroundPosition = "auto";
          break;
      }
    }
  }, {
    key: "$onSourceChanged",
    value: function $onSourceChanged(source) {
      this.progress = 0;
      this.status = this.Image.Loading;
      var imageURL = QmlWeb.engine.$resolveImageURL(source);
      this.impl.style.backgroundImage = "url(\"" + imageURL + "\")";
      this.$img.src = imageURL;
      if (this.$img.complete) {
        this.progress = 1;
        this.status = this.Image.Ready;
      }
      this.$updateFillMode();
    }
  }, {
    key: "$onMirrorChanged",
    value: function $onMirrorChanged(val) {
      var transformRule = "scale(-1,1)";
      if (!val) {
        var index = this.transform.indexOf(transformRule);
        if (index >= 0) {
          this.transform.splice(index, 1);
        }
      } else {
        this.transform.push(transformRule);
      }
      this.$updateTransform();
    }
  }, {
    key: "$onFillModeChanged",
    value: function $onFillModeChanged(val) {
      this.$updateFillMode(val);
    }
  }, {
    key: "$onSmoothChanged",
    value: function $onSmoothChanged(val) {
      var style = this.impl.style;
      if (val) {
        style.imageRendering = "auto";
      } else {
        style.imageRendering = "-webkit-optimize-contrast";
        style.imageRendering = "-moz-crisp-edges";
        style.imageRendering = "crisp-edges";
        style.imageRendering = "pixelated";
      }
    }
  }]);

  return _class45;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "IntValidator",
  versions: /.*/,
  baseClass: "Item",
  properties: {
    bottom: { type: "int", initialValue: -2147483647 },
    top: { type: "int", initialValue: 2147483647 }
  }
}, function () {
  function _class46(meta) {
    _classCallCheck(this, _class46);

    QmlWeb.callSuper(this, meta);
  }

  _createClass(_class46, [{
    key: "validate",
    value: function validate(string) {
      var regExp = /^(-|\+)?\s*[0-9]+$/;
      var acceptable = regExp.test(string.trim());

      if (acceptable) {
        var value = parseInt(string, 10);
        acceptable = this.bottom <= value && this.top >= value;
      }
      return acceptable;
    }
  }]);

  return _class46;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "Item",
  versions: /.*/,
  baseClass: "QtQml.QtObject",
  properties: {
    $opacity: { type: "real", initialValue: 1 },
    parent: "Item",
    antialiasing: "bool",
    state: "string",
    states: "list",
    transitions: "list",
    data: "list",
    children: "list",
    resources: "list",
    transform: "list",
    x: "real",
    y: "real",
    z: "real",
    width: "real",
    height: "real",
    implicitWidth: "real",
    implicitHeight: "real",
    left: "real",
    right: "real",
    top: "real",
    bottom: "real",
    horizontalCenter: "real",
    verticalCenter: "real",
    rotation: "real",
    scale: { type: "real", initialValue: 1 },
    opacity: { type: "real", initialValue: 1 },
    visible: { type: "bool", initialValue: true },
    clip: "bool",
    focus: "bool"
  },
  defaultProperty: "data"
}, function () {
  function _class47(meta) {
    _classCallCheck(this, _class47);

    QmlWeb.callSuper(this, meta);

    if (!this.dom) {
      // Create a dom element for this item.
      this.dom = document.createElement(meta.tagName || "div");
    }
    this.dom.style.position = "absolute";
    this.dom.style.pointerEvents = "none";
    // In case the class is qualified, only use the last part for the css class
    // name.
    var classComponent = meta.object.$class.split(".").pop();
    this.dom.className = "" + classComponent + (this.id ? " " + this.id : "");
    this.css = this.dom.style;
    this.impl = null; // Store the actually drawn element

    this.css.boxSizing = "border-box";

    if (this.$isComponentRoot) {
      QmlWeb.createProperty("var", this, "activeFocus");
    }

    this.parentChanged.connect(this, this.$onParentChanged_);
    this.dataChanged.connect(this, this.$onDataChanged);
    this.stateChanged.connect(this, this.$onStateChanged);
    this.visibleChanged.connect(this, this.$onVisibleChanged_);
    this.clipChanged.connect(this, this.$onClipChanged);
    this.zChanged.connect(this, this.$onZChanged);
    this.xChanged.connect(this, this.$onXChanged);
    this.yChanged.connect(this, this.$onYChanged);
    this.widthChanged.connect(this, this.$onWidthChanged_);
    this.heightChanged.connect(this, this.$onHeightChanged_);
    this.focusChanged.connect(this, this.$onFocusChanged_);

    this.widthChanged.connect(this, this.$updateHGeometry);
    this.heightChanged.connect(this, this.$updateVGeometry);
    this.implicitWidthChanged.connect(this, this.$onImplicitWidthChanged);
    this.implicitHeightChanged.connect(this, this.$onImplicitHeightChanged);

    this.$isUsingImplicitWidth = true;
    this.$isUsingImplicitHeight = true;

    this.anchors = new QmlWeb.QObject(this);
    QmlWeb.createProperties(this.anchors, {
      left: "var",
      right: "var",
      top: "var",
      bottom: "var",
      horizontalCenter: "var",
      verticalCenter: "var",
      fill: "Item",
      centerIn: "Item",
      margins: "real",
      leftMargin: "real",
      rightMargin: "real",
      topMargin: "real",
      bottomMargin: "real"
    });
    this.anchors.leftChanged.connect(this, this.$updateHGeometry);
    this.anchors.rightChanged.connect(this, this.$updateHGeometry);
    this.anchors.topChanged.connect(this, this.$updateVGeometry);
    this.anchors.bottomChanged.connect(this, this.$updateVGeometry);
    this.anchors.horizontalCenterChanged.connect(this, this.$updateHGeometry);
    this.anchors.verticalCenterChanged.connect(this, this.$updateVGeometry);
    this.anchors.fillChanged.connect(this, this.$updateHGeometry);
    this.anchors.fillChanged.connect(this, this.$updateVGeometry);
    this.anchors.centerInChanged.connect(this, this.$updateHGeometry);
    this.anchors.centerInChanged.connect(this, this.$updateVGeometry);
    this.anchors.leftMarginChanged.connect(this, this.$updateHGeometry);
    this.anchors.rightMarginChanged.connect(this, this.$updateHGeometry);
    this.anchors.topMarginChanged.connect(this, this.$updateVGeometry);
    this.anchors.bottomMarginChanged.connect(this, this.$updateVGeometry);
    this.anchors.marginsChanged.connect(this, this.$updateHGeometry);
    this.anchors.marginsChanged.connect(this, this.$updateVGeometry);

    // childrenRect property
    this.childrenRect = new QmlWeb.QObject(this);
    QmlWeb.createProperties(this.childrenRect, {
      x: "real", // TODO ro
      y: "real", // TODO ro
      width: "real", // TODO ro
      height: "real" // TODO ro
    });

    this.rotationChanged.connect(this, this.$updateTransform);
    this.scaleChanged.connect(this, this.$updateTransform);
    this.transformChanged.connect(this, this.$updateTransform);

    this.Component.completed.connect(this, this.Component$onCompleted_);
    this.opacityChanged.connect(this, this.$calculateOpacity);
    if (this.$parent) {
      this.$parent.$opacityChanged.connect(this, this.$calculateOpacity);
    }

    this.spacing = 0;
    this.$revertActions = [];
    this.css.left = this.x + "px";
    this.css.top = this.y + "px";
  }

  _createClass(_class47, [{
    key: "$onParentChanged_",
    value: function $onParentChanged_(newParent, oldParent, propName) {
      if (oldParent) {
        oldParent.children.splice(oldParent.children.indexOf(this), 1);
        oldParent.childrenChanged();
        oldParent.dom.removeChild(this.dom);
      }
      if (newParent && newParent.children.indexOf(this) === -1) {
        newParent.children.push(this);
        newParent.childrenChanged();
      }
      if (newParent) {
        newParent.dom.appendChild(this.dom);
      }
      this.$updateHGeometry(newParent, oldParent, propName);
      this.$updateVGeometry(newParent, oldParent, propName);
    }
  }, {
    key: "$onDataChanged",
    value: function $onDataChanged(newData) {
      var QMLItem = QmlWeb.getConstructor("QtQuick", "2.0", "Item");
      for (var i in newData) {
        var child = newData[i];
        if (child instanceof QMLItem) {
          child.parent = this; // This will also add it to children.
        } else {
          this.resources.push(child);
        }
      }
    }
  }, {
    key: "$onStateChanged",
    value: function $onStateChanged(newVal, oldVal) {
      // let oldState; // TODO: do we need oldState?
      var newState = void 0;
      for (var i = 0; i < this.states.length; i++) {
        if (this.states[i].name === newVal) {
          newState = this.states[i];
        }
        /*
        else if (this.states[i].name === oldVal) {
          oldState = this.states[i];
        }
        */
      }

      var actions = this.$revertActions.slice();

      // Get current values for revert actions
      for (var _i6 in actions) {
        var action = actions[_i6];
        action.from = action.target[action.property];
      }
      if (newState) {
        var changes = newState.$getAllChanges();

        // Get all actions we need to do and create actions to revert them
        for (var _i7 = 0; _i7 < changes.length; _i7++) {
          this.$applyChange(actions, changes[_i7]);
        }
      }

      // Set all property changes and fetch the actual values afterwards
      // The latter is needed for transitions. We need to set all properties
      // before we fetch the values because properties can be interdependent.
      for (var _i8 in actions) {
        var _action = actions[_i8];
        _action.target.$properties[_action.property].set(_action.value, QmlWeb.QMLProperty.ReasonUser, _action.target, newState ? newState.$context : _action.target.$context);
      }
      for (var _i9 in actions) {
        var _action2 = actions[_i9];
        _action2.to = _action2.target[_action2.property];
        if (_action2.explicit) {
          // Remove binding
          _action2.target[_action2.property] = _action2.target[_action2.property];
          _action2.value = _action2.target[_action2.property];
        }
      }

      // Find the best transition to use
      var transition = void 0;
      var rating = 0;
      for (var _i10 = 0; _i10 < this.transitions.length; _i10++) {
        // We need to stop running transitions, so let's do
        // it while iterating through the transitions anyway
        this.transitions[_i10].$stop();
        var curTransition = this.transitions[_i10];
        var curRating = 0;
        if (curTransition.from === oldVal || curTransition.reversible && curTransition.from === newVal) {
          curRating += 2;
        } else if (curTransition.from === "*") {
          curRating++;
        } else {
          continue;
        }
        if (curTransition.to === newVal || curTransition.reversible && curTransition.to === oldVal) {
          curRating += 2;
        } else if (curTransition.to === "*") {
          curRating++;
        } else {
          continue;
        }
        if (curRating > rating) {
          rating = curRating;
          transition = curTransition;
        }
      }
      if (transition) {
        transition.$start(actions);
      }
    }
  }, {
    key: "$applyChange",
    value: function $applyChange(actions, change) {
      var _this57 = this;

      var arrayFindIndex = QmlWeb.helpers.arrayFindIndex;

      var _loop = function _loop(j) {
        var item = change.$actions[j];

        var action = {
          target: change.target,
          property: item.property,
          origValue: change.target.$properties[item.property].binding || change.target.$properties[item.property].val,
          value: item.value,
          from: change.target[item.property],
          to: undefined,
          explicit: change.explicit
        };

        var actionIndex = arrayFindIndex(actions, function (element) {
          return element.target === action.target && element.property === action.property;
        });
        if (actionIndex !== -1) {
          actions[actionIndex] = action;
        } else {
          actions.push(action);
        }

        // Look for existing revert action, else create it
        var revertIndex = arrayFindIndex(_this57.$revertActions, function (element) {
          return element.target === change.target && element.property === item.property;
        });
        if (revertIndex !== -1 && !change.restoreEntryValues) {
          // We don't want to revert, so remove it
          _this57.$revertActions.splice(revertIndex, 1);
        } else if (revertIndex === -1 && change.restoreEntryValues) {
          _this57.$revertActions.push({
            target: change.target,
            property: item.property,
            value: change.target.$properties[item.property].binding || change.target.$properties[item.property].val,
            from: undefined,
            to: change.target[item.property]
          });
        }
      };

      for (var j = 0; j < change.$actions.length; j++) {
        _loop(j);
      }
    }
  }, {
    key: "$onVisibleChanged_",
    value: function $onVisibleChanged_(newVal) {
      this.css.visibility = newVal ? "inherit" : "hidden";
    }
  }, {
    key: "$onClipChanged",
    value: function $onClipChanged(newVal) {
      this.css.overflow = newVal ? "hidden" : "visible";
    }
  }, {
    key: "$onZChanged",
    value: function $onZChanged() {
      this.$updateTransform();
    }
  }, {
    key: "$onXChanged",
    value: function $onXChanged(newVal) {
      this.css.left = newVal + "px";
      this.$updateHGeometry();
    }
  }, {
    key: "$onYChanged",
    value: function $onYChanged(newVal) {
      this.css.top = newVal + "px";
      this.$updateVGeometry();
    }
  }, {
    key: "$onWidthChanged_",
    value: function $onWidthChanged_(newVal) {
      this.css.width = newVal ? newVal + "px" : "auto";
    }
  }, {
    key: "$onHeightChanged_",
    value: function $onHeightChanged_(newVal) {
      this.css.height = newVal ? newVal + "px" : "auto";
    }
  }, {
    key: "$onFocusChanged",
    value: function $onFocusChanged(newVal) {
      if (newVal) {
        if (this.dom.firstChild) {
          this.dom.firstChild.focus();
        }
        document.qmlFocus = this;
        this.$context.activeFocus = this;
      } else if (document.qmlFocus === this) {
        document.getElementsByTagName("BODY")[0].focus();
        document.qmlFocus = QmlWeb.engine.rootContext().base;
        this.$context.activeFocus = null;
      }
    }
  }, {
    key: "setupFocusOnDom",
    value: function setupFocusOnDom(element) {
      var _this58 = this;

      var updateFocus = function updateFocus() {
        var hasFocus = document.activeElement === _this58.dom || document.activeElement === _this58.dom.firstChild;
        if (_this58.focus !== hasFocus) {
          _this58.focus = hasFocus;
        }
      };
      element.addEventListener("focus", updateFocus);
      element.addEventListener("blur", updateFocus);
    }
  }, {
    key: "$updateTransform",
    value: function $updateTransform() {
      var QMLTranslate = QmlWeb.getConstructor("QtQuick", "2.0", "Translate");
      var QMLRotation = QmlWeb.getConstructor("QtQuick", "2.0", "Rotation");
      var QMLScale = QmlWeb.getConstructor("QtQuick", "2.0", "Scale");
      var transform = "rotate(" + this.rotation + "deg) scale(" + this.scale + ")";
      var filter = "";
      var transformStyle = "preserve-3d";

      for (var i = 0; i < this.transform.length; i++) {
        var t = this.transform[i];
        if (t instanceof QMLRotation) {
          var ax = t.axis;
          transform += " rotate3d(" + ax.x + ", " + ax.y + ", " + ax.z + ", " + ax.angle + "deg)";
        } else if (t instanceof QMLScale) {
          transform += " scale(" + t.xScale + ", " + t.yScale + ")";
        } else if (t instanceof QMLTranslate) {
          transform += " translate(" + t.x + "px, " + t.y + "px)";
        } else if (typeof t.transformType !== "undefined") {
          if (t.transformType === "filter") {
            filter += t.operation + "(" + t.parameters + ") ";
          }
        } else if (typeof t === "string") {
          transform += t;
        }
      }
      if (typeof this.z === "number") {
        transform += " translate3d(0, 0, " + this.z + "px)";
      }
      this.dom.style.transform = transform;
      this.dom.style.transformStyle = transformStyle;
      this.dom.style.webkitTransform = transform; // Chrome, Safari and Opera
      this.dom.style.webkitTransformStyle = transformStyle;
      this.dom.style.msTransform = transform; // IE
      this.dom.style.filter = filter;
      this.dom.style.webkitFilter = filter; // Chrome, Safari and Opera
    }
  }, {
    key: "Component$onCompleted_",
    value: function Component$onCompleted_() {
      this.$calculateOpacity();
    }
  }, {
    key: "$calculateOpacity",
    value: function $calculateOpacity() {
      // TODO: reset all opacity on layer.enabled changed
      /*
      if (false) { // TODO: check layer.enabled
        this.css.opacity = this.opacity;
      }
      */
      var parentOpacity = this.$parent && this.$parent.$opacity || 1;
      this.$opacity = this.opacity * parentOpacity;
      if (this.impl) {
        this.impl.style.opacity = this.$opacity;
      }
    }
  }, {
    key: "$onImplicitWidthChanged",
    value: function $onImplicitWidthChanged() {
      if (this.$isUsingImplicitWidth) {
        this.width = this.implicitWidth;
        this.$isUsingImplicitWidth = true;
      }
    }
  }, {
    key: "$onImplicitHeightChanged",
    value: function $onImplicitHeightChanged() {
      if (this.$isUsingImplicitHeight) {
        this.height = this.implicitHeight;
        this.$isUsingImplicitHeight = true;
      }
    }
  }, {
    key: "$updateHGeometry",
    value: function $updateHGeometry(newVal, oldVal, propName) {
      var anchors = this.anchors || this;
      if (this.$updatingHGeometry) {
        return;
      }
      this.$updatingHGeometry = true;

      var flags = QmlWeb.Signal.UniqueConnection;
      var lM = anchors.leftMargin || anchors.margins;
      var rM = anchors.rightMargin || anchors.margins;
      var w = this.width;
      var left = this.parent ? this.parent.left : 0;

      // Width
      if (propName === "width") {
        this.$isUsingImplicitWidth = false;
      }

      // Position TODO: Layouts

      var u = {}; // our update object

      if (anchors.fill !== undefined) {
        var fill = anchors.fill;
        var props = fill.$properties;
        props.left.changed.connect(this, this.$updateHGeometry, flags);
        props.right.changed.connect(this, this.$updateHGeometry, flags);
        props.width.changed.connect(this, this.$updateHGeometry, flags);

        this.$isUsingImplicitWidth = false;
        u.width = fill.width - lM - rM;
        u.x = fill.left - left + lM;
        u.left = fill.left + lM;
        u.right = fill.right - rM;
        u.horizontalCenter = (u.left + u.right) / 2;
      } else if (anchors.centerIn !== undefined) {
        var horizontalCenter = anchors.centerIn.$properties.horizontalCenter;
        horizontalCenter.changed.connect(this, this.$updateHGeometry, flags);

        u.horizontalCenter = anchors.centerIn.horizontalCenter;
        u.x = u.horizontalCenter - w / 2 - left;
        u.left = u.horizontalCenter - w / 2;
        u.right = u.horizontalCenter + w / 2;
      } else if (anchors.left !== undefined) {
        u.left = anchors.left + lM;
        if (anchors.right !== undefined) {
          u.right = anchors.right - rM;
          this.$isUsingImplicitWidth = false;
          u.width = u.right - u.left;
          u.x = u.left - left;
          u.horizontalCenter = (u.right + u.left) / 2;
        } else if (anchors.horizontalCenter !== undefined) {
          u.horizontalCenter = anchors.horizontalCenter;
          this.$isUsingImplicitWidth = false;
          u.width = (u.horizontalCenter - u.left) * 2;
          u.x = u.left - left;
          u.right = 2 * u.horizontalCenter - u.left;
        } else {
          u.x = u.left - left;
          u.right = u.left + w;
          u.horizontalCenter = u.left + w / 2;
        }
      } else if (anchors.right !== undefined) {
        u.right = anchors.right - rM;
        if (anchors.horizontalCenter !== undefined) {
          u.horizontalCenter = anchors.horizontalCenter;
          this.$isUsingImplicitWidth = false;
          u.width = (u.right - u.horizontalCenter) * 2;
          u.x = 2 * u.horizontalCenter - u.right - left;
          u.left = 2 * u.horizontalCenter - u.right;
        } else {
          u.x = u.right - w - left;
          u.left = u.right - w;
          u.horizontalCenter = u.right - w / 2;
        }
      } else if (anchors.horizontalCenter !== undefined) {
        u.horizontalCenter = anchors.horizontalCenter;
        u.x = u.horizontalCenter - w / 2 - left;
        u.left = u.horizontalCenter - w / 2;
        u.right = u.horizontalCenter + w / 2;
      } else {
        if (this.parent) {
          var leftProp = this.parent.$properties.left;
          leftProp.changed.connect(this, this.$updateHGeometry, flags);
        }

        u.left = this.x + left;
        u.right = u.left + w;
        u.horizontalCenter = u.left + w / 2;
      }

      for (var _key37 in u) {
        this[_key37] = u[_key37];
      }

      this.$updatingHGeometry = false;

      if (this.parent) this.$updateChildrenRect(this.parent);
    }
  }, {
    key: "$updateVGeometry",
    value: function $updateVGeometry(newVal, oldVal, propName) {
      var anchors = this.anchors || this;
      if (this.$updatingVGeometry) {
        return;
      }
      this.$updatingVGeometry = true;

      var flags = QmlWeb.Signal.UniqueConnection;
      var tM = anchors.topMargin || anchors.margins;
      var bM = anchors.bottomMargin || anchors.margins;
      var h = this.height;
      var top = this.parent ? this.parent.top : 0;

      // HeighttopProp
      if (propName === "height") {
        this.$isUsingImplicitHeight = false;
      }

      // Position TODO: Layouts

      var u = {}; // our update object

      if (anchors.fill !== undefined) {
        var fill = anchors.fill;
        var props = fill.$properties;
        props.top.changed.connect(this, this.$updateVGeometry, flags);
        props.bottom.changed.connect(this, this.$updateVGeometry, flags);
        props.height.changed.connect(this, this.$updateVGeometry, flags);

        this.$isUsingImplicitHeight = false;
        u.height = fill.height - tM - bM;
        u.y = fill.top - top + tM;
        u.top = fill.top + tM;
        u.bottom = fill.bottom - bM;
        u.verticalCenter = (u.top + u.bottom) / 2;
      } else if (anchors.centerIn !== undefined) {
        var verticalCenter = anchors.centerIn.$properties.verticalCenter;
        verticalCenter.changed.connect(this, this.$updateVGeometry, flags);

        u.verticalCenter = anchors.centerIn.verticalCenter;
        u.y = u.verticalCenter - h / 2 - top;
        u.top = u.verticalCenter - h / 2;
        u.bottom = u.verticalCenter + h / 2;
      } else if (anchors.top !== undefined) {
        u.top = anchors.top + tM;
        if (anchors.bottom !== undefined) {
          u.bottom = anchors.bottom - bM;
          this.$isUsingImplicitHeight = false;
          u.height = u.bottom - u.top;
          u.y = u.top - top;
          u.verticalCenter = (u.bottom + u.top) / 2;
        } else if ((u.verticalCenter = anchors.verticalCenter) !== undefined) {
          this.$isUsingImplicitHeight = false;
          u.height = (u.verticalCenter - u.top) * 2;
          u.y = u.top - top;
          u.bottom = 2 * u.verticalCenter - u.top;
        } else {
          u.y = u.top - top;
          u.bottom = u.top + h;
          u.verticalCenter = u.top + h / 2;
        }
      } else if (anchors.bottom !== undefined) {
        u.bottom = anchors.bottom - bM;
        if ((u.verticalCenter = anchors.verticalCenter) !== undefined) {
          this.$isUsingImplicitHeight = false;
          u.height = (u.bottom - u.verticalCenter) * 2;
          u.y = 2 * u.verticalCenter - u.bottom - top;
          u.top = 2 * u.verticalCenter - u.bottom;
        } else {
          u.y = u.bottom - h - top;
          u.top = u.bottom - h;
          u.verticalCenter = u.bottom - h / 2;
        }
      } else if (anchors.verticalCenter !== undefined) {
        u.verticalCenter = anchors.verticalCenter;
        u.y = u.verticalCenter - h / 2 - top;
        u.top = u.verticalCenter - h / 2;
        u.bottom = u.verticalCenter + h / 2;
      } else {
        if (this.parent) {
          var topProp = this.parent.$properties.top;
          topProp.changed.connect(this, this.$updateVGeometry, flags);
        }

        u.top = this.y + top;
        u.bottom = u.top + h;
        u.verticalCenter = u.top + h / 2;
      }

      for (var _key38 in u) {
        this[_key38] = u[_key38];
      }

      this.$updatingVGeometry = false;

      if (this.parent) this.$updateChildrenRect(this.parent);
    }
  }, {
    key: "$updateChildrenRect",
    value: function $updateChildrenRect(component) {
      if (!component || !component.children || component.children.length === 0) {
        return;
      }
      var children = component.children;

      var maxWidth = 0;
      var maxHeight = 0;
      var minX = children.length > 0 ? children[0].x : 0;
      var minY = children.length > 0 ? children[0].y : 0;

      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        maxWidth = Math.max(maxWidth, child.x + child.width);
        maxHeight = Math.max(maxHeight, child.y + child.heighth);
        minX = Math.min(minX, child.x);
        minY = Math.min(minX, child.y);
      }

      component.childrenRect.x = minX;
      component.childrenRect.y = minY;
      component.childrenRect.width = maxWidth;
      component.childrenRect.height = maxHeight;
    }
  }]);

  return _class47;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "ListElement",
  versions: /.*/,
  baseClass: "QtQml.QtObject"
}, function () {
  function _class48(meta) {
    _classCallCheck(this, _class48);

    QmlWeb.callSuper(this, meta);

    for (var i in meta.object) {
      if (i[0] !== "$") {
        QmlWeb.createProperty("variant", this, i);
      }
    }
    QmlWeb.applyProperties(meta.object, this, this, this.$context);
  }

  return _class48;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "ListModel",
  versions: /.*/,
  baseClass: "QtQml.QtObject",
  properties: {
    count: "int",
    $items: "list"
  },
  defaultProperty: "$items"
}, function () {
  function _class49(meta) {
    var _this59 = this;

    _classCallCheck(this, _class49);

    QmlWeb.callSuper(this, meta);

    this.$firstItem = true;
    this.$itemsChanged.connect(this, this.$on$itemsChanged);
    this.$model = new QmlWeb.JSItemModel();
    this.$model.data = function (index, role) {
      return _this59.$items[index][role];
    };
    this.$model.rowCount = function () {
      return _this59.$items.length;
    };
  }

  _createClass(_class49, [{
    key: "$on$itemsChanged",
    value: function $on$itemsChanged(newVal) {
      this.count = this.$items.length;
      if (this.$firstItem && newVal.length > 0) {
        var QMLListElement = QmlWeb.getConstructor("QtQuick", "2.0", "ListElement");
        this.$firstItem = false;
        var roleNames = [];
        var dict = newVal[0];
        if (dict instanceof QMLListElement) {
          dict = dict.$properties;
        }
        for (var i in dict) {
          if (i !== "index") {
            roleNames.push(i);
          }
        }
        this.$model.setRoleNames(roleNames);
      }
    }
  }, {
    key: "append",
    value: function append(dict) {
      var index = this.$items.length;
      var c = 0;

      if (dict instanceof Array) {
        for (var _key39 in dict) {
          this.$items.push(dict[_key39]);
          c++;
        }
      } else {
        this.$items.push(dict);
        c = 1;
      }

      this.$itemsChanged(this.$items);
      this.$model.rowsInserted(index, index + c);
    }
  }, {
    key: "clear",
    value: function clear() {
      this.$items.length = 0;
      this.count = 0;
      this.$model.modelReset();
    }
  }, {
    key: "get",
    value: function get(index) {
      return this.$items[index];
    }
  }, {
    key: "insert",
    value: function insert(index, dict) {
      this.$items.splice(index, 0, dict);
      this.$itemsChanged(this.$items);
      this.$model.rowsInserted(index, index + 1);
    }
  }, {
    key: "move",
    value: function move(from, to, n) {
      var vals = this.$items.splice(from, n);
      for (var i = 0; i < vals.length; i++) {
        this.$items.splice(to + i, 0, vals[i]);
      }
      this.$model.rowsMoved(from, from + n, to);
    }
  }, {
    key: "remove",
    value: function remove(index) {
      this.$items.splice(index, 1);
      this.$model.rowsRemoved(index, index + 1);
      this.count = this.$items.length;
    }
  }, {
    key: "set",
    value: function set(index, dict) {
      this.$items[index] = dict;
      this.$model.dataChanged(index, index);
    }
  }, {
    key: "setProperty",
    value: function setProperty(index, property, value) {
      this.$items[index][property] = value;
      this.$model.dataChanged(index, index);
    }
  }]);

  return _class49;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "ListView",
  versions: /.*/,
  baseClass: "Repeater",
  properties: {
    orientation: "enum",
    spacing: "real"
  }
}, function () {
  function _class50(meta) {
    _classCallCheck(this, _class50);

    QmlWeb.callSuper(this, meta);
    this.modelChanged.connect(this, this.$styleChanged);
    this.delegateChanged.connect(this, this.$styleChanged);
    this.orientationChanged.connect(this, this.$styleChanged);
    this.spacingChanged.connect(this, this.$styleChanged);
    this._childrenInserted.connect(this, this.$applyStyleOnItem);
  }

  _createClass(_class50, [{
    key: "container",
    value: function container() {
      return this;
    }
  }, {
    key: "$applyStyleOnItem",
    value: function $applyStyleOnItem($item) {
      var Qt = QmlWeb.Qt;
      $item.dom.style.position = "initial";
      if (this.orientation === Qt.Horizontal) {
        $item.dom.style.display = "inline-block";
        if ($item !== this.$items[0]) {
          $item.dom.style["margin-left"] = this.spacing + "px";
        }
      } else {
        $item.dom.style.display = "block";
        if ($item !== this.$items[0]) {
          $item.dom.style["margin-top"] = this.spacing + "px";
        }
      }
    }
  }, {
    key: "$styleChanged",
    value: function $styleChanged() {
      for (var i = 0; i < this.$items.length; ++i) {
        this.$applyStyleOnItem(this.$items[i]);
      }
    }
  }]);

  return _class50;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "Loader",
  versions: /.*/,
  baseClass: "Item",
  properties: {
    active: { type: "bool", initialValue: true },
    asynchronous: "bool",
    item: "var",
    progress: "real",
    source: "url",
    sourceComponent: "Component",
    status: { type: "enum", initialValue: 1 }
  },
  signals: {
    loaded: []
  }
}, function () {
  function _class51(meta) {
    _classCallCheck(this, _class51);

    QmlWeb.callSuper(this, meta);

    this.$sourceUrl = "";

    this.activeChanged.connect(this, this.$onActiveChanged);
    this.sourceChanged.connect(this, this.$onSourceChanged);
    this.sourceComponentChanged.connect(this, this.$onSourceComponentChanged);
    this.widthChanged.connect(this, this.$updateGeometry);
    this.heightChanged.connect(this, this.$updateGeometry);
  }

  _createClass(_class51, [{
    key: "$onActiveChanged",
    value: function $onActiveChanged() {
      if (!this.active) {
        this.$unload();
        return;
      }
      if (this.source) {
        this.$onSourceChanged(this.source);
      } else if (this.sourceComponent) {
        this.$onSourceComponentChanged(this.sourceComponent);
      }
    }
  }, {
    key: "$onSourceChanged",
    value: function $onSourceChanged(fileName) {
      // TODO
      // if (fileName == this.$sourceUrl && this.item !== undefined) return;
      if (!this.active) return;
      this.$unload();

      if (!fileName) {
        this.sourceComponent = null;
        this.$sourceUrl = fileName;
        return;
      }

      var tree = QmlWeb.engine.loadComponent(fileName);
      var QMLComponent = QmlWeb.getConstructor("QtQml", "2.0", "Component");
      var meta = { object: tree, context: this.$context, parent: this };
      var qmlComponent = new QMLComponent(meta);
      qmlComponent.$basePath = QmlWeb.engine.extractBasePath(tree.$file);
      qmlComponent.$imports = tree.$imports;
      qmlComponent.$file = tree.$file;
      QmlWeb.engine.loadImports(tree.$imports, qmlComponent.$basePath, qmlComponent.importContextId);
      var loadedComponent = this.$createComponentObject(qmlComponent, this);
      this.sourceComponent = loadedComponent;
      this.$sourceUrl = fileName;
    }
  }, {
    key: "$onSourceComponentChanged",
    value: function $onSourceComponentChanged(newItem) {
      if (!this.active) return;
      this.$unload();

      if (!newItem) {
        this.item = null;
        return;
      }

      var QMLComponent = QmlWeb.getConstructor("QtQml", "2.0", "Component");
      var qmlComponent = newItem;
      if (newItem instanceof QMLComponent) {
        qmlComponent = newItem.$createObject(this, {}, this);
      }
      qmlComponent.parent = this;
      this.item = qmlComponent;
      this.$updateGeometry();
      if (this.item) {
        this.loaded();
      }
    }
  }, {
    key: "setSource",
    value: function setSource(url, options) {
      this.$sourceUrl = url;
      this.props = options;
      this.source = url;
    }
  }, {
    key: "$unload",
    value: function $unload() {
      if (!this.item) return;
      this.item.$delete();
      this.item.parent = undefined;
      this.item = undefined;
    }
  }, {
    key: "$callOnCompleted",
    value: function $callOnCompleted(child) {
      child.Component.completed();
      var QMLBaseObject = QmlWeb.getConstructor("QtQml", "2.0", "QtObject");
      for (var i = 0; i < child.$tidyupList.length; i++) {
        if (child.$tidyupList[i] instanceof QMLBaseObject) {
          this.$callOnCompleted(child.$tidyupList[i]);
        }
      }
    }
  }, {
    key: "$createComponentObject",
    value: function $createComponentObject(qmlComponent, parent) {
      var newComponent = qmlComponent.createObject(parent);
      if (QmlWeb.engine.operationState !== QmlWeb.QMLOperationState.Init) {
        // We don't call those on first creation, as they will be called
        // by the regular creation-procedures at the right time.
        QmlWeb.engine.$initializePropertyBindings();
        this.$callOnCompleted(newComponent);
      }
      return newComponent;
    }
  }, {
    key: "$updateGeometry",
    value: function $updateGeometry() {
      // Loader size doesn't exist
      if (!this.width) {
        this.width = this.item ? this.item.width : 0;
      } else if (this.item) {
        // Loader size exists
        this.item.width = this.width;
      }

      if (!this.height) {
        this.height = this.item ? this.item.height : 0;
      } else if (this.item) {
        // Loader size exists
        this.item.height = this.height;
      }
    }
  }]);

  return _class51;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "MouseArea",
  versions: /.*/,
  baseClass: "Item",
  properties: {
    acceptedButtons: { type: "variant", initialValue: 1 }, // Qt.LeftButton
    enabled: { type: "bool", initialValue: true },
    hoverEnabled: "bool",
    mouseX: "real",
    mouseY: "real",
    pressed: "bool",
    containsMouse: "bool",
    pressedButtons: { type: "variant", initialValue: 0 },
    cursorShape: "enum" // Qt.ArrowCursor
  },
  signals: {
    clicked: [{ type: "variant", name: "mouse" }],
    entered: [],
    exited: [],
    positionChanged: [{ type: "variant", name: "mouse" }]
  }
}, function () {
  function _class52(meta) {
    var _this60 = this;

    _classCallCheck(this, _class52);

    QmlWeb.callSuper(this, meta);

    this.dom.style.pointerEvents = "all";

    // IE does not handle mouse clicks to transparent divs, so we have
    // to set a background color and make it invisible using opacity
    // as that doesn't affect the mouse handling.
    this.dom.style.backgroundColor = "white";
    this.dom.style.opacity = 0;

    this.cursorShapeChanged.connect(this, this.$onCursorShapeChanged);

    this.dom.addEventListener("click", function (e) {
      return _this60.$handleClick(e);
    });
    this.dom.addEventListener("contextmenu", function (e) {
      return _this60.$handleClick(e);
    });
    var handleMouseMove = function handleMouseMove(e) {
      if (!_this60.enabled || !_this60.hoverEnabled && !_this60.pressed) return;
      _this60.$handlePositionChanged(e);
    };
    var handleMouseUp = function handleMouseUp() {
      _this60.pressed = false;
      _this60.pressedButtons = 0;
      document.removeEventListener("mouseup", handleMouseUp);
      _this60.$clientTransform = undefined;
      document.removeEventListener("mousemove", handleMouseMove);
    };
    this.dom.addEventListener("mousedown", function (e) {
      if (!_this60.enabled) return;
      // Handle scale and translate transformations
      var boundingRect = _this60.dom.getBoundingClientRect();
      _this60.$clientTransform = {
        x: boundingRect.left,
        y: boundingRect.top,
        xScale: _this60.width ? (boundingRect.right - boundingRect.left) / _this60.width : 1,
        yScale: _this60.height ? (boundingRect.bottom - boundingRect.top) / _this60.height : 1
      };
      var mouse = _this60.$eventToMouse(e);
      _this60.mouseX = mouse.x;
      _this60.mouseY = mouse.y;
      _this60.pressed = true;
      _this60.pressedButtons = mouse.button;
      document.addEventListener("mouseup", handleMouseUp);
      document.addEventListener("mousemove", handleMouseMove);
    });
    this.dom.addEventListener("mouseover", function () {
      _this60.containsMouse = true;
      _this60.entered();
    });
    this.dom.addEventListener("mouseout", function () {
      _this60.containsMouse = false;
      _this60.exited();
    });
    // This is to emit positionChanged for `hoverEnabled` only. When `pressed`,
    // `positionChanged` is handled by a temporary `mousemove` event listener
    // on `document`.
    this.dom.addEventListener("mousemove", function (e) {
      if (!_this60.enabled || !_this60.hoverEnabled || _this60.pressed) return;
      _this60.$handlePositionChanged(e);
    });
  }

  _createClass(_class52, [{
    key: "$onCursorShapeChanged",
    value: function $onCursorShapeChanged() {
      this.dom.style.cursor = this.$cursorShapeToCSS();
    }
  }, {
    key: "$handlePositionChanged",
    value: function $handlePositionChanged(e) {
      var mouse = this.$eventToMouse(e);
      this.mouseX = mouse.x;
      this.mouseY = mouse.y;
      this.positionChanged(mouse);
    }
  }, {
    key: "$handleClick",
    value: function $handleClick(e) {
      var mouse = this.$eventToMouse(e);
      if (this.enabled && this.acceptedButtons & mouse.button) {
        this.clicked(mouse);
      }
      // This decides whether to show the browser's context menu on right click or
      // not
      return !(this.acceptedButtons & QmlWeb.Qt.RightButton);
    }
  }, {
    key: "$eventToMouse",
    value: function $eventToMouse(e) {
      var Qt = QmlWeb.Qt;
      var mouse = {
        accepted: true,
        button: e.button === 0 ? Qt.LeftButton : e.button === 1 ? Qt.MiddleButton : e.button === 2 ? Qt.RightButton : 0,
        modifiers: e.ctrlKey * Qt.CtrlModifier | e.altKey * Qt.AltModifier | e.shiftKey * Qt.ShiftModifier | e.metaKey * Qt.MetaModifier
      };
      if (this.$clientTransform) {
        // Handle scale and translate transformations
        mouse.x = (e.clientX - this.$clientTransform.x) / this.$clientTransform.xScale;
        mouse.y = (e.clientY - this.$clientTransform.y) / this.$clientTransform.yScale;
      } else {
        mouse.x = e.offsetX || e.layerX;
        mouse.y = e.offsetY || e.layerY;
      }
      return mouse;
    }

    // eslint-disable-next-line complexity

  }, {
    key: "$cursorShapeToCSS",
    value: function $cursorShapeToCSS() {
      var Qt = QmlWeb.Qt;
      switch (this.cursorShape) {
        case Qt.ArrowCursor:
          return "default";
        case Qt.UpArrowCursor:
          return "n-resize";
        case Qt.CrossCursor:
          return "crosshair";
        case Qt.WaitCursor:
          return "wait";
        case Qt.IBeamCursor:
          return "text";
        case Qt.SizeVerCursor:
          return "ew-resize";
        case Qt.SizeHorCursor:
          return "ns-resize";
        case Qt.SizeBDiagCursor:
          return "nesw-resize";
        case Qt.SizeFDiagCursor:
          return "nwse-resize";
        case Qt.SizeAllCursor:
          return "all-scroll";
        case Qt.BlankCursor:
          return "none";
        case Qt.SplitVCursor:
          return "row-resize";
        case Qt.SplitHCursor:
          return "col-resize";
        case Qt.PointingHandCursor:
          return "pointer";
        case Qt.ForbiddenCursor:
          return "not-allowed";
        case Qt.WhatsThisCursor:
          return "help";
        case Qt.BusyCursor:
          return "progress";
        case Qt.OpenHandCursor:
          return "grab";
        case Qt.ClosedHandCursor:
          return "grabbing";
        case Qt.DragCopyCursor:
          return "copy";
        case Qt.DragMoveCursor:
          return "move";
        case Qt.DragLinkCursor:
          return "alias";
        //case Qt.BitmapCursor: return "auto";
        //case Qt.CustomCursor: return "auto";
      }
      return "auto";
    }
  }]);

  return _class52;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "NumberAnimation",
  versions: /.*/,
  baseClass: "PropertyAnimation"
}, function () {
  function _class53(meta) {
    var _this61 = this;

    _classCallCheck(this, _class53);

    QmlWeb.callSuper(this, meta);

    this.$at = 0;
    this.$loop = 0;

    QmlWeb.engine.$addTicker(function () {
      return _this61.$ticker.apply(_this61, arguments);
    });
    this.runningChanged.connect(this, this.$onRunningChanged);
  }

  _createClass(_class53, [{
    key: "$startLoop",
    value: function $startLoop() {
      for (var i in this.$actions) {
        var _action3 = this.$actions[i];
        _action3.from = _action3.from !== undefined ? _action3.from : _action3.target[_action3.property];
      }
      this.$at = 0;
    }
  }, {
    key: "$ticker",
    value: function $ticker(now, elapsed) {
      if (!this.running && this.$loop !== -1 || this.paused) {
        // $loop === -1 is a marker to just finish this run
        return;
      }
      if (this.$at === 0 && this.$loop === 0 && !this.$actions.length) {
        this.$redoActions();
      }
      this.$at += elapsed / this.duration;
      if (this.$at >= 1) {
        this.complete();
        return;
      }
      for (var i in this.$actions) {
        var _action4 = this.$actions[i];
        var value = _action4.from + (_action4.to - _action4.from) * this.easing.$valueForProgress(this.$at);
        var property = _action4.target.$properties[_action4.property];
        property.set(value, QmlWeb.QMLProperty.ReasonAnimation);
      }
    }
  }, {
    key: "$onRunningChanged",
    value: function $onRunningChanged(newVal) {
      if (newVal) {
        this.$startLoop();
        this.paused = false;
      } else if (this.alwaysRunToEnd && this.$at < 1) {
        this.$loop = -1; // -1 is used as a marker to stop
      } else {
        this.$loop = 0;
        this.$actions = [];
      }
    }
  }, {
    key: "complete",
    value: function complete() {
      for (var i in this.$actions) {
        var _action5 = this.$actions[i];
        var property = _action5.target.$properties[_action5.property];
        property.set(_action5.to, QmlWeb.QMLProperty.ReasonAnimation);
      }
      this.$loop++;
      if (this.$loop === this.loops) {
        this.running = false;
      } else if (!this.running) {
        this.$actions = [];
      } else {
        this.$startLoop(this);
      }
    }
  }]);

  return _class53;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "OpacityAnimator",
  versions: /^2\./,
  baseClass: "Animator"
}, function () {
  function _class54(meta) {
    _classCallCheck(this, _class54);

    QmlWeb.callSuper(this, meta);
  }

  return _class54;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "ParallelAnimation",
  versions: /.*/,
  baseClass: "Animation",
  enums: {
    Animation: { Infinite: Math.Infinite }
  },
  properties: {
    animations: "list"
  },
  defaultProperty: "animations"
}, function () {
  function _class55(meta) {
    var _this62 = this;

    _classCallCheck(this, _class55);

    QmlWeb.callSuper(this, meta);

    this.$runningAnimations = 0;

    this.animationsChanged.connect(this, this.$onAnimationsChanged);

    QmlWeb.engine.$registerStart(function () {
      if (!_this62.running) return;
      self.running = false; // toggled back by start();
      self.start();
    });
    QmlWeb.engine.$registerStop(function () {
      return _this62.stop();
    });
  }

  _createClass(_class55, [{
    key: "$onAnimationsChanged",
    value: function $onAnimationsChanged() {
      var flags = QmlWeb.Signal.UniqueConnection;
      for (var i = 0; i < this.animations.length; i++) {
        var animation = this.animations[i];
        animation.runningChanged.connect(this, this.$animationFinished, flags);
      }
    }
  }, {
    key: "$animationFinished",
    value: function $animationFinished(newVal) {
      this.$runningAnimations += newVal ? 1 : -1;
      if (this.$runningAnimations === 0) {
        this.running = false;
      }
    }
  }, {
    key: "start",
    value: function start() {
      if (this.running) return;
      this.running = true;
      for (var i = 0; i < this.animations.length; i++) {
        this.animations[i].start();
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      if (!this.running) return;
      for (var i = 0; i < this.animations.length; i++) {
        this.animations[i].stop();
      }
      this.running = false;
    }
  }, {
    key: "complete",
    value: function complete() {
      this.stop();
    }
  }]);

  return _class55;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "PauseAnimation",
  versions: /.*/,
  baseClass: "Animation",
  properties: {
    duration: { type: "int", initialValue: 250 }
  }
}, function () {
  function _class56(meta) {
    var _this63 = this;

    _classCallCheck(this, _class56);

    QmlWeb.callSuper(this, meta);

    this.$at = 0;

    QmlWeb.engine.$addTicker(function () {
      return _this63.$ticker.apply(_this63, arguments);
    });
    this.runningChanged.connect(this, this.$onRunningChanged);
  }

  _createClass(_class56, [{
    key: "$ticker",
    value: function $ticker(now, elapsed) {
      if (!this.running || this.paused) {
        return;
      }
      this.$at += elapsed / this.duration;
      if (this.$at >= 1) {
        this.complete();
      }
    }
  }, {
    key: "$onRunningChanged",
    value: function $onRunningChanged(newVal) {
      if (newVal) {
        this.$at = 0;
        this.paused = false;
      }
    }
  }, {
    key: "complete",
    value: function complete() {
      this.running = false;
    }
  }]);

  return _class56;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "Positioner",
  versions: /.*/,
  baseClass: "Item",
  properties: {
    spacing: "int"
  }
}, function () {
  function _class57(meta) {
    _classCallCheck(this, _class57);

    QmlWeb.callSuper(this, meta);

    this.childrenChanged.connect(this, this.$onChildrenChanged);
    this.spacingChanged.connect(this, this.layoutChildren);
    this.childrenChanged.connect(this, this.layoutChildren);
    this.layoutChildren();
  }

  _createClass(_class57, [{
    key: "$onChildrenChanged",
    value: function $onChildrenChanged() {
      var flags = QmlWeb.Signal.UniqueConnection;
      for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i];
        child.widthChanged.connect(this, this.layoutChildren, flags);
        child.heightChanged.connect(this, this.layoutChildren, flags);
        child.visibleChanged.connect(this, this.layoutChildren, flags);
      }
    }
  }]);

  return _class57;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "PropertyAnimation",
  versions: /.*/,
  baseClass: "Animation",
  properties: {
    duration: { type: "int", initialValue: 250 },
    from: "real",
    to: "real",
    properties: "string",
    property: "string",
    target: "QtObject",
    targets: "list"
  }
}, function () {
  function _class58(meta) {
    _classCallCheck(this, _class58);

    QmlWeb.callSuper(this, meta);

    this.easing = new QmlWeb.QObject(this);
    QmlWeb.createProperties(this.easing, {
      type: { type: "enum", initialValue: this.Easing.Linear },
      amplitude: { type: "real", initialValue: 1 },
      overshoot: { type: "real", initialValue: 1.70158 },
      period: { type: "real", initialValue: 0.3 },
      bezierCurve: "list"
    });

    this.easing.$valueForProgress = function (t) {
      return QmlWeb.$ease(this.type, this.period, this.amplitude, this.overshoot, t);
    };

    this.$props = [];
    this.$targets = [];
    this.$actions = [];

    this.targetChanged.connect(this, this.$redoTargets);
    this.targetsChanged.connect(this, this.$redoTargets);
    this.propertyChanged.connect(this, this.$redoProperties);
    this.propertiesChanged.connect(this, this.$redoProperties);

    if (meta.object.$on !== undefined) {
      this.property = meta.object.$on;
      this.target = this.$parent;
      this.running = true;
    }
  }

  _createClass(_class58, [{
    key: "$redoActions",
    value: function $redoActions() {
      this.$actions = [];
      for (var i = 0; i < this.$targets.length; i++) {
        for (var j in this.$props) {
          this.$actions.push({
            target: this.$targets[i],
            property: this.$props[j],
            from: this.from,
            to: this.to
          });
        }
      }
    }
  }, {
    key: "$redoProperties",
    value: function $redoProperties() {
      this.$props = this.properties.split(",");

      // Remove whitespaces
      for (var i = 0; i < this.$props.length; i++) {
        var matches = this.$props[i].match(/\w+/);
        if (matches) {
          this.$props[i] = matches[0];
        } else {
          this.$props.splice(i, 1);
          i--;
        }
      }
      // Merge properties and property
      if (this.property && this.$props.indexOf(this.property) === -1) {
        this.$props.push(this.property);
      }
    }
  }, {
    key: "$redoTargets",
    value: function $redoTargets() {
      this.$targets = this.targets.slice();
      if (this.target && this.$targets.indexOf(this.target) === -1) {
        this.$targets.push(this.target);
      }
    }
  }]);

  return _class58;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "PropertyChanges",
  versions: /.*/,
  baseClass: "QtQml.QtObject",
  properties: {
    target: "QtObject",
    explicit: "bool",
    restoreEntryValues: { type: "bool", initialValue: true }
  }
}, function () {
  function _class59(meta) {
    _classCallCheck(this, _class59);

    QmlWeb.callSuper(this, meta);

    this.$actions = [];
  }

  _createClass(_class59, [{
    key: "$setCustomData",
    value: function $setCustomData(property, value) {
      this.$actions.push({ property: property, value: value });
    }
  }]);

  return _class59;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "Rectangle",
  versions: /.*/,
  baseClass: "Item",
  properties: {
    color: { type: "color", initialValue: "white" },
    radius: "real"
  }
}, function () {
  function _class60(meta) {
    _classCallCheck(this, _class60);

    QmlWeb.callSuper(this, meta);

    this.border = new QmlWeb.QObject(this);
    QmlWeb.createProperties(this.border, {
      color: { type: "color", initialValue: "black" },
      width: { type: "int", initialValue: 1 }
    });
    this.$borderActive = false;

    var bg = this.impl = document.createElement("div");
    bg.style.pointerEvents = "none";
    bg.style.position = "absolute";
    bg.style.left = bg.style.right = bg.style.top = bg.style.bottom = "0px";
    bg.style.borderWidth = "0px";
    bg.style.borderStyle = "solid";
    bg.style.borderColor = this.border.color.$css;
    bg.style.backgroundColor = this.color.$css;
    this.dom.appendChild(bg);

    this.colorChanged.connect(this, this.$onColorChanged);
    this.radiusChanged.connect(this, this.$onRadiusChanged);
    this.border.colorChanged.connect(this, this.border$onColorChanged);
    this.border.widthChanged.connect(this, this.border$onWidthChanged);
    this.widthChanged.connect(this, this.$updateBorder);
    this.heightChanged.connect(this, this.$updateBorder);
  }

  _createClass(_class60, [{
    key: "$onColorChanged",
    value: function $onColorChanged(newVal) {
      this.impl.style.backgroundColor = newVal.$css;
    }
  }, {
    key: "border$onColorChanged",
    value: function border$onColorChanged(newVal) {
      this.$borderActive = true;
      this.impl.style.borderColor = newVal.$css;
      this.$updateBorder();
    }
  }, {
    key: "border$onWidthChanged",
    value: function border$onWidthChanged() {
      this.$borderActive = true;
      this.$updateBorder();
    }
  }, {
    key: "$onRadiusChanged",
    value: function $onRadiusChanged(newVal) {
      this.impl.style.borderRadius = newVal + "px";
    }
  }, {
    key: "$updateBorder",
    value: function $updateBorder() {
      var border = this.$borderActive ? Math.max(0, this.border.width) : 0;
      var style = this.impl.style;
      if (border * 2 > this.width || border * 2 > this.height) {
        // Border is covering the whole background
        style.borderWidth = "0px";
        style.borderTopWidth = this.height + "px";
      } else {
        style.borderWidth = border + "px";
      }
    }
  }]);

  return _class60;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "RegExpValidator",
  versions: /.*/,
  baseClass: "Item",
  properties: {
    regExp: "var"
  }
}, function () {
  function _class61(meta) {
    _classCallCheck(this, _class61);

    QmlWeb.callSuper(this, meta);
  }

  _createClass(_class61, [{
    key: "validate",
    value: function validate(string) {
      if (!this.regExp) return true;
      return this.regExp.test(string);
    }
  }]);

  return _class61;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "Repeater",
  versions: /.*/,
  baseClass: "Item",
  properties: {
    delegate: "Component",
    model: { type: "variant", initialValue: 0 },
    count: "int"
  },
  signals: {
    _childrenInserted: []
  },
  defaultProperty: "delegate"
}, function () {
  function _class62(meta) {
    _classCallCheck(this, _class62);

    QmlWeb.callSuper(this, meta);

    this.parent = meta.parent;
    // TODO: some (all ?) of the components including Repeater needs to know own
    // parent at creation time. Please consider this major change.

    this.$completed = false;
    this.$items = []; // List of created items

    this.modelChanged.connect(this, this.$onModelChanged);
    this.delegateChanged.connect(this, this.$onDelegateChanged);
    this.parentChanged.connect(this, this.$onParentChanged);
  }

  _createClass(_class62, [{
    key: "container",
    value: function container() {
      return this.parent;
    }
  }, {
    key: "itemAt",
    value: function itemAt(index) {
      return this.$items[index];
    }
  }, {
    key: "$onModelChanged",
    value: function $onModelChanged() {
      this.$applyModel();
    }
  }, {
    key: "$onDelegateChanged",
    value: function $onDelegateChanged() {
      this.$applyModel();
    }
  }, {
    key: "$onParentChanged",
    value: function $onParentChanged() {
      this.$applyModel();
    }
  }, {
    key: "$getModel",
    value: function $getModel() {
      var QMLListModel = QmlWeb.getConstructor("QtQuick", "2.0", "ListModel");
      return this.model instanceof QMLListModel ? this.model.$model : this.model;
    }
  }, {
    key: "$applyModel",
    value: function $applyModel() {
      if (!this.delegate || !this.parent) {
        return;
      }
      var model = this.$getModel();
      if (model instanceof QmlWeb.JSItemModel) {
        var flags = QmlWeb.Signal.UniqueConnection;
        model.dataChanged.connect(this, this.$_onModelDataChanged, flags);
        model.rowsInserted.connect(this, this.$_onRowsInserted, flags);
        model.rowsMoved.connect(this, this.$_onRowsMoved, flags);
        model.rowsRemoved.connect(this, this.$_onRowsRemoved, flags);
        model.modelReset.connect(this, this.$_onModelReset, flags);

        this.$removeChildren(0, this.$items.length);
        this.$insertChildren(0, model.rowCount());
      } else if (typeof model === "number") {
        if (this.$items.length > model) {
          // have more than we need
          this.$removeChildren(model, this.$items.length);
        } else {
          // need more
          this.$insertChildren(this.$items.length, model);
        }
      } else if (model instanceof Array) {
        this.$removeChildren(0, this.$items.length);
        this.$insertChildren(0, model.length);
      }
      this.count = this.$items.length;
    }
  }, {
    key: "$callOnCompleted",
    value: function $callOnCompleted(child) {
      child.Component.completed();
      var QMLBaseObject = QmlWeb.getConstructor("QtQml", "2.0", "QtObject");
      for (var i = 0; i < child.$tidyupList.length; i++) {
        if (child.$tidyupList[i] instanceof QMLBaseObject) {
          this.$callOnCompleted(child.$tidyupList[i]);
        }
      }
    }
  }, {
    key: "$_onModelDataChanged",
    value: function $_onModelDataChanged(startIndex, endIndex, roles) {
      var model = this.$getModel();
      var roleNames = roles || model.roleNames;
      for (var index = startIndex; index <= endIndex; index++) {
        var _item3 = this.$items[index];
        var modelData = _item3.$properties.model;
        for (var i in roleNames) {
          var roleName = roleNames[i];
          var roleData = model.data(index, roleName);
          _item3.$properties[roleName].set(roleData, QmlWeb.QMLProperty.ReasonInit, _item3, this.model.$context);
          modelData[roleName] = roleData;
        }
        _item3.$properties.model.set(modelData, QmlWeb.QMLProperty.ReasonInit, _item3, this.model.$context);
      }
    }
  }, {
    key: "$_onRowsInserted",
    value: function $_onRowsInserted(startIndex, endIndex) {
      this.$insertChildren(startIndex, endIndex);
      this.count = this.$items.length;
    }
  }, {
    key: "$_onRowsMoved",
    value: function $_onRowsMoved(sourceStartIndex, sourceEndIndex, destinationIndex) {
      var vals = this.$items.splice(sourceStartIndex, sourceEndIndex - sourceStartIndex);
      for (var i = 0; i < vals.length; i++) {
        this.$items.splice(destinationIndex + i, 0, vals[i]);
      }
      var smallestChangedIndex = sourceStartIndex < destinationIndex ? sourceStartIndex : destinationIndex;
      for (var _i11 = smallestChangedIndex; _i11 < this.$items.length; _i11++) {
        this.$items[_i11].index = _i11;
      }
    }
  }, {
    key: "$_onRowsRemoved",
    value: function $_onRowsRemoved(startIndex, endIndex) {
      this.$removeChildren(startIndex, endIndex);
      for (var i = startIndex; i < this.$items.length; i++) {
        this.$items[i].index = i;
      }
      this.count = this.$items.length;
    }
  }, {
    key: "$_onModelReset",
    value: function $_onModelReset() {
      this.$applyModel();
    }
  }, {
    key: "$insertChildren",
    value: function $insertChildren(startIndex, endIndex) {
      if (endIndex <= 0) {
        this.count = 0;
        return;
      }

      var QMLOperationState = QmlWeb.QMLOperationState;
      var createProperty = QmlWeb.createProperty;
      var model = this.$getModel();
      var index = void 0;
      for (index = startIndex; index < endIndex; index++) {
        var newItem = this.delegate.$createObject(this.parent);
        createProperty("int", newItem, "index", { initialValue: index });

        if (typeof model === "number" || model instanceof Array) {
          if (typeof newItem.$properties.modelData === "undefined") {
            createProperty("variant", newItem, "modelData");
          }
          var value = model instanceof Array ? model[index] : typeof model === "number" ? index : "undefined";
          newItem.$properties.modelData.set(value, QmlWeb.QMLProperty.ReasonInit, newItem, model.$context);
        } else {
          // QML exposes a "model" property in the scope that contains all role
          // data.
          var modelData = {};
          for (var i = 0; i < model.roleNames.length; i++) {
            var roleName = model.roleNames[i];
            if (typeof newItem.$properties[roleName] === "undefined") {
              createProperty("variant", newItem, roleName);
            }
            var roleData = model.data(index, roleName);
            modelData[roleName] = roleData;
            newItem.$properties[roleName].set(roleData, QmlWeb.QMLProperty.ReasonInit, newItem, this.model.$context);
          }
          if (typeof newItem.$properties.model === "undefined") {
            createProperty("variant", newItem, "model");
          }
          newItem.$properties.model.set(modelData, QmlWeb.QMLProperty.ReasonInit, newItem, this.model.$context);
        }

        this.$items.splice(index, 0, newItem);

        // parent must be set after the roles have been added to newItem scope in
        // case we are outside of QMLOperationState.Init and parentChanged has
        // any side effects that result in those roleNames being referenced.
        newItem.parent = this.parent;

        // TODO debug this. Without check to Init, Completed sometimes called
        // twice.. But is this check correct?
        if (QmlWeb.engine.operationState !== QMLOperationState.Init && QmlWeb.engine.operationState !== QMLOperationState.Idle) {
          // We don't call those on first creation, as they will be called
          // by the regular creation-procedures at the right time.
          this.$callOnCompleted(newItem);
        }
      }
      if (QmlWeb.engine.operationState !== QMLOperationState.Init) {
        // We don't call those on first creation, as they will be called
        // by the regular creation-procedures at the right time.
        QmlWeb.engine.$initializePropertyBindings();
      }

      if (index > 0) {
        this.container().childrenChanged();
      }

      for (var _i12 = endIndex; _i12 < this.$items.length; _i12++) {
        this.$items[_i12].index = _i12;
      }
    }
  }, {
    key: "$removeChildren",
    value: function $removeChildren(startIndex, endIndex) {
      var removed = this.$items.splice(startIndex, endIndex - startIndex);
      for (var index in removed) {
        removed[index].$delete();
        this.$removeChildProperties(removed[index]);
      }
    }
  }, {
    key: "$removeChildProperties",
    value: function $removeChildProperties(child) {
      var signals = QmlWeb.engine.completedSignals;
      signals.splice(signals.indexOf(child.Component.completed), 1);
      for (var i = 0; i < child.children.length; i++) {
        this.$removeChildProperties(child.children[i]);
      }
    }
  }]);

  return _class62;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "Rotation",
  versions: /.*/,
  baseClass: "QtQml.QtObject",
  properties: {
    angle: "real"
  }
}, function () {
  function _class63(meta) {
    _classCallCheck(this, _class63);

    QmlWeb.callSuper(this, meta);

    this.axis = new QmlWeb.QObject(this);
    QmlWeb.createProperties(this.axis, {
      x: "real",
      y: "real",
      z: { type: "real", initialValue: 1 }
    });

    this.origin = new QmlWeb.QObject(this);
    QmlWeb.createProperties(this.origin, {
      x: "real",
      y: "real"
    });

    this.angleChanged.connect(this.$parent, this.$parent.$updateTransform);
    this.axis.xChanged.connect(this.$parent, this.$parent.$updateTransform);
    this.axis.yChanged.connect(this.$parent, this.$parent.$updateTransform);
    this.axis.zChanged.connect(this.$parent, this.$parent.$updateTransform);
    this.origin.xChanged.connect(this, this.$updateOrigin);
    this.origin.yChanged.connect(this, this.$updateOrigin);
    this.$parent.$updateTransform();
  }

  _createClass(_class63, [{
    key: "$updateOrigin",
    value: function $updateOrigin() {
      var style = this.$parent.dom.style;
      style.transformOrigin = this.origin.x + "px " + this.origin.y + "px";
      style.webkitTransformOrigin = this.origin.x + "px " + this.origin.y + "px";
    }
  }]);

  return _class63;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "RotationAnimator",
  versions: /^2\./,
  baseClass: "Animator"
}, function () {
  function _class64(meta) {
    _classCallCheck(this, _class64);

    QmlWeb.callSuper(this, meta);
  }

  return _class64;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "Row",
  versions: /.*/,
  baseClass: "Positioner",
  properties: {
    layoutDirection: "enum"
  }
}, function () {
  function _class65(meta) {
    _classCallCheck(this, _class65);

    QmlWeb.callSuper(this, meta);

    this.layoutDirectionChanged.connect(this, this.layoutChildren);
    this.layoutChildren();
  }

  _createClass(_class65, [{
    key: "layoutChildren",
    value: function layoutChildren() {
      var curPos = 0;
      var maxHeight = 0;
      // When layoutDirection is RightToLeft we need oposite order
      var i = this.layoutDirection === 1 ? this.children.length - 1 : 0;
      var endPoint = this.layoutDirection === 1 ? -1 : this.children.length;
      var step = this.layoutDirection === 1 ? -1 : 1;
      for (; i !== endPoint; i += step) {
        var child = this.children[i];
        if (!(child.visible && child.width && child.height)) {
          continue;
        }
        maxHeight = child.height > maxHeight ? child.height : maxHeight;

        child.x = curPos;
        curPos += child.width + this.spacing;
      }
      this.implicitHeight = maxHeight;
      // We want no spacing at the right side
      this.implicitWidth = curPos - this.spacing;
    }
  }]);

  return _class65;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "Scale",
  versions: /.*/,
  baseClass: "QtQml.QtObject",
  properties: {
    xScale: { type: "real", initialValue: 1 },
    yScale: { type: "real", initialValue: 1 }
  }
}, function () {
  function _class66(meta) {
    _classCallCheck(this, _class66);

    QmlWeb.callSuper(this, meta);

    this.origin = new QmlWeb.QObject(this);
    QmlWeb.createProperties(this.origin, {
      x: "real",
      y: "real"
    });

    this.xScaleChanged.connect(this.$parent, this.$parent.$updateTransform);
    this.yScaleChanged.connect(this.$parent, this.$parent.$updateTransform);
    this.origin.xChanged.connect(this, this.$updateOrigin);
    this.origin.yChanged.connect(this, this.$updateOrigin);

    /* QML default origin is top-left, while CSS default origin is centre, so
     * $updateOrigin must be called to set the initial transformOrigin. */
    this.$updateOrigin();
  }

  _createClass(_class66, [{
    key: "$updateOrigin",
    value: function $updateOrigin() {
      var style = this.$parent.dom.style;
      style.transformOrigin = this.origin.x + "px " + this.origin.y + "px";
      style.webkitTransformOrigin = this.origin.x + "px " + this.origin.y + "px";
    }
  }]);

  return _class66;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "ScaleAnimator",
  versions: /^2\./,
  baseClass: "Animator"
}, function () {
  function _class67(meta) {
    _classCallCheck(this, _class67);

    QmlWeb.callSuper(this, meta);
  }

  return _class67;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "SequentialAnimation",
  versions: /.*/,
  baseClass: "Animation",
  properties: {
    animations: "list"
  },
  defaultProperty: "animations"
}, function () {
  function _class68(meta) {
    var _this64 = this;

    _classCallCheck(this, _class68);

    QmlWeb.callSuper(this, meta);

    this.animationsChanged.connect(this, this.$onAnimatonsChanged);

    QmlWeb.engine.$registerStart(function () {
      if (!_this64.running) return;
      _this64.running = false; // toggled back by start();
      _this64.start();
    });
    QmlWeb.engine.$registerStop(function () {
      return self.stop();
    });
  }

  _createClass(_class68, [{
    key: "$onAnimatonsChanged",
    value: function $onAnimatonsChanged() {
      var flags = QmlWeb.Signal.UniqueConnection;
      for (var i = 0; i < this.animations.length; i++) {
        var animation = this.animations[i];
        animation.runningChanged.connect(this, this.$nextAnimation, flags);
      }
    }
  }, {
    key: "$nextAnimation",
    value: function $nextAnimation(proceed) {
      if (this.running && !proceed) {
        this.$curIndex++;
        if (this.$curIndex < this.animations.length) {
          var anim = this.animations[this.$curIndex];
          console.log("nextAnimation", this, this.$curIndex, anim);
          anim.start();
        } else {
          this.$passedLoops++;
          if (this.$passedLoops >= this.loops) {
            this.complete();
          } else {
            this.$curIndex = -1;
            this.$nextAnimation();
          }
        }
      }
    }
  }, {
    key: "start",
    value: function start() {
      if (this.running) return;
      this.running = true;
      this.$curIndex = -1;
      this.$passedLoops = 0;
      this.$nextAnimation();
    }
  }, {
    key: "stop",
    value: function stop() {
      if (!this.running) return;
      this.running = false;
      if (this.$curIndex < this.animations.length) {
        this.animations[this.$curIndex].stop();
      }
    }
  }, {
    key: "complete",
    value: function complete() {
      if (!this.running) return;
      if (this.$curIndex < this.animations.length) {
        // Stop current animation
        this.animations[this.$curIndex].stop();
      }
      this.running = false;
    }
  }]);

  return _class68;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "ShaderEffect",
  versions: /.*/,
  baseClass: "Item",
  enums: {
    ShaderEffect: {
      NoCulling: 0, BackFaceCulling: 1, FrontFaceCulling: 2,
      Compiled: 0, Uncompiled: 1, Error: 2
    }
  },
  properties: {
    blending: { type: "bool", initialValue: true },
    cullMode: "enum", // ShaderEffect.NoCulling
    fragmentShader: "string",
    log: "string",
    mesh: "var",
    status: { type: "enum", initialValue: 1 }, // ShaderEffect.Uncompiled
    supportsAtlasTextures: "bool",
    vertexShader: "string"
  }
}, function () {
  function _class69(meta) {
    _classCallCheck(this, _class69);

    QmlWeb.callSuper(this, meta);

    // TODO
  }

  return _class69;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "ShaderEffectSource",
  versions: /.*/,
  baseClass: "Item",
  enums: {
    ShaderEffectSource: {
      Alpha: 0x6406, RGB: 0x6407, RGBA: 0x6408,
      NoMirroring: 0, MirrorHorizontally: 1, MirrorVertically: 2,
      ClampToEdge: 0, RepeatHorizontally: 1, RepeatVertically: 2, Repeat: 3
    }
  },
  properties: {
    format: { type: "enum", initialValue: 0x6408 }, // ShaderEffectSource.RGBA
    hideSource: "bool",
    live: { type: "bool", initialValue: true },
    mipmap: "bool",
    recursive: "bool",
    sourceItem: "Item",
    sourceRect: "rect",
    textureMirroring: { type: "enum", initialValue: 2 }, // MirrorVertically
    textureSize: "size",
    wrapMode: "enum" // ShaderEffectSource.ClampToEdge
  }
}, function () {
  function _class70(meta) {
    _classCallCheck(this, _class70);

    QmlWeb.callSuper(this, meta);

    // TODO
  }

  _createClass(_class70, [{
    key: "scheduleUpdate",
    value: function scheduleUpdate() {
      // TODO
    }
  }]);

  return _class70;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "State",
  versions: /.*/,
  baseClass: "QtQml.QtObject",
  properties: {
    name: "string",
    changes: "list",
    extend: "string",
    when: "bool"
  },
  defaultProperty: "changes"
}, function () {
  function _class71(meta) {
    _classCallCheck(this, _class71);

    QmlWeb.callSuper(this, meta);

    this.$item = this.$parent;

    this.whenChanged.connect(this, this.$onWhenChanged);
  }

  _createClass(_class71, [{
    key: "$getAllChanges",
    value: function $getAllChanges() {
      var _this65 = this;

      if (this.extend) {
        /* ECMAScript 2015. TODO: polyfill Array?
        const base = this.$item.states.find(state => state.name === this.extend);
        */
        var states = this.$item.states;
        var base = states.filter(function (state) {
          return state.name === _this65.extend;
        })[0];
        if (base) {
          return base.$getAllChanges().concat(this.changes);
        }
        console.error("Can't find the state to extend!");
      }
      return this.changes;
    }
  }, {
    key: "$onWhenChanged",
    value: function $onWhenChanged(newVal) {
      if (newVal) {
        this.$item.state = this.name;
      } else if (this.$item.state === this.name) {
        this.$item.state = "";
      }
    }
  }]);

  return _class71;
}());

var platformsDetectors = [
//{ name: "W8", regexp: /Windows NT 6\.2/ },
//{ name: "W7", regexp: /Windows NT 6\.1/ },
//{ name: "Windows", regexp: /Windows NT/ },
{ name: "OSX", regexp: /Macintosh/ }];

var systemPalettes = {};

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "SystemPalette",
  versions: /.*/,
  baseClass: "QtQml.QtObject",
  enums: {
    SystemPalette: {
      Active: 0, Inactive: 2, Disabled: 1
    }
  },
  properties: {
    alternateBase: { type: "color", readOnly: true },
    base: { type: "color", readOnly: true },
    button: { type: "color", readOnly: true },
    buttonText: { type: "color", readOnly: true },
    dark: { type: "color", readOnly: true },
    highlight: { type: "color", readOnly: true },
    highlightedText: { type: "color", readOnly: true },
    light: { type: "color", readOnly: true },
    mid: { type: "color", readOnly: true },
    midlight: { type: "color", readOnly: true },
    shadow: { type: "color", readOnly: true },
    text: { type: "color", readOnly: true },
    window: { type: "color", readOnly: true },
    windowText: { type: "color", readOnly: true },

    colorGroup: "enum"
  }
}, function () {
  function _class72(meta) {
    _classCallCheck(this, _class72);

    QmlWeb.callSuper(this, meta);

    this.colorGroupChanged.connect(this, this.$onColorGroupChanged);

    this.$platform = "OSX";
    // Detect OS
    for (var i = 0; i < platformsDetectors.length; ++i) {
      if (platformsDetectors[i].regexp.test(navigator.userAgent)) {
        this.$platform = platformsDetectors[i].name;
        break;
      }
    }

    this.$onColorGroupChanged(this.colorGroup);
  }

  _createClass(_class72, [{
    key: "$onColorGroupChanged",
    value: function $onColorGroupChanged(newVal) {
      var _this66 = this;

      var name = ["active", "disabled", "inactive"][newVal];
      var pallete = systemPalettes[this.$platform][name];
      this.$canEditReadOnlyProperties = true;
      Object.keys(pallete).forEach(function (key) {
        _this66[key] = pallete[key];
      });
      delete this.$canEditReadOnlyProperties;
    }
  }]);

  return _class72;
}());

systemPalettes.OSX = {
  active: {
    alternateBase: "#f6f6f6",
    base: "#ffffff",
    button: "#ededed",
    buttonText: "#000000",
    dark: "#bfbfbf",
    highlight: "#fbed73",
    highlightText: "#000000",
    light: "#ffffff",
    mid: "#a9a9a9",
    midlight: "#f6f6f6",
    shadow: "#8b8b8b",
    text: "#000000",
    window: "#ededed",
    windowText: "#000000"
  },
  inactive: {
    alternateBase: "#f6f6f6",
    base: "#ffffff",
    button: "#ededed",
    buttonText: "#000000",
    dark: "#bfbfbf",
    highlight: "#d0d0d0",
    highlightText: "#000000",
    light: "#ffffff",
    mid: "#a9a9a9",
    midlight: "#f6f6f6",
    shadow: "#8b8b8b",
    text: "#000000",
    window: "#ededed",
    windowText: "#000000"
  },
  disabled: {
    alternateBase: "#f6f6f6",
    base: "#ededed",
    button: "#ededed",
    buttonText: "#949494",
    dark: "#bfbfbf",
    highlight: "#d0d0d0",
    highlightText: "#7f7f7f",
    light: "#ffffff",
    mid: "#a9a9a9",
    midlight: "#f6f6f6",
    shadow: "#8b8b8b",
    text: "#7f7f7f",
    window: "#ededed",
    windowText: "#7f7f7f"
  }
};

QmlWeb.systemPalettes = systemPalettes;
QmlWeb.platformsDetectors = platformsDetectors;

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "Text",
  versions: /.*/,
  baseClass: "Item",
  enums: {
    Text: {
      NoWrap: 0, WordWrap: 1, WrapAnywhere: 2, Wrap: 3,
      WrapAtWordBoundaryOrAnywhere: 4,
      AlignLeft: 1, AlignRight: 2, AlignHCenter: 4, AlignJustify: 8,
      AlignTop: 32, AlignBottom: 64, AlignVCenter: 128,
      Normal: 0, Outline: 1, Raised: 2, Sunken: 3
    }
  },
  properties: {
    color: { type: "color", initialValue: "black" },
    text: "string",
    font: "font",
    lineHeight: "real",
    wrapMode: { type: "enum", initialValue: 0 }, // Text.NoWrap
    horizontalAlignment: { type: "enum", initialValue: 1 }, // Text.AlignLeft
    style: "enum",
    styleColor: "color"
  }
}, function () {
  function _class73(meta) {
    _classCallCheck(this, _class73);

    QmlWeb.callSuper(this, meta);

    var fc = this.impl = document.createElement("span");
    fc.style.pointerEvents = "none";
    fc.style.width = "100%";
    fc.style.height = "100%";
    fc.style.whiteSpace = "pre";
    this.dom.style.textAlign = "left";
    this.dom.appendChild(fc);

    this.colorChanged.connect(this, this.$onColorChanged);
    this.textChanged.connect(this, this.$onTextChanged);
    this.lineHeightChanged.connect(this, this.$onLineHeightChanged);
    this.wrapModeChanged.connect(this, this.$onWrapModeChanged);
    this.horizontalAlignmentChanged.connect(this, this.$onHorizontalAlignmentChanged);
    this.styleChanged.connect(this, this.$onStyleChanged);
    this.styleColorChanged.connect(this, this.$onStyleColorChanged);

    this.widthChanged.connect(this, this.$onWidthChanged);
    this.fontChanged.connect(this, this.$onFontChanged);

    this.Component.completed.connect(this, this.Component$onCompleted);
  }

  _createClass(_class73, [{
    key: "$onColorChanged",
    value: function $onColorChanged(newVal) {
      this.impl.style.color = newVal.$css;
    }
  }, {
    key: "$onTextChanged",
    value: function $onTextChanged(newVal) {
      this.impl.innerHTML = newVal;
      this.$updateImplicit();
    }
  }, {
    key: "$onWidthChanged",
    value: function $onWidthChanged() {
      this.$updateImplicit();
    }
  }, {
    key: "$onLineHeightChanged",
    value: function $onLineHeightChanged(newVal) {
      this.impl.style.lineHeight = newVal + "px";
      this.$updateImplicit();
    }
  }, {
    key: "$onStyleChanged",
    value: function $onStyleChanged(newVal) {
      this.$updateShadow(newVal, this.styleColor.$css);
    }
  }, {
    key: "$onStyleColorChanged",
    value: function $onStyleColorChanged(newVal) {
      this.$updateShadow(this.style, newVal.$css);
    }
  }, {
    key: "$onWrapModeChanged",
    value: function $onWrapModeChanged(newVal) {
      var style = this.impl.style;
      switch (newVal) {
        case this.Text.NoWrap:
          style.whiteSpace = "pre";
          break;
        case this.Text.WordWrap:
          style.whiteSpace = "pre-wrap";
          style.wordWrap = "normal";
          break;
        case this.Text.WrapAnywhere:
          style.whiteSpace = "pre-wrap";
          style.wordBreak = "break-all";
          break;
        case this.Text.Wrap:
        case this.Text.WrapAtWordBoundaryOrAnywhere:
          style.whiteSpace = "pre-wrap";
          style.wordWrap = "break-word";
      }
      this.$updateJustifyWhiteSpace();
    }
  }, {
    key: "$onHorizontalAlignmentChanged",
    value: function $onHorizontalAlignmentChanged(newVal) {
      var textAlign = null;
      switch (newVal) {
        case this.Text.AlignLeft:
          textAlign = "left";
          break;
        case this.Text.AlignRight:
          textAlign = "right";
          break;
        case this.Text.AlignHCenter:
          textAlign = "center";
          break;
        case this.Text.AlignJustify:
          textAlign = "justify";
          break;
      }
      this.dom.style.textAlign = textAlign;
      this.$updateJustifyWhiteSpace();
    }
  }, {
    key: "$onFontChanged",
    value: function $onFontChanged() {
      this.$updateImplicit();
    }
  }, {
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      this.$updateImplicit();
    }
  }, {
    key: "$updateImplicit",
    value: function $updateImplicit() {
      if (!this.text || !this.dom) {
        this.implicitHeight = this.implicitWidth = 0;
        return;
      }

      if (!this.$isUsingImplicitWidth) {
        this.implicitWidth = this.impl.offsetWidth;
        this.implicitHeight = this.impl.offsetHeight;
        return;
      }

      var fc = this.impl;
      var engine = QmlWeb.engine;
      // Need to move the child out of it's parent so that it can properly
      // recalculate it's "natural" offsetWidth/offsetHeight
      if (engine.dom === document.body && engine.dom !== engine.domTarget) {
        // Can't use document.body here, as it could have Shadow DOM inside
        // The root is document.body, though, so it's probably not hidden
        engine.domTarget.appendChild(fc);
      } else {
        document.body.appendChild(fc);
      }
      var height = fc.offsetHeight;
      var width = fc.offsetWidth;
      this.dom.appendChild(fc);

      this.implicitHeight = height;
      this.implicitWidth = width;
    }
  }, {
    key: "$updateShadow",
    value: function $updateShadow(textStyle, styleColor) {
      var style = this.impl.style;
      switch (textStyle) {
        case 0:
          style.textShadow = "none";
          break;
        case 1:
          style.textShadow = ["1px 0 0 " + styleColor, "-1px 0 0 " + styleColor, "0 1px 0 " + styleColor, "0 -1px 0 " + styleColor].join(",");
          break;
        case 2:
          style.textShadow = "1px 1px 0 " + styleColor;
          break;
        case 3:
          style.textShadow = "-1px -1px 0 " + styleColor;
          break;
      }
    }
  }, {
    key: "$updateJustifyWhiteSpace",
    value: function $updateJustifyWhiteSpace() {
      var style = this.impl.style;
      // AlignJustify doesn't work with pre/pre-wrap, so we decide the lesser of
      // the two evils to be ignoring "\n"s inside the text.
      if (this.horizontalAlignment === this.Text.AlignJustify) {
        style.whiteSpace = "normal";
      }
      this.$updateImplicit();
    }
  }]);

  return _class73;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "TextEdit",
  versions: /.*/,
  baseClass: "Item",
  properties: {
    activeFocusOnPress: { type: "bool", initialValue: true },
    baseUrl: "url",
    canPaste: "bool",
    canRedo: "bool",
    canUndo: "bool",
    color: { type: "color", initialValue: "white" },
    contentHeight: "real",
    contentWidth: "real",
    cursorDelegate: "Component",
    cursorPosition: "int",
    cursorRectangle: "rect",
    cursorVisible: { type: "bool", initialValue: true },
    effectiveHorizontalAlignment: "enum",
    font: "font",
    horizontalAlignment: "enum",
    hoveredLink: "string",
    inputMethodComposing: "bool",
    inputMethodHints: "enum",
    length: "int",
    lineCount: "int",
    mouseSelectionMode: "enum",
    persistentSelection: "bool",
    readOnly: "bool",
    renderType: "enum",
    selectByKeyboard: { type: "bool", initialValue: true },
    selectByMouse: "bool",
    selectedText: "string",
    selectedTextColor: { type: "color", initialValue: "yellow" },
    selectionColor: { type: "color", initialValue: "pink" },
    selectionEnd: "int",
    selectionStart: "int",
    text: "string",
    textDocument: "TextDocument",
    textFormat: "enum",
    textMargin: "real",
    verticalAlignment: "enum",
    wrapMode: "enum"
  },
  signals: {
    linkActivated: [{ type: "string", name: "link" }],
    linkHovered: [{ type: "string", name: "link" }]
  }
}, function () {
  function _class74(meta) {
    var _this67 = this;

    _classCallCheck(this, _class74);

    QmlWeb.callSuper(this, meta);

    // Undo / Redo stacks;
    this.undoStack = [];
    this.undoStackPosition = -1;
    this.redoStack = [];
    this.redoStackPosition = -1;

    var textarea = this.impl = document.createElement("textarea");
    textarea.style.pointerEvents = "auto";
    textarea.style.width = "100%";
    textarea.style.height = "100%";
    textarea.style.boxSizing = "border-box";
    textarea.style.borderWidth = "0";
    textarea.style.background = "none";
    textarea.style.outline = "none";
    textarea.style.resize = "none";
    textarea.style.padding = "0"; // TODO: padding/*Padding props from Qt 5.6
    // In some browsers text-areas have a margin by default, which distorts
    // the positioning, so we need to manually set it to 0.
    textarea.style.margin = "0";
    textarea.disabled = false;
    this.dom.appendChild(textarea);

    this.Component.completed.connect(this, this.Component$onCompleted);
    this.textChanged.connect(this, this.$onTextChanged);
    this.colorChanged.connect(this, this.$onColorChanged);

    this.impl.addEventListener("input", function () {
      return _this67.$updateValue();
    });
  }

  _createClass(_class74, [{
    key: "append",
    value: function append(text) {
      this.text += text;
    }
  }, {
    key: "copy",
    value: function copy() {
      // TODO
    }
  }, {
    key: "cut",
    value: function cut() {
      this.text = this.text(0, this.selectionStart) + this.text(this.selectionEnd, this.text.length);
      // TODO
    }
  }, {
    key: "deselect",
    value: function deselect() {
      //this.selectionStart = -1;
      //this.selectionEnd = -1;
      //this.selectedText = null;
      // TODO
    }
  }, {
    key: "getFormattedText",
    value: function getFormattedText(start, end) {
      var text = this.text.slice(start, end);
      // TODO
      // process text
      return text;
    }
  }, {
    key: "getText",
    value: function getText(start, end) {
      return this.text.slice(start, end);
    }
  }, {
    key: "insert",
    value: function insert() /*position, text*/{
      // TODO
    }
  }, {
    key: "isRightToLeft",
    value: function isRightToLeft() /*start, end*/{
      // TODO
    }
  }, {
    key: "linkAt",
    value: function linkAt() /*x, y*/{
      // TODO
    }
  }, {
    key: "moveCursorSelection",
    value: function moveCursorSelection() /*x, y*/{
      // TODO
    }
  }, {
    key: "paste",
    value: function paste() {
      // TODO
    }
  }, {
    key: "positionAt",
    value: function positionAt() /*x, y*/{
      // TODO
    }
  }, {
    key: "positionToRectangle",
    value: function positionToRectangle() /*position*/{
      // TODO
    }
  }, {
    key: "redo",
    value: function redo() {
      // TODO
    }
  }, {
    key: "remove",
    value: function remove() /*start, end*/{
      // TODO
    }
  }, {
    key: "select",
    value: function select() /*start, end*/{
      // TODO
    }
  }, {
    key: "selectAll",
    value: function selectAll() {
      // TODO
    }
  }, {
    key: "selectWord",
    value: function selectWord() {
      // TODO
    }
  }, {
    key: "undo",
    value: function undo() {
      // TODO
    }
  }, {
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      this.selectByKeyboard = !this.readOnly;
      this.$updateValue();
      this.implicitWidth = this.offsetWidth;
      this.implicitHeight = this.offsetHeight;
    }
  }, {
    key: "$onTextChanged",
    value: function $onTextChanged(newVal) {
      this.impl.value = newVal;
    }
  }, {
    key: "$onColorChanged",
    value: function $onColorChanged(newVal) {
      this.impl.style.color = newVal.$css;
    }
  }, {
    key: "$updateValue",
    value: function $updateValue() {
      if (this.text !== this.impl.value) {
        this.text = this.impl.value;
      }
      this.length = this.text.length;
      this.lineCount = this.$getLineCount();
      this.$updateCss();
    }
    // Transfer dom style to firstChild,
    // then clear corresponding dom style

  }, {
    key: "$updateCss",
    value: function $updateCss() {
      var supported = ["border", "borderRadius", "borderWidth", "borderColor", "backgroundColor"];
      var style = this.impl.style;
      for (var n = 0; n < supported.length; n++) {
        var o = supported[n];
        var v = this.css[o];
        if (v) {
          style[o] = v;
          this.css[o] = null;
        }
      }
    }
  }, {
    key: "$getLineCount",
    value: function $getLineCount() {
      return this.text.split(/\n/).length;
    }
  }]);

  return _class74;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "TextInput",
  versions: /.*/,
  baseClass: "Item",
  enums: {
    TextInput: { Normal: 0, Password: 1, NoEcho: 2, PasswordEchoOnEdit: 3 }
  },
  properties: {
    text: "string",
    font: "font",
    maximumLength: { type: "int", initialValue: -1 },
    readOnly: "bool",
    validator: "var",
    echoMode: "enum" // TextInput.Normal
  },
  signals: {
    accepted: []
  }
}, function () {
  function _class75(meta) {
    var _this68 = this;

    _classCallCheck(this, _class75);

    QmlWeb.callSuper(this, meta);

    var input = this.impl = document.createElement("input");
    input.type = "text";
    input.disabled = true;
    input.style.pointerEvents = "auto";
    // In some browsers text-inputs have a margin by default, which distorts
    // the positioning, so we need to manually set it to 0.
    input.style.margin = "0";
    input.style.padding = "0";
    input.style.width = "100%";
    input.style.height = "100%";
    this.dom.appendChild(input);
    this.setupFocusOnDom(input);
    input.disabled = false;

    this.Component.completed.connect(this, this.Component$onCompleted);
    this.textChanged.connect(this, this.$onTextChanged);
    this.echoModeChanged.connect(this, this.$onEchoModeChanged);
    this.maximumLengthChanged.connect(this, this.$onMaximumLengthChanged);
    this.readOnlyChanged.connect(this, this.$onReadOnlyChanged);
    this.Keys.pressed.connect(this, this.Keys$onPressed);

    this.impl.addEventListener("input", function () {
      return _this68.$updateValue();
    });
  }

  _createClass(_class75, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      this.implicitWidth = this.impl.offsetWidth;
      this.implicitHeight = this.impl.offsetHeight;
    }
  }, {
    key: "$onTextChanged",
    value: function $onTextChanged(newVal) {
      // We have to check if value actually changes.
      // If we do not have this check, then after user updates text input
      // following occurs: user updates gui text -> updateValue gets called ->
      // textChanged gets called -> gui value updates again -> caret position
      // moves to the right!
      if (this.impl.value !== newVal) {
        this.impl.value = newVal;
      }
    }
  }, {
    key: "$onEchoModeChanged",
    value: function $onEchoModeChanged(newVal) {
      var TextInput = this.TextInput;
      var input = this.impl;
      switch (newVal) {
        case TextInput.Normal:
          input.type = "text";
          break;
        case TextInput.Password:
          input.type = "password";
          break;
        case TextInput.NoEcho:
          // Not supported, use password, that's nearest
          input.type = "password";
          break;
        case TextInput.PasswordEchoOnEdit:
          // Not supported, use password, that's nearest
          input.type = "password";
          break;
      }
    }
  }, {
    key: "$onMaximumLengthChanged",
    value: function $onMaximumLengthChanged(newVal) {
      this.impl.maxLength = newVal < 0 ? null : newVal;
    }
  }, {
    key: "$onReadOnlyChanged",
    value: function $onReadOnlyChanged(newVal) {
      this.impl.disabled = newVal;
    }
  }, {
    key: "Keys$onPressed",
    value: function Keys$onPressed(e) {
      var Qt = QmlWeb.Qt;
      var submit = e.key === Qt.Key_Return || e.key === Qt.Key_Enter;
      if (submit && this.$testValidator()) {
        this.accepted();
        e.accepted = true;
      }
    }
  }, {
    key: "$testValidator",
    value: function $testValidator() {
      if (this.validator) {
        return this.validator.validate(this.text);
      }
      return true;
    }
  }, {
    key: "$updateValue",
    value: function $updateValue() {
      if (this.text !== this.impl.value) {
        this.$canEditReadOnlyProperties = true;
        this.text = this.impl.value;
        this.$canEditReadOnlyProperties = false;
      }
    }
  }]);

  return _class75;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "Transition",
  versions: /.*/,
  baseClass: "QtQml.QtObject",
  properties: {
    animations: "list",
    from: { type: "string", initialValue: "*" },
    to: { type: "string", initialValue: "*" },
    reversible: "bool"
  },
  defaultProperty: "animations"
}, function () {
  function _class76(meta) {
    _classCallCheck(this, _class76);

    QmlWeb.callSuper(this, meta);

    this.$item = this.$parent;
  }

  _createClass(_class76, [{
    key: "$start",
    value: function $start(actions) {
      for (var i = 0; i < this.animations.length; i++) {
        var animation = this.animations[i];
        animation.$actions = [];
        var $targets = animation.$targets,
            $props = animation.$props,
            $actions = animation.$actions;

        for (var j in actions) {
          var _action6 = actions[j];
          if (($targets.length === 0 || $targets.indexOf(_action6.target) !== -1) && ($props.length === 0 || $props.indexOf(_action6.property) !== -1)) {
            $actions.push(_action6);
          }
        }
        animation.start();
      }
    }
  }, {
    key: "$stop",
    value: function $stop() {
      for (var i = 0; i < this.animations.length; i++) {
        this.animations[i].stop();
      }
    }
  }]);

  return _class76;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "Translate",
  versions: /.*/,
  baseClass: "QtQml.QtObject",
  properties: {
    x: "real",
    y: "real"
  }
}, function () {
  function _class77(meta) {
    _classCallCheck(this, _class77);

    QmlWeb.callSuper(this, meta);

    this.xChanged.connect(this.$parent, this.$parent.$updateTransform);
    this.yChanged.connect(this.$parent, this.$parent.$updateTransform);
  }

  return _class77;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "UniformAnimator",
  versions: /^2\./,
  baseClass: "Animator",
  properties: {
    uniform: "string"
  }
}, function () {
  function _class78(meta) {
    _classCallCheck(this, _class78);

    QmlWeb.callSuper(this, meta);
  }

  return _class78;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "XAnimator",
  versions: /^2\./,
  baseClass: "Animator"
}, function () {
  function _class79(meta) {
    _classCallCheck(this, _class79);

    QmlWeb.callSuper(this, meta);
  }

  return _class79;
}());

QmlWeb.registerQmlType({
  module: "QtQuick",
  name: "YAnimator",
  versions: /^2\./,
  baseClass: "Animator"
}, function () {
  function _class80(meta) {
    _classCallCheck(this, _class80);

    QmlWeb.callSuper(this, meta);
  }

  return _class80;
}());

QmlWeb.registerQmlType({
  module: "QtTest",
  name: "TestCase",
  versions: /^1\./,
  baseClass: "QtQuick.Item",
  properties: {
    completed: "bool",
    name: "string",
    optional: "bool",
    running: "bool",
    when: "bool",
    windowShown: "bool"
  }
}, function () {
  function _class81(meta) {
    var _this69 = this;

    _classCallCheck(this, _class81);

    QmlWeb.callSuper(this, meta);
    this.Component.completed.connect(this, this.Component$onCompleted);

    var engine = QmlWeb.engine;
    if (!engine.tests) {
      QmlWeb.engine.tests = {
        name: engine.name || "Run_" + Math.random().toString(36).slice(2, 10),
        started: false,
        finished: false,
        duration: 0,
        total: 0,
        completed: 0,
        errors: [],
        stats: {
          pass: 0,
          fail: 0,
          skip: 0
        }
      };
    }
    QmlWeb.engine.tests.total++;

    this.console = {
      assert: function assert() {
        var _console;

        return (_console = console).assert.apply(_console, arguments);
      },
      error: function error() {
        var _console2;

        for (var _len26 = arguments.length, a = Array(_len26), _key40 = 0; _key40 < _len26; _key40++) {
          a[_key40] = arguments[_key40];
        }

        return (_console2 = console).error.apply(_console2, ["QSYSTEM: " + _this69.$testId + " qml:"].concat(a));
      },
      info: function info() {
        var _console3;

        for (var _len27 = arguments.length, a = Array(_len27), _key41 = 0; _key41 < _len27; _key41++) {
          a[_key41] = arguments[_key41];
        }

        return (_console3 = console).info.apply(_console3, ["QINFO  : " + _this69.$testId + " qml:"].concat(a));
      },
      log: function log() {
        var _console4;

        for (var _len28 = arguments.length, a = Array(_len28), _key42 = 0; _key42 < _len28; _key42++) {
          a[_key42] = arguments[_key42];
        }

        return (_console4 = console).log.apply(_console4, ["QDEBUG : " + _this69.$testId + " qml:"].concat(a));
      },
      time: function time() {
        var _console5;

        return (_console5 = console).time.apply(_console5, arguments);
      },
      timeEnd: function timeEnd() {
        var _console6;

        return (_console6 = console).timeEnd.apply(_console6, arguments);
      },
      trace: function trace() {
        var _console7;

        return (_console7 = console).trace.apply(_console7, arguments);
      },
      warn: function warn() {
        var _console8;

        for (var _len29 = arguments.length, a = Array(_len29), _key43 = 0; _key43 < _len29; _key43++) {
          a[_key43] = arguments[_key43];
        }

        return (_console8 = console).warn.apply(_console8, ["QWARN  : " + _this69.$testId + " qml:"].concat(a));
      }
    };
  }

  _createClass(_class81, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      var _this70 = this;

      var info = QmlWeb.engine.tests;
      if (!info.started) {
        console.log("********* Start testing of " + info.name + " *********");
        console.log("Config: Using QmlWeb, " + window.navigator.userAgent);
        info.started = true;
      }

      var keys = Object.keys(this);
      var tests = keys.filter(function (key) {
        return key.lastIndexOf("test_", 0) === 0;
      }).filter(function (key) {
        return key.indexOf("_data", key.length - 5) === -1;
      }).sort();

      tests.unshift("initTestCase");
      tests.push("cleanupTestCase");
      tests.forEach(function (test) {
        _this70.$testId = info.name + "::" + _this70.name + "::" + test + "()";
        var special = test === "initTestCase" || test === "cleanupTestCase";

        var dstart = performance.now();
        var data = void 0;
        if (_this70[test + "_data"] && !special) {
          data = _this70[test + "_data"]();
          if (!data || !data.length) {
            _this70.warn("no data supplied for " + test + "() by " + test + "_data()");
            data = [];
          }
        } else if (_this70.init_data && !special) {
          data = _this70.init_data();
          if (!data || !data.length) {
            data = undefined;
          }
        }
        if (!data) {
          data = [null];
        }
        var dend = performance.now();
        info.duration += dend - dstart;

        data.forEach(function (row) {
          var arg = row ? row.tag : "";
          _this70.$testId = info.name + "::" + _this70.name + "::" + test + "(" + arg + ")";
          var start = performance.now();
          var error = void 0;
          try {
            if (!special) {
              _this70.init();
            }
            _this70[test](row);
          } catch (e) {
            error = e;
          } finally {
            if (!special) {
              _this70.cleanup();
            }
          }
          var end = performance.now();
          info.duration += end - start;
          if (error && error.skip) {
            info.stats.skip++;
            console.log("SKIP   : " + _this70.$testId + " " + error.message);
          } else if (error) {
            info.stats.fail++;
            info.errors.push(_this70.$testId + " " + error.message);
            console.log("FAIL!  : " + _this70.$testId + " " + error.message);
            if ("actual" in error) {
              console.log("   Actual   (): " + error.actual);
            }
            if ("expected" in error) {
              console.log("   Expected (): " + error.expected);
            }
          } else {
            info.stats.pass++;
            console.log("PASS   : " + _this70.$testId);
          }
        });

        _this70.$testId = info.name + "::UnknownTestFunc()";
      });

      // TODO: benchmarks

      info.completed++;
      if (info.completed === info.total) {
        info.finished = true;
        var _info$stats = info.stats,
            pass = _info$stats.pass,
            fail = _info$stats.fail,
            skip = _info$stats.skip;

        var duration = Math.round(info.duration * 100) / 100;
        console.log("Totals: " + pass + " passed, " + fail + " failed, " + skip + " skipped, " + duration + "ms");
        console.log("********* Finished testing of " + info.name + " *********");
      }
    }

    // No-ops

  }, {
    key: "init",
    value: function init() {}
  }, {
    key: "initTestCase",
    value: function initTestCase() {}
  }, {
    key: "cleanup",
    value: function cleanup() {}
  }, {
    key: "cleanupTestCase",
    value: function cleanupTestCase() {}

    // API

  }, {
    key: "compare",
    value: function compare(actual, expected) {
      var message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

      if (actual !== expected) {
        var err = new Error(message);
        err.actual = actual;
        err.expected = expected;
        throw err;
      }
    }
  }, {
    key: "verify",
    value: function verify(condition) {
      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

      if (!condition) {
        throw new Error("'" + message + "' returned FALSE. ()");
      }
    }
  }, {
    key: "fail",
    value: function fail() {
      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

      throw new Error(message);
    }
  }, {
    key: "warn",
    value: function warn(message) {
      console.warn("WARNING: " + this.$testId + " " + message);
    }
  }, {
    key: "skip",
    value: function skip() {
      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

      var err = new Error(message);
      err.skip = true;
      throw err;
    }
    /*
    expectFail(tag, message) {
      // TODO
    }
    expectFailContinue(tag, message) {
      // TODO
    }
    findChild(parent, objectName) {
      // TODO
      // return QtObject
    }
    fuzzyCompare(actual, expected, delta, message) {
      // TODO
    }
    grabImage(item) {
      if (!window.top || !window.top.callPhantom) {
        this.skip("Can't use TestCase::grabImage() without PhantomJS.");
      }
      // TODO
      return {
        red: (x, y) => {},
        green: (x, y) => {},
        blue: (x, y) => {},
        alpha: (x, y) => {},
        pixel: (x, y) => {},
        equals: image => false
      };
    }
    ignoreWarning(message) {
      // TODO
    }
    sleep(ms) {
      // TODO
    }
    tryCompare(obj, property, expected, timeout, message) {
      // TODO
    }
    wait(ms) {
      // TODO
    }
    waitForRendering(item, timeout = 5000) {
      // TODO
    }
    */

    // TODO
    /*
    // Events
    keyClick(key, modifiers, delay = -1) {
      // TODO
    }
    keyPress(key, modifiers, delay = -1) {
      // TODO
    }
    keyRelease(key, modifiers, delay = -1) {
      // TODO
    }
    mouseClick(item, x, y, button, modifiers, delay = -1) {
      // TODO
    }
    mouseDoubleClick(item, x, y, button, modifiers, delay = -1) {
      // TODO
    }
    mouseDoubleClickSequence(item, x, y, button, modifiers, delay = -1) {
      // TODO
    }
    mouseDrag(item, x, y, dx, dy, button, modifiers, delay = -1) {
      // TODO
    }
    mouseMove(item, x, y, delay = -1) {
      // TODO
    }
    mousePress(item, x, y, button, modifiers, delay = -1) {
      // TODO
    }
    mouseRelease(item, x, y, button, modifiers, delay = -1) {
      // TODO
    }
    mouseWheel(item, x, y, xDelta, yDelta, button, modifiers, delay = -1) {
      // button = Qt.LeftButton, modifiers = Qt.NoModifier
      // TODO
    }
    */

  }]);

  return _class81;
}());

// WARNING: Can have wrong behavior if url is changed while the socket is in
// Connecting state.
// TODO: Recheck everything.

QmlWeb.registerQmlType({
  module: "QtWebSockets",
  name: "WebSocket",
  versions: /.*/,
  baseClass: "QtQml.QtObject",
  enums: {
    WebSocket: { Connecting: 0, Open: 1, Closing: 2, Closed: 3, Error: 4 }
  },
  properties: {
    active: "bool",
    status: { type: "enum", initialValue: 3 }, // WebSocket.Closed
    errorString: "string",
    url: "url"
  },
  signals: {
    textMessageReceived: [{ type: "string", name: "message" }]
  }
}, function () {
  function _class82(meta) {
    _classCallCheck(this, _class82);

    QmlWeb.callSuper(this, meta);

    this.$socket = undefined;
    this.$reconnect = false;

    this.statusChanged.connect(this, this.$onStatusChanged);
    this.activeChanged.connect(this, this.$reconnectSocket);
    this.urlChanged.connect(this, this.$reconnectSocket);
  }

  _createClass(_class82, [{
    key: "$onStatusChanged",
    value: function $onStatusChanged(status) {
      if (status !== this.WebSocket.Error) {
        this.errorString = "";
      }
    }
  }, {
    key: "$connectSocket",
    value: function $connectSocket() {
      var _this71 = this;

      this.$reconnect = false;

      if (!this.url || !this.active) {
        return;
      }

      this.status = this.WebSocket.Connecting;
      this.$socket = new WebSocket(this.url);
      this.$socket.onopen = function () {
        _this71.status = _this71.WebSocket.Open;
      };
      this.$socket.onclose = function () {
        _this71.status = _this71.WebSocket.Closed;
        if (_this71.$reconnect) {
          _this71.$connectSocket();
        }
      };
      this.$socket.onerror = function (error) {
        _this71.errorString = error.message;
        _this71.status = _this71.WebSocket.Error;
      };
      this.$socket.onmessage = function (message) {
        _this71.textMessageReceived(message.data);
      };
    }
  }, {
    key: "$reconnectSocket",
    value: function $reconnectSocket() {
      this.$reconnect = true;
      if (this.status === this.WebSocket.Open) {
        this.status = this.WebSocket.Closing;
        this.$socket.close();
      } else if (this.status !== this.WebSocket.Closing) {
        this.$connectSocket();
      }
    }
  }, {
    key: "sendTextMessage",
    value: function sendTextMessage(message) {
      if (this.status === this.WebSocket.Open) {
        this.$socket.send(message);
      }
    }
  }]);

  return _class82;
}());

QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Accordion",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    expanded: "bool",
    eventName: { type: "string", initialValue: "click" }
  },
  signals: {
    open: [{ type: "int", name: "index" }],
    opening: [{ type: "int", name: "index" }],
    change: [{ type: "int", name: "index" }],
    close: [{ type: "int", name: "index" }],
    closing: [{ type: "int", name: "index" }]
  }
}, function () {
  function _class83(meta) {
    _classCallCheck(this, _class83);

    QmlWeb.callSuper(this, meta);
    this.Component.completed.connect(this, this.Component$onCompleted);
    this.expandedChanged.connect(this, this.$onExpandedChanged);
    this.baseClassName = "ui accordion";
    this.dom.style.position = "relative";
  }

  _createClass(_class83, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      this.$accordion = $(this.dom).accordion({
        on: this.eventName,
        onOpen: this.onOpen.bind(this),
        onOpening: this.onOpening.bind(this),
        onChange: this.onChange.bind(this),
        onClose: this.onClose.bind(this),
        onClosing: this.onClosing.bind(this),
        animateChildren: false
      });
    }
  }, {
    key: "$onExpandedChanged",
    value: function $onExpandedChanged() {
      var _this72 = this;

      $(document).ready(function () {
        if (_this72.expanded) {
          _this72.$accordion.accordion('open', 0);
        } else {
          _this72.$accordion.accordion('close', 0);
        }
      });
    }

    //by default when we wanna call some method on accordion
    //we have to get the accordions by jquery like $('.ui.accordion')
    //above will get all accordions object
    //to open the first accordion in page: $('.ui.accordion').accordion('open', 0)
    //but if we want to reduce the scope to our dom
    //we have to get an accordion by $(this.dom)
    //and the accordion object will only has 1 children
    //so we can open it by $(this.dom).accordion('open', 0)

  }, {
    key: "expand",
    value: function expand() {
      if (!this.$accordion) return;
      this.$accordion.accordion('open', 0);
    }
  }, {
    key: "collapse",
    value: function collapse() {
      if (!this.$accordion) return;
      this.$accordion.accordion('close', 0);
    }
  }, {
    key: "toggle",
    value: function toggle() {
      if (!this.$accordion) return;
      this.$accordion.accordion('toggle', 0);
    }
  }, {
    key: "onOpen",
    value: function onOpen() {
      this.open(this.$accordion.index());
      //work around for fixing dgrid style
      document.body.dispatchEvent(new CustomEvent("resizeDgrid", {
        detail: {
          dom: this.dom
        }
      }));
    }
  }, {
    key: "onOpening",
    value: function onOpening() {
      this.opening(this.$accordion.index());
    }
  }, {
    key: "onChange",
    value: function onChange() {
      this.change(this.$accordion.index());
    }
  }, {
    key: "onClose",
    value: function onClose() {
      this.close(this.$accordion.index());
    }
  }, {
    key: "onClosing",
    value: function onClosing() {
      this.closing(this.$accordion.index());
    }
  }]);

  return _class83;
}());
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "AccordionContent",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {}
}, function () {
  function _class84(meta) {
    _classCallCheck(this, _class84);

    QmlWeb.callSuper(this, meta);
    this.baseClassName = "content";
  }

  return _class84;
}());
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "AccordionItem",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {}
}, function () {
  function _class85(meta) {
    _classCallCheck(this, _class85);

    QmlWeb.callSuper(this, meta);
    this.baseClassName = "item";
  }

  return _class85;
}());
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "AccordionTitle",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    text: "string"
  },
  signals: {
    clicked: []
  }
}, function () {
  function _class86(meta) {
    _classCallCheck(this, _class86);

    QmlWeb.callSuper(this, meta);
    this.textChanged.connect(this, this.$onTextChanged);
    this.baseClassName = "title";
    $(this.dom).on('click', this.titleClick.bind(this));
  }

  _createClass(_class86, [{
    key: "titleClick",
    value: function titleClick(event) {
      this.clicked();
    }
  }, {
    key: "$onTextChanged",
    value: function $onTextChanged() {
      var iconNode = void 0,
          placeholderNode = document.createElement("div");
      this.children.forEach(function (child) {
        return placeholderNode.appendChild(iconNode = child.dom);
      });
      this.dom.innerHTML = "";
      iconNode && this.dom.appendChild(iconNode);
      this.dom.appendChild(document.createTextNode(this.text));
    }
  }]);

  return _class86;
}());
QmlWeb.registerQmlType({
  module: 'Semantic.Html',
  name: 'ActionTextBox',
  versions: /.*/,
  baseClass: 'Semantic.Html.TextBox',
  properties: {
    enableButton: { type: 'bool', initialValue: true },
    icon: 'string',
    buttonText: 'string',
    buttonColor: 'string'
  },
  signals: {
    buttonClicked: []
  }
}, function () {
  function _class87(meta) {
    var _iconDom$classList,
        _this73 = this;

    _classCallCheck(this, _class87);

    QmlWeb.callSuper(this, meta);
    this.enableButtonChanged.connect(this, this.$onEnableButtonChanged);
    this.iconChanged.connect(this, this.$onIconChanged);
    this.buttonColorChanged.connect(this, this.$onButtonColorChanged);
    this.buttonTextChanged.connect(this, this.$onButtonTextChanged);

    this.suffixClassName = 'action input';

    this.button = document.createElement('button');
    this.button.classList.add('ui', 'icon', 'button');

    this._icon = ['search'];
    this.iconDom = document.createElement('i');
    (_iconDom$classList = this.iconDom.classList).add.apply(_iconDom$classList, _toConsumableArray(this._icon).concat(['icon']));

    this.button.appendChild(this.iconDom);
    this.dom.appendChild(this.button);

    this.button.onclick = function () {
      if (_this73.enableButton) _this73.buttonClicked();
    };
  }

  _createClass(_class87, [{
    key: "$onEnableButtonChanged",
    value: function $onEnableButtonChanged() {
      this.button.classList.add('disabled');
      if (this.enableButton) this.button.classList.remove('disabled');
    }
  }, {
    key: "$onIconChanged",
    value: function $onIconChanged() {
      var _iconDom$classList2, _iconDom$classList3;

      this.icon = this.icon.replace(/  +/g, ' ');
      var iconList = this.icon.split(' ');

      (_iconDom$classList2 = this.iconDom.classList).remove.apply(_iconDom$classList2, _toConsumableArray(this._icon));
      (_iconDom$classList3 = this.iconDom.classList).add.apply(_iconDom$classList3, _toConsumableArray(iconList));
      this._icon = iconList;
    }
  }, {
    key: "$onButtonColorChanged",
    value: function $onButtonColorChanged() {
      var COLORS = ['red', 'orange', 'yellow', 'olive', 'green', 'teal', 'blue', 'violet', 'purple', 'pink', 'brown', 'grey', 'black'];
      this.button.classList.remove(this._buttonColor);
      if (COLORS.includes(this.buttonColor)) {
        this.button.classList.add(this.buttonColor);
        this._buttonColor = this.buttonColor;
      }
    }
  }, {
    key: "$onButtonTextChanged",
    value: function $onButtonTextChanged() {
      this.button.innerHTML = this.buttonText;
    }
  }]);

  return _class87;
}());

QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Agenda",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    events: { type: "var", initialValue: [] },
    views: { type: "var", initialValue: ["month", "agendaWeek", "agendaDay", "listMonth"] },
    selectedView: { type: "string", initialValue: "" },
    size: { type: "int", initialValue: 550 },
    newEvent: "var",
    optionalSetting: { type: "var", initialValue: {} }
  },
  signals: {
    rendered: [],
    eventRemoved: [{ type: 'var', name: 'calEvent' }]
  }
}, function () {
  function _class88(meta) {
    var _this74 = this;

    _classCallCheck(this, _class88);

    QmlWeb.callSuper(this, meta);
    this.Component.completed.connect(this, this.Component$onCompleted);
    this.selectedViewChanged.connect(this, this.$onSelectedViewChanged);
    this.eventsChanged.connect(this, this.$onEventsChanged);
    this.timePattern = /^([0-1][0-9]|[2][0-3]):([0-5][0-9])$/;
    this.datePattern = /^\d{1,2}\/\d{1,2}\/\d{4}$/;
    this.$dom = $("\n            <div>\n                <div data-main=\"fullcalendar\" style=\"margin:auto\"></div>\n                <div class=\"ui mini modal\" data-action=\"info\">\n                    <div class=\"header\">\n                        <h3>\u0E19\u0E31\u0E14\u0E2B\u0E21\u0E32\u0E22</h3>\n                    </div>\n                    <div class=\"content\">\n                        <div class=\"ui form\">\n                            <div class=\"inline field\">\n                                <label style=\"width:30px\">\u0E40\u0E23\u0E34\u0E48\u0E21:</label>\n                                <div class=\"ui large blue label\">\n                                    <div class=\"detail\" data-info=\"start\"></div>\n                                </div>\n                            </div>\n                            <div class=\"inline field\">\n                                <label style=\"width:30px\">\u0E16\u0E36\u0E07: </label>\n                                <div class=\"ui large orange label\">\n                                    <div class=\"detail\" data-info=\"end\"></div>\n                                </div>\n                            </div>\n                            <div class=\"ui horizontal divider\">\u0E23\u0E32\u0E22\u0E25\u0E30\u0E40\u0E2D\u0E35\u0E22\u0E14</div>\n                            <div class=\"field\">\n                                <p data-info=\"detail\">\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25</p>\n                            </div>\n                        </div>\n                    </div>\n                    <div class=\"actions\">\n                        <button class=\"ui small red button\" data-action=\"delete\">\u0E25\u0E1A</button>\n                    </div>\n                </div>\n                <div class=\"ui mini modal\" data-action=\"confirm\">\n                    <div class=\"header\">\n                        <h3>\u0E15\u0E49\u0E2D\u0E07\u0E01\u0E32\u0E23\u0E25\u0E1A\u0E19\u0E31\u0E14\u0E2B\u0E21\u0E32\u0E22\u0E19\u0E35\u0E49\u0E43\u0E0A\u0E48\u0E2B\u0E23\u0E37\u0E2D\u0E44\u0E21\u0E48</h3>\n                    </div>\n                    <div class=\"actions\">\n                        <button class=\"ui small green button\" data-action=\"yes\">\u0E43\u0E0A\u0E48</button>\n                        <button class=\"ui small red button\" data-action=\"no\">\u0E44\u0E21\u0E48</button>\n                    </div>\n                </div>\n            </div>\n        ");

    this.dom = this.$dom[0];
    this.$calendar = this.$dom.find('div[data-main=fullcalendar]');
    this.$infoModal = this.$dom.find('.ui.modal[data-action=info]');
    this.$confirmModal = this.$dom.find('.ui.modal[data-action=confirm]');
    this.$yesButton = this.$dom.find('.ui.button[data-action=yes]');
    this.$noButton = this.$dom.find('.ui.button[data-action=no]');
    this.$delButton = this.$dom.find('.ui.button[data-action=delete]');
    this.$startInfo = this.$infoModal.find('.content div[data-info=start]');
    this.$endInfo = this.$infoModal.find('.content div[data-info=end]');
    this.$detailInfo = this.$infoModal.find('.content p[data-info=detail]');

    this.infoModalContext = document.createElement('div');
    this.confirmModalContext = document.createElement('div');

    this.infoModalContext.style.display = 'none';
    this.confirmModalContext.style.display = 'none';
    document.body.appendChild(this.infoModalContext);
    document.body.appendChild(this.confirmModalContext);

    this.$infoModal.modal({ dimmerSettings: { opacity: 0.5 }, duration: 270, context: this.infoModalContext });
    this.$confirmModal.modal({ dimmerSettings: { opacity: 0.5 }, duration: 270, context: this.confirmModalContext });

    this.$yesButton.on('click', function () {
      var event = _this74.$infoModal.data("event");
      _this74.eventRemoved(event);
      _this74.$calendar.fullCalendar('removeEvents', event._id);
      _this74.confirmModalContext.style.display = 'none';
      _this74.$confirmModal.modal('hide');
    });

    this.$noButton.on('click', function () {
      _this74.confirmModalContext.style.display = 'none';
      _this74.$confirmModal.modal('hide');
    });

    this.$delButton.on('click', function () {
      document.body.appendChild(_this74.confirmModalContext);
      _this74.confirmModalContext.style.display = '';
      _this74.$confirmModal.modal('show');
    });

    this.setting = {};
    this.setting["locale"] = "th";
    this.setting["navLinks"] = true;
    this.setting["editable"] = true;
    this.setting["selectable"] = true;

    this.setting["header"] = {
      left: 'prevYear prev,next nextYear today',
      center: 'title'
    };

    this.setting["views"] = {
      month: {
        titleFormat: 'MMMM B'
      },
      agendaWeek: {
        allDaySlot: false,
        titleFormat: 'DD MMMM B',
        columnFormat: 'dd D',
        slotLabelFormat: 'H:mm'
      },
      agendaDay: {
        allDaySlot: false,
        slotLabelFormat: 'H:mm',
        titleFormat: 'DD MMMM B'
      }
    };

    //To allow or not allow select overlab
    this.setting["selectOverlap"] = function (event) {
      return !event.disabled;
    };

    //To allow or not allow drag or resize overlap
    this.setting["eventOverlap"] = function (stillEvent, movingEvent) {
      return !stillEvent.disabled;
    };

    this.setting["eventClick"] = function (calEvent, jsEvent, view) {
      var start = "-",
          end = "-";
      if (calEvent.start) start = calEvent.start.format('DD MMMM B HH:mm');
      if (calEvent.end) end = calEvent.end.format('DD MMMM B HH:mm');

      _this74.$startInfo.html(start);
      _this74.$endInfo.html(end);
      _this74.$detailInfo.html(calEvent.title);
      document.body.appendChild(_this74.infoModalContext);
      _this74.infoModalContext.style.display = '';
      _this74.$infoModal.modal('show');
      _this74.$infoModal.data("event", calEvent);
    };

    this.setting["select"] = function (start, end) {
      var allow = void 0,
          shiftedEnd = start.clone(),
          calendar = _this74.$calendar.data('fullCalendar'),
          viewType = _this74.$calendar.fullCalendar("getView").type;

      if (!_this74.newEvent || viewType === "month") return;

      shiftedEnd.add(parseInt(_this74.newEvent.hour), 'hour');
      shiftedEnd.add(parseInt(_this74.newEvent.minute), 'minute');
      _this74.newEvent.start = start;
      _this74.newEvent.end = shiftedEnd;
      allow = calendar.isSelectionSpanAllowed({ start: start, end: shiftedEnd });

      if (allow) _this74.$calendar.fullCalendar('renderEvent', _this74.newEvent, true);else return;

      _this74.$calendar.fullCalendar('unselect');
      _this74.newEvent = null;
    };
    this.setting["eventAfterAllRender"] = this.onEventAfterAllRender.bind(this);
    this.setting["eventDestroy"] = this.onEventDestroy.bind(this);
  }

  _createClass(_class88, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      this.setting["events"] = this.getAgendarEvents();
      this.setting["header"]["right"] = this.views.join(',');
      this.setting["defaultView"] = this.selectedView ? this.selectedView : this.views[0];
      this.setting = Object.assign(this.setting, this.optionalSetting);
      this.$calendar.width(parseInt(this.size));
      this.$calendar.fullCalendar(this.setting);
      this.completed = true;
    }
  }, {
    key: "$onSelectedViewChanged",
    value: function $onSelectedViewChanged() {
      if (this.completed) {
        this.$calendar.fullCalendar('changeView', selectedView);
      }
    }

    /* !!!!!!! DO NOT !!!!!!!!!!!! set the events to any rendered events   */

  }, {
    key: "$onEventsChanged",
    value: function $onEventsChanged() {
      if (this.bySystem || !this.events instanceof Array) {
        return;
      }
      if (this.completed) {
        var calEvents = this.getAgendarEvents.call({
          events: this.events.slice(),
          timePattern: this.timePattern,
          datePattern: this.datePattern
        });

        this.$calendar.fullCalendar("removeEvents");
        this.$calendar.fullCalendar("renderEvents", calEvents, true);
      }
    }
  }, {
    key: "onEventAfterAllRender",
    value: function onEventAfterAllRender(view) {
      //Change happens to event
      this.updateEventsObject();
      this.rendered();
    }
  }, {
    key: "onEventDestroy",
    value: function onEventDestroy(event, element, view) {
      //After event is destroy
      this.updateEventsObject();
    }
  }, {
    key: "updateEventsObject",
    value: function updateEventsObject() {
      this.bySystem = true;
      var events = this.$calendar.fullCalendar('clientEvents');
      events.forEach(function (item) {
        if (item.start) {
          item.startDate = item.start.format("DD/MM/B");
          item.startTime = item.start.format("HH:mm");
        }
        if (item.end) {
          item.endDate = item.end.format("DD/MM/B");
          item.endTime = item.end.format("HH:mm");
        }
      });
      this.events = events;
      this.bySystem = false;
    }
  }, {
    key: "getAgendarEvents",
    value: function getAgendarEvents() {
      var _this75 = this;

      this.events.forEach(function (item) {
        var startValid = void 0,
            endValid = void 0,
            start = void 0,
            end = void 0,
            day = void 0,
            month = void 0,
            year = void 0;
        startValid = _this75.datePattern.test(item.startDate);
        startValid = startValid && _this75.timePattern.test(item.startTime);
        endValid = _this75.datePattern.test(item.endDate);
        endValid = endValid && _this75.timePattern.test(item.endTime);

        if (startValid) {
          var _item$startDate$split = item.startDate.split("/");

          var _item$startDate$split2 = _slicedToArray(_item$startDate$split, 3);

          day = _item$startDate$split2[0];
          month = _item$startDate$split2[1];
          year = _item$startDate$split2[2];

          year = Math.max(0, Number(year) - 543);
          start = year + "-" + month + "-" + day + "T" + item.startTime + ":00";
        }

        if (endValid) {
          var _item$endDate$split = item.endDate.split("/");

          var _item$endDate$split2 = _slicedToArray(_item$endDate$split, 3);

          day = _item$endDate$split2[0];
          month = _item$endDate$split2[1];
          year = _item$endDate$split2[2];

          year = Math.max(0, Number(year) - 543);
          end = year + "-" + month + "-" + day + "T" + item.endTime + ":00";
        };

        delete item.startDate;
        delete item.startTime;
        delete item.endDate;
        delete item.endTime;

        item["start"] = start;
        item["end"] = end;
      });
      return this.events;
    }

    /* This method won't check if a new event overlap a disabled event or not   *
     * !!!!!!! DO NOT !!!!!!!!!!!! pass a rendered event                        */

  }, {
    key: "addEvent",
    value: function addEvent(event) {
      var calEvent = this.getAgendarEvents.call({
        events: [event],
        timePattern: this.timePattern,
        datePattern: this.datePattern
      })[0];

      this.$calendar.fullCalendar('renderEvent', calEvent, true);
    }

    /*  param: id            *
     *  get it by event._id  */

  }, {
    key: "removeEvent",
    value: function removeEvent(id) {
      id && this.$calendar.fullCalendar('removeEvents', id);
    }
  }, {
    key: "removeAllEvents",
    value: function removeAllEvents() {
      this.$calendar.fullCalendar('removeEvents');
    }

    // param: the rendered event that has an id

  }, {
    key: "updateEvent",
    value: function updateEvent(event) {
      event && this.$calendar.fullCalendar('updateEvent', event);
    }
  }, {
    key: "gotoDate",
    value: function gotoDate(date) {
      var day = void 0,
          month = void 0,
          year = void 0;
      if (!this.completed) return;
      if (this.datePattern.test(date)) {
        var _date$split = date.split("/");

        var _date$split2 = _slicedToArray(_date$split, 3);

        day = _date$split2[0];
        month = _date$split2[1];
        year = _date$split2[2];

        year = Math.max(0, Number(year) - 543);
        this.$calendar.fullCalendar('gotoDate', moment(year + "-" + month + "-" + day));
      }
    }
  }, {
    key: "refresh",
    value: function refresh() {
      this.$calendar.fullCalendar('render', event);
    }
  }, {
    key: "rerender",
    value: function rerender() {
      this.$calendar.fullCalendar('render');
    }
  }]);

  return _class88;
}());

QmlWeb.registerQmlType({
  module: 'Semantic.Html',
  name: 'AutoCompleteBox',
  versions: /.*/,
  baseClass: 'Semantic.Html.Dom',
  properties: {
    options: 'var',
    placeholder: 'string',
    optionTextField: { type: 'string', initialValue: 'name' }
  },
  signals: {}
}, function () {
  function _class89(meta) {
    _classCallCheck(this, _class89);

    QmlWeb.callSuper(this, meta);
    this.Component.completed.connect(this, this.Component$onCompleted);
    this.optionsChanged.connect(this, this.$onOptionsChanged);
    this.placeholderChanged.connect(this, this.$onPlaceholderChanged);

    this.dom.style = 'padding:4px; border:1px solid #ddd; border-radius: 3px; background-color:#fff; width: 100%;';
    this.functionList = [];
  }

  _createClass(_class89, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      var _this76 = this;

      $(document).ready(function () {
        _this76.auto = completely(_this76.dom, {
          fontSize: '15px',
          fontFamily: 'Arial'
        });

        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = _this76.functionList[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            func = _step4.value;

            func.bind(_this76)();
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        _this76.dom.onclick = function () {
          _this76.auto.startForm = event.target.selectionStart;
          _this76.auto.repaint();
        };

        _this76.dom.onkeydown = function () {
          if (event.keyCode == 32) {
            // space bar
            _this76.auto.startFrom = event.target.selectionStart + 1;
          }
        };

        var isStoping = false;
        var fromSelected = false;

        var stopTyping = _this76.$debounce(function (event) {
          _this76.auto.repaint();
        }, 250);

        _this76.auto.onChange = function (text) {
          if (!isStoping) {
            isStoping = true;
            _this76.auto.startFrom = event.target.selectionStart == 1 ? 0 : event.target.selectionStart;
          }
          if (event.target.selectionStart < _this76.auto.startFrom) {
            var startIndex = event.target.selectionStart - 1;
            if (text < _this76.text) {
              startIndex = event.target.selectionStart;
            }
            _this76.auto.startFrom = startIndex;
          }
          if (1 < event.target.selectionStart - _this76.auto.endIndex) {
            if (fromSelected) {
              fromSelected = false;
            } else {
              _this76.auto.startFrom = event.target.selectionStart - 1;
            }
          }

          _this76.auto.endIndex = event.target.selectionStart;
          stopTyping(event);

          _this76.bySystem = true;
          _this76.text = _this76.auto.getText();
          _this76.bySystem = false;
        };

        _this76.auto.onSelect = function (text, rightSide) {
          fromSelected = true;
          var caret = text.length - rightSide.length;
          _this76.auto.input.setSelectionRange(caret, caret);
          isStoping = false;
        };
      });
    }
  }, {
    key: "setFocus",
    value: function setFocus() {
      var _this77 = this;

      if (!this.auto) {
        this.functionList.push(this.setFocus);
        return;
      }

      setTimeout(function () {
        _this77.auto.input.focus();
      }, 0);
    }
  }, {
    key: "$debounce",
    value: function $debounce(func, wait, immediate) {
      var timeout;
      return function () {
        var context = this,
            args = arguments;
        var later = function later() {
          timeout = null;
          if (!immediate) func.apply(context, args);
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(context, args);
      };
    }
  }, {
    key: "$onOptionsChanged",
    value: function $onOptionsChanged() {
      if (!this.auto) {
        this.functionList.push(this.$onOptionsChanged);
        return;
      }

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this.options[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          option = _step5.value;

          this.auto.options.push(option[this.optionTextField]);
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    }
  }, {
    key: "$onTextChanged",
    value: function $onTextChanged() {
      if (!this.auto) {
        this.functionList.push(this.$onTextChanged);
        return;
      }

      if (!this.bySystem) {
        this.auto.setText(this.text);
      }
    }
  }, {
    key: "$onPlaceholderChanged",
    value: function $onPlaceholderChanged() {
      if (!this.auto) {
        this.functionList.push(this.$onPlaceholderChanged);
        return;
      }

      this.auto.input.placeholder = this.placeholder;
    }
  }]);

  return _class89;
}());

QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Br",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    text: "string"
  }
}, function () {
  function _class90(meta) {
    _classCallCheck(this, _class90);

    meta.object.tagName = "br";
    QmlWeb.callSuper(this, meta);
  }

  return _class90;
}());
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Button",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    text: "string",
    backgroundColor: { type: "string", initialValue: "" },
    size: { type: "string", initialValue: "" },
    fluid: "bool",
    circular: "bool",
    basic: "bool",
    inverted: "bool",
    icon: "string",
    loading: "bool",
    active: "bool",
    toggle: "bool",
    enabled: { type: "bool", initialValue: true }
  },
  signals: {
    clicked: [],
    hovered: []
  }
}, function () {
  function _class91(meta) {
    var _this78 = this;

    _classCallCheck(this, _class91);

    meta.object.tagName = "button";
    QmlWeb.callSuper(this, meta);
    this.backgroundColorChanged.connect(this, this.$onBackgroundColorChanged);
    this.sizeChanged.connect(this, this.$onSizeChanged);
    this.textChanged.connect(this, this.$onTextChanged);
    this.fluidChanged.connect(this, this.$onFluidChanged);
    this.circularChanged.connect(this, this.$onCircularChanged);
    this.enabledChanged.connect(this, this.$onEnabledChanged);
    this.loadingChanged.connect(this, this.$onLoadingChanged);
    this.basicChanged.connect(this, this.$onBasicChanged);
    this.invertedChanged.connect(this, this.$onInvertedChanged);
    this.iconChanged.connect(this, this.$onIconChanged);
    this.activeChanged.connect(this, this.$onActiveChanged);
    this.toggleChanged.connect(this, this.$onToggleChanged);

    this._size = "medium";
    this.suffixClassName = "button";

    this.dom.onclick = function () {
      _this78.clicked();
    };
    this.dom.onmouseover = function () {
      _this78.hovered();
    };
  }

  _createClass(_class91, [{
    key: "setIconAndText",
    value: function setIconAndText() {
      var icon = this.icon || "",
          text = this.text || "";

      this.dom.innerHTML = "";

      this.addClass("icon");
      this.iconNode = document.createElement("i");
      this.iconNode.className = icon + " icon";
      icon && this.dom.appendChild(this.iconNode);
      text && this.dom.appendChild(document.createTextNode(text));
    }
  }, {
    key: "$onTextChanged",
    value: function $onTextChanged() {
      this.setIconAndText();
    }
  }, {
    key: "$onBackgroundColorChanged",
    value: function $onBackgroundColorChanged() {
      var BACKGROUNDCOLOR = ['red', 'orange', 'yellow', 'olive', 'green', 'teal', 'blue', 'violet', 'purple', 'pink', 'brown', 'grey', 'black'];
      this.dom.style.backgroundColor = "";
      this.removeClass(this._backgroundColor);
      if (BACKGROUNDCOLOR.includes(this.backgroundColor)) {
        this.addClass(this.backgroundColor);
      } else {
        this.dom.style.backgroundColor = this.backgroundColor;
      }
      this._backgroundColor = this.backgroundColor;
    }
  }, {
    key: "$onSizeChanged",
    value: function $onSizeChanged() {
      this.removeClass(this._size);
      this.addClass(this.size);
      this._size = this.size;
    }
  }, {
    key: "$onFluidChanged",
    value: function $onFluidChanged() {
      this.addClass("fluid");
      if (!this.fluid) this.removeClass("fluid");
    }
  }, {
    key: "$onCircularChanged",
    value: function $onCircularChanged() {
      this.addClass("circular");
      if (!this.circular) this.removeClass("circular");
    }
  }, {
    key: "$onEnabledChanged",
    value: function $onEnabledChanged() {
      this.addClass("disabled");
      if (this.enabled) this.removeClass("disabled");
    }
  }, {
    key: "$onLoadingChanged",
    value: function $onLoadingChanged() {
      this.addClass("loading");
      this.dom.style.pointerEvents = "none";
      if (!this.loading) {
        this.dom.style.pointerEvents = "auto";
        this.removeClass("loading");
      }
    }
  }, {
    key: "$onBasicChanged",
    value: function $onBasicChanged() {
      this.addClass("basic");
      if (!this.basic) this.removeClass("basic");
    }
  }, {
    key: "$onInvertedChanged",
    value: function $onInvertedChanged() {
      this.addClass("inverted");
      if (!this.inverted) this.removeClass("inverted");
    }
  }, {
    key: "$onIconChanged",
    value: function $onIconChanged() {
      this.setIconAndText();
    }
  }, {
    key: "$onActiveChanged",
    value: function $onActiveChanged() {
      this.addClass("active");
      if (!this.active) this.removeClass("active");
    }
  }, {
    key: "$onToggleChanged",
    value: function $onToggleChanged() {
      this.addClass("toggle");
      if (!this.toggle) this.removeClass("toggle");
    }
  }]);

  return _class91;
}());

{

  var Buttons = function () {
    function Buttons(meta) {
      _classCallCheck(this, Buttons);

      QmlWeb.callSuper(this, meta);
      this.fluidChanged.connect(this, this.$onFluidChanged);
      this.verticalChanged.connect(this, this.$onVerticalChanged);
      this.sizeChanged.connect(this, this.$onSizeChanged);
      this.backgroundColorChanged.connect(this, this.$onBackgroundColorChanged);
      this.basicChanged.connect(this, this.$onBasicChanged);
      this.equalWidthChanged.connect(this, this.$onEqualwidthChanged);

      this.suffixClassName = "buttons";
    }

    _createClass(Buttons, [{
      key: "validateProperty",
      value: function validateProperty(prop) {
        prop = prop.toLowerCase();
        if (Buttons.backgroundColor.includes(prop)) return [true, "" + prop];
        if (Buttons.size.includes(prop)) return [true, "" + prop];
        if (Buttons.equalWidth.includes(prop)) return [true, "" + prop];
        return [false, ""];
      }
    }, {
      key: "$onBackgroundColorChanged",
      value: function $onBackgroundColorChanged() {
        var _validateProperty = this.validateProperty(this.backgroundColor),
            _validateProperty2 = _slicedToArray(_validateProperty, 2),
            pass = _validateProperty2[0],
            css = _validateProperty2[1];

        if (!pass) return;
        this.dom.classList.remove("" + this._backgroundColor);
        this.dom.classList.add(css);
        this._backgroundColor = this.backgroundColor;
      }
    }, {
      key: "$onSizeChanged",
      value: function $onSizeChanged() {
        var _validateProperty3 = this.validateProperty(this.size),
            _validateProperty4 = _slicedToArray(_validateProperty3, 2),
            pass = _validateProperty4[0],
            css = _validateProperty4[1];

        if (!pass) return;
        this.dom.classList.remove("" + this._size);
        this.dom.classList.add(css);
        this._size = this.size;
      }
    }, {
      key: "$onEqualwidthChanged",
      value: function $onEqualwidthChanged() {
        var _validateProperty5 = this.validateProperty(this.equalWidth),
            _validateProperty6 = _slicedToArray(_validateProperty5, 2),
            pass = _validateProperty6[0],
            css = _validateProperty6[1];

        if (!pass) return;
        this.dom.classList.remove("" + this._equalWidth);
        this.dom.classList.add(css);
        this._equalWidth = this.equalWidth;
      }
    }, {
      key: "$onFluidChanged",
      value: function $onFluidChanged() {
        this.dom.classList.remove("fluid");
        if (this.fluid) this.dom.classList.add("fluid");
      }
    }, {
      key: "$onVerticalChanged",
      value: function $onVerticalChanged() {
        this.dom.classList.remove("vertical");
        if (this.vertical) this.dom.classList.add("vertical");
      }
    }, {
      key: "$onBasicChanged",
      value: function $onBasicChanged() {
        this.dom.classList.remove("basic");
        if (this.basic) this.dom.classList.add("basic");
      }
    }]);

    return Buttons;
  }();

  Buttons.backgroundColor = ["red", "orange", "yellow", "olive", "green", "teal", "blue", "violet", "purple", "pink", "brown", "grey", "black"];

  Buttons.size = ["mini", "tiny", "small", "medium", "large", "big", "huge", "massive"];

  Buttons.equalWidth = ["two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve"];

  QmlWeb.registerQmlType({
    module: "Semantic.Html",
    name: "Buttons",
    versions: /.*/,
    baseClass: "Semantic.Html.Dom",
    properties: {
      text: "string",
      vertical: "bool",
      size: "string",
      backgroundColor: "string",
      equalWidth: "string",
      basic: "bool",
      fluid: { type: "bool", initialValue: true },
      enabled: { type: "bool", initialValue: true }
    },
    signals: {
      clicked: []
    }
  }, Buttons);
}
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Calendar",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    startDate: { type: "string", initialValue: "" },
    endDate: { type: "string", initialValue: "" },
    firstDayOfWeek: { type: "int", initialValue: 0 },
    multipleSelection: 'bool',
    selectedDate: 'var'
  },
  signals: {
    selected: [{ type: "string", name: "value" }],
    monthChanged: [{ type: "string", name: "firstDay" }, { type: "string", name: "lastDay" }]
  }
}, function () {
  function _class92(meta) {
    var _this79 = this;

    _classCallCheck(this, _class92);

    QmlWeb.callSuper(this, meta);

    this.Component.completed.connect(this, this.Component$onCompleted);
    this.startDateChanged.connect(this, this.$onStartDateChanged);
    this.endDateChanged.connect(this, this.$onEndDateChanged);
    this.selectedDateChanged.connect(this, this.$onSelectedDateChanged);
    this.multipleSelectionChanged.connect(this, this.$onMultipleSelectionChanged);

    var template = "<div class=\"vccalendar dropdown-menu\">\n                            <div class=\"ranges\"></div>\n                            <div class=\"calendar first left\"></div>\n                        </div>";

    this.dom = $(template)[0];

    $(this.dom).on("selectDate", function (evt, value) {
      _this79.bySystem = true;
      _this79.selectedDate = value;
      _this79.bySystem = false;
      _this79.selected(value);
    });

    $(this.dom).on("selectDates", function (evt, value) {
      _this79.bySystem = true;
      _this79.selectedDate = value;
      _this79.bySystem = false;
      _this79.selected(value);
    });

    $(this.dom).on("monthChange", function (evt, value) {
      var firstDay = value.firstDay.format('DD/MM/YYYY').split('/');
      firstDay[2] = (parseInt(firstDay[2]) + 543).toString();
      firstDay = firstDay.join('/');
      var lastDay = value.lastDay.format('DD/MM/YYYY').split('/');
      lastDay[2] = (parseInt(lastDay[2]) + 543).toString();
      lastDay = lastDay.join('/');

      _this79.monthChanged(firstDay, lastDay);
    });
  }

  _createClass(_class92, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      var _this80 = this;

      $(document).ready(function () {
        !_this80.setting && _this80.ThaiStyleSetting();
        _this80.refreshCalendar();

        //Do the thing that can't do before component is completed
        //Set selectedDate 
        _this80.selectedDate && _this80.$onSelectedDateChanged();
      });
    }
  }, {
    key: "$onSelectedDateChanged",
    value: function $onSelectedDateChanged() {
      if (this.bySystem) return;
      if (!this.calendar) return;
      if (!this.multipleSelection && typeof this.selectedDate !== "string") {
        console.error("Selected Date is not a string type");
        return;
      }
      if (this.multipleSelection && !(this.selectedDate instanceof Array)) {
        console.error("Selected Date is not an Array type");
        return;
      }

      if (!this.multipleSelection) {
        this.calendar.setCalendarDate(this.selectedDate);
      }
      if (this.multipleSelection) {
        this.calendar.setCalendarDates(this.selectedDate);
      }
    }
  }, {
    key: "getDate",
    value: function getDate() {
      if (!this.calendar) return;
      if (!this.multipleSelection) {
        return this.calendar.getCalendarDate(this.selectedDate);
      }
      if (this.multipleSelection) {
        return this.calendar.getCalendarDates(this.selectedDate);
      }
    }
  }, {
    key: "$onMultipleSelectionChanged",
    value: function $onMultipleSelectionChanged() {
      this.ThaiStyleSetting();
      this.setting["multipleSelect"] = this.multipleSelection;
      this.calendar && this.refreshCalendar();
    }
  }, {
    key: "$onStartDateChanged",
    value: function $onStartDateChanged() {
      this.ThaiStyleSetting();
      Reflect.deleteProperty(this.setting, "startDate");
      if (this.startDate !== "") this.setting["startDate"] = this.startDate;
      this.calendar && this.refreshCalendar();
    }
  }, {
    key: "$onEndDateChanged",
    value: function $onEndDateChanged() {
      this.ThaiStyleSetting();
      Reflect.deleteProperty(this.setting, "endDate");
      if (this.endDate !== "") this.setting["endDate"] = this.endDate;
      this.calendar && this.refreshCalendar();
    }
  }, {
    key: "refreshCalendar",
    value: function refreshCalendar() {
      this.calendar = $(this.dom).calendar(this.setting);
    }
  }, {
    key: "ThaiStyleSetting",
    value: function ThaiStyleSetting() {
      this.setting = {};
      this.setting["singleDatePicker"] = true;
      this.setting["separator"] = " - ";
      this.setting["showDropdowns"] = true;
      this.setting["multipleSelect"] = false;
      this.setting["ranges"] = {};
      this.setting["ranges"]["Today"] = [moment(), moment()];
      this.setting["locale"] = {};
      this.setting["locale"]["weekLabel"] = "W";
      this.setting["locale"]["daysOfWeek"] = ["อ.", "จ.", "อ.", "พ.", "พฤ.", "ศ.", "ส."];
      this.setting["locale"]["firstDay"] = 0;
      this.setting["locale"]["monthNames"] = ["มกราคม", "กุมภาพันธ์", "มีนาคม", "เมษายน", "พฤษภาคม", "มิถุนายน", "กรกฎาคม", "สิงหาคม", "กันยายน", "ตุลาคม", "พฤศจิกายน", "ธันวาคม "];

      if (this.startDate !== "") this.setting["startDate"] = this.startDate;
      if (this.endDate !== "") this.setting["endDate"] = this.endDate;
    }
  }]);

  return _class92;
}());
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Card",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    group: "bool"
  },
  signals: {
    clicked: [],
    dblclicked: []
  }
}, function () {
  function _class93(meta) {
    _classCallCheck(this, _class93);

    QmlWeb.callSuper(this, meta);
    this.groupChanged.connect(this, this.$onGroupChanged);

    this.suffixClassName = "card";
    this.dom.onclick = this.clicked;
    this.dom.ondblclick = this.dblclicked;
  }

  _createClass(_class93, [{
    key: "$onGroupChanged",
    value: function $onGroupChanged() {
      if (this.group) this.suffixClassName = "cards";else this.suffixClassName = "card";
    }
  }]);

  return _class93;
}());

/**
* Chart.js for plotting graph.
* More information at http://www.chartjs.org/ or http://www.chartjs.org/
* TODO.... Create destructor to free memory ( call method .destroy() on chart object).
**/

QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Chart",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    width: "int", // Width of the canvas to draw the graph, undefine width&height value to use responsive auto resize feature
    height: "int", // Height of the canvas to draw the graph, undefine width&height value to use responsive auto resize feature
    labels: "var", // Label at the xAxis of table ( on each graph ) [TYPE : Array of label]
    zoom: "boolean", // Default value of zoom feature, default is false
    datasets: { type: "var", initialValue: [] } // Contains data for each graph drawn on screen, More parameter at [[http://www.chartjs.org/docs/#line-chart-dataset-structure]]
  }
}, function () {

  /**
  * Constructor of this Chart object.
  * Params : Width, Height, Type (line, bar, radar, polarArea...)
  **/
  function _class94(meta) {
    var _this81 = this;

    _classCallCheck(this, _class94);

    QmlWeb.callSuper(this, meta);
    this.Component.completed.connect(this, this.Component$onCompleted);
    this.labelsChanged.connect(this, this.$onLabelsChanged);
    this.datasetsChanged.connect(this, this.$onDatasetsChanged);

    this.myChart = null;

    // Prepare canvas for drawing graph
    this.canvas = document.createElement("canvas");
    if (meta.object.width !== undefined) {
      this.canvas.width = meta.object.width;
      this.canvas.style.width = meta.object.width + "px";
    }

    if (meta.object.height !== undefined) {
      this.canvas.height = meta.object.height;
      this.canvas.style.height = meta.object.height + "px";
    }

    // Set initial parameters
    this.chartType = 'bar'; // Set default chart type to line in case user doesn't explicitly declare type in datasets
    this.label = meta.object.label;
    this.zoom = meta.object.zoom === undefined ? false : meta.object.zoom;
    this.chartDatasets = null;
    this.chartLabels = null;
    this.dom.appendChild(this.canvas);

    // Set up zoom controller
    this.zoomDiv = document.createElement("div");
    this.zoomDiv.classList.add("ui", "checkbox", "toggle");
    this.zoomInput = document.createElement("input");
    this.zoomInput.id = "zoomCheckBox01";
    this.zoomInput.type = "checkbox";
    this.zoomLabel = document.createElement("label");
    this.zoomLabel.innerHTML = "Zoom";
    this.zoomLabel.setAttribute("for", "zoomCheckBox01");
    this.zoomDiv.appendChild(this.zoomInput);
    this.zoomDiv.appendChild(this.zoomLabel);
    this.dom.appendChild(this.zoomDiv);
    this.zoomInput.addEventListener("change", function () {
      _this81.$onZoomToggled();
    });
  }

  _createClass(_class94, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      var _this82 = this;

      $(document).ready(function () {
        _this82.myChart = new Chart(_this82.canvas, {
          type: _this82.chartType,
          data: {
            labels: _this82.chartLabels,
            datasets: _this82.chartDatasets
          },
          options: {
            responsive: _this82.width === 0 || _this82.height === 0 ? true : false, // Auto resize ?
            beginAtZero: true, // Fix the scale to start from 0
            spanGaps: true, // To skip the missing data
            showLines: true, // Force to show the line even the data is missing
            scales: {
              xAxes: [{
                display: true,
                gridLines: {
                  display: true
                },
                labels: {
                  show: true
                },
                barThickness: 3,
                stacked: false,
                ticks: {
                  beginAtZero: false
                }
              }],
              yAxes: [{
                type: "linear",
                display: true,
                position: "left",
                gridLines: {
                  display: true
                },
                labels: {
                  show: true
                },
                stacked: false,
                ticks: {
                  beginAtZero: false
                }
              }]
            },
            pan: {
              enabled: true,
              mode: 'x',
              speed: 10,
              threshold: 10
            },
            zoom: {
              enabled: true,
              mode: 'x',
              sensitivity: 1
            }
          }
        }); // End of Chart constructor

        // Manually enable/disable zoom feature
        if (_this82.zoom !== true) {
          _this82.$disableZoom();
        }
      }); // End of document ready
    } // End of onCompleted function

  }, {
    key: "$onLabelsChanged",
    value: function $onLabelsChanged() {
      this.chartLabels = this.labels;
      if (this.myChart != null) {
        // Update the labels value of graph object
        this.myChart.data.labels = this.chartLabels;

        // Refresh chart on screen
        this.myChart.update();
      }
    }
  }, {
    key: "$onDatasetsChanged",
    value: function $onDatasetsChanged() {
      // Update the chardatasets value
      this.chartDatasets = this.datasets;

      if (this.myChart != null) {
        // Update the dataset value of graph object
        this.myChart.data.datasets = this.chartDatasets;

        // Refresh chart on screen
        this.myChart.update();
      }
    }
  }, {
    key: "$disableZoom",
    value: function $disableZoom() {
      // Prevent the chart to hi-jack mouse wheel event from page if zoom or pan is disabled
      this.myChart.ctx.canvas.removeEventListener('wheel', this.myChart.zoom._wheelHandler);
    }
  }, {
    key: "$enableZoom",
    value: function $enableZoom() {
      // Give the chart control over mouse wheel event
      this.myChart.ctx.canvas.addEventListener('wheel', this.myChart.zoom._wheelHandler);
    }
  }, {
    key: "$onZoomToggled",
    value: function $onZoomToggled() {
      if (this.zoomInput.checked) {
        this.$enableZoom();
      } else {
        this.$disableZoom();
      }
    }
  }]);

  return _class94;
}());
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "CheckBox",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    checked: "bool",
    value: "var",
    readOnly: "bool",
    text: "string",
    color: "string",
    toggleColor: "string",
    fitted: "bool",
    type: "string",
    dataValidate: "string",
    enabled: { type: "bool", initialValue: true }
  },
  signals: {
    changed: [{ name: "event", type: "var" }, { name: "value", type: "var" }, { name: "bySystem", type: "var" }]
  }
}, function () {
  function _class95(meta) {
    var _this83 = this;

    _classCallCheck(this, _class95);

    QmlWeb.callSuper(this, meta);
    this.Component.completed.connect(this, this.Component$onCompleted);
    this.checkedChanged.connect(this, this.$onCheckedChanged);
    this.valueChanged.connect(this, this.$onValueChanged);
    this.textChanged.connect(this, this.$onTextChanged);
    this.enabledChanged.connect(this, this.$onEnabledChanged);
    this.readOnlyChanged.connect(this, this.$onReadOnlyChanged);
    this.colorChanged.connect(this, this.$onColorChanged);
    this.fittedChanged.connect(this, this.$onFittedChanged);
    this.typeChanged.connect(this, this.$onTypeChanged);
    this.dataValidateChanged.connect(this, this.$onDataValidateChanged);
    this.toggleColorChanged.connect(this, this.$onToggleColorChanged);

    this.checkbox = document.createElement("input");
    this.label = document.createElement("label");
    this.checkbox.type = "checkbox";
    this.dom.appendChild(this.checkbox);
    this.dom.appendChild(this.label);
    this.suffixClassName = "checkbox";

    this.checkbox.onchange = function (event) {
      _this83.onCheckedChanged();
      _this83.changed(event, _this83.checkbox.checked, _this83.bySystem);
    };
  }

  _createClass(_class95, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      var _this84 = this;

      this.checkbox.name = this.doc_label || this.text;
      $(document).ready(function () {
        return $(_this84.dom).checkbox();
      });
    }

    //override

  }, {
    key: "$onHtmlIDChanged",
    value: function $onHtmlIDChanged() {
      this.checkbox.id = this.htmlID;
    }
  }, {
    key: "$onDataValidateChanged",
    value: function $onDataValidateChanged() {
      this.checkbox.setAttribute("data-validate", this.dataValidate);
    }
  }, {
    key: "$onCheckedChanged",
    value: function $onCheckedChanged() {
      if (!this.bySystem) {
        this.checkbox.checked = this.checked;
        this.changed(null, this.checked, this.bySystem);
      }
    }
  }, {
    key: "onCheckedChanged",
    value: function onCheckedChanged() {
      this.bySystem = true;
      this.checked = this.checkbox.checked;
      this.bySystem = false;
    }
  }, {
    key: "$onValueChanged",
    value: function $onValueChanged() {
      this.checkbox.value = this.value;
    }
  }, {
    key: "$onTextChanged",
    value: function $onTextChanged() {
      this.label.innerHTML = this.text;
    }
  }, {
    key: "$onEnabledChanged",
    value: function $onEnabledChanged() {
      this.dom.classList.remove("disabled");
      if (!this.enabled) this.dom.classList.add("disabled");
    }
  }, {
    key: "$onReadOnlyChanged",
    value: function $onReadOnlyChanged() {
      this.dom.classList.remove("read-only");
      if (this.readOnly) this.dom.classList.add("read-only");
    }
  }, {
    key: "$onColorChanged",
    value: function $onColorChanged() {
      this.label.style.color = this.color;
    }
  }, {
    key: "$onToggleColorChanged",
    value: function $onToggleColorChanged() {
      var _validateProperty7 = this.validateProperty(this.toggleColor),
          _validateProperty8 = _slicedToArray(_validateProperty7, 2),
          pass = _validateProperty8[0],
          css = _validateProperty8[1];

      if (!pass) return;
      this.dom.classList.remove("" + this._color);
      if (!css) return; // return if css is "" prevent error when call classList.add with ""
      this.dom.classList.add(css);
      this._color = this.color;
    }
  }, {
    key: "$onFittedChanged",
    value: function $onFittedChanged() {
      this.dom.classList.remove("fitted");
      if (this.fitted) this.dom.classList.add("fitted");
    }
  }, {
    key: "$onTypeChanged",
    value: function $onTypeChanged() {
      if (this._lastType) this.dom.classList.remove(this._lastType);

      this.dom.classList.add(this.type);
      this._lastType = this.type;
    }
  }, {
    key: "validateProperty",
    value: function validateProperty(prop) {
      var colorList = ["", "red", "orange", "yellow", "olive", "green", "teal", "blue", "violet", "purple", "pink", "brown", "grey", "black"];

      if (prop || prop === "") {
        // prevent error from undefined prop and allow property ""
        prop = prop.toLowerCase();
        if (colorList.includes(prop)) {
          return [true, "" + prop];
        }
      }
      return [false, ""];
    }
  }]);

  return _class95;
}());
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Column",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {}
}, function () {
  function _class96(meta) {
    _classCallCheck(this, _class96);

    QmlWeb.callSuper(this, meta);
    this.baseClassName = "ui";
    this.suffixClassName = "column";
  }

  return _class96;
}());
/**
 * ComboBox, a dropdown allows a user to select a value from a series of options
 * <pre>
 *                                   | multipleSelection | allowAdditions | Example                     |
 *   1. Select one item              | no                | no             | REG/Blood type              |
 *   2. Select multiple items        | yes               | no             | PTM/CardFoodEdit/ข้อจำกัด     |
 *   3. FreeText one item            | no                | yes            | REG/Career, เหตุผลการเปลี่ยนชื่อ | ต้องการ selected item
 *   4. FreeText multiple items      | yes               | yes            | DPO/ICD10                   |
 * </pre>
 * @overview
 */
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "ComboBox",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    /** list of dict [{id:1, name: "One"}, [{id:2, name: "Two"}] */
    items: "var",

    /** create ID blank item as first item of "items" [use with single selection only] */
    emptyItem: { type: "string", initialValue: "" },

    /** selected id, or comma separated list of ids */
    value: "string",

    /** allow usert to select multiple items */
    multipleSelection: "bool",

    /** false or maximum number of selections allowed in multi select */
    maxSelections: "int",

    /** free-text / allow user to add new value */
    allowAdditions: { type: "bool", initialValue: false },

    /** When false, user additions will appear in the results menu */
    hideAdditions: { type: "bool", initialValue: false },

    /** Get/Set Text displayed in ComboBox */
    text: "string",

    /** Allow user type to search */
    search: "bool",

    /** false/true/"exact" : control full-text search behavior */
    fullTextSearch: "var",

    /** When search=true, specify how to match values (text|value|both) */
    match: { type: "string", initialValue: "text" },

    /** Whether search selection will force currently selected choice when element is blurred. */
    forceSelection: { type: "bool", initialValue: false },

    /** currently typed text (not evaluate into 'value' yet) */
    searchText: { type: "string", initialValue: "" },

    /** items has no id, use id from 'name'/'text' instead */
    useTextValue: "bool",

    /** field in 'items' to use instead of 'name' */
    optionTextField: "string",

    /** HTML name of &lt;select&gt; or &lt;input&gt; of this ComboBox */
    inputName: "string", // HTML Input Name

    // validation and control
    /** Enable this ComboBox */
    enabled: { type: "bool", initialValue: true },

    /** Set this ComboBox read only */
    readOnly: { type: "bool", initialValue: false },

    /** Focus this combobox if set to true */
    focused: "bool",

    /** unique identifier for this form field (to use with Form validation) */
    dataValidate: "string",

    /** Look & Feel: fluid */
    fluid: "bool",

    /** Look & Feel: compact */
    compact: "bool",

    /** Look & Feel: highlight this field as error */
    error: "bool",

    /** valueList: list of string -- list of selected id for multiple selection */
    valueList: { type: "var", initialValue: [] }
  },
  signals: {
    /** Fire when user select new item */
    changed: [{ type: "string", name: "value" }, { type: "string", name: "text" }],
    /** Fire when user press keyboard */
    keyup: [{ type: "string", name: "event" }]
  }
}, function () {
  function _class97(meta) {
    _classCallCheck(this, _class97);

    QmlWeb.callSuper(this, meta);
    this.Component.completed.connect(this, this.Component$onCompleted);
    this.focusedChanged.connect(this, this.$onFocusChanged);
    this.textChanged.connect(this, this.$onTextChanged);
    this.inputNameChanged.connect(this, this.$onInputNameChanged);
    this.searchChanged.connect(this, this.$onSearchChanged);
    this.fluidChanged.connect(this, this.$onFluidChanged);
    this.allowAdditionsChanged.connect(this, this.$onAllowAdditionsChanged);
    this.multipleSelectionChanged.connect(this, this.$onMultipleSelectionChanged);
    this.enabledChanged.connect(this, this.$onEnabledChanged);
    this.readOnlyChanged.connect(this, this.$onReadOnlyChanged);
    this.maxSelectionsChanged.connect(this, this.$onMaxSelectionsChanged);
    this.compactChanged.connect(this, this.$onCompactChanged);
    this.itemsChanged.connect(this, this.$onItemsChanged);
    this.valueChanged.connect(this, this.$onValueChanged);
    this.valueListChanged.connect(this, this.$onValueListChanged);
    this.searchTextChanged.connect(this, this.$onSearchTextChanged);
    this.dataValidateChanged.connect(this, this.$onDataValidateChanged);
    this.fullTextSearchChanged.connect(this, this.$onFullTextSearchChanged);
    this.forceSelectionChanged.connect(this, this.$onForceSelectionChanged);
    this.matchChanged.connect(this, this.$onMatchChanged);
    this.hideAdditionsChanged.connect(this, this.$onHideAdditionsChanged);

    this.baseClassName = "ui";
    this.suffixClassName = "selection dropdown";
    this.input = document.createElement("input");
    this.input.type = "hidden";
    this.defaultText = document.createElement("div");
    this.defaultText.classList.add("default", "text");
    this.icon = document.createElement("i");
    this.icon.classList.add("dropdown", "icon");
    this.menu = document.createElement("div");
    this.menu.classList.add("menu");

    this.dom.appendChild(this.input);
    this.dom.appendChild(this.defaultText);
    this.dom.appendChild(this.icon);
    this.dom.appendChild(this.menu);

    this.$dropdown = $(this.dom);

    this.bySystem = false; // is this a change by system (that we want to suppress signal)
    this.dropdown_setting = {
      allowAdditions: this.allowAdditions,
      forceSelection: this.forceSelection,
      keys: {
        delimiter: false
      },
      onAdd: this.onAdd.bind(this),
      onChange: this.onChange.bind(this),
      match: this.match,
      hideAdditions: this.hideAdditions,
      message: {
        addResult: 'เพิ่ม <b>{term}</b>'
      }
    };

    this.functionList = [];
  }

  _createClass(_class97, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      var _this85 = this;

      //start semantic component
      this.$dropdown = $(this.dom);
      $(document).ready(function () {
        _this85.$dropdown.dropdown(_this85.dropdown_setting);
        _this85.$setupSearchTextListener();
        _this85.completed = true;
        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = _this85.functionList[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            func = _step6.value;

            func.bind(_this85)();
          }
        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6.return) {
              _iterator6.return();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }
      });
    }
  }, {
    key: "$updateTextProp",
    value: function $updateTextProp() {
      if (this.multipleSelection) {
        var prev = this.getText();
        if (prev.length > 0 && this.searchText.length > 0) {
          // comma separate only if has two value
          this.text = prev + ',' + this.searchText;
        } else {
          this.text = prev + this.searchText;
        }
      } else {
        if (this.searchText === '') {
          // Clear text in case emptyItem(had default text) is set
          if (this.value === '') {
            this.text = '';
          }
          // selected some text
          else {
              this.text = this.defaultText.innerHTML;
            }
        } else {
          this.text = this.searchText;
        }
      }
    }
  }, {
    key: "$setupSearchTextListener",
    value: function $setupSearchTextListener() {
      var _this86 = this;

      if (this.search) {
        this.$searchInput = this.$dropdown.find('input.search');
        this.$searchInput.off('keyup');
        this.$searchInput.on('keyup', function (event) {
          _this86.bySystem = true;
          _this86.searchText = _this86.$searchInput.val();
          _this86.$updateTextProp();
          _this86.keyup(event);
          _this86.bySystem = false;
        });
      }
    }

    //override

  }, {
    key: "$onHtmlIDChanged",
    value: function $onHtmlIDChanged() {
      this.input.id = this.htmlID;
    }
  }, {
    key: "$onValueChanged",
    value: function $onValueChanged() {
      if (this.bySystem) return;

      if (!this.completed) {
        this.functionList.push(this.$onValueChanged);
        return;
      }

      if (!this.value) {
        this.clear();
      } else {
        this.setSelected(this.value.split(","));
      }
    }
  }, {
    key: "$onValueListChanged",
    value: function $onValueListChanged() {
      if (this.bySystem) return;
      // convert list of int to list of string
      this.setSelected(this.valueList.map(function (x) {
        return x.toString();
      }));
    }
  }, {
    key: "$onSearchTextChanged",
    value: function $onSearchTextChanged() {
      if (this.bySystem) return;

      if (!this.completed) {
        this.functionList.push(this.$onSearchTextChanged);
        return;
      }

      if (this.search) {
        this.$searchInput.val(this.searchText);
      }
    }
  }, {
    key: "$onDataValidateChanged",
    value: function $onDataValidateChanged() {
      this.input.setAttribute("data-validate", this.dataValidate);
    }
  }, {
    key: "$onFocusChanged",
    value: function $onFocusChanged() {
      if (this.focused) this.setFocus();
    }
  }, {
    key: "$onTextChanged",
    value: function $onTextChanged() {
      if (this.bySystem) return;

      this.value = this.text;
    }
  }, {
    key: "$onInputNameChanged",
    value: function $onInputNameChanged() {
      this.input.name = this.inputName;
    }
  }, {
    key: "$onSearchChanged",
    value: function $onSearchChanged() {
      this.dom.classList.remove("search");
      if (this.search) this.dom.classList.add("search");
      this.$dropdown && this.$dropdown.dropdown(this.dropdown_setting);
      if (this.search) {
        this.$setupSearchTextListener();
      }
    }
  }, {
    key: "$onFluidChanged",
    value: function $onFluidChanged() {
      this.dom.classList.remove("fluid");
      if (this.fluid) this.dom.classList.add("fluid");
    }
  }, {
    key: "$onMultipleSelectionChanged",
    value: function $onMultipleSelectionChanged() {
      this.dom.classList.remove("multiple");
      if (this.multipleSelection) this.dom.classList.add("multiple");
    }
  }, {
    key: "$onEnabledChanged",
    value: function $onEnabledChanged() {
      this.dom.classList.remove("disabled");
      if (!this.enabled) this.dom.classList.add("disabled");
    }
  }, {
    key: "$onReadOnlyChanged",
    value: function $onReadOnlyChanged() {
      if (!this.completed) {
        this.functionList.push(this.$onReadOnlyChanged);
        return;
      }

      this.dom.style.pointerEvents = 'auto';
      if (this.readOnly) {
        this.$dropdown.dropdown('hide');
        this.dom.style.pointerEvents = 'none';
      }
    }
  }, {
    key: "$onCompactChanged",
    value: function $onCompactChanged() {
      this.dom.classList.remove("compact");
      if (this.compact) this.dom.classList.add("compact");
    }
  }, {
    key: "$onMaxSelectionsChanged",
    value: function $onMaxSelectionsChanged() {
      this.dropdown_setting.maxSelections = this.maxSelections;
      this.$dropdown && this.$dropdown.dropdown('setting', 'maxSelections', this.maxSelections);
    }
  }, {
    key: "$onAllowAdditionsChanged",
    value: function $onAllowAdditionsChanged() {
      this.dropdown_setting.allowAdditions = this.allowAdditions;
      this.$dropdown && this.$dropdown.dropdown('setting', 'allowAdditions', this.allowAdditions);
    }
  }, {
    key: "$onHideAdditionsChanged",
    value: function $onHideAdditionsChanged() {
      this.dropdown_setting.hideAdditions = this.hideAdditions;
      this.$dropdown && this.$dropdown.dropdown('setting', 'hideAdditions', this.hideAdditions);
    }
  }, {
    key: "$onFullTextSearchChanged",
    value: function $onFullTextSearchChanged() {
      this.dropdown_setting.fullTextSearch = this.fullTextSearch;
      this.$dropdown && this.$dropdown.dropdown('setting', 'fullTextSearch', this.fullTextSearch);
    }
  }, {
    key: "$onForceSelectionChanged",
    value: function $onForceSelectionChanged() {
      this.dropdown_setting.forceSelection = this.forceSelection;
      this.$dropdown && this.$dropdown.dropdown('setting', 'forceSelection', this.forceSelection);
    }
  }, {
    key: "$onMatchChanged",
    value: function $onMatchChanged() {
      this.dropdown_setting.match = this.match;
      this.$dropdown && this.$dropdown.dropdown('setting', 'match', this.match);
    }
  }, {
    key: "$onItemsChanged",
    value: function $onItemsChanged() {
      this.menu.innerHTML = "";
      var foundValueInItems = false;
      if (!this.items) return;
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = this.items[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var item = _step7.value;

          if (item.id == this.value) {
            foundValueInItems = true;
            break;
          }
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }

      if (!foundValueInItems) {
        this.$dropdown && this.clear();
      }
      this.addItems(this.items);
    }
  }, {
    key: "onAdd",
    value: function onAdd(addedValue, addedText, $addedChoice) {
      if ($addedChoice[0].classList.contains("addition")) {
        $(this.dom).dropdown("remove visible");
      }
    }
  }, {
    key: "onChange",
    value: function onChange(value, text, $choice) {
      this.bySystem = true;

      // Clear when set value blank
      if (value === "") {
        this.clear();
      }

      if (this.$searchInput) {
        this.searchText = this.$searchInput.val();
      }
      this.value = this.getValue();
      if (this.value.length == 0) {
        this.valueList = [];
      } else {
        this.valueList = this.value.split(',');
      }
      this.$updateTextProp();
      this.bySystem = false;

      //fire change signal
      this.changed(value, text);

      if (this.dom.classList.contains("multiple")) return;
      if ($choice && $choice[0].classList.contains("addition")) {
        $(this.dom).dropdown("remove visible");
      }
    }
  }, {
    key: "setFocus",
    value: function setFocus() {
      var _this87 = this;

      requestAnimationFrame(function () {
        return _this87.dom.focus();
      });
    }
  }, {
    key: "getValue",
    value: function getValue() {
      return this.$dropdown.dropdown("get value");
    }

    /** Clear selection (preserve items) */

  }, {
    key: "clear",
    value: function clear() {
      this.value = '';
      this.searchText = '';
      this.$dropdown && this.$dropdown.dropdown("clear");
    }

    /** Set value as seleced
     * @param {string} value - 'id' of item to select or comma-separated list of id
     */

  }, {
    key: "setSelected",
    value: function setSelected(value) {
      if (this.multipleSelection) {
        this.$dropdown.dropdown("set exactly", value);
      } else {
        this.$dropdown.dropdown("set selected", value);
      }
    }

    /** Get selected index
     * 
     * Useable with non multipleSelection only
     * @return {int}
     */

  }, {
    key: "getIndex",
    value: function getIndex() {
      if (this.multipleSelection) throw new Error("Not support with multipleSelection");

      var value = this.getValue();
      var returnValue = -1;
      for (var i = 0; i < this.items.length; i++) {
        if (this.useTextValue && value == this.items[i].name) {
          // if useTextValue == true : get index by name
          returnValue = i;
          break;
        } else if (value == this.items[i].id) {
          // if useTextValue == false : get index by id
          returnValue = i;
          break;
        }
      }
      return returnValue;
    }

    /** Get list of selected index
     * 
     * Useable with multipleSelection only
     * @return {Array}
     */

  }, {
    key: "getIndexList",
    value: function getIndexList() {
      if (!this.multipleSelection) throw new Error("Only support with multipleSelection");

      var selected = this.getValue().split(",");
      var returnValue = [];
      for (var i = 0; i < this.items.length; i++) {
        if (this.useTextValue && selected.includes(this.items[i].name)) {
          // if useTextValue == true : get index by name
          returnValue.push(i);
        } else if (selected.includes("" + this.items[i].id)) {
          // if useTextValue == false : get index by id
          returnValue.push(i);
        }
      }
      return returnValue;
    }

    /**
     * Get text displayed in ComboBox
     * 
     * (including allow addition)
     * @return {string} text displayed in ComboBox (for multipleSelection, return comma-separated text)
     */

  }, {
    key: "getText",
    value: function getText() {
      var values = this.$dropdown.dropdown("get value");
      var result = [];
      if (values) {
        var _iteratorNormalCompletion8 = true;
        var _didIteratorError8 = false;
        var _iteratorError8 = undefined;

        try {
          for (var _iterator8 = values.split(",")[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var value = _step8.value;

            var text = this.$dropdown.dropdown("get item", value);
            if (text && text.length > 0) {
              if (text[0].classList.contains("addition")) {
                // addition case: use 'value' instead (innerText = เพิ่ม value)
                result.push(value);
              } else {
                // item was listed in items
                result.push(text[0].innerText);
              }
            } else {
              // addition case
              result.push(value);
            }
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
      }
      return result.join(",");
    }
  }, {
    key: "addItems",
    value: function addItems(items) {
      var _this88 = this;

      // Append blank item to be first item of this.menu
      if (this.emptyItem !== "") {
        if (this.multipleSelection) throw new Error("Not support with multipleSelection");

        // Set default text when emptyItem set
        this.defaultText.innerHTML = this.emptyItem;

        this.menu.appendChild($("<div>", {
          class: "item",
          text: this.emptyItem,
          "data-value": ""
        })[0]);
      }

      // Append item to this.menu
      items.forEach(function (item, i) {
        var classList = item.disabled ? "disabled item" : "item";
        if (_this88.optionTextField) {
          item.name = item[_this88.optionTextField];
        }
        var item_id;
        if (_this88.useTextValue) {
          item_id = item.name || item.text;
        } else {
          item_id = item.id;
        }
        _this88.menu.appendChild($("<div>", {
          class: classList,
          text: item.name || item.text,
          "data-value": item_id
        })[0]);
      }, this);

      //re-initialize dropdown after add new items
      this.$dropdown.dropdown(this.dropdown_setting);
      this.$onValueChanged();
    }
  }, {
    key: "getSelected",
    value: function getSelected() {
      return this.items[this.getIndex()];
    }
  }]);

  return _class97;
}());

QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Container",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {},
  signals: {
    hovered: []
  }
}, function () {
  function _class98(meta) {
    _classCallCheck(this, _class98);

    QmlWeb.callSuper(this, meta);
    this.baseClassName = "ui container";

    this.dom.addEventListener('mouseover', this.hovered);
  }

  return _class98;
}());

QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "CSS",
  versions: /.*/,
  baseClass: "Item",
  properties: {
    url: "string", // ex. /TPD/test.css
    media: { type: "string", initialValue: 'all' }
  }
}, function () {
  function _class99(meta) {
    _classCallCheck(this, _class99);

    QmlWeb.callSuper(this, meta);
    this.Component.completed.connect(this, this.Component$onCompleted);
  }

  _createClass(_class99, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      var hashCode = this.b64EncodeUnicode(this.url);
      if (this.url.charAt(0) === '/') {
        this.url = this.url.substring(1);
      }
      if (!document.getElementById(hashCode) && this.url) {
        var head = document.getElementsByTagName('head')[0];
        var link = document.createElement('link');
        link.id = hashCode;
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '/static/qml/' + this.url;
        link.media = this.media;
        head.appendChild(link);
      }
    }
  }, {
    key: "b64EncodeUnicode",
    value: function b64EncodeUnicode(str) {
      return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function (match, p1) {
        return String.fromCharCode('0x' + p1);
      }));
    }
  }]);

  return _class99;
}());
// DateTextBox.size = [
//     "mini",
//     "small",
//     "large",
//     "big",
//     "huge",
//     "massive"
// ];

QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "DateTextBox",
  versions: /.*/,
  baseClass: "Semantic.Html.TextBox",
  properties: {
    buttons: "var",
    thai: "bool",
    startDate: { type: "string", initialValue: "" },
    endDate: { type: "string", initialValue: "" },
    future: { type: "bool", initialValue: true },
    firstDayOfWeek: { type: "int", initialValue: 0 },
    //if this property is set
    //the DateTextBox will set its position relative to this property
    boundary: "var",
    //TODO check why these props is not inherited from baseItem
    doc_label: "string",
    doc_mandatory: "bool",
    doc_auto_input: "bool",
    doc_condition: "string",
    doc_remark: "string"
  },
  signals: {
    changed: [{ type: "string", name: "value" }]
  }
}, function () {
  function DateTextBox(meta) {
    var _this89 = this;

    _classCallCheck(this, DateTextBox);

    var icon = document.createElement("i");
    QmlWeb.callSuper(this, meta);

    this.Component.completed.connect(this, this.Component$onCompleted);
    this.buttonsChanged.connect(this, this.$onButtonsChanged);
    this.thaiChanged.connect(this, this.$onThaiChanged);
    this.startDateChanged.connect(this, this.$onStartDateChanged);
    this.endDateChanged.connect(this, this.$onEndDateChanged);
    this.boundaryChanged.connect(this, this.$onBoundaryChanged);
    this.futureChanged.connect(this, this.$onFutureChanged);

    this.singleMode = true;
    this.thai = true;

    this.addClass("icon");
    icon.classList.add("calendar", "icon");
    this.dom.appendChild(icon);

    $(this.input).on("dateChange", function (evt, val) {
      _this89.bySystem = true;
      _this89.text = val;
      _this89.bySystem = false;
      _this89.changed(val);
    });

    $(this.input).on("blur", function (evt) {
      if (_this89.error) _this89.text = "";
    });

    $(this.input).on("keydown", function (evt) {
      if (_this89.error && evt.keyCode === 13) _this89.text = "";
    });

    // if year < moment A.D. year, it will auto convert A.D. -> B.E.
    $(this.input).on("keyup", function (evt) {
      var datePattern = /^\d{1,2}\/\d{1,2}\/\d{4}$/;

      var _input$value$split = _this89.input.value.split("/"),
          _input$value$split2 = _slicedToArray(_input$value$split, 3),
          day = _input$value$split2[0],
          month = _input$value$split2[1],
          year = _input$value$split2[2];

      if (Number(year) <= Number(moment().format('YYYY'))) {
        year = Number(year) + 543;
        var date = day + "/" + month + "/" + year;
        if (datePattern.test(date)) {
          _this89.text = date;
        }
      }
    });
  }

  _createClass(DateTextBox, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      var _this90 = this;

      $(document).ready(function () {
        _this90.refreshCalendar();
        _this90.datePicker.data('daterangepicker').updateDateText();
      });
    }
  }, {
    key: "toDashFormat",
    value: function toDashFormat() {
      if (this.input.value === "") return "";

      var _input$value$split3 = this.input.value.split("/"),
          _input$value$split4 = _slicedToArray(_input$value$split3, 3),
          day = _input$value$split4[0],
          month = _input$value$split4[1],
          year = _input$value$split4[2];

      return year + "-" + month + "-" + day;
    }
  }, {
    key: "toSlashFormat",
    value: function toSlashFormat() {
      if (this.input.value === "") return "";

      var _input$value$split5 = this.input.value.split("-"),
          _input$value$split6 = _slicedToArray(_input$value$split5, 3),
          day = _input$value$split6[0],
          month = _input$value$split6[1],
          year = _input$value$split6[2];

      return day + "/" + month + "/" + year;
    }
  }, {
    key: "$onBoundaryChanged",
    value: function $onBoundaryChanged() {
      this.thai ? this.ThaiStyleSetting() : this.EnglishStyleSetting();
      if (this.boundary && this.boundary.dom) this.setting["parentEl"] = this.boundary.dom;
      if (this.boundary && typeof this.boundary === "string") this.setting["parentEl"] = this.boundary;
      this.datePicker && this.refreshCalendar();
    }
  }, {
    key: "$onThaiChanged",
    value: function $onThaiChanged() {
      this.thai ? this.ThaiStyleSetting() : this.EnglishStyleSetting();
      this.datePicker && this.refreshCalendar();
    }
  }, {
    key: "$onStartDateChanged",
    value: function $onStartDateChanged() {
      this.thai ? this.ThaiStyleSetting() : this.EnglishStyleSetting();
      Reflect.deleteProperty(this.setting, "startDate");
      if (this.startDate !== "") this.setting["startDate"] = this.startDate;
      this.datePicker && this.refreshCalendar();
    }
  }, {
    key: "$onEndDateChanged",
    value: function $onEndDateChanged() {
      this.thai ? this.ThaiStyleSetting() : this.EnglishStyleSetting();
      Reflect.deleteProperty(this.setting, "endDate");
      if (this.endDate !== "") this.setting["endDate"] = this.endDate;
      this.datePicker && this.refreshCalendar();
    }
  }, {
    key: "$onFutureChanged",
    value: function $onFutureChanged() {
      this.thai ? this.ThaiStyleSetting() : this.EnglishStyleSetting();
      Reflect.deleteProperty(this.setting, "maxDate");
      if (!this.future) this.setting["maxDate"] = moment();
      this.datePicker && this.refreshCalendar();
    }
  }, {
    key: "$onButtonsChanged",
    value: function $onButtonsChanged() {
      var _this91 = this;

      this.thai ? this.ThaiStyleSetting() : this.EnglishStyleSetting();

      if (this.buttons.length > 0) this.setting["ranges"] = {};

      this.buttons.forEach(function (button) {
        if (typeof button.date === "number") {
          var date = moment();

          if (_this91.thai) {
            date.add(button.date, 'day');
            var year = date.year() + 543,
                month = date.month() + 1,
                day = date.date();
            date = day + "/" + month + "/" + year;
          }

          if (!_this91.thai) {
            date.add(button.date, 'day');
          }

          _this91.setting["ranges"][button.text] = [date, date];
        }
      });

      this.datePicker && this.refreshCalendar();
    }
  }, {
    key: "$onTextChanged",
    value: function $onTextChanged() {
      if (this.bySystem) return;

      if (this.text === null) {
        // DjangoRestFramework allow date to be null (we translate to "")
        this.bySystem = true;
        this.text = "";
        this.bySystem = false;
      }

      this.input.value = this.text;
      this.datePicker && this.datePicker.data('daterangepicker').updateDateText();
      this.refreshCalendar();
    }
  }, {
    key: "notValidDate",
    value: function notValidDate() {
      this.error = this.text.length === 0 ? false : true;
    }
  }, {
    key: "validDate",
    value: function validDate() {
      this.error = false;
    }
  }, {
    key: "refreshCalendar",
    value: function refreshCalendar() {
      this.datePicker = $(this.input).daterangepicker(this.setting, null, this.validDate.bind(this), this.notValidDate.bind(this));
    }
  }, {
    key: "setToday",
    value: function setToday() {
      var date = moment();
      var year = date.year() + 543,
          month = date.month() + 1,
          day = date.date();

      date = day + "/" + month + "/" + year;
      var today = this.thai ? date : moment().format('DD/MM/YYYY');
      this.text = today;
    }
  }, {
    key: "ThaiStyleSetting",
    value: function ThaiStyleSetting() {
      this.setting = {};
      this.setting["singleDatePicker"] = this.singleMode ? true : false;
      this.setting["singleModeRange"] = this.singleMode ? true : false;
      this.setting["thai"] = this.thai ? true : false;
      this.setting["separator"] = " - ";
      this.setting["showDropdowns"] = true;
      this.setting["locale"] = {};
      this.setting["locale"]["applyLabel"] = "ยืนยัน";
      this.setting["locale"]["cancelLabel"] = "ยกเลิก";
      this.setting["locale"]["fromLabel"] = "จาก";
      this.setting["locale"]["toLabel"] = "ถึง";
      this.setting["locale"]["customRangeLabel"] = "เพิ่มเติม";
      this.setting["locale"]["weekLabel"] = "W";
      this.setting["locale"]["daysOfWeek"] = ["อ.", "จ.", "อ.", "พ.", "พฤ.", "ศ.", "ส."];
      this.setting["locale"]["firstDay"] = 0;
      this.setting["locale"]["monthNames"] = ["มกราคม", "กุมภาพันธ์", "มีนาคม", "เมษายน", "พฤษภาคม", "มิถุนายน", "กรกฎาคม", "สิงหาคม", "กันยายน", "ตุลาคม", "พฤศจิกายน", "ธันวาคม "];

      if (this.startDate !== "") this.setting["startDate"] = this.startDate;
      if (this.endDate !== "") this.setting["endDate"] = this.endDate;
    }
  }, {
    key: "EnglishStyleSetting",
    value: function EnglishStyleSetting() {
      this.setting = {};
      this.setting["singleDatePicker"] = this.singleMode ? true : false;
      this.setting["singleModeRange"] = this.singleMode ? true : false;
      this.setting["thai"] = this.thai ? true : false;
      this.setting["separator"] = " - ";
      this.setting["showDropdowns"] = true;
      if (this.startDate !== "") this.setting["startDate"] = this.startDate;
      if (this.endDate !== "") this.setting["endDate"] = this.endDate;
    }
  }]);

  return DateTextBox;
}());
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Dimmer",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    active: "bool"
  },
  signals: {}
}, function () {
  function _class100(meta) {
    _classCallCheck(this, _class100);

    QmlWeb.callSuper(this, meta);
    this.activeChanged.connect(this, this.$onActiveChanged);
    this.Component.completed.connect(this, this.Component$onCompleted);

    this.suffixClassName = "dimmer";
  }

  _createClass(_class100, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      this.completed = true;
      this.$onActiveChanged();
    }
  }, {
    key: "$onActiveChanged",
    value: function $onActiveChanged() {
      if (!this.completed) return;

      if (!this.active) {
        this.removeClass("active");
        this.parent.dom.removeEventListener('keydown', this.onKeyup.bind(this), true);
      } else {
        this.addClass("active");
        this.parent.dom.addEventListener('keydown', this.onKeyup.bind(this), true);
      }
    }
  }, {
    key: "onKeyup",
    value: function onKeyup(event) {

      if (this.active) {
        event.stopImmediatePropagation();
        event.preventDefault();
      }
    }
  }]);

  return _class100;
}());

QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Divider",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    text: "string"
  }
}, function () {
  function _class101(meta) {
    _classCallCheck(this, _class101);

    QmlWeb.callSuper(this, meta);
    this.textChanged.connect(this, this.$onTextChanged);
    this.baseClassName = "ui";
    this.suffixClassName = "divider";
  }

  _createClass(_class101, [{
    key: "$onTextChanged",
    value: function $onTextChanged() {
      if (this.text !== "" && !this.dom.classList.contains("horizontal")) this.dom.classList.add("horizontal");
      this.dom.innerHTML = this.text;
    }
  }]);

  return _class101;
}());
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Dom",
  versions: /.*/,
  baseClass: "QtQml.QtObject",
  properties: {
    $opacity: { type: "real", initialValue: 1 },
    parent: "Item",
    htmlID: "string",
    htmlAttr: "var",
    data: "list",
    children: "list",
    resources: "list",
    visible: { type: "bool", initialValue: true },
    displayNone: { type: "bool", initialValue: false },
    tagName: { type: "string", initialValue: "div" },
    baseClassName: { type: "string", initialValue: "ui" },
    suffixClassName: { type: "string", initialValue: "" },
    className: { type: "string", initialValue: "" },
    customClass: { type: "string", initialValue: "" },
    text: { type: "string", initialValue: "" },
    style: { type: "var", initialValue: null },

    // property for ui2doc
    doc_label: "string",
    doc_mandatory: "bool",
    doc_auto_input: "bool",
    doc_condition: "string",
    doc_remark: "string",
    doc_read_only: "bool",
    doc_skip: "var", // "me", "all", "child"
    doc_type: "string"
  },
  defaultProperty: "data"
}, function () {
  function _class102(meta) {
    _classCallCheck(this, _class102);

    QmlWeb.callSuper(this, meta);

    this.baseClassNameChanged.connect(this, this.$onClassNameChanged);
    this.suffixClassNameChanged.connect(this, this.$onClassNameChanged);
    this.classNameChanged.connect(this, this.$onClassNameChanged);
    this.customClassChanged.connect(this, this.$onClassNameChanged);
    this._qmlClass = '';

    this.parentChanged.connect(this, this.$onParentChanged_);
    this.dataChanged.connect(this, this.$onDataChanged);
    this.textChanged.connect(this, this.$onTextChanged);
    this.styleChanged.connect(this, this.$onStyleChanged);
    this.htmlIDChanged.connect(this, this.$onHtmlIDChanged);
    this.htmlAttrChanged.connect(this, this.$onHtmlAttrChanged);
    this.visibleChanged.connect(this, this.$onVisibleChanged);
    this.displayNoneChanged.connect(this, this.$onDisplayNoneChanged);

    if (!this.dom) {
      // Create a dom element for this item.
      var tagName = meta.object.tagName || "div";
      var node = document.createElement(tagName);
      this.dom = node;
    }
    // TODO: support properties, styles, perhaps changing the tagName
  }

  _createClass(_class102, [{
    key: "destructor",
    value: function destructor() {
      this.dom = null;
    }
  }, {
    key: "$onClassNameChanged",
    value: function $onClassNameChanged() {
      var classList = [];
      classList.push(this.baseClassName);
      classList.push(this.className);
      classList.push(this.suffixClassName);
      classList.push(this.customClass);
      classList.push(this._qmlClass);

      classList = classList.join(" ").trim();
      this.dom.className = classList.replace(/  +/g, ' ');
    }
  }, {
    key: "$onTextChanged",
    value: function $onTextChanged() {
      this.dom.innerHTML = this.text;
    }
  }, {
    key: "$onStyleChanged",
    value: function $onStyleChanged() {
      if (typeof this.style === "string") this.dom.style = this.style;
      if (_typeof(this.style) === "object") $(this.dom).css(this.style);
    }
  }, {
    key: "$onHtmlIDChanged",
    value: function $onHtmlIDChanged() {
      this.dom.id = this.htmlID;
    }
  }, {
    key: "$onHtmlAttrChanged",
    value: function $onHtmlAttrChanged() {
      var newVal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      $(this.dom).attr(newVal);
    }
  }, {
    key: "$onVisibleChanged",
    value: function $onVisibleChanged() {
      if (this.visible) this.dom.style.visibility = "visible";else this.dom.style.visibility = "hidden";
    }
  }, {
    key: "$onDisplayNoneChanged",
    value: function $onDisplayNoneChanged() {
      if (typeof this.displayNoneCallBack === 'function') {
        this.displayNoneCallBack();
      } else {
        if (this.displayNone) this.dom.style.display = "none";else this.dom.style.display = "";
      }
    }
  }, {
    key: "$onParentChanged_",
    value: function $onParentChanged_(newParent, oldParent, propName) {
      if (oldParent) {
        oldParent.children.splice(oldParent.children.indexOf(this), 1);
        oldParent.childrenChanged();

        //Workaround for removing node error in DCustomColumn
        var hasParentNode = this.dom.parentNode !== null;
        var sameParentNode = hasParentNode && this.dom.parentNode.isSameNode(oldParent.dom);

        if (hasParentNode && sameParentNode) {
          oldParent.dom.removeChild(this.dom);
        }
        if (hasParentNode && !sameParentNode) {
          this.dom.parentNode.removeChild(this.dom);
        }
      }
      if (newParent && newParent.children.indexOf(this) === -1) {
        newParent.children.push(this);
        newParent.childrenChanged();
      }
      if (newParent) {
        //set repeater's items position
        if (this._placeAfter === "first") {
          newParent.dom.insertAdjacentElement("afterbegin", this.dom);
        } else if (this._placeAfter) {
          $(this.dom).insertAfter(this._placeAfter);
        } else {
          newParent.dom.appendChild(this.dom);
        }
      } else {
        this.destructor();
      }
    }
  }, {
    key: "addClass",
    value: function addClass(str) {
      this.customClass += " " + str;
    }
  }, {
    key: "removeClass",
    value: function removeClass(str) {
      var classList = this.className.split(" ");
      classList = classList.filter(function (item) {
        return item !== str ? item : null;
      });
      this.className = classList.join(" ");
      classList = this.customClass.split(" ");
      classList = classList.filter(function (item) {
        return item !== str ? item : null;
      });
      this.customClass = classList.join(" ");
    }
  }, {
    key: "navigate",
    value: function navigate() {
      // Naviate to this dom
      //this.dom.scrollIntoView({block: 'start',  behaviour: 'smooth'});
      // Chrome still not support parameter on scrollIntoView function
      this.dom.scrollIntoView({ behaviour: 'smooth' });
    }
  }, {
    key: "$onDataChanged",
    value: function $onDataChanged(newData) {
      var HtmlDom = QmlWeb.getConstructor("Semantic.Html", "1.0", "Dom");
      for (var i in newData) {
        var child = newData[i];
        if (child instanceof HtmlDom) {
          child.parent = this; // This will also add it to children.
        } else {
          this.resources.push(child);
        }
      }
    }
  }, {
    key: "transition",
    value: function transition(value) {
      $(this.dom).transition(value);
    }
  }]);

  return _class102;
}()); // End of semantic


QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Field",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    label: { type: "string", initialValue: "&nbsp;" },
    labelColor: "string",
    labelAlign: "string",
    skipInline: { type: "bool", initialValue: false },
    enabled: { type: "bool", initialValue: true },
    error: { type: "bool", initialValue: false }
  },
  signals: {
    clicked: []
  }
}, function () {
  function _class103(meta) {
    var _this92 = this;

    _classCallCheck(this, _class103);

    QmlWeb.callSuper(this, meta);
    this.Component.completed.connect(this, this.Component$onCompleted);
    this.baseClassName = "";
    this.suffixClassName = "field";
    this.labelChanged.connect(this, this.$onLabelChanged);
    this.labelColorChanged.connect(this, this.$onLabelColorChanged);
    this.labelAlignChanged.connect(this, this.$onLabelAlignChanged);
    this.enabledChanged.connect(this, this.$onEnabledChanged);
    this.errorChanged.connect(this, this.$onErrorChanged);
    this.$onLabelChanged();

    this.dom.onclick = function () {
      _this92.clicked();
    };
  }

  _createClass(_class103, [{
    key: "$onLabelChanged",
    value: function $onLabelChanged() {
      if (!this.labelNode) {
        this.labelNode = document.createElement("label");
        this.dom.insertBefore(this.labelNode, this.dom.firstChild);
      }
      this.labelNode.innerHTML = this.label;
    }
  }, {
    key: "$onLabelColorChanged",
    value: function $onLabelColorChanged() {
      this.labelNode.style.color = this.labelColor;
    }
  }, {
    key: "$onLabelAlignChanged",
    value: function $onLabelAlignChanged() {
      if (this.labelAlign) {
        this.labelNode.style.width = "100%";
      } else {
        this.labelNode.style.width = "";
      }

      this.labelNode.style.textAlign = this.labelAlign;
    }
  }, {
    key: "$onEnabledChanged",
    value: function $onEnabledChanged() {
      this.removeClass("disabled");
      if (!this.enabled) this.addClass("disabled");
    }
  }, {
    key: "$onErrorChanged",
    value: function $onErrorChanged() {
      this.removeClass("error");
      if (this.error) this.addClass("error");
    }
  }, {
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      var isInline = this.dom.classList.contains("inline") || this.parent && this.parent.dom.classList.contains("inline");
      var containsNBSP = this.label === "&nbsp;";
      var hasChildLabel = this.labelNode.parentNode && this.labelNode.parentNode.isSameNode(this.dom);

      if (isInline && containsNBSP && hasChildLabel) {
        this.dom.removeChild(this.labelNode);
      }
    }
  }]);

  return _class103;
}());
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Fields",
  versions: /.*/,
  baseClass: "Semantic.Html.Field", // inherited from Field
  properties: {
    skipInline: { type: "bool", initialValue: false }
  }
}, function () {
  function _class104(meta) {
    _classCallCheck(this, _class104);

    QmlWeb.callSuper(this, meta);
    this.baseClassName = "";
    this.suffixClassName = "fields";
  }

  return _class104;
}());
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Form",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    inline: "bool",
    inlineWidth: "int",
    textAlign: "string",
    validateSetting: "var",
    preventSubmit: { type: 'bool', initialValue: false // this will prevent validation as well
    } },
  signals: {
    valid: [],
    invalid: [],
    success: [{ type: "var", name: "event" }, { type: "var", name: "fields" }],
    failure: [{ type: "var", name: "formErrors" }, { type: "var", name: "fields" }]
  }
}, function () {
  function _class105(meta) {
    _classCallCheck(this, _class105);

    QmlWeb.callSuper(this, meta);
    this.Component.completed.connect(this, this.Component$onCompleted);
    this.validateSettingChanged.connect(this, this.$onValidateSettingChanged);
    this.suffixClassName = "form";
    this.setting = {
      onValid: this._onValid.bind(this),
      onInvalid: this._onInvalid.bind(this),
      onSuccess: this._onSuccess.bind(this),
      onFailure: this._onFailure.bind(this)
    };

    this.validateSetting = {};
    $(this.dom).submit(this.preventSubmitEvent.bind(this));

    // Define new rules
    $(this.dom).form.settings.rules.greaterThan = function (inputValue, validationValue) {
      return inputValue > validationValue;
    };

    $(this.dom).form.settings.rules.drugDurationRule = function (inputValue) {
      /**
      * Special rule for drug duration. It needs to be allow empty and check for number
      * Usually semantics UI use "Optional-fields" (https://semantic-ui.com/behaviors/form.html#optional-fields)
      * But we still have no idea how to put optional: true parameters into the field.
      **/
      if (inputValue === '') {
        // This rule ignore empty value
        return true;
      } else if (!/^\+?(0|[1-9]\d*)$/.test(inputValue)) {
        // This is not normal integer
        return false;
      } else {
        return inputValue > 0;
      }
    };
  }

  _createClass(_class105, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      var child_fields = this.$findChildField(this.children);
      this.$applyLabelInline(child_fields);
      $(this.dom).form(this.setting);
    }
  }, {
    key: "_onValid",
    value: function _onValid() {
      this.valid();
    }
  }, {
    key: "_onInvalid",
    value: function _onInvalid() {
      this.invalid();
    }
  }, {
    key: "_onSuccess",
    value: function _onSuccess(event, fields) {
      this.success.apply(this, arguments);
    }
  }, {
    key: "_onFailure",
    value: function _onFailure(formErrors, fields) {
      this.failure.apply(this, arguments);
    }
  }, {
    key: "$onValidateSettingChanged",
    value: function $onValidateSettingChanged() {
      Object.assign(this.setting, this.validateSetting);
      $(this.dom).form(this.setting);
    }
  }, {
    key: "preventSubmitEvent",
    value: function preventSubmitEvent(event) {
      if (this.preventSubmit) {
        event.preventDefault();
        event.stopImmediatePropagation // to prevent validation
        ();
      }
    }
  }, {
    key: "$findChildField",
    value: function $findChildField(children) {
      return children.filter(function (child) {
        return child.dom.classList.contains("field") || child.dom.classList.contains("fields");
      });
    }
  }, {
    key: "$applyLabelInline",
    value: function $applyLabelInline(fields) {
      if (this.inline) {
        var _iteratorNormalCompletion9 = true;
        var _didIteratorError9 = false;
        var _iteratorError9 = undefined;

        try {
          for (var _iterator9 = fields[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
            var f = _step9.value;

            if (f.skipInline) {
              continue;
            } else {
              f.dom.classList.add("inline");
            }

            var label = $(f.dom).find("label");

            if (this.inlineWidth && f.dom.classList.contains("inline") && label && label[0].innerHTML != "&nbsp;") {
              label[0].style.width = this.inlineWidth + "px";
              label[0].style.textAlign = this.textAlign;
            }

            this.$applyLabelInline(this.$findChildField(f.children));
          }
        } catch (err) {
          _didIteratorError9 = true;
          _iteratorError9 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion9 && _iterator9.return) {
              _iterator9.return();
            }
          } finally {
            if (_didIteratorError9) {
              throw _iteratorError9;
            }
          }
        }
      }
    }

    //**************************** public method *******************************

    // Returns true/false whether a form passes its validation rules

  }, {
    key: "isValid",
    value: function isValid() {
      return $(this.dom).form('is valid');
    }

    // Validates form and calls onSuccess or onFailure

  }, {
    key: "validateForm",
    value: function validateForm() {
      var result = $(this.dom).form('validate form');
      if (result.hasClass('error')) {
        return false;
      } else if (result.hasClass('success')) {
        return true;
      }
    }

    // Returns element with matching name, id, or data- validate metadata to ID

  }, {
    key: "getField",
    value: function getField(identifier) {
      return $(this.dom).form('get field', identifier);
    }

    // Returns value of element with id

  }, {
    key: "getValue",
    value: function getValue(id) {
      return $(this.dom).form('get value', id);
    }

    // Returns object of element values that match array of ids.If no IDS are passed will return all fields

  }, {
    key: "getValues",
    value: function getValues(ids) {
      return $(this.dom).form('get values', ids);
    }

    // Sets value of element with id

  }, {
    key: "setValue",
    value: function setValue(id) {
      $(this.dom).form('set value', id);
    }

    // Sets key/ value pairs from passed values object to matching ids

  }, {
    key: "setValues",
    value: function setValues(target) {
      $(this.dom).form('set values', target);
    }

    // Returns validation rules for a given jQuery- referenced input field

  }, {
    key: "getValidation",
    value: function getValidation(target) {
      var $target = target.dom ? $(target.dom) : target;
      return $(this.dom).form('get validation', $target);
    }

    // Returns whether a field exists

  }, {
    key: "hasField",
    value: function hasField(target) {
      return $(this.dom).form('has field', $target);
    }
  }, {
    key: "getFieldLabel",
    value: function getFieldLabel(name, ctx, props) {
      var $field = this.getField(name);
      var $label = $field.closest('.field').find('label').eq(0);
      var label = $label.length == 1 ? $label.text() : $field.prop('placeholder');
      if (label == '') {
        var prop = props[name];
        if (prop && prop.type == "alias") {
          var qmlField = ctx[prop.val.objectName];
          label = qmlField.doc_label;
        }
      }
      return label;
    }

    /** Auto set `dataValidate` to all fields inside Form that are alias in RestModel
        this should be called from `Component.onCompleted` of RestModel
         Example:
        RestModel {
            id: restModel
            property alias first_name: txtFirstName.text
            Component.onCompleted: {
                form.setupValidate($context, $properties, restModel);
            }
        }
        Form {
            id: form
            Message { className: "error" }
            TextBox {
                id: txtFirstName
            }
        }
    **/

  }, {
    key: "setupValidate",
    value: function setupValidate(ctx, props, restModel) {
      var form = this;
      if (restModel) {
        restModel.failed.connect(function (error, xhr) {
          form.clear();
          if (xhr.status != 404) {
            form.showError(error, ctx, props);
          }
        });
        restModel.saved.connect(function () {
          form.clear();
        });
      }
      for (var key in props) {
        var prop = props[key];
        if (prop.type == "alias") {
          var field = ctx[prop.val.objectName];
          field.dataValidate = key;
        }
      }
    }
  }, {
    key: "$renderErrorList",
    value: function $renderErrorList(messages) {
      var list = '';
      if (typeof messages === 'string') {
        list += "<li>" + messages + "</li>";
      } else {
        var _iteratorNormalCompletion10 = true;
        var _didIteratorError10 = false;
        var _iteratorError10 = undefined;

        try {
          for (var _iterator10 = messages[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
            message = _step10.value;

            list += "<li>" + message + "</li>";
          }
        } catch (err) {
          _didIteratorError10 = true;
          _iteratorError10 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion10 && _iterator10.return) {
              _iterator10.return();
            }
          } finally {
            if (_didIteratorError10) {
              throw _iteratorError10;
            }
          }
        }
      }
      return list;
    }

    // Set error state to field
    //param - err = {
    //   'identifier': { ['Error message 1', 'Error message 2'],
    //   'identifier2': ['Error message 1', 'Error message 2'],
    // }
    // identifier = value from dataValidate

  }, {
    key: "showError",
    value: function showError() {
      var err = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var ctx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var message = void 0,
          allErrors = [],
          $form = $(this.dom),
          keys = Object.keys(err);

      var _iteratorNormalCompletion11 = true;
      var _didIteratorError11 = false;
      var _iteratorError11 = undefined;

      try {
        for (var _iterator11 = keys[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
          var name = _step11.value;

          messages = err[name];
          if (name == '__all__' || name == 'non_field_errors') {
            // do not render field name for __all__ or non_field_errors
            allErrors.push(this.$renderErrorList(messages));
            continue;
          } else if (name == 'action') {
            if ('message' in messages) {
              allErrors.push(this.$renderErrorList(messages.message));
            } else {
              allErrors.push(messages);
            }
            continue;
          }
          if (this.validateSetting.inline) {
            messages = messages.join(".<br>");
          } else {
            var label = this.getFieldLabel(name, ctx, props) || name;
            var list = "<ul class=\"list\"><b>" + label + "</b>";
            list += this.$renderErrorList(messages);
            list += '</ul>';
            allErrors.push(list);
          }

          $form.form("add prompt", name, messages);
        }
      } catch (err) {
        _didIteratorError11 = true;
        _iteratorError11 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion11 && _iterator11.return) {
            _iterator11.return();
          }
        } finally {
          if (_didIteratorError11) {
            throw _iteratorError11;
          }
        }
      }

      if (allErrors.length == 0) {
        console.debug('showError: called but no error displayed (maybe "err" is empty)');
      } else {
        $form.form("add errors", allErrors);
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      $(this.dom).form("set success");
      $(this.dom).find(".error:not(.ui.message)").removeClass('error');
    }
  }]);

  return _class105;
}());

QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Grid",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {}
}, function () {
  function _class106(meta) {
    _classCallCheck(this, _class106);

    QmlWeb.callSuper(this, meta);
    this.baseClassName = "ui";
    this.suffixClassName = "grid";
  }

  return _class106;
}());
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Icon",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    icon: "string"
  },
  signals: {
    clicked: [],
    hovered: [],
    mouseOuted: []
  }
}, function () {
  function _class107(meta) {
    _classCallCheck(this, _class107);

    QmlWeb.callSuper(this, meta);
    this.baseClassName = "icon";
    this.dom = document.createElement("i");
    this.iconChanged.connect(this, this.$onIconChanged);
    this.dom.addEventListener('click', this.clicked);
    this.dom.addEventListener('mouseover', this.hovered);
    this.dom.addEventListener('mouseout', this.mouseOuted);
  }

  _createClass(_class107, [{
    key: "$onIconChanged",
    value: function $onIconChanged() {
      this.className = this.icon;
    }
  }]);

  return _class107;
}());
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Image",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    source: "string",
    cursor: "string"
  },
  signals: {
    clicked: []
  }
}, function () {
  function _class108(meta) {
    var _this93 = this;

    _classCallCheck(this, _class108);

    QmlWeb.callSuper(this, meta);
    this.sourceChanged.connect(this, this.$onSourceChanged);
    this.cursorChanged.connect(this, this.$onCursorChanged);
    this.suffixClassName = "image";
    this.imageContainer = document.createElement("img");

    this.dom.appendChild(this.imageContainer);
    this.dom.addEventListener('click', function () {
      _this93.clicked();
    });
  }

  _createClass(_class108, [{
    key: "$onCursorChanged",
    value: function $onCursorChanged() {
      this.dom.style.cursor = this.cursor;
    }
  }, {
    key: "$onSourceChanged",
    value: function $onSourceChanged() {
      this.imageContainer.src = this.source;
    }
  }, {
    key: "getBase64Image",
    value: function getBase64Image() {
      var canvas = document.createElement("canvas");
      canvas.width = this.imageContainer.width;
      canvas.height = this.imageContainer.height;
      var ctx = canvas.getContext("2d");
      ctx.drawImage(this.imageContainer, 0, 0);
      var dataURL = canvas.toDataURL("image/png");
      //return dataURL.replace(/^data:image\/(png|jpg);base64,/, "");
      return dataURL;
    }
  }]);

  return _class108;
}());
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "ImageButton",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    source: "string",
    text: "string"
  },
  signals: {
    clicked: []
  }
}, function () {
  function _class109(meta) {
    var _this94 = this;

    _classCallCheck(this, _class109);

    QmlWeb.callSuper(this, meta);
    this.sourceChanged.connect(this, this.$onSourceChanged);
    this.textChanged.connect(this, this.$onTextChanged);
    this.classNameChanged.connect(this, this.$onClassNameChanged);
    this.Component.completed.connect(this, this.Component$onCompleted);

    this.$container = $("\n            <div class=\"card\">\n                <div class=\"blurring dimmable image\">\n                    <div class=\"ui dimmer\">\n                        <div class=\"content\">\n                            <div class=\"center\">\n                                <div class=\"ui inverted button\">Upload</div>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </div>\n            ");
    this.$imageContainer = $("<div><img></div>");
    this.$imageNode = $(this.$imageContainer).find('img');
    this.$buttonNode = $(this.$container).find('.ui.button');
    this.$dimmableNode = $(this.$container).find('.blurring.dimmable.image');
    this.$dimmableNode.append(this.$imageContainer);
    this.dom.className = "ui special cards";
    this.$container.css('width', 'auto');
    $(this.dom).append(this.$container);

    this.$buttonNode.on('click', function () {
      _this94.clicked();
    });
  }

  _createClass(_class109, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      this.$dimmableNode.dimmer({
        on: 'hover'
      });
    }
  }, {
    key: "$onSourceChanged",
    value: function $onSourceChanged() {
      this.$imageNode.attr('src', this.source);
    }
  }, {
    key: "$onTextChanged",
    value: function $onTextChanged() {
      this.$buttonNode.html(this.text);
    }

    //override

  }, {
    key: "$onClassNameChanged",
    value: function $onClassNameChanged() {
      this.$imageContainer[0].className = "ui " + this.className + " image";
    }
  }]);

  return _class109;
}());
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "InnerMenu",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {},
  signals: {}
}, function () {
  function _class110(meta) {
    _classCallCheck(this, _class110);

    QmlWeb.callSuper(this, meta);
    this.baseClassName = "";
    this.suffixClassName = "menu";
  }

  return _class110;
}());

QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Item",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    dropdown: { type: "bool", initialValue: false }
  }
}, function () {
  function _class111(meta) {
    _classCallCheck(this, _class111);

    QmlWeb.callSuper(this, meta);
    this.dropdownChanged.connect(this, this.$onDropdownChanged);
    this.suffixClassName = "item";
  }

  _createClass(_class111, [{
    key: "$onDropdownChanged",
    value: function $onDropdownChanged() {
      var _this95 = this;

      //start semantic component
      if (this.dropdown && !this.$dropdownCompleted) {
        this.addClass("dropdown");
        $(document).ready(function () {
          $(_this95.dom).dropdown();
          _this95.$dropdownCompleted = true;
        });
      }
    }
  }]);

  return _class111;
}());

QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "LabelTag",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    text: "string",
    icon: "string",
    size: "string",
    backgroundColor: "string",
    basic: "bool",
    tag: "bool",
    circular: "bool",
    link: "bool",
    floating: "bool"
  },
  signals: {
    clicked: [],
    changed: [],
    hovered: [],
    mouseOuted: []
  }
}, function () {
  function _class112(meta) {
    _classCallCheck(this, _class112);

    QmlWeb.callSuper(this, meta);
    this.Component.completed.connect(this, this.Component$onCompleted);
    this.textChanged.connect(this, this.$onTextChanged);
    this.iconChanged.connect(this, this.$onIconChanged);
    this.backgroundColorChanged.connect(this, this.$onBackgroundColorChanged);
    this.sizeChanged.connect(this, this.$onSizeChanged);
    this.tagChanged.connect(this, this.$onTagChanged);
    this.basicChanged.connect(this, this.$onBasicChanged);
    this.circularChanged.connect(this, this.$onCircularChanged);
    this.linkChanged.connect(this, this.$onLinkChanged);
    this.floatingChanged.connect(this, this.$onFloatingChanged);

    this.suffixClassName = "label";
    this.dom.style.pointerEvents = "auto";
    this.dom = this.dom;
    this.$addEvents();
  }

  _createClass(_class112, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      this.implicitWidth = this.dom.offsetWidth;
      this.implicitHeight = this.dom.offsetHeight;
    }
  }, {
    key: "validateProperty",
    value: function validateProperty(prop) {
      var BACKGROUNDCOLOR = ["", "red", "orange", "yellow", "olive", "green", "teal", "blue", "violet", "purple", "pink", "brown", "grey", "black"];

      var SIZE = ["mini", "tiny", "small", "medium", "large", "big", "huge", "massive"];
      if (prop || prop === "") {
        // prevent error from undefined prop and allow property ""
        prop = prop.toLowerCase();
        if (BACKGROUNDCOLOR.includes(prop) || SIZE.includes(prop)) {
          return [true, "" + prop];
        }
      }
      return [false, ""];
    }
  }, {
    key: "$addEvents",
    value: function $addEvents() {
      var _this96 = this;

      this.dom.onclick = function () {
        _this96.clicked();
      };
      this.dom.addEventListener('mouseover', this.hovered);
      this.dom.addEventListener('mouseout', this.mouseOuted);
    }
  }, {
    key: "$onTextChanged",
    value: function $onTextChanged() {
      this.dom.innerHTML = this.text;
      this.changed();
    }
  }, {
    key: "$onIconChanged",
    value: function $onIconChanged() {
      this.iconNode = document.createElement("i");
      this.iconNode.classList.add("" + this.icon, "icon");
      this.dom.innerHTML = "";
      this.dom.insertAdjacentElement("beforeend", this.iconNode);
      if (this.text !== "") this.dom.insertAdjacentText("afterbegin", this.text);
    }
  }, {
    key: "$onBackgroundColorChanged",
    value: function $onBackgroundColorChanged() {
      var _validateProperty9 = this.validateProperty(this.backgroundColor),
          _validateProperty10 = _slicedToArray(_validateProperty9, 2),
          pass = _validateProperty10[0],
          css = _validateProperty10[1];

      if (!pass) {
        this.dom.style.backgroundColor = this.backgroundColor;
        return;
      }
      this.dom.classList.remove("" + this._backgroundColor);
      if (!css) return; // return if css is "" prevent error when call classList.add with ""
      this.dom.classList.add(css);
      this._backgroundColor = this.backgroundColor;
    }
  }, {
    key: "$onSizeChanged",
    value: function $onSizeChanged() {
      var _validateProperty11 = this.validateProperty(this.size),
          _validateProperty12 = _slicedToArray(_validateProperty11, 2),
          pass = _validateProperty12[0],
          css = _validateProperty12[1];

      if (!pass) return;
      this.dom.classList.remove("" + this._size);
      this.dom.classList.add(css);
      this._size = this.size;
    }
  }, {
    key: "$onTagChanged",
    value: function $onTagChanged() {
      this.dom.classList.remove("tag");
      if (this.tag) this.dom.classList.add("tag");
    }
  }, {
    key: "$onBasicChanged",
    value: function $onBasicChanged() {
      this.dom.classList.remove("basic");
      if (this.basic) this.dom.classList.add("basic");
    }
  }, {
    key: "$onCircularChanged",
    value: function $onCircularChanged() {
      this.dom.classList.remove("circular");
      if (this.circular) this.dom.classList.add("circular");
    }
  }, {
    key: "$onLinkChanged",
    value: function $onLinkChanged() {
      var old_label = this.dom;
      this.dom = document.createElement("a");
      this.dom.classList = old_label.classList;
      this.dom.innerHTML = old_label.innerHTML;
      this.$addEvents();
      old_label.remove();
    }
  }, {
    key: "$onFloatingChanged",
    value: function $onFloatingChanged() {
      this.dom.classList.remove("floating");
      if (this.floating) this.dom.classList.add("floating");
    }
  }]);

  return _class112;
}());

QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Link",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    href: "string",
    text: "string"
  },
  signals: {
    clicked: []
  }
}, function () {
  function _class113(meta) {
    _classCallCheck(this, _class113);

    meta.object.tagName = "a";
    QmlWeb.callSuper(this, meta);
    this.textChanged.connect(this, this.$onTextChanged);
    this.hrefChanged.connect(this, this.$onHrefChanged);
    $(this.dom).on('click', this.onClick.bind(this));
  }

  _createClass(_class113, [{
    key: "onClick",
    value: function onClick() {
      this.clicked();
    }
  }, {
    key: "$onTextChanged",
    value: function $onTextChanged() {
      $(this.dom).html(this.text);
    }
  }, {
    key: "$onHrefChanged",
    value: function $onHrefChanged() {
      $(this.dom).attr('href', this.href);
    }
  }]);

  return _class113;
}());
QmlWeb.registerQmlType({
  module: 'Semantic.Html',
  name: 'List',
  versions: /.*/,
  baseClass: 'Semantic.Html.Dom',
  properties: {}
}, function () {
  function _class114(meta) {
    _classCallCheck(this, _class114);

    QmlWeb.callSuper(this, meta);
    this.suffixClassName = 'list';
  }

  return _class114;
}());

QmlWeb.registerQmlType({
  module: 'Semantic.Html',
  name: 'ListContent',
  versions: /.*/,
  baseClass: 'Semantic.Html.Dom',
  properties: {
    header: 'string'
  }
}, function () {
  function _class115(meta) {
    _classCallCheck(this, _class115);

    QmlWeb.callSuper(this, meta);
    this.headerChanged.connect(this, this.$onHeaderChanged);

    this.prefixClassName = '';
    this.suffixClassName = 'content';

    this.headerContainer = document.createElement('div');
    this.headerContainer.classList.add('header');

    this.dom.appendChild(this.headerContainer);
  }

  _createClass(_class115, [{
    key: "$onHeaderChanged",
    value: function $onHeaderChanged() {
      this.headerContainer.innerHTML = this.header;
    }
  }, {
    key: "$onTextChanged",
    value: function $onTextChanged() {
      var _this97 = this;

      if (this.textNode) {
        this.dom.childNodes.forEach(function (element) {
          if (element.nodeType === 3) {
            element.nodeValue = _this97.text;
          }
        });
      } else {
        this.textNode = document.createTextNode(this.text);
        this.dom.insertAdjacentText('beforeend', this.textNode.textContent);
      }
    }
  }]);

  return _class115;
}());

QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "ListElement",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom"
}, function () {
  function _class116(meta) {
    _classCallCheck(this, _class116);

    QmlWeb.callSuper(this, meta);

    var createProperty = QmlWeb.createProperty;
    for (var i in meta.object) {
      if (i[0] !== "$") {
        createProperty("variant", this, i);
      }
    }
    QmlWeb.applyProperties(meta.object, this, this, this.$context);
  }

  return _class116;
}());

QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "ListModel",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    count: "int",
    $items: "list",
    model: "var"
  },
  defaultProperty: "$items",
  signals: {
    changed: []
  }
}, function () {
  function _class117(meta) {
    var _this98 = this;

    _classCallCheck(this, _class117);

    QmlWeb.callSuper(this, meta);

    this.$firstItem = true;
    this.$itemsChanged.connect(this, this.$on$itemsChanged);
    this.modelChanged.connect(this, this.$onModelChanged);
    this.$model = new QmlWeb.JSItemModel();
    this.$model.data = function (index, role) {
      return _this98.$items[index][role];
    };
    this.$model.rowCount = function () {
      return _this98.$items.length;
    };
  }

  _createClass(_class117, [{
    key: "$onModelChanged",
    value: function $onModelChanged() {
      // Use ListModel with property model
      this.$items = [];
      if (this.model.length > 0) {
        var c = 0;
        var roleNames = [];
        if (this.model instanceof Array) {
          for (var _key44 in this.model) {
            this.$items.push(this.model[_key44]);
            c++;
          }
        } else {
          this.$items.push(this.model);
          c = 1;
        }
        for (var i in this.model[0]) {
          if (i !== "index") {
            roleNames.push(i);
          }
        }
        this.$model.setRoleNames(roleNames);
      }
      this.count = this.$items.length;
      this.changed();
    }
  }, {
    key: "$on$itemsChanged",
    value: function $on$itemsChanged(newVal) {
      // Use ListModel with ListElement
      this.count = this.$items.length;
      if (this.$firstItem && newVal.length > 0) {
        var QMLListElement = QmlWeb.getConstructor("Semantic.Html", "2.0", "ListElement");
        this.$firstItem = false;
        var roleNames = [];
        var dict = newVal[0];
        if (dict instanceof QMLListElement) {
          dict = dict.$properties;
        }
        for (var i in dict) {
          if (i !== "index") {
            roleNames.push(i);
          }
        }
        this.$model.setRoleNames(roleNames);
      }
    }
  }, {
    key: "append",
    value: function append(dict) {
      var index = this.$items.length;
      var c = 0;

      if (dict instanceof Array) {
        for (var _key45 in dict) {
          this.$items.push(dict[_key45]);
          this.model.push(dict[_key45]);
          c++;
        }
      } else {
        this.$items.push(dict);
        this.model.push(dict);
        c = 1;
      }
      this.$itemsChanged(this.$items);
      this.$model.rowsInserted(index, index + c);
    }
  }, {
    key: "clear",
    value: function clear() {
      this.$items.length = 0;
      this.count = 0;
      this.$model.modelReset();
    }
  }, {
    key: "get",
    value: function get(index) {
      return this.$items[index];
    }
  }, {
    key: "insert",
    value: function insert(index, dict) {
      this.$items.splice(index, 0, dict);
      this.$itemsChanged(this.$items);
      this.$model.rowsInserted(index, index + 1);
    }
  }, {
    key: "move",
    value: function move(from, to, n) {
      var vals = this.$items.splice(from, n);
      for (var i = 0; i < vals.length; i++) {
        this.$items.splice(to + i, 0, vals[i]);
      }
      this.$model.rowsMoved(from, from + n, to);
    }
  }, {
    key: "remove",
    value: function remove(index) {
      this.$items.splice(index, 1);
      this.model.splice(index, 1);
      this.$model.rowsRemoved(index, index + 1);
      this.count = this.$items.length;
    }
  }, {
    key: "set",
    value: function set(index, dict) {
      this.$items[index] = dict;
      this.model[index] = dict;
      this.$model.dataChanged(index, index);
    }
  }, {
    key: "updateItem",
    value: function updateItem(index, property, value) {
      this.setProperty(index, property, value);
    }
  }, {
    key: "setProperty",
    value: function setProperty(index, property, value) {
      this.$items[index][property] = value;
      this.$model.dataChanged(index, index);
    }
  }]);

  return _class117;
}());

QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Loader",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    active: { type: "bool", initialValue: false },
    asynchronous: "bool",
    item: "var",
    progress: "real",
    source: "url",
    sourceComponent: "Component",
    status: { type: "enum", initialValue: 1 }
  },
  defaultProperty: "sourceComponent",
  signals: {
    loaded: []
  }
}, function () {
  function _class118(meta) {
    _classCallCheck(this, _class118);

    QmlWeb.callSuper(this, meta);
    this.meta = meta;
    this.$sourceUrl = "";

    this.activeChanged.connect(this, this.$onActiveChanged);
    this.sourceChanged.connect(this, this.$onSourceChanged);
    this.sourceComponentChanged.connect(this, this.$onSourceComponentChanged);
  }

  _createClass(_class118, [{
    key: "$onActiveChanged",
    value: function $onActiveChanged() {
      if (!this.active) {
        this.$unload();
        return;
      }
      if (this.source) {
        this.$onSourceChanged(this.source);
      } else if (this.sourceComponent) {
        this.$onSourceComponentChanged(this.sourceComponent);
      }
    }
  }, {
    key: "$onSourceChanged",
    value: function $onSourceChanged(fileName) {
      // TODO
      // if (fileName == this.$sourceUrl && this.item !== undefined) return;
      if (!this.active) return;
      this.$unload();

      if (!fileName) {
        this.sourceComponent = null;
        this.$sourceUrl = fileName;
        return;
      }

      var tree = QmlWeb.engine.loadComponent(fileName);
      var QMLComponent = QmlWeb.getConstructor("QtQml", "2.0", "Component");
      var meta = { object: tree, context: this.$context, parent: this };
      var qmlComponent = new QMLComponent(meta);
      qmlComponent.$basePath = QmlWeb.engine.extractBasePath(tree.$file);
      qmlComponent.$imports = tree.$imports;
      qmlComponent.$file = tree.$file;
      QmlWeb.engine.loadImports(tree.$imports, qmlComponent.$basePath, qmlComponent.importContextId);
      var loadedComponent = this.$createComponentObject(qmlComponent, this);
      this.sourceComponent = loadedComponent;
      this.$sourceUrl = fileName;
    }
  }, {
    key: "$onSourceComponentChanged",
    value: function $onSourceComponentChanged(newItem) {
      var _this99 = this;

      if (!this.active) return;
      this.$unload();

      if (!newItem) {
        this.item = null;
        return;
      }

      var QMLComponent = QmlWeb.getConstructor("QtQml", "2.0", "Component");
      var qmlComponent = newItem;
      if (newItem instanceof QMLComponent) {
        qmlComponent = newItem.$createObject(this, {}, this.$context);
      }
      qmlComponent.parent = this;
      this.item = qmlComponent;

      // Prevent id of item from sourceUrl included on rootContext
      if (!this.$sourceUrl) {
        // To add newItem to rootContext
        if (QmlWeb.engine.rootObject == null) {
          // our context is the root context
          this.$context[this.item.id] = this.item;
        } else {
          var rootContext = QmlWeb.engine.rootContext();
          rootContext[this.item.id] = this.item;
        }
      }
      if (newItem instanceof QMLComponent) {
        // call onCompleted for SourceComponent ($createObject won't call for us)
        if (QmlWeb.engine.operationState === QmlWeb.QMLOperationState.Running) {
          QmlWeb.engine.$initializePropertyBindings();
        }
        if (QmlWeb.engine.firstCallCompleted) {
          this.$callOnCompleted(this.item);
        }
      }

      $(document).ready(function () {
        if (_this99.isLoadAndShow) {
          _this99.isLoadAndShow = false;
          _this99.item.show();
        }
        _this99.loaded();
      });
    }
  }, {
    key: "setSource",
    value: function setSource(url, options) {
      this.$sourceUrl = url;
      this.props = options;
      this.source = url;
    }
    // Handle with Modal to load and show

  }, {
    key: "loadAndShowModal",
    value: function loadAndShowModal() {
      this.isLoadAndShow = true;
      if (this.active) {
        this.item.show();
      }
      this.active = true;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.isLoadAndShow = false;
      this.active = false;
      this.$unload();
    }
  }, {
    key: "$unload",
    value: function $unload() {
      if (!this.item) return;
      var rootContext = QmlWeb.engine.rootContext();
      rootContext[this.item.id] = null;
      this.item.$delete();
      this.item.parent = undefined;
      this.item = undefined;
    }
  }, {
    key: "$callOnCompleted",
    value: function $callOnCompleted(child) {
      child.Component.completed();
      var QMLBaseObject = QmlWeb.getConstructor("QtQml", "2.0", "QtObject");
      for (var i = 0; i < child.$tidyupList.length; i++) {
        if (child.$tidyupList[i] instanceof QMLBaseObject) {
          this.$callOnCompleted(child.$tidyupList[i]);
        }
      }
    }
  }, {
    key: "$createComponentObject",
    value: function $createComponentObject(qmlComponent, parent) {
      var newComponent = qmlComponent.createObject(parent);
      if (QmlWeb.engine.operationState === QmlWeb.QMLOperationState.Running) {
        QmlWeb.engine.$initializePropertyBindings();
      }
      if (QmlWeb.engine.firstCallCompleted) {
        // We don't call those on first creation, as they will be called
        // by the regular creation-procedures at the right time.
        this.$callOnCompleted(newComponent);
      }
      return newComponent;
    }
  }]);

  return _class118;
}());

QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Loading",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {},
  signals: {}
}, function () {
  function _class119(meta) {
    _classCallCheck(this, _class119);

    QmlWeb.callSuper(this, meta);

    this.suffixClassName = "loader";
  }

  return _class119;
}());

QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Menu",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    selectedTab: "string"
  },
  signals: {
    changed: [{ type: "string", name: "selected" }],
    refreshed: []
  }
}, function () {
  function _class120(meta) {
    _classCallCheck(this, _class120);

    QmlWeb.callSuper(this, meta);
    this.Component.completed.connect(this, this.Component$onCompleted);
    this.selectedTabChanged.connect(this, this.$onSelectedTabChanged);
    this.baseClassName = "ui";
    this.suffixClassName = "menu";
  }

  _createClass(_class120, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      this.$menuItem = $(this.dom).find("a.item, .link.item");
      this.handler = {
        activate: function activate(evt) {
          this.selectedTab = evt.target.getAttribute("data-tab");
          var activeAll = $(evt.target).attr("data-active-all");
          if (activeAll) {
            $(this.dom).parent().find(".ui.tab").addClass("active");

            $(this.dom).find(".item").not($(evt.target)).removeClass("active");
          }
          this.changed(this.selectedTab);
        }
      };
      this.enableBinding = true;
      this.bindClickEvent();
      //call method that can't do until component complete
      this.$onSelectedTabChanged();

      this.observer = new MutationObserver(this.refresh.bind(this));
      this.observer.observe(this.dom, {
        childList: true
      });
    }
  }, {
    key: "refresh",
    value: function refresh() {
      this.bindClickEvent();
      this.$onSelectedTabChanged();
      this.refreshed();
    }
  }, {
    key: "bindClickEvent",
    value: function bindClickEvent() {
      if (!this.enableBinding) return;

      this.$menuItem.off("click", this.handler.activate.bind(this));
      this.$menuItem = $(this.dom).find("a.item, .link.item");
      this.$menuItem.on("click", this.handler.activate.bind(this));
    }
  }, {
    key: "$onSelectedTabChanged",
    value: function $onSelectedTabChanged() {
      if (this.bySystem) return;

      if (!this.selectedTab) return;

      var activeMenu = "a.item[data-tab=\"" + this.selectedTab + "\"], .link.item[data-tab=\"" + this.selectedTab + "\"]";
      $(this.dom).find("a.item, .link.item").removeClass("active");
      $(".ui.tab").removeClass("active");
      $(this.dom).find(activeMenu).addClass("active");
      $(".ui.tab[data-tab=\"" + this.selectedTab + "\"]").addClass('active');

      var tabContent = $(".ui.segment[data-tab=\"" + this.selectedTab + "\"],\n                        .ui.segments[data-tab=\"" + this.selectedTab + "\"]");

      if (tabContent.get(0)) {
        document.body.dispatchEvent(new CustomEvent("resizeDgrid", {
          detail: {
            dom: tabContent.get(0)
          }
        }));
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      $(this.dom).find("a.item, .link.item").removeClass("active");
      $(".ui.tab").removeClass("active");
      this.selectedTab = '';
      this.bindClickEvent();
    }
  }]);

  return _class120;
}());

QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "MenuItem",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    dataTab: "string",
    activeAll: "bool"
  },
  signals: {
    clicked: []
  }
}, function () {
  function _class121(meta) {
    var _this100 = this;

    _classCallCheck(this, _class121);

    meta.object.tagName = "a";
    QmlWeb.callSuper(this, meta);
    this.dataTabChanged.connect(this, this.$onDataTabChanged);
    this.activeAllChanged.connect(this, this.$onActiveAllChanged);
    this.baseClassName = "";
    this.suffixClassName = "item";

    this.dom.addEventListener("click", function () {
      return _this100.clicked();
    });
  }

  _createClass(_class121, [{
    key: "$onTextChanged",
    value: function $onTextChanged() {
      var _this101 = this;

      if (this.textNode) {
        this.dom.childNodes.forEach(function (element) {
          if (element.nodeType === 3) {
            element.nodeValue = _this101.text;
          }
        });
      } else {
        this.textNode = document.createTextNode(this.text);
        this.dom.insertAdjacentText("afterbegin", this.textNode.textContent);
      }
    }
  }, {
    key: "$onDataTabChanged",
    value: function $onDataTabChanged() {
      this.dom.setAttribute("data-tab", this.dataTab);
    }
  }, {
    key: "$onActiveAllChanged",
    value: function $onActiveAllChanged() {
      $(this.dom).attr('data-active-all', this.activeAll);
    }
  }]);

  return _class121;
}());

{
  var _BACKGROUNDCOLOR = ['red', 'orange', 'yellow', 'olive', 'green', 'teal', 'blue', 'violet', 'purple', 'pink', 'brown', 'grey', 'black'];

  QmlWeb.registerQmlType({
    module: "Semantic.Html",
    name: "Message",
    versions: /.*/,
    baseClass: "Semantic.Html.Dom",
    properties: {
      icon: "string",
      spinning: "bool",
      dismissable: "bool",
      contentStyle: "string",
      backgroundColor: "string"
    }
  }, function () {
    function _class122(meta) {
      _classCallCheck(this, _class122);

      QmlWeb.callSuper(this, meta);
      this.Component.completed.connect(this, this.Component$onCompleted);
      this.iconChanged.connect(this, this.$onIconChanged);
      this.spinningChanged.connect(this, this.$onSpinningChanged);
      this.dismissableChanged.connect(this, this.$onDismissableChanged);
      this.contentStyleChanged.connect(this, this.$onContentStyleChanged);
      this.backgroundColorChanged.connect(this, this.$onBackgroundColorChanged);
      this.suffixClassName = "message";
      this.contentNode = document.createElement("div");
      this.contentNode.classList.add("content");
      this.iconNode = document.createElement("i");
    }

    _createClass(_class122, [{
      key: "Component$onCompleted",
      value: function Component$onCompleted() {
        //Move all dom's childNodes to contentNode 
        while (this.dom.childNodes.length > 0) {
          this.contentNode.appendChild(this.dom.childNodes[0]);
        }

        this.dom.appendChild(this.iconNode);
        this.dom.appendChild(this.contentNode);
      }
    }, {
      key: "$onIconChanged",
      value: function $onIconChanged() {
        if (!this.icon) return;
        var icon = this.icon.split(" ");
        this.iconNode.className = "";
        this.iconNode.classList.add("icon");

        if (this.dismissable) {
          this.iconNode.classList.add("close");
        } else {
          var _iconNode$classList;

          (_iconNode$classList = this.iconNode.classList).add.apply(_iconNode$classList, _toConsumableArray(icon));
        }

        this.spinning && this.iconNode.classList.add("loading");
        this.icon && this.dom.classList.add("icon");
      }
    }, {
      key: "$onSpinningChanged",
      value: function $onSpinningChanged() {
        var iconClassList = this.iconNode.classList;
        if (this.spinning) {
          !iconClassList.contains("loading") && iconClassList.add("loading");
        } else {
          iconClassList.remove("loading");
        }
      }
    }, {
      key: "$onDismissableChanged",
      value: function $onDismissableChanged() {
        //there is a bug here
        //when set dismissable to true it can't be set to false
        this.iconNode.className = "";
        this.iconNode.classList.add("close", "icon");

        $(document).ready(function () {
          $('.message .close').on('click', function () {
            $(this).closest('.message').transition('fade');
          });
        });
      }
    }, {
      key: "$onContentStyleChanged",
      value: function $onContentStyleChanged() {
        if (typeof this.contentStyle === 'string') {
          this.contentNode.style = this.contentStyle;
        }
        if (_typeof(this.contentStyle) === 'object') {
          $(this.contentNode).css(this.contentStyle);
        }
      }
    }, {
      key: "$onBackgroundColorChanged",
      value: function $onBackgroundColorChanged() {
        var classList = this.dom.classList;

        this.dom.style.backgroundColor = "";
        this._backgroundColor && classList.remove(this._backgroundColor);
        if (_BACKGROUNDCOLOR.includes(this.backgroundColor)) {
          classList.add(this.backgroundColor);
        } else {
          this.dom.style.backgroundColor = this.backgroundColor;
        }
        this._backgroundColor = this.backgroundColor;
      }
    }, {
      key: "show",
      value: function show() {
        this.displayNone = false;
        $(this.dom).transition('fade in');
      }
    }, {
      key: "hide",
      value: function hide() {
        this.displayNone = true;
        $(this.dom).transition('fade out');
      }
    }]);

    return _class122;
  }());
}
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Modal",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    autofocus: { type: "bool", initialValue: false },
    allowMultiple: { type: "bool", initialValue: true },
    duration: { type: "int", initialValue: 200 },
    closable: { type: "bool", initialValue: true }
  },
  signals: {
    hidden: [],
    showed: []
  }
}, function () {
  function _class123(meta) {
    _classCallCheck(this, _class123);

    QmlWeb.callSuper(this, meta);
    this.Component.completed.connect(this, this.Component$onCompleted);
    this.suffixClassName = "modal";
    this.context = document.createElement('div');
    this.context.style.display = 'none';
    document.body.appendChild(this.context);
  }

  _createClass(_class123, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      var _this102 = this;

      $(document).ready(function () {
        _this102.modal = $(_this102.dom).modal({
          onVisible: _this102.onVisible.bind(_this102),
          onHidden: _this102.hidden,
          autofocus: _this102.autofocus,
          allowMultiple: _this102.allowMultiple,
          duration: _this102.duration,
          closable: _this102.closable,
          context: _this102.context
        });
      });
    }
  }, {
    key: "onVisible",
    value: function onVisible() {
      document.body.dispatchEvent(new CustomEvent("resizeDgrid", {
        detail: {
          dom: this.dom
        }
      }));
      this.showed();
    }
  }, {
    key: "show",
    value: function show() {
      document.body.appendChild(this.context);
      this.context.style.display = '';
      $(this.dom).modal("show");
    }
  }, {
    key: "hide",
    value: function hide() {
      this.context.style.display = 'none';
      $(this.dom).modal("hide");
    }

    /**
    * Show alert dialog and auto hide when duration reached
    * @param {int} duration number of toast to show on screen
    */

  }, {
    key: "toast",
    value: function toast() {
      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;

      var self = this;
      self.show();
      setTimeout(function () {
        self.hide();
      }, duration);
    }

    /**
     * @deprecated please remove the call to this method
     */

  }, {
    key: "setActive",
    value: function setActive() {
      // $(this.dom).modal("set active");
    }
  }, {
    key: "isActive",
    value: function isActive() {
      return $(this.dom).modal("is active");
    }

    /**
     * @deprecated please remove the call to this method
     */

  }, {
    key: "refresh",
    value: function refresh() {
      console.warn('refresh is deprecated');
    }
  }]);

  return _class123;
}());

QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Popup",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    inline: "bool",
    target: "var",
    position: "string",
    boundary: "var",
    lastResort: "bool",
    hoverable: { type: "bool", initialValue: false },
    activeEvent: { type: "string", initialValue: "hover" }
  }
}, function () {
  function _class124(meta) {
    _classCallCheck(this, _class124);

    QmlWeb.callSuper(this, meta);
    this.Component.completed.connect(this, this.Component$onCompleted);
    this.targetChanged.connect(this, this.$onTargetChanged);
    this.boundaryChanged.connect(this, this.$onBoundaryChanged);
    this.positionChanged.connect(this, this.$onPositionChanged);
    this.activeEventChanged.connect(this, this.$onActiveEventChanged);
    this.lastResortChanged.connect(this, this.$onLastResortChanged);
    this.suffixClassName = "popup";

    this.settings = {
      popup: $(this.dom),
      onUnplaceable: this.onUnplaceable.bind(this)
    };
  }

  _createClass(_class124, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      var _this103 = this;

      this.settings.hoverable = this.hoverable;
      $(document).ready(function () {
        return $(_this103.getTarget()).popup(_this103.settings);
      });
    }
  }, {
    key: "onUnplaceable",
    value: function onUnplaceable() {
      console.error("Plaese increase the height of grid (if you are using DGrid)");
    }
  }, {
    key: "$onTargetChanged",
    value: function $onTargetChanged() {
      var _this104 = this;

      $(document).ready(function () {
        var target = _this104.getTarget();
        if (!target) return;
        $(target).popup(_this104.settings);
      });
    }
  }, {
    key: "$onLastResortChanged",
    value: function $onLastResortChanged() {
      var target = this.getTarget();
      this.settings.lastResort = this.lastResort;
      target && $(target).popup(this.settings);
    }
  }, {
    key: "$onBoundaryChanged",
    value: function $onBoundaryChanged() {
      var target = this.getTarget();
      var notNull = !!this.boundary;
      var hasDom = notNull && this.boundary.hasOwnProperty("dom");
      var isGrid = hasDom && this.boundary.dom.classList.contains("dgrid-grid");

      if (notNull) {
        this.settings.boundary = this.boundary.dom || window;
      }
      if (notNull && hasDom && isGrid) {
        this.settings.boundary = $(this.boundary.dom).find('.dgrid-scroller');
      }
      target && $(target).popup(this.settings);
    }
  }, {
    key: "getTarget",
    value: function getTarget() {
      if (this.target && this.target.hasOwnProperty("dom")) return this.target.dom;
      if (this.parent && this.parent.hasOwnProperty("dom")) return this.parent.dom;
    }
  }, {
    key: "show",
    value: function show() {
      $(this.getTarget()).popup("show");
    }
  }, {
    key: "hide",
    value: function hide() {
      $(this.getTarget()).popup("hide");
    }
  }, {
    key: "$onTextChanged",
    value: function $onTextChanged() {
      var _this105 = this;

      if (this.textNode) {
        this.dom.childNodes.forEach(function (element) {
          if (element.nodeType === 3) {
            element.nodeValue = _this105.text;
          }
        });
      } else {
        this.textNode = document.createTextNode(this.text);
        this.dom.insertAdjacentText("afterbegin", this.textNode.textContent);
      }
    }
  }, {
    key: "$onPositionChanged",
    value: function $onPositionChanged() {
      var _this106 = this;

      $(document).ready(function () {
        var target = _this106.getTarget();
        var availablePositions = ["top left", "top center", "top right", "bottom left", "bottom center", "bottom right", "right center", "left center"];
        if (!target) return;
        if (!availablePositions.includes(_this106.position)) return;
        target.setAttribute("data-position", _this106.position);
        $(document).ready(function () {
          return $(target).popup(_this106.settings);
        });
      });
    }
  }, {
    key: "$onActiveEventChanged",
    value: function $onActiveEventChanged() {
      var _this107 = this;

      $(document).ready(function () {
        //workaround for fixing couldn't find parent
        var target = _this107.getTarget();
        if (!target) return;
        var availableEvents = ["focus", "click", "hover", "manual"];
        if (availableEvents.includes(_this107.activeEvent)) {
          _this107.settings.on = _this107.activeEvent;
          $(target).popup(_this107.settings);
        }
      });
    }
  }]);

  return _class124;
}());

QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "RadioButton",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    value: "var",
    checked: "bool",
    readOnly: "bool",
    text: "string",
    color: "string",
    group: "string",
    fitted: "bool",
    type: "string",
    dataValidate: "string",
    enabled: { type: "bool", initialValue: true }
  },
  signals: {
    changed: [{ name: "event", type: "var" }, { name: "value", type: "var" }]
  }
}, function () {
  function _class125(meta) {
    var _this108 = this;

    _classCallCheck(this, _class125);

    QmlWeb.callSuper(this, meta);
    this.Component.completed.connect(this, this.Component$onCompleted);
    this.valueChanged.connect(this, this.$onValueChanged);
    this.checkedChanged.connect(this, this.$onCheckedChanged);
    this.textChanged.connect(this, this.$onTextChanged);
    this.enabledChanged.connect(this, this.$onEnabledChanged);
    this.readOnlyChanged.connect(this, this.$onReadOnlyChanged);
    this.colorChanged.connect(this, this.$onColorChanged);
    this.groupChanged.connect(this, this.$onGroupChanged);
    this.fittedChanged.connect(this, this.$onFittedChanged);
    this.typeChanged.connect(this, this.$onTypeChanged);
    this.dataValidateChanged.connect(this, this.$onDataValidateChanged);

    this._lastType = "radio";
    this.radioContainer = document.createElement("div");
    this.radio = document.createElement("input");
    this.label = document.createElement("label");
    this.radioContainer.classList.add("ui", this._lastType, "checkbox");
    this.radio.type = "radio";
    this.radio.value = null;
    this.radioContainer.appendChild(this.radio);
    this.radioContainer.appendChild(this.label);
    this.dom = this.radioContainer;

    $(this.radio).on("checkedChanged", function () {
      return _this108.onCheckChanged();
    });
    $(this.radio).on("readonlyChanged", function (evt, readonly) {
      _this108.readOnly = readonly;
    });
    $(this.radio).on("enabledChanged", function (evt, enabled) {
      _this108.enabled = enabled;
    });
    $(this.radio).on("onRadioClear", function () {
      _this108.checked = false;
    });

    this.radio.onchange = function (event) {
      $.each($("input[name=" + _this108.group + "]:radio"), function (index, dom) {
        if (!_this108.dom.contains(dom)) {
          $(dom).trigger("checkedChanged");
        }
      });
      _this108.onCheckChanged();
      _this108.changed(event, _this108.radio.value);
    };
  }

  _createClass(_class125, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      $(document).ready(function () {
        return $(".ui.radio.checkbox").checkbox();
      });
    }

    //override

  }, {
    key: "$onHtmlIDChanged",
    value: function $onHtmlIDChanged() {
      this.radio.id = this.htmlID;
    }
  }, {
    key: "$onDataValidateChanged",
    value: function $onDataValidateChanged() {
      this.radio.setAttribute("data-validate", this.dataValidate);
    }
  }, {
    key: "$onValueChanged",
    value: function $onValueChanged() {
      this.radio.value = this.value;
    }
  }, {
    key: "$onCheckedChanged",
    value: function $onCheckedChanged() {
      if (!this.bySystem) this.radio.checked = this.checked;
    }
  }, {
    key: "onCheckChanged",
    value: function onCheckChanged() {
      this.bySystem = true;
      this.checked = this.radio.checked;
      this.bySystem = false;
    }
  }, {
    key: "$onTextChanged",
    value: function $onTextChanged() {
      this.label.innerHTML = this.text;
    }
  }, {
    key: "$onEnabledChanged",
    value: function $onEnabledChanged() {
      this.radioContainer.classList.remove("disabled");
      if (!this.enabled) this.radioContainer.classList.add("disabled");
    }
  }, {
    key: "$onReadOnlyChanged",
    value: function $onReadOnlyChanged() {
      this.radioContainer.classList.remove("read-only");
      if (this.readOnly) this.radioContainer.classList.add("read-only");
    }
  }, {
    key: "$onColorChanged",
    value: function $onColorChanged() {
      this.label.style.color = this.color;
    }
  }, {
    key: "$onGroupChanged",
    value: function $onGroupChanged() {
      this.radio.name = this.group;
    }
  }, {
    key: "$onFittedChanged",
    value: function $onFittedChanged() {
      this.radioContainer.classList.remove("fitted");
      if (this.fitted) this.radioContainer.classList.add("fitted");
    }
  }, {
    key: "$onTypeChanged",
    value: function $onTypeChanged() {
      this.radioContainer.classList.remove(this._lastType);
      this.radioContainer.classList.add(this.type);
      this._lastType = this.type;
    }
  }]);

  return _class125;
}());
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "RadioGroup",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    value: "var",
    group: "var",
    readOnly: 'bool',
    enabled: { type: "bool", initialValue: true },
    dataValidate: "string"
  },
  signals: {
    changed: [{ name: "value", type: "var" }, { name: "text", type: "var" }, { name: "bySystem", type: "var" }]
  }
}, function () {
  function _class126(meta) {
    _classCallCheck(this, _class126);

    QmlWeb.callSuper(this, meta);
    this.Component.completed.connect(this, this.Component$onCompleted);
    this.valueChanged.connect(this, this.$onValueChanged);
    this.groupChanged.connect(this, this.$onGroupChanged);
    this.enabledChanged.connect(this, this.$onEnabledChanged);
    this.readOnlyChanged.connect(this, this.$onReadOnlyChanged);
    this.dataValidateChanged.connect(this, this.$onDataValidateChanged);

    this.input = document.createElement("input");
    this.input.style.display = "none";
    this.dom.appendChild(this.input);
  }

  _createClass(_class126, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      this.completed = true;
      this.$onGroupChanged();
      this.$onReadOnlyChanged();
      this.$onEnabledChanged();
      this.value && this.$onValueChanged();
    }
  }, {
    key: "$onReadOnlyChanged",
    value: function $onReadOnlyChanged() {
      var _this109 = this;

      if (!this.completed) return;

      this.loopThroughRadio(function (index, ele) {
        $(ele).trigger("readonlyChanged", [_this109.readOnly]);
      });
    }
  }, {
    key: "$onEnabledChanged",
    value: function $onEnabledChanged() {
      var _this110 = this;

      if (!this.completed) return;

      this.loopThroughRadio(function (index, ele) {
        $(ele).trigger("enabledChanged", [_this110.enabled]);
      });
    }
  }, {
    key: "$onValueChanged",
    value: function $onValueChanged() {
      if (!this.completed) return;

      if (this.bySystem) return;

      if (!this.group) return;

      var $target = $("input[name='" + this.group + "'][value='" + this.value + "']:radio");
      this.input.value = this.value;

      if (!$target[0]) {
        console.warn("can't find radio button with value: " + this.value + ".");
        return;
      }

      $target[0].checked = true;

      this.loopThroughRadio(function (index, ele) {
        $(ele).trigger("checkedChanged");
      });

      this.changed(this.value, this.text, this.bySystem);
    }
  }, {
    key: "$onGroupChanged",
    value: function $onGroupChanged() {
      var _this111 = this;

      if (!this.completed) return;

      if (!this.group) return;

      this.$radios = this.loopThroughRadio(function (index, ele) {
        if (ele.checked) {
          _this111.bySystem = true;
          _this111.value = ele.value;
          _this111.bySystem = false;
        }
      });

      if (this.$radios.length === 0) {
        $(document).ready(function () {
          _this111.$radios = _this111.loopThroughRadio(function (index, ele) {
            if (ele.checked) {
              _this111.bySystem = true;
              _this111.value = ele.value;
              _this111.bySystem = false;
            }
          });

          if (_this111.$radios.length === 0) {
            console.warn("can't find group:" + _this111.group + " maybe content is not ready");
            return;
          }

          _this111.$radios.off('change', _this111.onRadioCheckedChange.bind(_this111));
          _this111.$radios.on('change', _this111.onRadioCheckedChange.bind(_this111));
        });
      } else {
        this.$radios.off('change', this.onRadioCheckedChange.bind(this));
        this.$radios.on('change', this.onRadioCheckedChange.bind(this));
      }
    }
  }, {
    key: "$onDataValidateChanged",
    value: function $onDataValidateChanged() {
      this.input.setAttribute("data-validate", this.dataValidate);
    }
  }, {
    key: "clear",
    value: function clear() {
      this.bySystem = true;
      this.value = "";
      this.loopThroughRadio(function (index, ele) {
        $(ele).trigger("onRadioClear");
      });
      this.bySystem = false;
    }
  }, {
    key: "onRadioCheckedChange",
    value: function onRadioCheckedChange(evt) {
      this.bySystem = true;
      this.value = evt.target.value;
      this.bySystem = false;

      var text = $(evt.target.parentElement).find('label').html();
      this.changed(this.value, text, this.bySystem);
    }
  }, {
    key: "loopThroughRadio",
    value: function loopThroughRadio(cb) {
      var $radios = $("input[name=" + this.group + "]:radio");
      $.each($radios, cb);
      return $radios;
    }
  }]);

  return _class126;
}());
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Repeater",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    delegate: "Component",
    model: { type: "var", initialValue: [] },
    count: "int",
    placeAfter: "var", // if "first" it will be the first child
    useItemModel: { type: "bool", initialValue: false }
  },
  signals: {
    renderCompleted: []
  },
  defaultProperty: "delegate"
}, function () {
  function _class127(meta) {
    _classCallCheck(this, _class127);

    QmlWeb.callSuper(this, meta);

    this.parent = meta.parent;
    // TODO: some (all ?) of the components including Repeater needs to know own
    // parent at creation time. Please consider this major change.

    this.$completed = false;
    this.$items = []; // List of created items

    this.modelChanged.connect(this, this.$onModelChanged);
    this.delegateChanged.connect(this, this.$onDelegateChanged);
    this.useItemModelChanged.connect(this, this.$getModel);
    this.parentChanged.connect(this, this.$onParentChanged);
    this.Component.completed.connect(this, this.Component$onCompleted);

    this.dom.parentNode.removeChild(this.dom);
  }

  _createClass(_class127, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      var QMLListModel = QmlWeb.getConstructor("Semantic.Html", "2.0", "ListModel");
      if (this.model instanceof QMLListModel) {
        this.model.changed.connect(this, this.$onModelChanged);
      }
      if (!(this.model || this.$properties['model'].binding)) {
        this.model = new QmlWeb.ItemModel([]);
      }
      this.$getModel();
    }
  }, {
    key: "container",
    value: function container() {
      return this.parent;
    }
  }, {
    key: "itemAt",
    value: function itemAt(index) {
      return this.$items[index];
    }
  }, {
    key: "$onModelChanged",
    value: function $onModelChanged() {
      this.$applyModel();
    }
  }, {
    key: "$onDelegateChanged",
    value: function $onDelegateChanged() {
      this.$applyModel();
    }
  }, {
    key: "$onParentChanged",
    value: function $onParentChanged() {
      this.$applyModel();
    }
  }, {
    key: "$getModel",
    value: function $getModel() {
      var QMLListModel = QmlWeb.getConstructor("Semantic.Html", "2.0", "ListModel");
      if (this.model instanceof Array && this.useItemModel) {
        var newMod = new QmlWeb.ItemModel(this.model);
        var roleNames = [];
        for (var i in this.model[0]) {
          if (i !== "index") {
            roleNames.push(i);
          }
        }
        newMod.setRoleNames(roleNames);
        this.model = newMod; // this invoke $onModelChanged automatically
        return false;
      }
      return this.model instanceof QMLListModel ? this.model.$model : this.model;
    }
  }, {
    key: "$applyModel",
    value: function $applyModel() {
      if (!this.delegate || !this.parent) {
        return;
      }
      var model = this.$getModel();
      if (model === false) {
        return; // we already invoke another modelChanged inside $getModel, so don't continue here
      }
      if (model instanceof QmlWeb.JSItemModel || model instanceof QmlWeb.ItemModel) {
        var flags = QmlWeb.Signal.UniqueConnection;
        model.dataChanged.connect(this, this.$_onModelDataChanged, flags);
        model.rowsInserted.connect(this, this.$insertChildren, flags);
        model.rowsMoved.connect(this, this.$_onRowsMoved, flags);
        model.rowsRemoved.connect(this, this.$_onRowsRemoved, flags);
        model.modelReset.connect(this, this.$_onModelReset, flags);

        this.$removeChildren(0, this.$items.length);
        this.$insertChildren(0, model.rowCount());
      } else if (typeof model === "number") {
        // must be more elegant here.. do not delete already created models..
        //this.$removeChildren(0, this.$items.length);
        //this.$insertChildren(0, model);

        if (this.$items.length > model) {
          // have more than we need
          this.$removeChildren(model, this.$items.length);
        } else {
          // need more
          this.$insertChildren(this.$items.length, model);
        }
      } else if (model instanceof Array) {
        this.$removeChildren(0, this.$items.length);
        this.$insertChildren(0, model.length);
      }
    }
  }, {
    key: "$callOnCompleted",
    value: function $callOnCompleted(child) {
      child.Component.completed();
      var QMLBaseObject = QmlWeb.getConstructor("QtQml", "2.0", "QtObject");
      for (var i = 0; i < child.$tidyupList.length; i++) {
        if (child.$tidyupList[i] instanceof QMLBaseObject) {
          this.$callOnCompleted(child.$tidyupList[i]);
        }
      }
    }
  }, {
    key: "$_onModelDataChanged",
    value: function $_onModelDataChanged(startIndex, endIndex, roles) {
      var model = this.$getModel();
      var roleNames = roles || model.roleNames;
      for (var index = startIndex; index <= endIndex; index++) {
        var _item4 = this.$items[index];
        for (var i in roleNames) {
          _item4.$properties[roleNames[i]].set(model.data(index, roleNames[i]), QmlWeb.QMLProperty.ReasonInit, _item4, this.model.$context);
        }
      }
    }
  }, {
    key: "$_onRowsMoved",
    value: function $_onRowsMoved(sourceStartIndex, sourceEndIndex, destinationIndex) {
      var vals = this.$items.splice(sourceStartIndex, sourceEndIndex - sourceStartIndex);
      for (var i = 0; i < vals.length; i++) {
        this.$items.splice(destinationIndex + i, 0, vals[i]);
      }
      var smallestChangedIndex = sourceStartIndex < destinationIndex ? sourceStartIndex : destinationIndex;
      for (var _i13 = smallestChangedIndex; _i13 < this.$items.length; _i13++) {
        this.$items[_i13].index = _i13;
      }
    }
  }, {
    key: "$_onRowsRemoved",
    value: function $_onRowsRemoved(startIndex, endIndex) {
      this.$removeChildren(startIndex, endIndex);
      for (var i = startIndex; i < this.$items.length; i++) {
        this.$items[i].index = i;
      }
      this.count = this.$items.length;
    }
  }, {
    key: "$_onModelReset",
    value: function $_onModelReset() {
      this.$applyModel();
    }
  }, {
    key: "$insertChildren",
    value: function $insertChildren(startIndex, endIndex) {
      if (endIndex <= 0) {
        this.count = 0;
        return;
      }
      var RestModel = QmlWeb.getConstructor("QmlWeb", "2.0", "RestModel");
      var QMLOperationState = QmlWeb.QMLOperationState;
      var createProperty = QmlWeb.createProperty;
      var model = this.$getModel();
      var index = void 0;
      for (index = startIndex; index < endIndex; index++) {
        var newItem = this.delegate.$createObject();
        createProperty("int", newItem, "index", { initialValue: index });

        // To properly import JavaScript in the context of a component
        this.delegate.finalizeImports();

        if (typeof model === "number" || model instanceof Array) {
          if (typeof newItem.$properties.modelData === "undefined") {
            createProperty("variant", newItem, "modelData");
          }
          var value = model instanceof Array ? model[index] : typeof model === "number" ? index : "undefined";
          newItem.$properties.modelData.set(value, QmlWeb.QMLProperty.ReasonInit, newItem, model.$context);
        } else if (model instanceof QmlWeb.ItemModel) {
          if (newItem.model && newItem.model instanceof RestModel) {
            var itemModel = newItem.model;
            itemModel.$updatePropertiesFromRepeater(model.get(index));
          }
          for (var i = 0; i < model.roleNames.length; i++) {
            var roleName = model.roleNames[i];
            if (typeof newItem.$properties[roleName] === "undefined") {
              createProperty("variant", newItem, roleName);
              newItem.$properties[roleName].set(model.data(index, roleName), QmlWeb.QMLProperty.ReasonInit, newItem, this.model.$context);
            }
          }
        } else {
          for (var _i14 = 0; _i14 < model.roleNames.length; _i14++) {
            var _roleName = model.roleNames[_i14];
            if (typeof newItem.$properties[_roleName] === "undefined") {
              createProperty("variant", newItem, _roleName);
              newItem.$properties[_roleName].set(model.data(index, _roleName), QmlWeb.QMLProperty.ReasonInit, newItem, this.model.$context);
            }
          }
        }
        var firstItem = this.$items.length == 0;
        this.$items.splice(index, 0, newItem);

        //use for setting the position of items
        if (typeof this.placeAfter === "string") {
          newItem._placeAfter = this.placeAfter;
        } else {
          // place after existing items (if exists)
          if (this.placeAfter) {
            newItem._placeAfter = this.placeAfter.dom;
          } else {
            if (index - 1 >= 0) {
              var previousItem = this.itemAt(index - 1);
              newItem._placeAfter = previousItem.dom;
            } else if (index === 0 && !firstItem) {
              newItem._placeAfter = 'first';
            }
          }
        }

        newItem._repeaterID = this.$Component.objectId;

        // parent must be set after the roles have been added to newItem scope in
        // case we are outside of QMLOperationState.Init and parentChanged has
        // any side effects that result in those roleNames being referenced.
        newItem.parent = this.parent;

        // TODO debug this. Without check to Init, Completed sometimes called
        // twice.. But is this check correct?
        if (QmlWeb.engine.firstCallCompleted) {
          // We don't call those on first creation, as they will be called
          // by the regular creation-procedures at the right time.
          this.$callOnCompleted(newItem);
        }
      }
      if (QmlWeb.engine.operationState !== QMLOperationState.Init) {
        // We don't call those on first creation, as they will be called
        // by the regular creation-procedures at the right time.
        QmlWeb.engine.$initializePropertyBindings();
      }

      if (index > 0) {
        this.container().childrenChanged();
      }

      for (var _i15 = endIndex; _i15 < this.$items.length; _i15++) {
        this.$items[_i15].index = _i15;
      }

      this.count = this.$items.length;
      this.renderCompleted();
    }
  }, {
    key: "$removeChildren",
    value: function $removeChildren(startIndex, endIndex) {
      var removed = this.$items.splice(startIndex, endIndex - startIndex);
      for (var index in removed) {
        removed[index].$delete();
        this.$removeChildProperties(removed[index]);
      }
      this.renderCompleted();
    }
  }, {
    key: "$removeChildProperties",
    value: function $removeChildProperties(child) {
      var signals = QmlWeb.engine.completedSignals;
      signals.splice(signals.indexOf(child.Component.completed), 1);
      for (var i = 0; i < child.children.length; i++) {
        this.$removeChildProperties(child.children[i]);
      }
    }
  }]);

  return _class127;
}());

QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Row",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {}
}, function () {
  function _class128(meta) {
    _classCallCheck(this, _class128);

    QmlWeb.callSuper(this, meta);
    this.baseClassName = "ui";
    this.suffixClassName = "row";
  }

  return _class128;
}());
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Schedule",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    events: { type: "var", initialValue: [] },
    size: { type: "int", initialValue: 550 },
    resources: { type: "var", initialValue: [] },
    newEvent: "var"
  },
  signals: {
    rendered: [],
    clicked: [{ type: 'var', name: 'calEvent' }, { type: 'var', name: 'jsEvent' }]
  }
}, function () {
  function _class129(meta) {
    var _this112 = this;

    _classCallCheck(this, _class129);

    QmlWeb.callSuper(this, meta);
    this.Component.completed.connect(this, this.Component$onCompleted);
    this.eventsChanged.connect(this, this.$onEventsChanged);
    this.resourcesChanged.connect(this, this.$onResourcesChanged);
    this.timePattern = /^([0-1][0-9]|[2][0-3]):([0-5][0-9])$/;
    this.datePattern = /^\d{1,2}\/\d{1,2}\/\d{4}$/;
    this.$calendar = $(this.dom);

    this.setting = {};
    this.setting["locale"] = "th";

    this.setting["header"] = {
      left: 'prevYear prev,next nextYear',
      center: 'title',
      right: 'today'
    };

    this.setting["views"] = {
      scheduleView: {
        titleFormat: 'DD MMMM B',
        resourceHeight: 100,
        slotEventOverlap: true
      }
    };

    this.setting["eventClick"] = function (calEvent, jsEvent, view) {
      _this112.clicked(calEvent, jsEvent);
    };

    this.setting["defaultView"] = "scheduleView";
    this.setting["eventAfterAllRender"] = this.onEventAfterAllRender.bind(this);
    this.setting["eventDestroy"] = this.onEventDestroy.bind(this);
  }

  _createClass(_class129, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      this.setting["events"] = this._getScheduleEvents();
      this.setting["views"]["scheduleView"]["resources"] = this.resources;
      this.$calendar.width(parseInt(this.size));
      this.$calendar.fullCalendar(this.setting);
      this.completed = true;
    }

    /* !!!!!!! DO NOT !!!!!!!!!!!! set the events to any rendered events   */

  }, {
    key: "$onEventsChanged",
    value: function $onEventsChanged() {
      if (this.bySystem || !this.events instanceof Array) {
        return;
      }
      if (this.completed) {
        var calEvents = this._getScheduleEvents.call({
          events: this.events.slice(),
          timePattern: this.timePattern,
          datePattern: this.datePattern,
          _containsResourceID: this._containsResourceID.bind(this)
        });

        this.$calendar.fullCalendar("removeEvents");
        this.$calendar.fullCalendar("renderEvents", calEvents, true);
      }
    }
  }, {
    key: "$onResourcesChanged",
    value: function $onResourcesChanged() {
      if (this.completed) {
        this.$calendar.fullCalendar('destroy');
        this.completed = false;
        this.Component$onCompleted();
      }
    }
  }, {
    key: "onEventAfterAllRender",
    value: function onEventAfterAllRender(view) {
      //Change happens to event
      this._updateEventsObject();
      this.rendered();
    }
  }, {
    key: "onEventDestroy",
    value: function onEventDestroy(event, element, view) {
      //After event is destroy
      this._updateEventsObject();
    }
  }, {
    key: "_updateEventsObject",
    value: function _updateEventsObject() {
      this.bySystem = true;
      var events = this.$calendar.fullCalendar('clientEvents');
      events.forEach(function (item) {
        if (item.start) {
          item.startDate = item.start.format("DD/MM/B");
          item.startTime = item.start.format("HH:mm");
        }
        if (item.end) {
          item.endDate = item.end.format("DD/MM/B");
          item.endTime = item.end.format("HH:mm");
        }
      });
      this.events = events;
      this.bySystem = false;
    }
  }, {
    key: "_getScheduleEvents",
    value: function _getScheduleEvents() {
      var _this113 = this;

      this.events.forEach(function (item) {
        var startValid = void 0,
            endValid = void 0,
            start = void 0,
            end = void 0,
            day = void 0,
            month = void 0,
            year = void 0;
        startValid = _this113.datePattern.test(item.startDate);
        startValid = startValid && _this113.timePattern.test(item.startTime);
        endValid = _this113.datePattern.test(item.endDate);
        endValid = endValid && _this113.timePattern.test(item.endTime);

        if (startValid) {
          var _item$startDate$split3 = item.startDate.split("/");

          var _item$startDate$split4 = _slicedToArray(_item$startDate$split3, 3);

          day = _item$startDate$split4[0];
          month = _item$startDate$split4[1];
          year = _item$startDate$split4[2];

          year = Math.max(0, Number(year) - 543);
          start = year + "-" + month + "-" + day + "T" + item.startTime + ":00";
        }

        if (endValid) {
          var _item$endDate$split3 = item.endDate.split("/");

          var _item$endDate$split4 = _slicedToArray(_item$endDate$split3, 3);

          day = _item$endDate$split4[0];
          month = _item$endDate$split4[1];
          year = _item$endDate$split4[2];

          year = Math.max(0, Number(year) - 543);
          end = year + "-" + month + "-" + day + "T" + item.endTime + ":00";
        };

        delete item.startDate;
        delete item.startTime;
        delete item.endDate;
        delete item.endTime;

        item["start"] = start;
        item["end"] = end;
      });

      //Warn user if they put resourceID that doesn't exist
      this.events.forEach(function (item) {
        if (!item.resourceID) {
          console.error('There is no resourceID provide');
          return false;
        }
        if (!_this113._containsResourceID(item.resourceID)) {
          console.error("resourceID: " + item.resourceID + " not found");
        }
      });

      return this.events;
    }
  }, {
    key: "_containsResourceID",
    value: function _containsResourceID(id) {
      var res = void 0;
      this.resources.filter(function (item) {
        if (item.id === id) {
          res = true;
        }
      });
      return res;
    }

    /* This method won't check if a new event overlap a disabled event or not   *
     * !!!!!!! DO NOT !!!!!!!!!!!! pass a rendered event                        */

  }, {
    key: "addEvent",
    value: function addEvent(event) {
      var calEvent = this._getScheduleEvents.call({
        events: [event],
        timePattern: this.timePattern,
        datePattern: this.datePattern,
        _containsResourceID: this._containsResourceID.bind(this)
      })[0];

      this.$calendar.fullCalendar('renderEvent', calEvent, true);
    }

    /*  param: id            *
     *  get it by event._id  */

  }, {
    key: "removeEvent",
    value: function removeEvent(id) {
      id && this.$calendar.fullCalendar('removeEvents', id);
    }
  }, {
    key: "removeAllEvents",
    value: function removeAllEvents() {
      this.$calendar.fullCalendar('removeEvents');
    }

    // param: the rendered event that has an id

  }, {
    key: "updateEvent",
    value: function updateEvent(event) {
      event && this.$calendar.fullCalendar('updateEvent', event);
    }
  }, {
    key: "gotoDate",
    value: function gotoDate(date) {
      var day = void 0,
          month = void 0,
          year = void 0;
      if (!this.completed) return;
      if (this.datePattern.test(date)) {
        var _date$split3 = date.split("/");

        var _date$split4 = _slicedToArray(_date$split3, 3);

        day = _date$split4[0];
        month = _date$split4[1];
        year = _date$split4[2];

        year = Math.max(0, Number(year) - 543);
        this.$calendar.fullCalendar('gotoDate', moment(year + "-" + month + "-" + day));
      }
    }
  }, {
    key: "refresh",
    value: function refresh() {
      this.$calendar.fullCalendar('render', event);
    }
  }]);

  return _class129;
}());

QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "SearchBox",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    baseURL: "string",

    /** Target field for query */
    targetField: "string",

    /** Model field name for use as title */
    title: { type: "string", initialValue: "title" },

    /** Model field name for use as description */
    description: { type: "string", initialValue: "description" },

    /** Allow using cache */
    cache: { type: "bool", initialValue: false },

    /** Min input character to start searching */
    minCharacters: { type: "int", initialValue: 1 },

    /** Number of result shown in dropdown */
    maxResults: { type: "int", initialValue: 7 },

    /** Text appeared on box */
    text: "string",

    /** Placeholder appeared on box */
    placeholder: "string",

    /** Icon appeared on box */
    icon: 'string',

    /** Use link on icon */
    linkIcon: { type: "bool", initialValue: false },

    /** Object of selected item */
    selectedRow: "var",

    /** id of selected item */
    selectedId: { type: "int", initialValue: -1 },

    // validation and control
    /** Enable this SearchBox */
    enabled: { type: "bool", initialValue: true },

    /** Set this SearchBox read only */
    readOnly: { type: "bool", initialValue: false },

    /** Error message */
    serverErrorMsg: { type: "string", initialValue: 'There was an issue with querying the server.' }
  },
  signals: {
    selected: [],
    searchClicked: []
  }
}, function () {
  function _class130(meta) {
    var _iconDom$classList4,
        _this114 = this;

    _classCallCheck(this, _class130);

    QmlWeb.callSuper(this, meta);
    this.Component.completed.connect(this, this.Component$onCompleted);
    this.textChanged.connect(this, this.$onTextChanged);
    this.baseURLChanged.connect(this, this.$onBaseURLTargetChanged);
    this.targetFieldChanged.connect(this, this.$onBaseURLTargetChanged);
    this.titleChanged.connect(this, this.$onFieldsChanged);
    this.descriptionChanged.connect(this, this.$onFieldsChanged);
    this.linkIconChanged.connect(this, this.$onLinkIconChanged);
    this.enabledChanged.connect(this, this.$onEnabledChanged);
    this.readOnlyChanged.connect(this, this.$onReadOnlyChanged);
    this.placeholderChanged.connect(this, this.$onPlaceholderChanged);
    this.iconChanged.connect(this, this.$onIconChanged);

    this.suffixClassName = "fluid search";

    this.inputContainer = document.createElement("div");
    this.inputContainer.classList.add("ui", "icon", "input");

    this.input = document.createElement("input");
    this.input.type = "text";
    this.input.classList.add("prompt");

    this._icon = ["search"];
    this.iconDom = document.createElement("i");
    (_iconDom$classList4 = this.iconDom.classList).add.apply(_iconDom$classList4, _toConsumableArray(this._icon).concat(["icon"]));

    this.results = document.createElement("div");
    this.results.classList.add("results");

    this.inputContainer.appendChild(this.input);
    this.inputContainer.appendChild(this.iconDom);
    this.dom.appendChild(this.inputContainer);
    this.dom.appendChild(this.results);

    this.input.addEventListener("keyup", function () {
      _this114.updateValue();
    });
    this.input.addEventListener("focus", function () {
      _this114.input.select();
    });
    this.iconDom.addEventListener("click", function () {
      _this114.searchClicked();
    });
  }

  _createClass(_class130, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      var _this115 = this;

      $(document).ready(function () {
        _this115.searchBox = $(_this115.dom).search({
          apiSettings: {
            url: _this115.baseURL + '?' + _this115.targetField + '={query}'
          },
          fields: {
            results: 'items',
            title: _this115.title,
            description: _this115.description
          },
          cache: _this115.cache,
          error: {
            serverError: _this115.serverErrorMsg
          },
          minCharacters: _this115.minCharacters,
          maxResults: _this115.maxResults,
          onSelect: _this115.$onSelect.bind(_this115)
        });
      });
    }
  }, {
    key: "updateValue",
    value: function updateValue() {
      this.bySystem = true;
      this.text = this.input.value;
      if (!this.input.value.length) {
        this.selectedId = -1;
      }
      this.bySystem = false;
    }
  }, {
    key: "query",
    value: function query() {
      if (!this.searchBox) return;
      this.searchBox.search('query');
    }
  }, {
    key: "clear",
    value: function clear() {
      this.selectedRow = null;
      this.selectedId = -1;
      this.text = '';
    }
  }, {
    key: "$onSelect",
    value: function $onSelect(result, response) {
      this.selectedRow = result;
      this.selectedId = result.id;
      this.bySystem = true;
      this.text = result[this.title];
      this.bySystem = false;

      this.selected();
    }
  }, {
    key: "$onBaseURLTargetChanged",
    value: function $onBaseURLTargetChanged() {
      if (!this.searchBox) return;
      this.searchBox.search('setting', {
        apiSettings: {
          url: this.baseURL + '?' + this.targetField + '={query}'
        }
      });
    }
  }, {
    key: "$onFieldsChanged",
    value: function $onFieldsChanged() {
      if (!this.searchBox) return;
      this.searchBox.search('setting', {
        fields: {
          results: 'items',
          title: this.title,
          description: this.description
        }
      });
    }
  }, {
    key: "$onTextChanged",
    value: function $onTextChanged() {
      if (!this.bySystem) this.input.value = this.text;
    }
  }, {
    key: "$onPlaceholderChanged",
    value: function $onPlaceholderChanged() {
      this.input.placeholder = this.placeholder;
    }
  }, {
    key: "$onIconChanged",
    value: function $onIconChanged() {
      var _iconDom$classList5, _iconDom$classList6;

      this.icon = this.icon.replace(/  +/g, ' ');
      var iconList = this.icon.split(' ');

      (_iconDom$classList5 = this.iconDom.classList).remove.apply(_iconDom$classList5, _toConsumableArray(this._icon));
      (_iconDom$classList6 = this.iconDom.classList).add.apply(_iconDom$classList6, _toConsumableArray(iconList));
      this._icon = iconList;
    }
  }, {
    key: "$onLinkIconChanged",
    value: function $onLinkIconChanged() {
      if (this.linkIcon) {
        this.iconDom.classList.add("link");
      } else {
        this.iconDom.classList.remove("link");
      }
    }
  }, {
    key: "$onEnabledChanged",
    value: function $onEnabledChanged() {
      this.input.disabled = true;
      if (!this.enabled) this.input.disabled = false;
    }
  }, {
    key: "$onReadOnlyChanged",
    value: function $onReadOnlyChanged() {
      this.dom.style.pointerEvents = 'none';
      if (!this.readOnly) this.dom.style.pointerEvents = 'auto';
    }
  }, {
    key: "setData",
    value: function setData(data) {
      this.selectedRow = data;
      this.selectedId = data.id;
      this.text = data[this.title];
      this.selected();
    }
  }]);

  return _class130;
}());

QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Segment",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    dataTab: "string",
    color: "string"
  },
  signals: {
    dblclicked: []
  }
}, function () {
  function _class131(meta) {
    _classCallCheck(this, _class131);

    QmlWeb.callSuper(this, meta);
    this.dataTabChanged.connect(this, this.$onDataTabChanged);
    this.colorChanged.connect(this, this.$onColorChanged);
    this.displayNoneChanged.connect(this, this.$onDisplayNoneChanged);
    this.baseClassName = "ui";
    this.suffixClassName = "segment";

    this.dom.ondblclick = this.dblclicked;
  }

  _createClass(_class131, [{
    key: "destructor",
    value: function destructor() {
      this.dom.ondblclick = null;
      this.dom = null;
    }
  }, {
    key: "$onColorChanged",
    value: function $onColorChanged() {
      var _validateProperty13 = this.validateProperty(this.color),
          _validateProperty14 = _slicedToArray(_validateProperty13, 2),
          pass = _validateProperty14[0],
          css = _validateProperty14[1];

      if (!pass) return;
      this.dom.classList.remove("" + this._color);
      if (!css) return; // return if css is "" prevent error when call classList.add with ""
      this.dom.classList.add(css);
      this._color = this.color;
    }
  }, {
    key: "validateProperty",
    value: function validateProperty(prop) {
      var colorList = ["", "red", "orange", "yellow", "olive", "green", "teal", "blue", "violet", "purple", "pink", "brown", "grey", "black"];

      if (prop || prop === "") {
        // prevent error from undefined prop and allow property ""
        prop = prop.toLowerCase();
        if (colorList.includes(prop)) {
          return [true, "" + prop];
        }
      }
      return [false, ""];
    }
  }, {
    key: "$onDataTabChanged",
    value: function $onDataTabChanged() {
      this.dom.setAttribute("data-tab", this.dataTab);
      if (this.dataTab && this.suffixClassName.indexOf('tab') === -1) {
        this.suffixClassName = "tab" + " " + this.suffixClassName;
      } else {
        this.suffixClassName = this.suffixClassName.replace("tab", "").trim();
      }
    }
  }, {
    key: "$onDisplayNoneChanged",
    value: function $onDisplayNoneChanged() {
      if (this.displayNone) this.dom.style.display = "none";else this.dom.style.display = "";

      // fix header of dgrid when displayNone changed
      document.body.dispatchEvent(new CustomEvent("resizeDgrid", {
        detail: {
          dom: this.dom
        }
      }));
    }
  }]);

  return _class131;
}());

QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Segments",
  versions: /.*/,
  baseClass: "Semantic.Html.Segment", // inherited from Segment
  properties: {}
}, function () {
  function _class132(meta) {
    _classCallCheck(this, _class132);

    QmlWeb.callSuper(this, meta);
    this.baseClassName = "ui";
    this.suffixClassName = "segments";
  }

  return _class132;
}());
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Sidebar",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    content: "var"
  },
  signal: {}
}, function () {
  function _class133(meta) {
    _classCallCheck(this, _class133);

    QmlWeb.callSuper(this, meta);
    this.Component.completed.connect(this, this.Component$onCompleted);
    this.contentChanged.connect(this, this.$onContentChanged);

    this.suffixClassName = "sidebar";
  }

  _createClass(_class133, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      var _this116 = this;

      $(document).ready(function () {
        return $(_this116.dom).sidebar({
          transition: "overlay"
        });
      });
    }
  }, {
    key: "$onContentChanged",
    value: function $onContentChanged() {
      this.content.dom.classList.add("pusher");
      document.body.appendChild(this.content.dom);
    }
  }, {
    key: "toggle",
    value: function toggle() {
      $(this.dom).sidebar('toggle');
    }
  }]);

  return _class133;
}());
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Sticky",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    context: "string",
    mannualRefresh: "bool"
  }
}, function () {
  function _class134(meta) {
    _classCallCheck(this, _class134);

    QmlWeb.callSuper(this, meta);
    this.Component.completed.connect(this, this.Component$onCompleted);
    this.mannualRefreshChanged.connect(this, this.$onMannualRefreshChanged);
    this.contextChanged.connect(this, this.$onContextChanged);
    this.baseClassName = "ui";
    this.suffixClassName = "sticky";
  }

  _createClass(_class134, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {}
  }, {
    key: "$onContextChanged",
    value: function $onContextChanged() {
      var _this117 = this;

      $(document).ready(function () {
        _this117.context = !_this117.context.dom ? _this117.context : _this117.context.dom, _this117.sticky = $(_this117.dom).sticky({
          context: _this117.context
        });
        _this117.$onMannualRefreshChanged();
      });
    }
  }, {
    key: "$onMannualRefreshChanged",
    value: function $onMannualRefreshChanged() {
      var _this118 = this;

      if (!this.context) return;
      $(document).ready(function () {
        if (_this118.mannualRefresh && _this118.observer) {
          _this118.observer.disconnect();
          _this118.observer = null;
        }
        if (!_this118.mannualRefresh && !_this118.observer) {
          _this118.observer = new MutationObserver(_this118.refreshSticky.bind(_this118));
          _this118.observer.observe($(_this118.context)[0], {
            childList: true, //observe adding and removing
            subtree: true, //observe mutation
            attributeFilter: ["style", "class"]
          });
        }
      });
    }
  }, {
    key: "refreshSticky",
    value: function refreshSticky(mutations) {
      var _this119 = this;

      //disconnect observer before refresh sticky
      //to prevent observing sticky's style changes
      //and making infinity observing loop
      this.observer.disconnect();
      this.observer = null;
      //wait for animation complete and refresh sticky
      setTimeout(function () {
        return _this119.sticky.sticky("refresh");
      }, 200);
      //after refresh sticky
      //observe this context for any change again
      setTimeout(function () {
        return _this119.$onMannualRefreshChanged();
      }, 300);
    }
  }]);

  return _class134;
}());
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Tab",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    headerStyle: { type: "string", initialValue: "default" },
    height: { type: "int", initialValue: "-1" }
  },
  signals: {}
}, function () {
  function _class135(meta) {
    _classCallCheck(this, _class135);

    QmlWeb.callSuper(this, meta);
    this.Component.completed.connect(this, this.Component$onCompleted);
    this.headerStyleChanged.connect(this, this.$onHeaderStyleChanged);
    this.heightChanged.connect(this, this.$onHeightChanged);
    this.headerNode = document.createElement("div");
    this.headerNode.classList.add("ui", "top", "attached", "menu", "tabular");
    this.dom.appendChild(this.headerNode);
  }

  _createClass(_class135, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      var _this120 = this;

      var aNode = void 0,
          headerList = [];
      //create tab header
      this.children.forEach(function (child) {
        aNode = document.createElement("a");
        aNode.classList.add("item");
        aNode.innerHTML = child.text;
        aNode.setAttribute("data-tab", child.timestamp);
        aNode.onclick = child.onUserSelect.bind(child);

        _this120.headerNode.appendChild(aNode);
        child.jObject = $(aNode);
        headerList.push(aNode);
      });

      $(document).ready(function () {
        var index = headerList.length - 1;
        var _iteratorNormalCompletion12 = true;
        var _didIteratorError12 = false;
        var _iteratorError12 = undefined;

        try {
          for (var _iterator12 = headerList.reverse()[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
            var _aNode = _step12.value;

            $(_aNode).tab({
              context: 'parent',
              onVisible: _this120.onVisible.bind(null, _this120.children[index--].dom)
            });
            $(_aNode).tab("change tab", _aNode.getAttribute("data-tab"));
          }
        } catch (err) {
          _didIteratorError12 = true;
          _iteratorError12 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion12 && _iterator12.return) {
              _iterator12.return();
            }
          } finally {
            if (_didIteratorError12) {
              throw _iteratorError12;
            }
          }
        }
      });
    }
  }, {
    key: "onVisible",
    value: function onVisible(dom) {
      document.body.dispatchEvent(new CustomEvent("resizeDgrid", {
        detail: {
          dom: dom
        }
      }));
    }
  }, {
    key: "$onHeightChanged",
    value: function $onHeightChanged() {
      var _this121 = this;

      if (this.height > 0) {
        this.children.forEach(function (child) {
          child.dom.style.overflowY = "auto";
          child.dom.style.height = _this121.height + "px";
        });
      }
    }
  }, {
    key: "$onHeaderStyleChanged",
    value: function $onHeaderStyleChanged() {
      if (!this.headerNode) return;

      this.headerNode.classList.remove("pointing", "secondary", "top", "attached");

      if (this.headerStyle === "line") {
        this.headerNode.classList.add("pointing", "secondary");
        this.headerNode.style.marginBottom = "0px";
      } else {
        this.headerNode.classList.add("top", "attached");
      }
    }
  }]);

  return _class135;
}());
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "TabContent",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    text: "string"
  },
  signals: {
    selected: [{ type: "bool", name: "bySystem" }]
  }
}, function () {
  function _class136(meta) {
    _classCallCheck(this, _class136);

    QmlWeb.callSuper(this, meta);
    this.textChanged.connect(this, this.$onTextChanged);
    this.dom.classList.add("ui", "bottom", "attached", "tab", "segment");
    //Fix segment style bug
    this.dom.style.marginBottom = "0px";
    this.timestamp = "" + Date.now();
  }

  _createClass(_class136, [{
    key: "$onTextChanged",
    value: function $onTextChanged() {
      this.dom.setAttribute("data-tab", this.timestamp);
    }
  }, {
    key: "loading",
    value: function loading() {
      this.select();
      this.jObject.tab('set loading', this.timestamp);
    }
  }, {
    key: "select",
    value: function select() {
      this.jObject.tab('change tab', this.timestamp);
      this.selected(true);
    }
  }, {
    key: "onUserSelect",
    value: function onUserSelect() {
      this.selected(false);
    }
  }]);

  return _class136;
}());
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Text",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {}
}, function () {
  function _class137(meta) {
    _classCallCheck(this, _class137);

    meta.object.tagName = "span";
    QmlWeb.callSuper(this, meta);
  }

  return _class137;
}());
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "TextArea",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    text: "string",
    placeholder: "string",
    focused: "bool",
    rows: "int",
    maxLength: "int",
    dataValidate: "string",
    readOnly: { type: "bool", initialValue: false },
    enabled: { type: "bool", initialValue: true }
  },
  signals: {
    clicked: [],
    entered: [], // user press [Enter]
    changed: [],
    blured: [],
    keyUped: [{ type: "string", name: "keyCode" }],
    keyDowned: [{ type: "string", name: "event" }]
  }
}, function () {
  function _class138(meta) {
    _classCallCheck(this, _class138);

    QmlWeb.callSuper(this, meta);
    this.focusedChanged.connect(this, this.$onFocusChanged);
    this.placeholderChanged.connect(this, this.$onPlaceholderChanged);
    this.rowsChanged.connect(this, this.$onRowsChanged);
    this.textChanged.connect(this, this.$onTextChanged);
    this.maxLengthChanged.connect(this, this.$onMaxLengthChanged);
    this.readOnlyChanged.connect(this, this.$onReadOnlyChanged);
    this.dataValidateChanged.connect(this, this.$onDataValidateChanged);
    this.enabledChanged.connect(this, this.$onEnabledChanged);

    this.textarea = document.createElement("textarea");
    this.textarea.style = "resize: none";
    if (this.rows) {
      this.textarea.rows = this.rows;
    }
    this.textarea.addEventListener("keyup", this.updateValue.bind(this));
    this.textarea.addEventListener("change", this.updateValue.bind(this));

    this.dom = this.textarea;
  }

  _createClass(_class138, [{
    key: "updateValue",
    value: function updateValue() {
      this.bySystem = true;
      this.text = this.textarea.value;
      this.bySystem = false;
    }
  }, {
    key: "setFocus",
    value: function setFocus() {
      var _this122 = this;

      if (this.focused) requestAnimationFrame(function () {
        return _this122.textarea.focus();
      });
    }

    //override

  }, {
    key: "$onHtmlIDChanged",
    value: function $onHtmlIDChanged() {
      this.textarea.id = this.htmlID;
    }
  }, {
    key: "$onDataValidateChanged",
    value: function $onDataValidateChanged() {
      this.textarea.setAttribute("data-validate", this.dataValidate);
    }
  }, {
    key: "$onReadOnlyChanged",
    value: function $onReadOnlyChanged() {
      if (this.readOnly) $(this.textarea).prop("readonly", true);else $(this.textarea).prop("readonly", false);
    }
  }, {
    key: "$onFocusChanged",
    value: function $onFocusChanged() {
      this.setFocus();
    }
  }, {
    key: "$onPlaceholderChanged",
    value: function $onPlaceholderChanged() {
      this.textarea.placeholder = this.placeholder;
    }
  }, {
    key: "$onRowsChanged",
    value: function $onRowsChanged() {
      this.textarea.rows = this.rows;
    }
  }, {
    key: "$onTextChanged",
    value: function $onTextChanged() {
      if (!this.bySystem) $(this.textarea).val(this.text);
    }
  }, {
    key: "$onMaxLengthChanged",
    value: function $onMaxLengthChanged() {
      this.textarea.maxLength = this.maxLength;
    }
  }, {
    key: "$onEnabledChanged",
    value: function $onEnabledChanged() {
      this.textarea.removeAttribute("disabled");
      if (!this.enabled) {
        this.textarea.setAttribute("disabled", "");
      }
    }
  }]);

  return _class138;
}());

QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "TextBox",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    text: "string",
    size: "string",
    state: "string",
    placeholder: "string",
    focused: "bool",
    loading: "bool",
    error: "bool",
    textLength: "string",
    inputType: "string",
    inputName: "string",
    dataValidate: "string",
    readOnly: { type: "bool", initialValue: false },
    enabled: { type: "bool", initialValue: true },
    inputStyle: "string",
    inputAttr: "val",
    formatter: "var"
  },
  signals: {
    clicked: [],
    entered: [], // user press [Enter]
    changed: [],
    blured: [],
    keyUped: [{ type: "string", name: "keyCode" }],
    keyDowned: [{ type: "string", name: "event" }]
  }
}, function () {
  function TextBox(meta) {
    var _this123 = this;

    _classCallCheck(this, TextBox);

    QmlWeb.callSuper(this, meta);
    this.Component.completed.connect(this, this.Component$onCompleted);
    this.textChanged.connect(this, this.$onTextChanged);
    this.enabledChanged.connect(this, this.$onEnabledChanged);
    this.focusedChanged.connect(this, this.$onFocusChanged);
    this.sizeChanged.connect(this, this.$onSizeChanged);
    this.readOnlyChanged.connect(this, this.$onReadOnlyChanged);
    this.loadingChanged.connect(this, this.$onLoadingChanged);
    this.errorChanged.connect(this, this.$onErrorChanged);
    this.placeholderChanged.connect(this, this.$onPlaceholderChanged);
    this.textLengthChanged.connect(this, this.$onTextLengthChanged);
    this.inputTypeChanged.connect(this, this.$onInputTypeChanged);
    this.inputNameChanged.connect(this, this.$onInputNameChanged);
    this.dataValidateChanged.connect(this, this.$onDataValidateChanged);
    this.inputStyleChanged.connect(this, this.$onInputStyleChanged);
    this.inputAttrChanged.connect(this, this.$onInputAttrChanged);

    this.inputContainer = document.createElement("div");
    this.inputContainer.classList.add("ui", "input");
    this.input = document.createElement("input");
    this.input.type = "text";
    this.input.addEventListener("click", function () {
      return _this123.clicked();
    });
    this.input.addEventListener("blur", function () {
      return _this123.blured();
    });
    this.input.addEventListener("focus", function () {
      return _this123.input.select();
    });
    this.input.addEventListener("change", function () {
      return _this123.updateValue();
    });
    this.input.addEventListener("keyup", function (evt) {
      _this123.updateValue();
      evt.keyCode === 13 && _this123.entered();
      _this123.keyUped(evt.keyCode);
    });
    this.input.addEventListener("keydown", function (evt) {
      _this123.keyDowned(evt);
    });
    this.inputContainer.appendChild(this.input);
    this.dom = this.inputContainer;

    this.suffixClassName = "input";
  }

  _createClass(TextBox, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      var _this124 = this;

      if (!this.dom.classList.contains("right")) {
        this.children.forEach(function (child) {
          if (child.dom.classList.contains("label")) {
            _this124.dom.insertBefore(child.dom, _this124.input);
          }
        });
      }
    }

    //override

  }, {
    key: "$onHtmlIDChanged",
    value: function $onHtmlIDChanged() {
      this.input.id = this.htmlID;
    }
  }, {
    key: "$onDataValidateChanged",
    value: function $onDataValidateChanged() {
      this.input.setAttribute("data-validate", this.dataValidate);
    }
  }, {
    key: "$onTextChanged",
    value: function $onTextChanged() {
      if (!this.bySystem) {
        if (this.formatter) {
          this.input.value = this.formatter(this.text);
        } else {
          this.input.value = this.text;
        }
      }
    }
  }, {
    key: "$onReadOnlyChanged",
    value: function $onReadOnlyChanged() {
      if (this.readOnly) $(this.input).prop("readonly", true);else $(this.input).prop("readonly", false);
    }
  }, {
    key: "updateValue",
    value: function updateValue() {
      this.bySystem = true;
      this.text = this.input.value;
      this.bySystem = false;
      this.changed();
    }
  }, {
    key: "$onEnabledChanged",
    value: function $onEnabledChanged() {
      this.input.removeAttribute("disabled");
      if (!this.enabled) {
        this.input.setAttribute("disabled", "");
      }
    }
  }, {
    key: "setFocus",
    value: function setFocus() {
      var _this125 = this;

      if (this.focused) requestAnimationFrame(function () {
        return _this125.input.focus();
      });
    }
  }, {
    key: "$onFocusChanged",
    value: function $onFocusChanged() {
      this.setFocus();
    }
  }, {
    key: "validateProperty",
    value: function validateProperty(prop) {
      var TEXTBOX_SIZE = ["mini", "small", "large", "big", "huge", "massive"];
      prop = prop.toLowerCase();
      if (TEXTBOX_SIZE.includes(prop)) return [true, "" + prop];
      return [false, ""];
    }
  }, {
    key: "$onSizeChanged",
    value: function $onSizeChanged() {
      var _validateProperty15 = this.validateProperty(this.size),
          _validateProperty16 = _slicedToArray(_validateProperty15, 2),
          pass = _validateProperty16[0],
          css = _validateProperty16[1];

      if (!pass) return;
      if (this._size) this.inputContainer.classList.remove("" + this._size);
      this.inputContainer.classList.add(css);
      this._size = this.size;
    }
  }, {
    key: "$onPlaceholderChanged",
    value: function $onPlaceholderChanged() {
      this.input.placeholder = this.placeholder;
    }
  }, {
    key: "$onLoadingChanged",
    value: function $onLoadingChanged() {
      if (this.loading) {
        this.icon = document.createElement("i");
        this.icon.classList.add("refresh", "icon");
        this.inputContainer.classList.add("icon", "loading");
        this.inputContainer.appendChild(this.icon);
      } else {
        this.inputContainer.classList.remove("icon", "loading");
        this.inputContainer.removeChild(this.icon);
        this.icon = null;
      }
    }
  }, {
    key: "$onErrorChanged",
    value: function $onErrorChanged() {
      this.inputContainer.classList.remove("error");
      if (this.error) this.inputContainer.classList.add("error");
    }
  }, {
    key: "$onTextLengthChanged",
    value: function $onTextLengthChanged() {
      this.input.setAttribute('maxlength', this.textLength);
    }
  }, {
    key: "$onInputTypeChanged",
    value: function $onInputTypeChanged() {
      this.input.type = this.inputType;
    }
  }, {
    key: "$onInputNameChanged",
    value: function $onInputNameChanged() {
      this.input.name = this.inputName;
    }
  }, {
    key: "$onInputStyleChanged",
    value: function $onInputStyleChanged() {
      this.input.style = this.inputStyle;
    }
  }, {
    key: "$onInputAttrChanged",
    value: function $onInputAttrChanged() {
      var newVal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      $(this.input).attr(newVal);
    }
  }]);

  return TextBox;
}());

QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "TextBoxIcon",
  versions: /.*/,
  baseClass: "Semantic.Html.TextBox",
  properties: {
    icon: "string"
  },
  signals: {
    iconClicked: []
  }
}, function () {
  function _class139(meta) {
    _classCallCheck(this, _class139);

    QmlWeb.callSuper(this, meta);
    this.Component.completed.connect(this, this.Component$onCompleted);
    this.iconChanged.connect(this, this.$onIconChanged);
  }

  _createClass(_class139, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      this.completed = true;
      this.addOrRemoveIcon();
    }
  }, {
    key: "$onIconChanged",
    value: function $onIconChanged() {
      if (this.completed) {
        this.addOrRemoveIcon();
      }
    }
  }, {
    key: "addOrRemoveIcon",
    value: function addOrRemoveIcon() {
      if (this.icon !== "") {
        this.removeIcon();
        this.addIcon();
      } else {
        this.removeIcon();
      }
    }
  }, {
    key: "removeIcon",
    value: function removeIcon() {
      this.inputContainer.classList.remove("icon");
      $(this.inputContainer).find('i.icon').off('click', this.iconClick.bind(this));
      $(this.inputContainer).find('i.icon').remove();
    }
  }, {
    key: "addIcon",
    value: function addIcon() {
      this.inputContainer.classList.remove("input");
      this.inputContainer.classList.add("icon");
      this.inputContainer.classList.add("input");
      this.inputContainer.insertAdjacentElement("beforeend", $("<i class=\"" + this.icon + " link icon\"></i>")[0]);
      $(this.inputContainer).find('i.icon').on('click', this.iconClick.bind(this));
    }
  }, {
    key: "iconClick",
    value: function iconClick() {
      this.iconClicked();
    }
  }]);

  return _class139;
}());
QmlWeb.registerQmlType({
  module: 'Semantic.Html',
  name: 'TimeTextBox',
  versions: /.*/,
  baseClass: 'Semantic.Html.Dom',
  properties: {
    /** The time of the first item in the combobox */
    startTime: 'string',

    /** Separation in minutes between time entries in the dropdown menu */
    interval: 'int',

    /** Time setting */
    text: 'string',

    // validation and control
    /** Enable this TimeTextBox */
    enabled: { type: 'bool', initialValue: true },

    /** Set this TimeTextBox read only */
    readOnly: { type: 'bool', initialValue: false }
  },
  signals: {
    changed: [{ type: 'string', name: 'time' }, { type: 'var', name: 'datetime' }]
  }
}, function () {
  function _class140(meta) {
    var _this126 = this;

    _classCallCheck(this, _class140);

    QmlWeb.callSuper(this, meta);
    this.Component.completed.connect(this, this.Component$onCompleted);
    this.textChanged.connect(this, this.$onTextChanged);
    this.startTimeChanged.connect(this, this.$onStartTimeChanged);
    this.enabledChanged.connect(this, this.$onEnabledChanged);
    this.readOnlyChanged.connect(this, this.$onReadOnlyChanged);

    this.suffixClassName = 'icon input timetextbox';

    this.input = document.createElement('input');
    this.input.classList.add('timepicker');
    this.input.type = 'text';
    this.icon = document.createElement('i');
    this.icon.classList.add('wait', 'link', 'icon');
    this.icon.setAttribute('title', 'เวลาปัจจุบัน');

    this.dom.appendChild(this.input);
    this.dom.appendChild(this.icon);
    this.input.addEventListener('click', function () {
      _this126.$onInputClicked();
    });
    this.icon.addEventListener('click', function () {
      _this126.$onIconClicked();
    });

    this.functionList = [];
  }

  _createClass(_class140, [{
    key: "$setupTimeTextBox",
    value: function $setupTimeTextBox() {
      $(this.input).timepicker(this.setting);
      this.timepicker = $(this.input).timepicker();

      var _iteratorNormalCompletion13 = true;
      var _didIteratorError13 = false;
      var _iteratorError13 = undefined;

      try {
        for (var _iterator13 = this.functionList[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
          func = _step13.value;

          func.bind(this)();
        }
      } catch (err) {
        _didIteratorError13 = true;
        _iteratorError13 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion13 && _iterator13.return) {
            _iterator13.return();
          }
        } finally {
          if (_didIteratorError13) {
            throw _iteratorError13;
          }
        }
      }
    }
  }, {
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      var _this127 = this;

      this.setting = {
        timeFormat: 'HH:mm',
        dropdown: true,
        scrollbar: true,
        change: this.$onChanged.bind(this)
      };
      if (this.interval) {
        this.setting.interval = this.interval;
      }
      if (this.startTime) {
        this.setting.startTime = this.startTime;
      }
      if (this.text) {
        this.setting.defaultTime = this.text;
      }
      $(document).ready(function () {
        _this127.$setupTimeTextBox();
      });
    }
  }, {
    key: "$onChanged",
    value: function $onChanged(time) {
      if (!this.timepicker) return;

      if (time) {
        var formatted_time = this.timepicker.format(time);
        this.bySystem = true;
        this.text = formatted_time;
        this.input.value = formatted_time;
        this.bySystem = false;
      } else if (time === false) {
        this.bySystem = true;
        this.text = '';
        this.input.value = '';
        this.bySystem = false;
      }

      this.changed(time, this.text);
    }
  }, {
    key: "$onTextChanged",
    value: function $onTextChanged() {
      if (!this.timepicker) {
        this.functionList.push(this.$onTextChanged);
        return;
      }
      if (this.bySystem) return;

      this.timepicker.setTime(this.text);
    }
  }, {
    key: "$onStartTimeChanged",
    value: function $onStartTimeChanged() {
      if (!this.timepicker) return;

      this.timepicker.option('startTime', this.startTime);
    }
  }, {
    key: "$onEnabledChanged",
    value: function $onEnabledChanged() {
      this.input.removeAttribute('disabled');
      this.icon.classList.add('link');
      if (!this.enabled) {
        this.input.setAttribute('disabled', '');
        this.icon.classList.remove('link');
      }
    }
  }, {
    key: "$onReadOnlyChanged",
    value: function $onReadOnlyChanged() {
      this.dom.style.pointerEvents = 'auto';
      if (this.readOnly) {
        this.dom.style.pointerEvents = 'none';
      }
    }
  }, {
    key: "$onInputClicked",
    value: function $onInputClicked() {
      // Select all when clicked
      this.input.select();
    }
  }, {
    key: "$onIconClicked",
    value: function $onIconClicked() {
      // Change time to now
      this.$onChanged(new Date());
    }
  }]);

  return _class140;
}());

require(["dijit/TooltipDialog", "dijit/popup"], function (TooltipDialog, popup) {
  QmlWeb.registerQmlType({
    module: "Semantic.Html",
    name: "TooltipDialog",
    versions: /.*/,
    baseClass: "Item",
    properties: {
      target: { type: "var", initialValue: {} },
      activeEvent: { type: "string", initialValue: "hover" },
      style: { type: "var", initialValue: '' },

      /** should toggle show/hide when clicking on target dom */
      toggle: { type: "bool", initialValue: true },
      disabled: "bool"
    },
    signals: {
      shown: [],
      hidden: [],
      outSideClicked: []
    }
  }, function () {
    function _class141(meta) {
      _classCallCheck(this, _class141);

      QmlWeb.callSuper(this, meta);
      this.Component.completed.connect(this, this.Component$onCompleted);
      this.activeEventChanged.connect(this, this.$onActiveEventChanged);
      this.targetChanged.connect(this, this.$onTargetChanged);
      this.styleChanged.connect(this, this.$onStyleChanged);
      this._show = this.show.bind(this);
      this._hide = this.hide.bind(this);
      this._hideGracefully = this.hideGracefully.bind(this);
      this.showing = false;
    }

    _createClass(_class141, [{
      key: "Component$onCompleted",
      value: function Component$onCompleted() {
        this.widget = new TooltipDialog({
          content: this.dom.childNodes,
          style: this.style,
          onMouseLeave: this.onMouseLeave.bind(this),
          onHide: this.onHide.bind(this),
          onShow: this.onShow.bind(this),
          onKeyDown: function onKeyDown(event) {
            // workaround for fixing indefinitely activates ComboBox in TooltipDialog
            if (event.keyCode === 13) {
              event.stopImmediatePropagation();
            }
          }
        });
      }
    }, {
      key: "$onStyleChanged",
      value: function $onStyleChanged() {
        if (!this.completed) {
          return;
        }
        this.widget.set('style', this.style);
      }
    }, {
      key: "$onTargetChanged",
      value: function $onTargetChanged(newVal, oldVal) {
        if (!newVal) {
          return;
        }
        if (!newVal.dom) {
          return;
        }
        //unbind old target and bind new target
        this.$onActiveEventChanged(this.activeEvent, this.activeEvent);
      }
    }, {
      key: "$onActiveEventChanged",
      value: function $onActiveEventChanged(newVal, oldVal) {
        if (!newVal) {
          return;
        }
        if (!this.target) {
          return;
        }
        if (!this.target.dom) {
          return;
        }
        if (!oldVal) {
          oldVal = '';
        }
        if (oldVal === 'hover') {
          this.target.dom.removeEventListener('mouseenter', this._show);
          this.target.dom.removeEventListener('mouseleave', this._hide);
        } else {
          this.target.dom.removeEventListener(oldVal, this._show);
        }
        if (newVal === 'hover') {
          this.target.dom.addEventListener('mouseenter', this._show);
          this.target.dom.addEventListener('mouseleave', this._hide);
        } else {
          this.target.dom.addEventListener(newVal, this._show);
        }
      }
    }, {
      key: "hideGracefully",
      value: function hideGracefully(event) {
        var $target = $(event.target);
        var isInDOM = $.contains(document.documentElement, event.target);
        var inPopup = $target.closest('.dijitPopup.dijitTooltipDialogPopup').length > 0;

        // don't close on clicks inside popup
        if (event && !inPopup && isInDOM) {
          // Click occurred outside popup hiding popup
          this.hide();
          this.outSideClicked();
        }
      }
    }, {
      key: "onMouseLeave",
      value: function onMouseLeave(event) {
        if (['hover', 'mouseover', 'mouseenter'].indexOf(this.activeEvent) !== -1) {
          popup.close(this.widget);
        }
      }
    }, {
      key: "onHide",
      value: function onHide(event) {
        //unbind close event
        //incase changing activeElement when dialog is still showing
        $(document).off('click', this._hideGracefully);
        this.showing = false;
        this.hidden();
      }
    }, {
      key: "onShow",
      value: function onShow(event) {
        var _this128 = this;

        setTimeout(function () {
          $(document).on('click', _this128._hideGracefully);
        }

        // workaround for fixing dojo fire onShow event twice
        // when tooltip is shown for the first time
        );if (!this.showing) {
          this.showing = true;
          this.shown();
        }
      }

      /**
       * return true if a target has registered to tooltip
       * @param {var} target - QML_ID or DOM
       */

    }, {
      key: "hasTargetRegistered",
      value: function hasTargetRegistered(target) {
        var dom = target;

        if (!target) {
          dom = {};
        }
        if (target.dom) {
          dom = target.dom;
        }
        if (dom instanceof Element && dom.isSameNode(this.target.dom)) {
          return true;
        } else {
          return false;
        }
      }
    }, {
      key: "show",
      value: function show() {
        if (!this.target) {
          return;
        }
        if (!this.target.dom) {
          return;
        }
        if (this.disabled) {
          this.hide();
          return;
        }

        if (this.toggle && this.showing && this.activeEvent === 'click') {
          this.hide();
        } else {
          // fix positioning bug with modal
          var popupContent = this.widget.domNode;
          var popupContainer = popupContent.parentElement;

          if (popupContainer) {
            var parent = popupContainer.parentElement;
            parent.appendChild(popupContainer);
          }

          popup.open({
            popup: this.widget,
            around: this.target.dom
          });
        }
      }
    }, {
      key: "hide",
      value: function hide() {
        popup.close(this.widget);
      }
    }]);

    return _class141;
  }());
}

/**
* Upload.js for upload the file to server
* We'll use plain HTML uploader without any thirdparty library
* HTML5 uploader is HTML input tag with type file
* @param {String} accept the accept file type [https://www.w3schools.com/tags/att_input_accept.asp]
**/
);QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Uploader",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    accept: { type: "string", initialValue: "*" }
  },
  signals: {
    startUpload: [{ type: "string", name: "filebase64" }]
  }
}, function () {
  function _class142(meta) {
    _classCallCheck(this, _class142);

    QmlWeb.callSuper(this, meta);
    var self = this;
    this.acceptChanged.connect(this, this.$onAcceptChanged);

    this.mainDiv = document.createElement("div");

    // Create uploader element
    this.uploader = document.createElement("input");
    this.uploader.setAttribute("type", "file");
    this.uploader.addEventListener('change', function () {
      self.$onFileSelected(this.files);
    });
    $(this.uploader).css({ 'margin': '10px' });
    this.mainDiv.appendChild(this.uploader);

    // Image previewer
    this.previewDiv = document.createElement("div");
    $(this.previewDiv).css({
      'width': '100%',
      'height': '200px',
      'text-align': 'center'
    });
    this.previewImg = document.createElement("img");
    $(this.previewImg).css({
      'max-height': '200px',
      'max-width': '360px'
    });
    $(this.previewImg).click(function () {
      // Activate choose file automatically
      $(self.uploader).trigger('click');
    });
    this.previewImg.src = '../../static/images/picture.gif';
    this.previewDiv.appendChild(this.previewImg);

    this.mainDiv.appendChild(this.previewDiv);

    // // Create progress element but not show on screen
    // this.divProgress = document.createElement("div");
    // this.divProgress.setAttribute("class", "ui teal active progress");
    // this.divBar = document.createElement("div");
    // this.divBar.setAttribute("class", "bar");
    // this.divBarProgress = document.createElement("div");
    // this.divBarProgress.setAttribute("class", "progress");
    // this.divProgressLabel = document.createElement("div");
    // this.divProgressLabel.setAttribute("class", "label")
    // this.divProgressLabel.innerHTML = "Uploading.....";

    // this.divProgress.appendChild(this.divBar);
    // this.divBar.appendChild(this.divBarProgress);
    // this.divProgress.appendChild(this.divProgressLabel);

    // Create upload button element
    this.btnUploadNode = $("\n            <button class=\"ui labeled icon green button\" data-type='upload'>\n                <i class=\"cloud upload icon\"></i>\n                    Upload\n            </button>\n        ");
    this.btnUploadNode.on('click', function () {
      self.$doUploadFile();
    });
    var btnDiv = document.createElement("div");
    $(btnDiv).css({
      'text-align': 'center',
      'margin': '10px'
    });
    btnDiv.classList.add('inline');
    btnDiv.appendChild(this.btnUploadNode[0]);
    this.mainDiv.appendChild(btnDiv);

    this.contentBase64 = "";

    // Append the mainDiv to screen
    this.dom.appendChild(this.mainDiv);
  }

  _createClass(_class142, [{
    key: "clear",
    value: function clear() {
      // Clear and reset the variable back to inital state
      // Should be call every time you close this dialog
      this.previewImg.src = '../../static/images/picture.gif';
      self.selectedFile = undefined;
      this.contentBase64 = "";
      $(this.previewImg).val("");
    }
  }, {
    key: "$onAcceptChanged",
    value: function $onAcceptChanged() {
      this.uploader.setAttribute("accept", this.accept);
    }
  }, {
    key: "$onFileSelected",
    value: function $onFileSelected(files) {
      this.selectedFile = files[0];
      if (this.selectedFile !== undefined) {
        this.$previewImage(this.selectedFile);
        this.$getBase64(this.selectedFile);
      } else {
        this.clear();
      }
    }

    /**
     * Read the selected file into base64 and attach the previewed file into previewImg
     * @param {File} The selected file object
     */

  }, {
    key: "$previewImage",
    value: function $previewImage(file) {
      var imageType = /image.*/;

      if (!file.type.match(imageType)) {
        //throw "File Type must be an image";
        this.previewImg.src = '../../static/images/ready_picture.gif';
      }

      this.previewImg.file = file;

      // // Using FileReader to display the image content
      // var reader = new FileReader();
      // reader.onload = (function(aImg) { return function(e) { aImg.src = e.target.result; }; })(this.previewImg);
      // reader.onerror = function (error) { console.error("Error loading file : ", error); };
      // reader.readAsDataURL(file);
    }
  }, {
    key: "$doUploadFile",
    value: function $doUploadFile() {

      if (this.contentBase64 === "") {
        console.warn("Failed to load the base64 content");
        return;
      }

      if (this.selectedFile === undefined) {
        console.warn("Cannot upload. The file is undefined");
        return;
      }

      console.group("File selected");
      console.log("name : " + this.selectedFile.name);
      console.log("size : " + this.selectedFile.size);
      console.log("type : " + this.selectedFile.type);
      console.log("date : " + this.selectedFile.lastModified);
      console.groupEnd();

      this.startUpload(this.contentBase64);
    }
  }, {
    key: "$getBase64",
    value: function $getBase64(file) {
      var self = this;
      var reader = new FileReader();
      reader.readAsDataURL(file);
      reader.onload = function () {
        //self.startUpload(reader.result);
        var result = reader.result;
        var imageType = /image.*/;

        // preview if this is image
        if (file.type.match(imageType)) {
          self.previewImg.src = result;
        }

        // store the base64 for return
        self.contentBase64 = result;
      };
      reader.onerror = function (error) {
        console.log('Error: ', error);
      };
    }
  }]);

  return _class142;
}());
QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "WebCam",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    width: { type: "int", initialValue: 640 },
    height: { type: "int", initialValue: 480 },
    destWidth: "int",
    destHeight: "int",
    enabled: { type: "bool", initialValue: true },
    fliped: { type: "bool", initialValue: false },
    closeable: { type: "bool", initialValue: true },
    base64Img: "var"
  },
  signals: {
    captured: []
  }
}, function () {
  function _class143(meta) {
    var _this129 = this;

    _classCallCheck(this, _class143);

    QmlWeb.callSuper(this, meta);
    this.Component.completed.connect(this, this.Component$onCompleted);
    this.widthChanged.connect(this, this.$onWidthChanged);
    this.heightChanged.connect(this, this.$onHeightChanged);
    this.enabledChanged.connect(this, this.$onEnabledChanged);
    this.flipedChanged.connect(this, this.$onFlipedChanged);
    this.closeableChanged.connect(this, this.$onCloseableChanged);
    this.destWidthChanged.connect(this, this.$onDestWidthChanged);
    this.destHeightChanged.connect(this, this.$onDestHeightChanged);

    this.setting = {
      fps: 45,
      width: this.width,
      height: this.height,
      flip_horiz: this.fliped,
      dest_width: this.destWidth,
      dest_height: this.destHeight
    };

    this.state = "off";

    Webcam.on('load', function () {
      this.state = "load";
    });

    Webcam.on('live', function () {
      _this129.state = "live";
      _this129.setNewSize();
    });

    this.cameraPane = $("\n            <div style=\"background-color: grey;\n                        overflow: hidden;\n                        width: " + this.width + "px;\n                        height: " + this.height + "px;\">\n            </div>");

    this.imgPane = $("\n            <img style=\"background-color: grey;\">\n            </img>");

    this.textNode = $("\n            <div style=\"display: table-cell; \n                    text-align: center; \n                    vertical-align: middle;\n                    font-weight: bold;\n                    font-size:xx-large\">\n                <div style=\"color: white;\">OFF</div>\n            </div>\n        ");

    this.controlPane = $("\n            <div class=\"ui centered padded grid\" \n                 style=\"width: " + this.width + "px; \n                        background-color: black;\n                        opacity: 0.85;\n                        filter: alpha(opacity=85);\n                 \">\n            </div>\n        ");

    this.captureNode = $("\n            <div class=\"ui centered row\">\n                <button class=\"ui circular icon button\" style=\"background: transparent\">\n                    <i class=\"large photo icon\" style=\"color:white\"></i>\n                </button>\n            </div>\n        ");

    this.afterCaptureNode = $("\n            <div class=\"centered row\">\n                <button class=\"ui icon blue button\" data-type='retake' style=\"background:transparent\">\n                    <i class=\"large repeat blue icon\"></i>\n                </button>\n                <div class=\"column\"></div>\n                <button class=\"ui icon button\" data-type='use' style=\"background:transparent\">\n                    <i class=\"large checkmark green icon\"></i>\n                </button>\n            </div>\n        ");

    this.captureButton = this.captureNode.find('button');
    this.retakeButton = this.afterCaptureNode.find('button[data-type=retake]');
    this.useButton = this.afterCaptureNode.find('button[data-type=use]');

    this.controlPane[0].appendChild(this.captureNode[0]);
    this.controlPane[0].appendChild(this.afterCaptureNode[0]);
    this.dom.appendChild(this.cameraPane[0]);
    this.dom.appendChild(this.controlPane[0]);

    this.captureButton.on('click', function () {
      return _this129.capture();
    });
    this.retakeButton.on('click', function () {
      _this129.showCapturePane();
    });
    this.useButton.on('click', function () {
      _this129.showCapturePane();
      //fire signal
      _this129.captured();
    });
    this.showCapturePane();
  }

  _createClass(_class143, [{
    key: "Component$onCompleted",
    value: function Component$onCompleted() {
      this.completed = true;
      this.refreshWebcam();
    }
  }, {
    key: "refreshWebcam",
    value: function refreshWebcam() {
      if (!this.completed) return;
      if (this.enabled) {
        this.turnoff();
        this.turnon();
      }
    }
  }, {
    key: "showTurnoffBackground",
    value: function showTurnoffBackground() {
      this.display = $(this.dom).css('display');
      this.cameraPane[0].style.display = "table";
      this.cameraPane[0].appendChild(this.textNode[0]);
    }
  }, {
    key: "turnoff",
    value: function turnoff() {
      Webcam.reset();
      this.showTurnoffBackground();
    }
  }, {
    key: "turnon",
    value: function turnon() {
      if (this.cameraPane[0].childNodes.length > 0) {
        this.cameraPane[0].style.display = this.display;
        this.cameraPane[0].removeChild(this.textNode[0]);
      }
      Webcam.set(this.setting);
      Webcam.attach(this.cameraPane[0]);
    }
  }, {
    key: "$onWidthChanged",
    value: function $onWidthChanged() {
      this.setNewSize();
      this.controlPane[0].style.width = this.width + "px";
      this.setting.width = this.width;
      this.refreshWebcam();
    }
  }, {
    key: "$onHeightChanged",
    value: function $onHeightChanged() {
      this.setNewSize();
      this.setting.height = this.height;
      this.refreshWebcam();
    }
  }, {
    key: "$onFlipedChanged",
    value: function $onFlipedChanged() {
      this.setting.flip_horiz = this.fliped;
      this.refreshWebcam();
    }
  }, {
    key: "$onEnabledChanged",
    value: function $onEnabledChanged() {
      if (!this.enabled) {
        this.turnoff();
      } else {
        this.turnon();
      }
    }
  }, {
    key: "$onDestWidthChanged",
    value: function $onDestWidthChanged() {
      this.setting.dest_width = this.destWidth;
      this.refreshWebcam();
    }
  }, {
    key: "$onDestHeightChanged",
    value: function $onDestHeightChanged() {
      this.setting.dest_height = this.destHeight;
      this.refreshWebcam();
    }
  }, {
    key: "capture",
    value: function capture() {
      var _this130 = this;

      Webcam.snap(function (base64) {
        _this130.cameraPane.find("video").transition({
          animation: 'fade',
          duration: 150
        }).transition({
          animation: 'fade',
          duration: 150,
          onComplete: _this130.showAfterCapturePane.bind(_this130)
        });
        _this130.base64Img = base64;
      });
    }
  }, {
    key: "setNewSize",
    value: function setNewSize() {
      this.cameraPane[0].style.width = this.width + "px";
      this.cameraPane[0].style.height = this.height + "px";
      this.imgPane.attr('width', this.width);
      this.imgPane.attr('height', this.height);
    }
  }, {
    key: "showCapturePane",
    value: function showCapturePane() {
      this.afterCaptureNode[0].style.display = "none";
      this.imgPane[0].style.display = "none";
      this.captureNode[0].style.display = "flex";
      if (this.cameraPane.find('video')[0]) this.cameraPane.find('video')[0].style.display = "block";
    }
  }, {
    key: "showAfterCapturePane",
    value: function showAfterCapturePane() {
      this.afterCaptureNode[0].style.display = "flex";
      this.imgPane.attr('src', this.base64Img);
      this.imgPane[0].style.display = "block";
      this.captureNode[0].style.display = "none";
      if (this.cameraPane.find('video')[0]) {
        this.cameraPane.find('video')[0].style.display = "none";
        this.cameraPane[0].insertBefore(this.imgPane[0], this.cameraPane.find('video')[0]);
      }
    }
  }]);

  return _class143;
}());
/**
* Whiteboard.js a whiteboard library for simple drawing and annotating image
* It use fabric.js library [http://fabricjs.com]
**/

// ========= Static variables =========
var TOOL_OFFSET = 50; // Offset div for tool
var BG_COLOR = "#D5D8DC";
var SELECT_CORNOR_SIZE = 6;
var FREEHAND_COLOR = "#ff3300";
var FREEHAND_STROKE_WIDTH = 2;
var ANNOTATION_MARKER_SIZE = 10;
var ANNOTATION_MARKER_OPACITY = 0.7;
var ANNOTATION_MARKER_COLOR = "#EFA8A8";
var ANNOTATION_TEXT_SIZE = 20;
var ANNOTATION_TEXT_COLOR = "#ff3300";

// Key code
var KEY_DEL = 8;
var KEY_DELETE = 46;
var KEY_ESC = 27;
var KEY_1 = 49;
var KEY_2 = 50;
var KEY_3 = 51;
// ========= Static variables =========


QmlWeb.registerQmlType({
  module: "Semantic.Html",
  name: "Whiteboard",
  versions: /.*/,
  baseClass: "Semantic.Html.Dom",
  properties: {
    source: { type: "string", initialValue: "" },
    width: "int",
    height: "int",
    showCloseBtn: { type: "boolean", initialValue: false },
    showSaveBtn: { type: "boolean", initialValue: false }
  },
  signals: {
    saved: [{ type: "string", name: "base64Img" }],
    closed: []
  }
}, function () {

  /**
  * Constructor
  **/
  function _class144(meta) {
    var _this131 = this;

    _classCallCheck(this, _class144);

    QmlWeb.callSuper(this, meta);
    this.sourceChanged.connect(this, this.$_onSourceChanged);
    this.showCloseBtnChanged.connect(this, this.$_onShowCloseBtnChanged);
    this.showSaveBtnChanged.connect(this, this.$_onShowSaveBtnChanged);

    var self = this;
    this.mainDiv = document.createElement("div");
    this.mainDiv.setAttribute("class", "inline");
    this.mainDiv.width = meta.object.width;
    this.mainDiv.height = meta.object.height;

    // Whiteboard
    this.whiteboard = document.createElement("canvas");
    this.whiteboard.setAttribute("id", "MAIN_WB");
    this.whiteboard.width = meta.object.width;
    this.whiteboard.height = meta.object.height;
    this.mainDiv.tabIndex = 1000;
    this.mainDiv.addEventListener("keydown", function (evt) {
      self.$_onKeyDown(self, evt);
    }, false);

    // Close button

    this.closeBtnDiv = document.createElement("div");
    this.closeBtn = document.createElement("a");
    this.closeBtn.setAttribute("title", "Close");
    this.closeBtn.style.position = "absolute";
    this.closeBtn.style.right = "5px";
    this.closeBtn.style.top = "5px";
    this.closeBtn.style.color = "red";
    this.closeBtn.style.fontSize = "x-large";
    this.closeBtn.style.zIndex = "2";
    this.closeBtn.href = "javascript:void(0)";
    this.closeBtn.innerHTML = "&#10006";
    this.closeBtn.addEventListener("click", function () {
      _this131.closed();
    });
    this.closeBtnDiv.appendChild(this.closeBtn);

    // Tools
    this.toolsWrapper = document.createElement("div");
    this.toolsWrapper.setAttribute("class", "ui form");
    this.tools = document.createElement("div");
    this.tools.setAttribute("class", "inline fields");
    this.toolsWrapper.appendChild(this.tools);

    // Selection
    this.selectionDiv = document.createElement("div");
    this.selectionDiv.setAttribute("class", "field inline");
    this.selection = document.createElement("button");
    this.selection.setAttribute("title", "Selection Tool (1)");
    this.selection.setAttribute("class", "ui grey button icon");
    this.selectionIcon = document.createElement("i");
    this.selectionIcon.setAttribute("class", "mouse pointer icon");
    this.selection.addEventListener("click", function () {
      self.$_onSelectionTool();
    });
    this.selectionDiv.appendChild(this.selection);
    this.selection.appendChild(this.selectionIcon);
    this.tools.appendChild(this.selectionDiv);

    // Free hand
    this.freehandDiv = document.createElement("div");
    this.freehandDiv.setAttribute("class", "field inline");
    this.freehand = document.createElement("button");
    this.freehand.setAttribute("title", "Drawing Tool (2)");
    this.freehand.setAttribute("class", "ui grey button icon");
    this.freehandIcon = document.createElement("i");
    this.freehandIcon.setAttribute("class", "write icon");
    this.freehand.addEventListener("click", function () {
      self.$_onFreehandTool();
    });
    this.freehandDiv.appendChild(this.freehand);
    this.freehand.appendChild(this.freehandIcon);
    this.tools.appendChild(this.freehandDiv);

    // Annotation
    this.annotateDiv = document.createElement("div");
    this.annotateDiv.setAttribute("class", "field inline");
    this.annotate = document.createElement("button");
    this.annotate.setAttribute("title", "Annotation Tool (3)");
    this.annotate.setAttribute("class", "ui grey button icon");
    this.annotateIcon = document.createElement("i");
    this.annotateIcon.setAttribute("class", "font icon");
    this.annotate.addEventListener("click", function () {
      self.$_onAnnotationTool();
    });
    this.annotateDiv.appendChild(this.annotate);
    this.annotate.appendChild(this.annotateIcon);
    this.tools.appendChild(this.annotateDiv);

    this.blankDiv = document.createElement("div");
    this.blankDiv.setAttribute("class", "one wide field inline");
    this.tools.appendChild(this.blankDiv);

    // Save button
    this.saveBtnDiv = document.createElement("div");
    this.saveBtnDiv.setAttribute("class", "field inline");
    this.saveBtn = document.createElement("button");
    this.saveBtn.setAttribute("title", "Save");
    this.saveBtn.setAttribute("class", "ui green labeled icon button");
    this.saveBtn.innerHTML = "Save";
    this.saveBtn.addEventListener("click", function () {
      self.$_onSaveBtnPressed();
    });
    this.saveBtnIcon = document.createElement("i");
    this.saveBtnIcon.setAttribute("class", "save icon");
    this.saveBtnDiv.appendChild(this.saveBtn);
    this.saveBtn.appendChild(this.saveBtnIcon);
    // this.tools.appendChild(this.saveBtnDiv);

    // Append components to main DIV
    this.mainDiv.appendChild(this.toolsWrapper);
    this.mainDiv.appendChild(this.whiteboard);
    this.dom.appendChild(this.mainDiv);

    // Create canvas and paint image background
    this.canvas = new fabric.Canvas(this.whiteboard, {
      backgroundColor: BG_COLOR
    });
    fabric.Object.prototype.transparentCorners = false;
    this.$_onSelectionTool(); // Set default tool
  }

  _createClass(_class144, [{
    key: "clear",
    value: function clear() {
      if (this.canvas !== undefined) {
        this.canvas.clear();
      }
    }
  }, {
    key: "$_onKeyDown",
    value: function $_onKeyDown(self, evt) {
      if (evt.keyCode == KEY_DEL || evt.keyCode == KEY_DELETE) {
        // Remove selected object
        if (self.canvas.getActiveObject() != null) {
          // Clear for single selection
          self.canvas.getActiveObject().remove();
        } else if (self.canvas.getActiveGroup() != null) {
          // Clear for multiple selection
          var o = self.canvas.getActiveGroup();
          o._objects.forEach(function (object, key) {
            self.canvas.remove(object);
            o.removeWithUpdate(object);
          });
          self.canvas.discardActiveGroup();
          self.canvas.renderAll();
        }
      } else if (evt.keyCode == KEY_ESC) {
        // Cancel selection
        if (self.canvas.getActiveObject() == null || self.canvas.getActiveGroup() == null) {
          // Don't select anything and press ESC
          self.$_onSelectionTool();
        }
        self.canvas.deactivateAll().renderAll();
      } else if (evt.keyCode == KEY_1) {
        // Short cut menu
        self.$_onSelectionTool();
      } else if (evt.keyCode == KEY_2) {
        // Short cut menu
        self.$_onFreehandTool();
      } else if (evt.keyCode == KEY_3) {
        // Short cut menu
        self.$_onAnnotationTool();
      }
    }
  }, {
    key: "$_onSelectionTool",
    value: function $_onSelectionTool() {
      var _canvas = this.canvas;
      _canvas.isDrawingMode = false;
      _canvas.off("mouse:up"); // Unregister listener

      this.selection.setAttribute("class", "ui teal button icon");
      this.freehand.setAttribute("class", "ui grey button icon");
      this.annotate.setAttribute("class", "ui grey button icon");
    }
  }, {
    key: "$_onFreehandTool",
    value: function $_onFreehandTool() {
      var _canvas = this.canvas;
      _canvas.freeDrawingBrush = new fabric['PencilBrush'](this.canvas);
      _canvas.freeDrawingBrush.color = FREEHAND_COLOR;
      _canvas.freeDrawingBrush.width = FREEHAND_STROKE_WIDTH;
      _canvas.isDrawingMode = true;
      _canvas.off("mouse:up"); // Unregister listener

      this.selection.setAttribute("class", "ui grey button icon");
      this.freehand.setAttribute("class", "ui teal button icon");
      this.annotate.setAttribute("class", "ui grey button icon");
    }
  }, {
    key: "$_onAnnotationTool",
    value: function $_onAnnotationTool() {
      var self = this;
      var _canvas = this.canvas;
      _canvas.isDrawingMode = false;
      _canvas.on("mouse:up", function (options) {
        if (options.target == null) {
          // Create annotation marker
          var circle = new fabric.Circle({
            left: options.e.offsetX - ANNOTATION_MARKER_SIZE,
            top: options.e.offsetY - ANNOTATION_MARKER_SIZE,
            radius: ANNOTATION_MARKER_SIZE,
            fill: ANNOTATION_MARKER_COLOR,
            opacity: ANNOTATION_MARKER_OPACITY,
            cornerSize: SELECT_CORNOR_SIZE
          });

          _canvas.add(circle);

          // Create empty text object and add to canvas with editing mode
          var text = new fabric.IText('', {
            left: options.e.offsetX + ANNOTATION_MARKER_SIZE,
            top: options.e.offsetY + ANNOTATION_MARKER_SIZE,
            fontSize: ANNOTATION_TEXT_SIZE,
            stroke: ANNOTATION_TEXT_COLOR,
            fill: ANNOTATION_TEXT_COLOR,
            cornerSize: SELECT_CORNOR_SIZE
          });

          // Handle leaving editing mode with empty text
          text.on("editing:exited", function () {
            if (text.getText().trim() === "") {
              // Empty text found, remove the text element
              _canvas.remove(text);
              _canvas.remove(circle);
            }
            // Move to selection tool
            self.$_onSelectionTool();
          });

          _canvas.add(text).setActiveObject(text);
          text.enterEditing();
        }
      });
      this.selection.setAttribute("class", "ui grey button icon");
      this.freehand.setAttribute("class", "ui grey button icon");
      this.annotate.setAttribute("class", "ui teal button icon");
    }
  }, {
    key: "$_onSaveBtnPressed",
    value: function $_onSaveBtnPressed() {
      this.saved(getBase64Image());
    }
  }, {
    key: "$_onSourceChanged",
    value: function $_onSourceChanged() {
      var _canvas = this.canvas;
      var self = this;
      this.clear();
      fabric.Image.fromURL(this.source, function (oImg) {
        console.log("Done setting SOURCE");
        _canvas.setBackgroundImage(oImg, _canvas.renderAll.bind(_canvas));
        // Resize canvas to fit image
        self.$_resizeComponent(oImg.width, oImg.height);
      });
    }
  }, {
    key: "$_resizeComponent",
    value: function $_resizeComponent(width, height) {
      this.mainDiv.width = width;
      this.mainDiv.height = height;
      this.canvas.setWidth(width);
      this.canvas.setHeight(height);
      this.canvas.renderAll();
    }
  }, {
    key: "$_onShowCloseBtnChanged",
    value: function $_onShowCloseBtnChanged() {
      if (this.showCloseBtn) {
        this.mainDiv.appendChild(this.closeBtnDiv);
      } else {
        this.mainDiv.removeChild(this.closeBtnDiv);
      }
    }
  }, {
    key: "$_onShowSaveBtnChanged",
    value: function $_onShowSaveBtnChanged() {
      if (this.showSaveBtn) {
        this.tools.appendChild(this.saveBtnDiv);
      } else {
        this.tools.removeChild(this.saveBtnDiv);
      }
    }
  }, {
    key: "getBase64Image",
    value: function getBase64Image() {
      var base64Img = this.canvas.toDataURL('png');
      return base64Img;
    }
  }]);

  return _class144;
}());
}(typeof global != "undefined" ? global : window));

//# sourceMappingURL=qt.js.map
